

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>初期化 (initialization)、終了処理 (finalization)、スレッド &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python/C API リファレンスマニュアル" href="index.html" />
    <link rel="next" title="メモリ管理" href="memory.html" />
    <link rel="prev" title="コードオブジェクト" href="code.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="memory.html" title="メモリ管理"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="code.html" title="コードオブジェクト"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python/C API リファレンスマニュアル</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">初期化 (initialization)、終了処理 (finalization)、スレッド</a><ul>
<li><a class="reference internal" href="#id1">インタプリタの初期化と終了処理</a></li>
<li><a class="reference internal" href="#id2">プロセスワイドのパラメータ</a></li>
<li><a class="reference internal" href="#thread-state-global-interpreter-lock">スレッド状態 (thread state) とグローバルインタプリタロック (global interpreter lock)</a><ul>
<li><a class="reference internal" href="#gil">拡張コード内で GIL を解放する</a></li>
<li><a class="reference internal" href="#python">Python 以外で作られたスレッド</a></li>
<li><a class="reference internal" href="#api">高レベルAPI</a></li>
<li><a class="reference internal" href="#id3">低レベルAPI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">サブインタプリタサポート</a><ul>
<li><a class="reference internal" href="#id5">バグと注意事項</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">非同期通知</a></li>
<li><a class="reference internal" href="#profiling-and-tracing">プロファイルとトレース (profiling and tracing)</a></li>
<li><a class="reference internal" href="#advanced-debugger-support">高度なデバッガサポート (advanced debugger support)</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="code.html"
                        title="前の章へ">コードオブジェクト</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="memory.html"
                        title="次の章へ">メモリ管理</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/c-api/init.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="initialization-finalization">
<span id="initialization"></span><h1>初期化 (initialization)、終了処理 (finalization)、スレッド<a class="headerlink" href="#initialization-finalization" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="id1">
<h2>インタプリタの初期化と終了処理<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="Py_Initialize">
void <tt class="descname">Py_Initialize</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_Initialize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-0">Python インタプリタを初期化します。
Python の埋め込みを行うアプリケーションでは、他のあらゆる Python/C API
を使用するよりも前にこの関数を呼び出さねばなりません。ただし、 <a class="reference internal" href="#Py_SetProgramName" title="Py_SetProgramName"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetProgramName()</span></tt></a>,
<a class="reference internal" href="#PyEval_InitThreads" title="PyEval_InitThreads"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_InitThreads()</span></tt></a>, <a class="reference internal" href="#PyEval_ReleaseLock" title="PyEval_ReleaseLock"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_ReleaseLock()</span></tt></a>, および
<a class="reference internal" href="#PyEval_AcquireLock" title="PyEval_AcquireLock"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_AcquireLock()</span></tt></a> は例外です。この関数はロード済みモジュールのテーブル (<tt class="docutils literal"><span class="pre">sys.modules</span></tt>) を初期化し、基盤となるモジュール群、 <a class="reference internal" href="../library/__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: トップレベルスクリプトが実行される環境。"><tt class="xref py py-mod docutils literal"><span class="pre">__main__</span></tt></a>, <a class="reference internal" href="../library/sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a>
を生成します。また、モジュール検索パス   (<tt class="docutils literal"><span class="pre">sys.path</span></tt>) も初期化します。 <tt class="docutils literal"><span class="pre">sys.argv</span></tt>
の設定は行いません。設定するには、 <a class="reference internal" href="#PySys_SetArgvEx" title="PySys_SetArgvEx"><tt class="xref c c-func docutils literal"><span class="pre">PySys_SetArgvEx()</span></tt></a> を使ってください。この関数を (<a class="reference internal" href="#Py_Finalize" title="Py_Finalize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Finalize()</span></tt></a> を呼ばずに) 再度呼び出しても何も行いません。戻り値はありません。初期化が失敗すれば、それは致命的なエラーです。</p>
</dd></dl>

<dl class="function">
<dt id="Py_InitializeEx">
void <tt class="descname">Py_InitializeEx</tt><big>(</big>int<em>&nbsp;initsigs</em><big>)</big><a class="headerlink" href="#Py_InitializeEx" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>initsigs</em> に1を指定すれば <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> と同じ処理を実行しますが、
Python埋め込みアプリケーションでは <em>initsigs</em> を0として初期化時にシグナルハンドラの登録をスキップすることができます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="Py_IsInitialized">
int <tt class="descname">Py_IsInitialized</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_IsInitialized" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python インタプリタがすでに初期化済みの場合に真 (非ゼロ) を返し、そうでない場合には偽 (ゼロ) を返します。
<a class="reference internal" href="#Py_Finalize" title="Py_Finalize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Finalize()</span></tt></a> を呼び出すと、次に <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> を呼び出すまでこの関数は偽を返します。</p>
</dd></dl>

<dl class="function">
<dt id="Py_Finalize">
void <tt class="descname">Py_Finalize</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_Finalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> とそれ以後の Python/C API 関数で行った全ての初期化処理を取り消し、最後の <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a>  呼び出し以後に Python
インタプリタが生成した全てのサブインタプリタ  (sub-interpreter,
下記の <a class="reference internal" href="#Py_NewInterpreter" title="Py_NewInterpreter"><tt class="xref c c-func docutils literal"><span class="pre">Py_NewInterpreter()</span></tt></a> を参照) を消去します。理想的な状況では、この関数によって Python インタプリタが確保したメモリは全て解放されます。この関数を (<a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> を呼ばずに) 再度呼び出しても何も行いません。戻り値はありません。 終了処理中のエラーは無視されます。</p>
<p>この関数が提供されている理由はいくつかあります。
Python の埋め込みを行っているアプリケーションでは、アプリケーションを再起動することなく Python を再起動したいことがあります。また、動的ロード可能イブラリ (あるいは DLL) から Python インタプリタをロードするアプリケーションでは、DLL をアンロードする前に Python が確保したメモリを全て解放したいと考えるかもしれません。アプリケーション内で起きているメモリリークを追跡する際に、開発者は Python
が確保したメモリをアプリケーションの終了前に解放させたいと思う場合もあります。</p>
<p><strong>バグおよび注意事項:</strong> モジュールやモジュール内のオブジェクトはランダムな順番で削除されます。このため、他のオブジェクト(関数オブジェクトも含みます) やモジュールに依存するデストラクタ  (<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> メソッド) が失敗してしまうことがあります。動的にロードされるようになっている拡張モジュールが Python によってロードされていた場合、アンロードされません。
Python が確保したメモリがわずかながら解放されないかもしれません
(メモリリークを発見したら、どうか報告してください)。オブジェクト間の循環参照に捕捉されているメモリは解放されないことがあります。拡張モジュールが確保したメモリは解放されないことがあります。拡張モジュールによっては、初期化ルーチンを 2 度以上呼び出すと正しく動作しないことがあります。 こうした状況は、 <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a>  や <a class="reference internal" href="#Py_Finalize" title="Py_Finalize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Finalize()</span></tt></a>
を 2 度以上呼び出すと起こり得ます。</p>
</dd></dl>

</div>
<div class="section" id="id2">
<h2>プロセスワイドのパラメータ<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="Py_SetProgramName">
void <tt class="descname">Py_SetProgramName</tt><big>(</big>char<em>&nbsp;*name</em><big>)</big><a class="headerlink" href="#Py_SetProgramName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-1">この関数を呼び出すなら、最初に <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> を呼び出すよりも前に呼び出さねばなりません。この関数はインタプリタにプログラムの <tt class="xref c c-func docutils literal"><span class="pre">main()</span></tt>
関数に指定した <tt class="docutils literal"><span class="pre">argv[0]</span></tt> 引数の値を教えます。この引数値は、 <a class="reference internal" href="#Py_GetPath" title="Py_GetPath"><tt class="xref c c-func docutils literal"><span class="pre">Py_GetPath()</span></tt></a> や、以下に示すその他の関数が、インタプリタの実行可能形式から Python ランタイムライブラリへの相対パスを取得するために使われます。デフォルトの値は <tt class="docutils literal"><span class="pre">'python'</span></tt> です。引数はゼロ終端されたキャラクタ文字列で、静的な記憶領域に入っていなければならず、その内容はプログラムの実行中に変更してはなりません。
Python インタプリタ内のコードで、この記憶領域の内容を変更するものは一切ありません。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetProgramName">
char* <tt class="descname">Py_GetProgramName</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetProgramName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-2"><a class="reference internal" href="#Py_SetProgramName" title="Py_SetProgramName"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetProgramName()</span></tt></a> で設定されたプログラム名か、デフォルトのプログラム名を返します。関数が返す文字列ポインタは静的な記憶領域を返します。関数の呼び出し側はこの値を変更できません。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetPrefix">
char* <tt class="descname">Py_GetPrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetPrefix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プラットフォーム非依存のファイル群がインストールされている場所である
<em>prefix</em> を返します。この値は <a class="reference internal" href="#Py_SetProgramName" title="Py_SetProgramName"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetProgramName()</span></tt></a> でセットされたプログラム名やいくつかの環境変数をもとに、数々の複雑な規則から導出されます。例えば、プログラム名が <tt class="docutils literal"><span class="pre">'/usr/local/bin/python'</span></tt> の場合、prefix は
<tt class="docutils literal"><span class="pre">'/usr/local'</span></tt> になります。関数が返す文字列ポインタは静的な記憶領域を返します;
関数の呼び出し側はこの値を変更できません。この値はトップレベルの <tt class="file docutils literal"><span class="pre">Makefile</span></tt> に指定されている変数
<strong class="makevar">prefix</strong> や、ビルド値に <strong class="program">configure</strong> スクリプトに指定した
<em class="xref std std-option">--prefix</em> 引数に対応しています。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.prefix</span></tt> として利用できます。これはUnixでのみ有用です。次に説明する関数も参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetExecPrefix">
char* <tt class="descname">Py_GetExecPrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetExecPrefix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プラットフォーム <em>依存</em> のファイルがインストールされている場所である
<em>exec-prefix</em> を返します。この値は <a class="reference internal" href="#Py_SetProgramName" title="Py_SetProgramName"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetProgramName()</span></tt></a> でセットされたプログラム名やいくつかの環境変数をもとに、数々の複雑な規則から導出されます。例えば、プログラム名が <tt class="docutils literal"><span class="pre">'/usr/local/bin/python'</span></tt> の場合、exec-prefix は
<tt class="docutils literal"><span class="pre">'/usr/local'</span></tt> になります。関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。この値はトップレベルの <tt class="file docutils literal"><span class="pre">Makefile</span></tt> に指定されている変数 <strong class="makevar">exec_prefix</strong> や、ビルド値に <strong class="program">configure</strong> スクリプトに指定した <em class="xref std std-option">--exec-prefix</em> 引数に対応しています。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.exec_prefix</span></tt> として利用できます。
Unixのみで有用です。</p>
<p>背景: プラットフォーム依存のファイル (実行形式や共有ライブラリ) が別のディレクトリツリー内にインストールされている場合、 exec-prefix は
prefix と異なります。典型的なインストール形態では、プラットフォーム非依存のファイルが
<tt class="file docutils literal"><span class="pre">/usr/local</span></tt> に収められる一方、プラットフォーム依存のファイルは <tt class="file docutils literal"><span class="pre">/usr/local/plat</span></tt> サブツリーに収められます。</p>
<p>一般的に、プラットフォームとは、ハードウェアとソフトウェアファミリの組み合わせを指します。例えば、 Solaris 2.x を動作させている Sparc
マシンは全て同じプラットフォームであるとみなしますが、Solaris 2.x
を動作させている Intel マシンは違うプラットフォームになりますし、同じ
Intel マシンでも Linux を動作させているならまた別のプラットフォームです。一般的には、同じオペレーティングシステムでも、メジャーリビジョンの違うものは異なるプラットフォームです。非 Unix のオペレーティングシステムの場合は話はまた別です; 非 Unix
のシステムでは、インストール方法はとても異なっていて、 prefix や exec-prefix
には意味がなく、空文字列が設定されています。コンパイル済みの Python バイトコードはプラットフォームに依存しないので注意してください
(ただし、どのバージョンの Python でコンパイルされたかには依存します!)。</p>
<p>システム管理者は、 <strong class="program">mount</strong> や <strong class="program">automount</strong> プログラムを使って、各プラットフォーム用の <tt class="file docutils literal"><span class="pre">/usr/local/plat</span></tt> を異なったファイルシステムに置き、プラットフォーム間で <tt class="file docutils literal"><span class="pre">/usr/local</span></tt> を共有するための設定方法を知っているでしょう。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetProgramFullPath">
char* <tt class="descname">Py_GetProgramFullPath</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetProgramFullPath" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-3">Python 実行可能形式の完全なプログラム名を返します;
この値はデフォルトのモジュール検索パスを
(前述の <a class="reference internal" href="#Py_SetProgramName" title="Py_SetProgramName"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetProgramName()</span></tt></a>  で設定された)
プログラム名から導出する際に副作用的に計算されます。関数が返す文字列ポインタは静的な記憶領域を返します;
関数の呼び出し側はこの値を変更できません。この値は Python コードからは
<tt class="docutils literal"><span class="pre">sys.executable</span></tt> として利用できます。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetPath">
char* <tt class="descname">Py_GetPath</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetPath" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-4">デフォルトのモジュール検索パスを返します; パスは (上の
<a class="reference internal" href="#Py_SetProgramName" title="Py_SetProgramName"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetProgramName()</span></tt></a> で設定された) プログラム名と、いくつかの環境変数から計算されます。戻り値となる文字列は、プラットフォーム依存のパス区切り文字で分割された一連のディレクトリ名からなります。区切り文字は Unix と Mac OS X では
<tt class="docutils literal"><span class="pre">':'</span></tt>, Windows では <tt class="docutils literal"><span class="pre">';'</span></tt> です。関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> はインタプリタによってこの値で初期化され、その後にモジュールをロードする際の検索パスを変更するために修正することが可能で、たいていそうされます。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetVersion">
const char* <tt class="descname">Py_GetVersion</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetVersion" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python インタプリタのバージョンを返します。バージョンは、次のような形式の文字列です。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="s">&quot;1.5 (#67, Dec 31 1997, 22:34:28) [GCC 2.7.2.2]&quot;</span>
</pre></div>
</div>
<p id="index-5">第一ワード (最初のスペース文字まで) は、現在の Python のバージョンです;
最初の三文字は、ピリオドで区切られたメジャーバージョンとマイナーバージョンです。関数が返す文字列ポインタは静的な記憶領域を返します;
関数の呼び出し側はこの値を変更できません。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.version</span></tt> として利用できます。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetPlatform">
const char* <tt class="descname">Py_GetPlatform</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetPlatform" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-6">現在のプラットフォームのプラットフォーム識別文字列を返します。
Unixでは、オペレーティングシステムの &#8220;公式の&#8221; 名前を小文字に変換し、後ろにメジャーリビジョン番号を付けた構成になっています。例えば Solaris 2.x は、SunOS 5.x, としても知られていますが、
<tt class="docutils literal"><span class="pre">'sunos5'</span></tt> になります。Mac OS X では <tt class="docutils literal"><span class="pre">'darwin'</span></tt> です。
Windows では <tt class="docutils literal"><span class="pre">'win'</span></tt> です。関数が返す文字列ポインタは静的な記憶領域を返します;
関数の呼び出し側はこの値を変更できません。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.platform</span></tt> として利用できます。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetCopyright">
const char* <tt class="descname">Py_GetCopyright</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetCopyright" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在の Python バージョンに対する公式の著作権表示文字列、例えば
<tt class="docutils literal"><span class="pre">'Copyright</span> <span class="pre">1991-1995</span> <span class="pre">Stichting</span> <span class="pre">Mathematisch</span> <span class="pre">Centrum,</span> <span class="pre">Amsterdam'</span></tt> を返します。</p>
<p id="index-7">関数が返す文字列ポインタは静的な記憶領域を返します;
関数の呼び出し側はこの値を変更できません。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.copyright</span></tt> として利用できます。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetCompiler">
const char* <tt class="descname">Py_GetCompiler</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetCompiler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在使っているバージョンの Python をビルドする際に用いたコンパイラを示す文字列を、角括弧で囲った文字列を返します。例えば:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="s">&quot;[GCC 2.7.2.2]&quot;</span>
</pre></div>
</div>
<p>になります。</p>
<p id="index-8">関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.version</span></tt> の一部として取り出せます。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetBuildInfo">
const char* <tt class="descname">Py_GetBuildInfo</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetBuildInfo" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在使っている Python インタプリタインスタンスの、シーケンス番号とビルド日時に関する情報を返します。例えば</p>
<div class="highlight-c"><div class="highlight"><pre><span class="s">&quot;#67, Aug  1 1997, 22:34:28&quot;</span>
</pre></div>
</div>
<p>になります。</p>
<p id="index-9">関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。この値は Python コードからは <tt class="docutils literal"><span class="pre">sys.version</span></tt> の一部として取り出せます。</p>
</dd></dl>

<dl class="function">
<dt id="PySys_SetArgvEx">
void <tt class="descname">PySys_SetArgvEx</tt><big>(</big>int<em>&nbsp;argc</em>, char<em>&nbsp;**argv</em>, int<em>&nbsp;updatepath</em><big>)</big><a class="headerlink" href="#PySys_SetArgvEx" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-10"><em>argc</em> および <em>argv</em> に基づいて <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><tt class="xref py py-data docutils literal"><span class="pre">sys.argv</span></tt></a> を設定します。これらの引数はプログラムの <tt class="xref c c-func docutils literal"><span class="pre">main()</span></tt> に渡した引数に似ていますが、最初の要素が Python インタプリタの宿主となっている実行形式の名前ではなく、実行されるスクリプト名を参照しなければならない点が違います。実行するスクリプトがない場合、 <em>argv</em> の最初の要素は空文字列にしてもかまいません。この関数が <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><tt class="xref py py-data docutils literal"><span class="pre">sys.argv</span></tt></a> の初期化に失敗した場合、致命的エラーを
<a class="reference internal" href="sys.html#Py_FatalError" title="Py_FatalError"><tt class="xref c c-func docutils literal"><span class="pre">Py_FatalError()</span></tt></a> で知らせます。</p>
<p><em>updatepath</em> が 0 の場合、ここまでの動作がこの関数がすることの全てです。
<em>updatepath</em> が 0 でない場合、この関数は <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> を以下のアルゴリズムに基づいて修正します:</p>
<ul class="simple">
<li>存在するスクリプトの名前が <tt class="docutils literal"><span class="pre">argv[0]</span></tt> に渡された場合、そのスクリプトがある場所の絶対パスを <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> の先頭に追加します。</li>
<li>それ以外の場合(<em>argc</em> が 0 だったり、 <tt class="docutils literal"><span class="pre">argv[0]</span></tt> が存在するファイル名をさしていない場合)、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> の先頭に空の文字列を追加します。これは現在の作業ディレクトリ (<tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>) を先頭に追加するのと同じです。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p>Python インタプリタを、単一のスクリプトを実行する以外の目的で埋め込むアプリケーションは、 <em>updatepath</em> に 0 を渡して必要なら自分で
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> を更新することをおすすめします。
<a class="reference external" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983">CVE-2008-5983</a>
を参照してください。</p>
<p>2.6.6 より前のバージョンでは、 <a class="reference internal" href="#PySys_SetArgv" title="PySys_SetArgv"><tt class="xref c c-func docutils literal"><span class="pre">PySys_SetArgv()</span></tt></a> を呼出たあとに同じ事を手動で <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a> の先頭の要素を取り除くことで実現できます。例えば、次のようにします。</p>
<div class="last highlight-c"><div class="highlight"><pre><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;import sys; sys.path.pop(0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PySys_SetArgv">
void <tt class="descname">PySys_SetArgv</tt><big>(</big>int<em>&nbsp;argc</em>, char<em>&nbsp;**argv</em><big>)</big><a class="headerlink" href="#PySys_SetArgv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#PySys_SetArgvEx" title="PySys_SetArgvEx"><tt class="xref c c-func docutils literal"><span class="pre">PySys_SetArgvEx()</span></tt></a> の <em>updatepath</em> に 1 を設定したのと同じように動作します。</p>
</dd></dl>

<dl class="function">
<dt id="Py_SetPythonHome">
void <tt class="descname">Py_SetPythonHome</tt><big>(</big>char<em>&nbsp;*home</em><big>)</big><a class="headerlink" href="#Py_SetPythonHome" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python の標準ライブラリがある、デフォルトの &#8220;home&#8221; ディレクトリを設定します。引数の文字列の意味については <span class="target" id="index-11"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></tt></a> を参照してください。</p>
<p>引数は静的なストレージに置かれてプログラム実行中に書き換えられないようなゼロ終端の文字列であるべきです。
Python インタプリタはこのストレージの内容を変更しません。</p>
</dd></dl>

<dl class="function">
<dt id="Py_GetPythonHome">
char* <tt class="descname">Py_GetPythonHome</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_GetPythonHome" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>前回の <a class="reference internal" href="#Py_SetPythonHome" title="Py_SetPythonHome"><tt class="xref c c-func docutils literal"><span class="pre">Py_SetPythonHome()</span></tt></a> 呼び出しで設定されたデフォルトの &#8220;home&#8221; か、
<span class="target" id="index-12"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></tt></a> 環境変数が設定されていればその値を返します。</p>
</dd></dl>

</div>
<div class="section" id="thread-state-global-interpreter-lock">
<span id="threads"></span><h2>スレッド状態 (thread state) とグローバルインタプリタロック (global interpreter lock)<a class="headerlink" href="#thread-state-global-interpreter-lock" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-13">Python インタプリタは完全にはスレッドセーフではありません。マルチスレッドの Python プログラムをサポートするために、グローバルインタプリタロック(<a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><em class="xref std std-term">global interpreter lock</em></a>, <a class="reference internal" href="../glossary.html#term-gil"><em class="xref std std-term">GIL</em></a>)
と呼ばれるグローバルなロックが存在していて、現在のスレッドが Python オブジェクトに安全にアクセスする前に必ずロックを獲得しなければならなくなっています。ロック機構がなければ、単純な操作でさえ、マルチスレッドプログラムの実行に問題を引き起こす可能性があります。たとえば、二つのスレッドが同じオブジェクトの参照カウントを同時にインクリメントすると、結果的に参照カウントは二回でなく一回だけしかインクリメントされないかもしれません。</p>
<p id="index-14">このため、 <a class="reference internal" href="../glossary.html#term-gil"><em class="xref std std-term">GIL</em></a> を獲得したスレッドだけが Python オブジェクトを操作したり、
Python/C API 関数を呼び出したりできるというルールがあります。並行処理をエミュレートするために、インタプリタは定期的にロックを解放したり獲得したりします。
(<a class="reference internal" href="../library/sys.html#sys.setcheckinterval" title="sys.setcheckinterval"><tt class="xref py py-func docutils literal"><span class="pre">sys.setcheckinterval()</span></tt></a> を参照)
このロックはブロックが起こりうる I/O 操作の付近でも解放・獲得され、
I/O を要求するスレッドが I/O 操作の完了を待つ間、他のスレッドが動作できるようにしています。</p>
<p id="index-15">Python インタプリタはスレッドごとに必要な情報を <a class="reference internal" href="#PyThreadState" title="PyThreadState"><tt class="xref c c-type docutils literal"><span class="pre">PyThreadState</span></tt></a> と呼ばれるデータ構造の中に保存します。そしてグローバル変数として現在の <a class="reference internal" href="#PyThreadState" title="PyThreadState"><tt class="xref c c-type docutils literal"><span class="pre">PyThreadState</span></tt></a> を指すポインタを1つ持ちます。このグローバル変数は <a class="reference internal" href="#PyThreadState_Get" title="PyThreadState_Get"><tt class="xref c c-func docutils literal"><span class="pre">PyThreadState_Get()</span></tt></a> を使って取得できます。</p>
<div class="section" id="gil">
<h3>拡張コード内で GIL を解放する<a class="headerlink" href="#gil" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>GIL を操作するほとんどのコードは、次のような単純な構造になります。</p>
<div class="highlight-c"><pre>スレッド状態をローカル変数に保存する。
GILを解放する。
...ブロックが起きるような何らかの I/O 操作...
GILを獲得する。
ローカル変数からスレッド状態を回復する。</pre>
</div>
<p>この構造は非常に一般的なので、作業を単純にするために2つのマクロが用意されています:</p>
<div class="highlight-c"><pre>Py_BEGIN_ALLOW_THREADS
...ブロックが起きるような何らかの I/O 操作...
Py_END_ALLOW_THREADS</pre>
</div>
<p id="index-16"><a class="reference internal" href="#Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></tt></a> マクロは新たなブロックを開始し、隠しローカル変数を宣言します; <a class="reference internal" href="#Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_END_ALLOW_THREADS</span></tt></a>
はブロックを閉じます。
Python をスレッドサポートなしでコンパイルしたときでもこの2つのマクロは利用可能です。
(単に、空行に展開されます)</p>
<p>スレッドサポートが有効になっている場合、上記のブロックは以下のようなコードに展開されます:</p>
<div class="highlight-c"><pre>PyThreadState *_save;

_save = PyEval_SaveThread();
...ブロックが起きるような何らかの I/O 操作...
PyEval_RestoreThread(_save);</pre>
</div>
<p id="index-17">これらの関数の動作を説明します。
GIL は現在のスレッド状態を指すポインタを保護するために使われます。ロックを解放してスレッド状態を退避する際、ロックを解放する前に現在のスレッド状態ポインタを取得しておかなければなりません (他のスレッドがすぐさまロックを獲得して、自らのスレッド状態をグローバル変数に保存してしまうかもしれないからです)。逆に、ロックを獲得してスレッド状態を復帰する際には、グローバル変数にスレッド状態ポインタを保存する前にロックを獲得しておかなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">GIL を解放するのはほとんどがシステムのI/O関数を呼び出す時ですが、メモリバッファに対する圧縮や暗号化のように、 Python のオブジェクトにアクセスしない長時間かかる計算処理を呼び出すときも GIL を解放することは有益です。例えば、 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: gzip 互換の圧縮／解凍ルーチンへの低レベルインタフェース"><tt class="xref py py-mod docutils literal"><span class="pre">zlib</span></tt></a> や <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: セキュアハッシュおよびメッセージダイジェストのアルゴリズム"><tt class="xref py py-mod docutils literal"><span class="pre">hashlib</span></tt></a> モジュールは圧縮やハッシュ計算の前に
GIL を開放します。</p>
</div>
</div>
<div class="section" id="python">
<h3>Python 以外で作られたスレッド<a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python API を通して作られたスレッド (<a class="reference internal" href="../library/threading.html#module-threading" title="threading: 高水準のスレッドインタフェース"><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> モジュールなど) では自動的にスレッド状態が割り当てられて、上記のコードは正しく動きます。しかし、(自前でスレッド管理を行う外部のライブラリなどにより)C言語でスレッドを生成した場合、そのスレッドには GIL がなく、スレッド状態データ構造体もないことに注意する必要があります。</p>
<p>このようなスレッドから Python コードを呼び出す必要がある場合
(外部のライブラリからコールバックするAPIなどがよくある例です)、
Python/C API を呼び出す前に、スレッド状態データ構造体を生成し、
GIL を獲得し、スレッド状態ポインタを保存することで、スレッドをインタプリタに登録しなければなりません。スレッドが作業を終えたら、スレッド状態ポインタをリセットして、ロックを解放し、最後にスレッド状態データ構造体のメモリを解放しなければなりません。</p>
<p><a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> と <a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> はこの処理を自動的に行います。
Cのスレッドから Python を呼び出す典型的な方法は以下のとおりです。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyGILState_STATE</span> <span class="n">gstate</span><span class="p">;</span>
<span class="n">gstate</span> <span class="o">=</span> <span class="n">PyGILState_Ensure</span><span class="p">();</span>

<span class="cm">/* Perform Python actions here. */</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">CallSomeFunction</span><span class="p">();</span>
<span class="cm">/* evaluate result or handle exception */</span>

<span class="cm">/* Release the thread. No Python API allowed beyond this point. */</span>
<span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_*()</span></tt> 関数は、(<a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> によって自動的に作られる)
グローバルインタプリタ1つだけが存在すると仮定する事に気をつけて下さい。
Python は (<a class="reference internal" href="#Py_NewInterpreter" title="Py_NewInterpreter"><tt class="xref c c-func docutils literal"><span class="pre">Py_NewInterpreter()</span></tt></a> を使って)
追加のインタプリタを作成できることに変わりはありませんが、複数インタプリタと
<tt class="xref c c-func docutils literal"><span class="pre">PyGILState_*()</span></tt> API を混ぜて使うことはサポートされていません。</p>
<p>注意しないといけないもう一つの重要な点は、 C の <tt class="xref c c-func docutils literal"><span class="pre">fork()</span></tt> を呼び出した時の動作です。ほとんどの <tt class="xref c c-func docutils literal"><span class="pre">fork()</span></tt> を持っているシステムでは、fork されたプロセスには fork を実行したスレッドしか存在しません。これは、別のスレッドに取得されたロックがずっと開放されないことを意味します。
Python は fork する前にロックを取得し、その後に fork を開放することでこの問題を解決しています。加えて、子プロセスではすべての <a class="reference internal" href="../library/threading.html#lock-objects"><em>Lock オブジェクト</em></a> をリセットします。
Python を拡張したり埋め込んだりしている場合、 Python に fork 前に取得したり
fork 後に開放しなければならない追加の (Python 以外の) ロックを Python に教える手段がありません。
Python と同じことを実現するには、 <tt class="xref c c-func docutils literal"><span class="pre">posix_atfork()</span></tt> のようなOSの機能を使う必要があります。加えて、Python を拡張したり埋め込んだりしているときに、 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><tt class="xref py py-func docutils literal"><span class="pre">os.fork()</span></tt></a>
を通してではなく直接 <tt class="xref c c-func docutils literal"><span class="pre">fork()</span></tt> を呼び出すと、fork後に失われるスレッドに取得されていた Python の内部ロックのためにデッドロックが発生するかもしれません。
<a class="reference internal" href="sys.html#PyOS_AfterFork" title="PyOS_AfterFork"><tt class="xref c c-func docutils literal"><span class="pre">PyOS_AfterFork()</span></tt></a> は必要なロックのリセットを試みますが、いつでもそれが可能とは限りません。</p>
</div>
<div class="section" id="api">
<h3>高レベルAPI<a class="headerlink" href="#api" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>C拡張を書いたりPythonインタプリタを埋め込むときに最も一般的に使われる型や関数は次のとおりです。</p>
<dl class="type">
<dt id="PyInterpreterState">
<tt class="descname">PyInterpreterState</tt><a class="headerlink" href="#PyInterpreterState" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このデータ構造体は、協調動作する多数のスレッド間で共有されている状態を表現します。同じインタプリタに属するスレッドはモジュール管理情報やその他いくつかの内部的な情報を共有しています。この構造体には公開 (public) のメンバはありません。</p>
<p>異なるインタプリタに属するスレッド間では、利用可能なメモリ、開かれているファイルデスクリプタなどといったプロセス状態を除いて、初期状態では何も共有されていません。
GILもまた、スレッドがどのインタプリタに属しているかに関わらずすべてのスレッドで共有されています。</p>
</dd></dl>

<dl class="type">
<dt id="PyThreadState">
<tt class="descname">PyThreadState</tt><a class="headerlink" href="#PyThreadState" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>単一のスレッドの状態を表現する表現するデータ構造体です。スレッドのインタプリタ状態を指すポインタ <a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState"><tt class="xref c c-type docutils literal"><span class="pre">PyInterpreterState</span> <span class="pre">*</span></tt></a> <tt class="xref py py-attr docutils literal"><span class="pre">interp</span></tt>
だけが公開されているデータメンバです。</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_InitThreads">
void <tt class="descname">PyEval_InitThreads</tt><big>(</big><big>)</big><a class="headerlink" href="#PyEval_InitThreads" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-18">GIL を初期化し、獲得します。この関数は、主スレッドが第二のスレッドを生成する以前や、
<a class="reference internal" href="#PyEval_ReleaseLock" title="PyEval_ReleaseLock"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_ReleaseLock()</span></tt></a> や <tt class="docutils literal"><span class="pre">PyEval_ReleaseThread(tstate)</span></tt>
といった他のスレッド操作に入るよりも前に呼び出されるようにしておかなければなりません。
<a class="reference internal" href="#PyEval_SaveThread" title="PyEval_SaveThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_SaveThread()</span></tt></a>, <a class="reference internal" href="#PyEval_RestoreThread" title="PyEval_RestoreThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_RestoreThread()</span></tt></a> の前に呼び出す必要はありません。</p>
<p id="index-19">二度目に呼び出すと何も行いません。この関数を <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> の前に呼び出しても安全です。</p>
<div class="admonition note" id="index-20">
<p class="first admonition-title">ノート</p>
<p>主スレッドしか存在しないのであれば、GIL操作は必要ありません。これはよくある状況ですし (ほとんどの Python プログラムはスレッドを使いません)、ロック操作はインタプリタをごくわずかに低速化します。従って、初期状態ではロックは生成されません。ロックを使わない状況は、すでにロックを獲得している状況と同じです: 単一のスレッドしかなければ、オブジェクトへのアクセスは全て安全です。従って、この関数がGILを初期化すると、同時にロックを獲得するようになっています。Python の <tt class="xref py py-mod docutils literal"><span class="pre">_thread</span></tt> モジュールは、新たなスレッドを作成する前に、ロックが存在するか、あるいはまだ作成されていないかを調べ、
<a class="reference internal" href="#PyEval_InitThreads" title="PyEval_InitThreads"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_InitThreads()</span></tt></a> を呼び出します。この関数から処理が戻った場合、ロックが作成され、呼び出し元スレッドがそのロックを獲得している事が保証されています。</p>
<p>どのスレッドが現在 GIL を (存在する場合) 持っているか分からない時にこの関数を使うのは安全では <strong>ありません</strong> 。</p>
<p class="last">この関数はコンパイル時にスレッドサポートを無効化すると利用できません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="PyEval_ThreadsInitialized">
int <tt class="descname">PyEval_ThreadsInitialized</tt><big>(</big><big>)</big><a class="headerlink" href="#PyEval_ThreadsInitialized" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#PyEval_InitThreads" title="PyEval_InitThreads"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_InitThreads()</span></tt></a> をすでに呼び出している場合は真 (非ゼロ)
を返します。この関数は、GILを獲得せずに呼び出すことができますので、シングルスレッドで実行している場合にはロック関連のAPI呼び出しを避けるために使うことができます。この関数はコンパイル時にスレッドサポートを無効化すると利用できません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyEval_SaveThread">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a>* <tt class="descname">PyEval_SaveThread</tt><big>(</big><big>)</big><a class="headerlink" href="#PyEval_SaveThread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(GIL が生成されていて、スレッドサポートが有効の場合) GILを解放して、スレッド状態を <em>NULL</em> にし、以前のスレッド状態 (<em>NULL</em> にはなりません)
を返します。ロックがすでに生成されている場合、現在のスレッドがロックを獲得していなければなりません。
(この関数はコンパイル時にスレッドサポートが無効にされていても利用できます。)</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_RestoreThread">
void <tt class="descname">PyEval_RestoreThread</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyEval_RestoreThread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(GIL が生成されていて、スレッドサポートが有効の場合) GIL を獲得して、現在のスレッド状態を <em>tstate</em> に設定します。
<em>tstate</em> は <em>NULL</em> であってはなりません。
GIL が生成されていて、この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。
(この関数はコンパイル時にスレッドサポートが無効にされていても利用できます。)</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_Get">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a>* <tt class="descname">PyThreadState_Get</tt><big>(</big><big>)</big><a class="headerlink" href="#PyThreadState_Get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のスレッド状態を返します。GIL を保持していなければなりません。現在のスレッド状態が <em>NULL</em> なら、(呼び出し側が <em>NULL</em> チェックをしなくてすむように)
この関数は致命的エラーを起こすようになっています。</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_Swap">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a>* <tt class="descname">PyThreadState_Swap</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyThreadState_Swap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のスレッド状態を <em>tstate</em> に指定したスレッド状態と入れ変えます。
<em>tstate</em> は <em>NULL</em> の場合があります。
GIL を保持していなければならず、開放しません。</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_ReInitThreads">
void <tt class="descname">PyEval_ReInitThreads</tt><big>(</big><big>)</big><a class="headerlink" href="#PyEval_ReInitThreads" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="sys.html#PyOS_AfterFork" title="PyOS_AfterFork"><tt class="xref c c-func docutils literal"><span class="pre">PyOS_AfterFork()</span></tt></a> から呼び出され、新しい子プロセスが、子プロセス内で実行していないスレッドが持っているロックを持たないようにします。</p>
</dd></dl>

<p>以下の関数はスレッドローカルストレージを利用していて、サブインタプリタとの互換性がありません。</p>
<dl class="function">
<dt id="PyGILState_Ensure">
PyGILState_STATE <tt class="descname">PyGILState_Ensure</tt><big>(</big><big>)</big><a class="headerlink" href="#PyGILState_Ensure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Pythonの状態やGILに関わらず、実行中スレッドでPython C APIの呼び出しが可能となるようにします。この関数はスレッド内で何度でも呼び出すことができますが、必ず全ての呼び出しに対応して
<a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> を呼び出す必要があります。</p>
<p>通常、 <a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> 呼び出しと
<a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> 呼び出しの間でこれ以外のスレッド関連API
を使用することができますが、Release()の前にスレッド状態は復元されていなければなりません。例えば、通常の <a class="reference internal" href="#Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></tt></a> マクロと
<a class="reference internal" href="#Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_END_ALLOW_THREADS</span></tt></a> は使用することができます。</p>
<p>戻り値は <a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> 呼び出し時のスレッド状態を隠蔽した&#8221;ハンドル&#8221;で、 <a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> に渡してPythonを同じ状態に保たなければなりません。再起呼び出しも可能ですが、ハンドルを共有することは <em>できません</em> -
それぞれの <a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> 呼び出しでハンドルを保存し、対応する <a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> 呼び出しで渡してください。</p>
<p>関数から復帰したとき、実行中のスレッドはGILを所有していて、任意の Python コードを実行できます。処理の失敗は致命的なエラーです。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyGILState_Release">
void <tt class="descname">PyGILState_Release</tt><big>(</big>PyGILState_STATE<big>)</big><a class="headerlink" href="#PyGILState_Release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>獲得したすべてのリソースを開放します。この関数を呼び出すと、Pythonの状態は対応する <a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> を呼び出す前と同じとなります。(通常、この状態は呼び出し元でははわかりませんので、GILState APIを利用するようにしてください。）</p>
<p><a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> を呼び出す場合は、必ず同一スレッド内で対応する
<a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> を呼び出してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<p>以下のマクロは、通常末尾にセミコロンを付けずに使います;
Python ソース配布物内の使用例を見てください。</p>
<dl class="macro">
<dt id="Py_BEGIN_ALLOW_THREADS">
<tt class="descname">Py_BEGIN_ALLOW_THREADS</tt><a class="headerlink" href="#Py_BEGIN_ALLOW_THREADS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このマクロを展開すると <tt class="docutils literal"><span class="pre">{</span> <span class="pre">PyThreadState</span> <span class="pre">*_save;</span> <span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></tt> になります。マクロに開き波括弧が入っていることに注意してください; この波括弧は後で <a class="reference internal" href="#Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_END_ALLOW_THREADS</span></tt></a>
マクロと対応させなければなりません。マクロについての詳しい議論は上記を参照してください。コンパイル時にスレッドサポートが無効化されていると何も行いません。</p>
</dd></dl>

<dl class="macro">
<dt id="Py_END_ALLOW_THREADS">
<tt class="descname">Py_END_ALLOW_THREADS</tt><a class="headerlink" href="#Py_END_ALLOW_THREADS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このマクロを展開すると <tt class="docutils literal"><span class="pre">PyEval_RestoreThread(_save);</span> <span class="pre">}</span></tt> になります。マクロに開き波括弧が入っていることに注意してください; この波括弧は事前の <a class="reference internal" href="#Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></tt></a>
マクロと対応していなければなりません。マクロについての詳しい議論は上記を参照してください。コンパイル時にスレッドサポートが無効化されていると何も行いません。</p>
</dd></dl>

<dl class="macro">
<dt id="Py_BLOCK_THREADS">
<tt class="descname">Py_BLOCK_THREADS</tt><a class="headerlink" href="#Py_BLOCK_THREADS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このマクロを展開すると <tt class="docutils literal"><span class="pre">PyEval_RestoreThread(_save);</span></tt> になります:
閉じ波括弧のない <a class="reference internal" href="#Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_END_ALLOW_THREADS</span></tt></a> と同じです。コンパイル時にスレッドサポートが無効化されていると何も行いません。</p>
</dd></dl>

<dl class="macro">
<dt id="Py_UNBLOCK_THREADS">
<tt class="descname">Py_UNBLOCK_THREADS</tt><a class="headerlink" href="#Py_UNBLOCK_THREADS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このマクロを展開すると <tt class="docutils literal"><span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></tt> になります:
開き波括弧のない <a class="reference internal" href="#Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><tt class="xref c c-macro docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></tt></a> と同じです。コンパイル時にスレッドサポートが無効化されていると何も行いません。</p>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>低レベルAPI<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の全ての関数はコンパイル時にスレッドサポートが有効になっている時だけ利用でき、呼び出すのはGILがすでに作成されている場合だけにしなくてはなりません。</p>
<dl class="function">
<dt id="PyInterpreterState_New">
<a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <tt class="descname">PyInterpreterState_New</tt><big>(</big><big>)</big><a class="headerlink" href="#PyInterpreterState_New" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいインタプリタ状態オブジェクトを生成します。
GIL を保持しておく必要はありませんが、この関数を次々に呼び出す必要がある場合には保持しておいたほうがよいでしょう。</p>
</dd></dl>

<dl class="function">
<dt id="PyInterpreterState_Clear">
void <tt class="descname">PyInterpreterState_Clear</tt><big>(</big><a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em>&nbsp;*interp</em><big>)</big><a class="headerlink" href="#PyInterpreterState_Clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタ状態オブジェクト内の全ての情報をリセットします。
GIL を保持していなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="PyInterpreterState_Delete">
void <tt class="descname">PyInterpreterState_Delete</tt><big>(</big><a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em>&nbsp;*interp</em><big>)</big><a class="headerlink" href="#PyInterpreterState_Delete" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタ状態オブジェクトを破壊します。GIL を保持しておく必要はありません。インタプリタ状態は <a class="reference internal" href="#PyInterpreterState_Clear" title="PyInterpreterState_Clear"><tt class="xref c c-func docutils literal"><span class="pre">PyInterpreterState_Clear()</span></tt></a> であらかじめリセットしておかなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_New">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a>* <tt class="descname">PyThreadState_New</tt><big>(</big><a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em>&nbsp;*interp</em><big>)</big><a class="headerlink" href="#PyThreadState_New" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定したインタプリタオブジェクトに属する新たなスレッド状態オブジェクトを生成します。
GIL を保持しておく必要はありませんが、この関数を次々に呼び出す必要がある場合には保持しておいたほうがよいでしょう。</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_Clear">
void <tt class="descname">PyThreadState_Clear</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyThreadState_Clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッド状態オブジェクト内の全ての情報をリセットします。
GIL を保持していなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_Delete">
void <tt class="descname">PyThreadState_Delete</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyThreadState_Delete" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッド状態オブジェクトを破壊します。GIL を保持する必要はありません。スレッド状態は <a class="reference internal" href="#PyThreadState_Clear" title="PyThreadState_Clear"><tt class="xref c c-func docutils literal"><span class="pre">PyThreadState_Clear()</span></tt></a> であらかじめリセットしておかなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_GetDict">
<a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a>* <tt class="descname">PyThreadState_GetDict</tt><big>(</big><big>)</big><a class="headerlink" href="#PyThreadState_GetDict" title="この定義へのパーマリンク">¶</a></dt>
<dd><em class="refcount">Return value: Borrowed reference.</em><p>拡張モジュールがスレッド固有の状態情報を保存できるような辞書を返します。各々の拡張モジュールが辞書に状態情報を保存するためには唯一のキーを使わねばなりません。現在のスレッド状態がない時にこの関数を呼び出してもかまいません。この関数が
<em>NULL</em> を返す場合、例外はまったく送出されず、呼び出し側は現在のスレッド状態が利用できないと考えねばなりません。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>以前は、現在のスレッドがアクティブなときのみ呼び出せるようになっており、
<em>NULL</em> は例外が送出されたことを意味していました.</p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_SetAsyncExc">
int <tt class="descname">PyThreadState_SetAsyncExc</tt><big>(</big>long<em>&nbsp;id</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*exc</em><big>)</big><a class="headerlink" href="#PyThreadState_SetAsyncExc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッド内で非同期的に例外を送出します。 <em>id</em> 引数はターゲットとなるスレッドのスレッド id です; <em>exc</em> は送出する例外オブジェクトです。この関数は <em>exc</em> に対する参照を一切盗み取りません。素朴な間違いを防ぐため、この関数を呼び出すには独自に C 拡張モジュールを書かねばなりません。
GIL を保持した状態で呼び出さなければなりません。</p>
<p>変更を受けたスレッド状態の数を返します; これは普通は1ですが、スレッドidが見つからなかった場合は0になります。もし <em>exc</em> が
<tt class="xref py py-const docutils literal"><span class="pre">NULL</span></tt> であれば、そのスレッドで保留されている例外があればクリアします。この場合は例外は発生しません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyEval_AcquireThread">
void <tt class="descname">PyEval_AcquireThread</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyEval_AcquireThread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>GIL を獲得し、現在のスレッド状態を <em>tstate</em> に設定します。
<em>tstate</em> は <em>NULL</em> であってはなりません。ロックはあらかじめ作成されていなければなりません。この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。</p>
<p><a class="reference internal" href="#PyEval_RestoreThread" title="PyEval_RestoreThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_RestoreThread()</span></tt></a> はより高レベルな関数で常に(スレッドサポートが無効な場合やスレッドが初期化されていない場合でも)利用できます。</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_ReleaseThread">
void <tt class="descname">PyEval_ReleaseThread</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyEval_ReleaseThread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のスレッド状態をリセットして <em>NULL</em> にし、GIL を解放します。ロックはあらかじめ作成されていなければならず、かつ現在のスレッドが保持していなければなりません。
<em>tstate</em> は <em>NULL</em> であってはなりませんが、その値が現在のスレッド状態を表現しているかどうかを調べるためにだけ使われます &#8212; もしそうでなければ、致命的エラーが報告されます。</p>
<p><a class="reference internal" href="#PyEval_SaveThread" title="PyEval_SaveThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_SaveThread()</span></tt></a> はより高レベルな関数で常に(スレッドサポートが無効な場合やスレッドが初期化されていない場合でも)利用できます。</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_AcquireLock">
void <tt class="descname">PyEval_AcquireLock</tt><big>(</big><big>)</big><a class="headerlink" href="#PyEval_AcquireLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>GILを獲得します。ロックは前もって作成されていなければなりません。この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">この関数は現在のスレッド状態を変更しません。代わりに
<a class="reference internal" href="#PyEval_RestoreThread" title="PyEval_RestoreThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_RestoreThread()</span></tt></a> か <a class="reference internal" href="#PyEval_AcquireThread" title="PyEval_AcquireThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_AcquireThread()</span></tt></a> を利用してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="PyEval_ReleaseLock">
void <tt class="descname">PyEval_ReleaseLock</tt><big>(</big><big>)</big><a class="headerlink" href="#PyEval_ReleaseLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>GILを解放します。ロックは前もって作成されていなければなりません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">この関数は現在のスレッド状態を変更しません。代わりに
<a class="reference internal" href="#PyEval_SaveThread" title="PyEval_SaveThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_SaveThread()</span></tt></a> か <a class="reference internal" href="#PyEval_ReleaseThread" title="PyEval_ReleaseThread"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_ReleaseThread()</span></tt></a> を利用してください。</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="id4">
<h2>サブインタプリタサポート<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ほとんどの場合は埋め込む Python インタプリタは1つだけですが、いくつかの場合に同一プロセス内、あるいは同一スレッド内で、複数の独立したインタプリタを作成する必要があります。サブインタプリタはこれを可能にします。
<a class="reference internal" href="#PyThreadState_Swap" title="PyThreadState_Swap"><tt class="xref c c-func docutils literal"><span class="pre">PyThreadState_Swap()</span></tt></a> 関数を使ってサブインタプリタを切り替えることができます。以下の関数を使ってサブインタプリタの作成と削除を行えます。</p>
<dl class="function">
<dt id="Py_NewInterpreter">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a>* <tt class="descname">Py_NewInterpreter</tt><big>(</big><big>)</big><a class="headerlink" href="#Py_NewInterpreter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-21">新しいサブインタプリタ (sub-interpreter) を生成します。サブインタプリタとは、(ほぼ完全に) 個別に分割された Python コードの実行環境です。特に、新しいサブインタプリタは、 import されるモジュール全てについて個別のバージョンを持ち、これには基盤となるモジュール <a class="reference internal" href="../library/__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: トップレベルスクリプトが実行される環境。"><tt class="xref py py-mod docutils literal"><span class="pre">__main__</span></tt></a> および <a class="reference internal" href="../library/sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a>
も含まれます。ロード済みのモジュールからなるテーブル
(<tt class="docutils literal"><span class="pre">sys.modules</span></tt>)  およびモジュール検索パス (<tt class="docutils literal"><span class="pre">sys.path</span></tt>) もサブインタプリタ毎に別個のものになります。新たなサブインタプリタ環境には <tt class="docutils literal"><span class="pre">sys.argv</span></tt> 変数がありません。また、サブインタプリタは新たな標準 I/O ストリーム <tt class="docutils literal"><span class="pre">sys.stdin</span></tt>, <tt class="docutils literal"><span class="pre">sys.stdout</span></tt>, <tt class="docutils literal"><span class="pre">sys.stderr</span></tt>
を持ちます (とはいえ、これらのストリームは根底にある C ライブラリの同じ <tt class="xref c c-type docutils literal"><span class="pre">FILE</span></tt>
構造体を参照しています)。</p>
<p>戻り値は、新たなサブインタプリタが生成したスレッド状態 (thread state) オブジェクトのうち、最初のものを指しています。このスレッド状態が現在のスレッド状態 (current thread state) になります。実際のスレッドが生成されるわけではないので注意してください;
下記のスレッド状態に関する議論を参照してください。新たなインタプリタの生成に失敗すると、 <em>NULL</em> を返します;
例外状態はセットされませんが、これは例外状態が現在のスレッド状態に保存されることになっていて、現在のスレッド状態なるものが存在しないことがあるからです。
(他の Python/C API 関数のように、この関数を呼び出す前にはGILが保持されていなければならず、関数が処理を戻した際にも保持されたままになります; しかし、他の Python/C API
関数とは違い、関数から戻ったときの現在のスレッド状態が関数に入るときと同じとは限らないので注意してください)。</p>
<p id="index-22">拡張モジュールは以下のような形で (サブ) インタプリタ間で共有されます:
ある特定の拡張モジュールを最初に import すると、モジュールを通常通りに初期化し、そのモジュールの辞書の
(浅い) コピーをしまい込んでおきます。他の (サブ) インタプリタが同じ拡張モジュールを import すると、新たなモジュールを初期化し、先ほどのコピーの内容で辞書の値を埋めます; 拡張モジュールの <tt class="docutils literal"><span class="pre">init</span></tt>
関数は呼び出されません。この挙動は、 <a class="reference internal" href="#Py_Finalize" title="Py_Finalize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Finalize()</span></tt></a> および <a class="reference internal" href="#Py_Initialize" title="Py_Initialize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Initialize()</span></tt></a> を呼び出してインタプリタを完全に再初期化した後に拡張モジュールを import した際の挙動とは異なるので注意してください;
再初期化後に import を行うと、拡張モジュールの <tt class="docutils literal"><span class="pre">initmodule</span></tt> は再度 <em>呼び出されます</em> 。</p>
<span class="target" id="index-23"></span></dd></dl>

<dl class="function">
<dt id="Py_EndInterpreter">
void <tt class="descname">Py_EndInterpreter</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#Py_EndInterpreter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-24">指定されたスレッド状態 <em>tstate</em> で表現される (サブ) インタプリタを抹消します。
<em>tstate</em> は現在のスレッド状態でなければなりません。下記のスレッド状態に関する議論を参照してください。関数呼び出しが戻ったとき、現在のスレッド状態は <em>NULL</em> になっています。このインタプリタに関連付けられた全てのスレッド状態は抹消されます。
(この関数を呼び出す前にはGILを保持しておかねばならず、ロックは関数が戻ったときも保持されています。) <a class="reference internal" href="#Py_Finalize" title="Py_Finalize"><tt class="xref c c-func docutils literal"><span class="pre">Py_Finalize()</span></tt></a> は、その時点で明示的に抹消されていない全てのサブインタプリタを抹消します。</p>
</dd></dl>

<div class="section" id="id5">
<h3>バグと注意事項<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サブインタプリタ (とメインインタプリタ) は同じプロセスの一部分なので、インタプリタ間の隔離は完璧ではありません &#8212; 例えば、 <a class="reference internal" href="../library/os.html#os.close" title="os.close"><tt class="xref py py-func docutils literal"><span class="pre">os.close()</span></tt></a> のような低レベルのファイル操作を使うと、
(偶然なり故意なりに) 互いのインタプリタ下にある開かれたファイルに影響を及ぼせてしまいます。拡張モジュールを (サブ) インタプリタ間で共有する方法のせいで、拡張モジュールによっては正しく動作しないかもしれません;
拡張モジュールが (静的な) グローバル変数を利用している場合や、拡張モジュールが初期化後に自身のモジュール辞書を操作する場合には特にそうです。一つのサブインタプリタで生成されたオブジェクトは他のサブインタプリタの名前空間への挿入が可能です; ユーザ定義関数、メソッド、インスタンスおよびクラスをサブインタプリタをサブインタプリタ間で共有しないように十分注意してください。というのは、これらの共有オブジェクトが実行した import
文は間違った (サブ) インタプリタのロード済みモジュール辞書に影響を及ぼす場合があるからです。</p>
<p>サブインタプリタを <tt class="xref c c-func docutils literal"><span class="pre">PyGILState_*()</span></tt> API と組み合わせるのが難しいことにも注意してください。これらのAPIはPythonのスレッド状態とOSレベルスレッドが1対1で対応していることを前提にしていて、サブインタプリタが存在するとその前提が崩れるからです。対応する <a class="reference internal" href="#PyGILState_Ensure" title="PyGILState_Ensure"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Ensure()</span></tt></a> と <a class="reference internal" href="#PyGILState_Release" title="PyGILState_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyGILState_Release()</span></tt></a> の呼び出しのペアの間では、サブインタプリタの切り替えを行わないことを強く推奨します。さらに、(<a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> のような)これらのAPIを使ってPythonの外で作られたスレッドから
Pythonコードを実行している拡張モジュールはサブインタプリタを使うと壊れる可能性があります。</p>
</div>
</div>
<div class="section" id="id6">
<h2>非同期通知<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>メインのインタプリタスレッドへの非同期通知機構が提供されています。この通知は関数ポインタと void 引数の形をしています。</p>
<p id="index-25">各チェックインターバルにおいて、GILがリリースされて再取得されるときに、
Python はそのような提供された関数を呼び出します。この関数は例えば非同期IOハンドラなどが利用できます。通知はワーカースレッドなどからスケジュールされ、実際の呼び出しはメインスレッドで最初の、GILを所有していて任意の Python API 呼び出しが可能なタイミングで実行されます。</p>
<dl class="function">
<dt id="Py_AddPendingCall">
int <tt class="descname">Py_AddPendingCall</tt><big>(</big>int (*func)(void<em>&nbsp;*)</em>, void<em>&nbsp;*arg</em><big>)</big><a class="headerlink" href="#Py_AddPendingCall" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-26">Python のメインスレッドへの通知を登録します。成功した場合、 <em>func</em> は引数 <em>arg</em> と共に、最初の適切なタイミングで呼び出されます。
<em>func</em> は GIL を取得した状態で呼び出されるので、任意の Python API を利用することができ、オブジェクトの属性にIOの完了を知らせるなど、任意の動作をすることができます。通知関数は成功したときには 0 を、例外を通知するときには -1 を返さなければなりません。通知関数は他の通知関数を再帰的に実行するために割り込まれることはありませんが、たとえばPythonコードをコールバックしたときにGILを開放して他のスレッドに切り替えられる可能性はあります。</p>
<p>この関数は成功して通知関数がスケジュールされたときは 0 を返します。それ以外の場合、たとえば通知バッファがいっぱいのときは、例外を設定せずに
-1 を返します。</p>
<p>この関数はどのスレッドからでも、 Python スレッドでもそれ以外のシステムスレッドからでも呼び出すことができます。
Python スレッドから呼び出される場合は、GILを確保していてもいなくてもかまいません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

</div>
<div class="section" id="profiling-and-tracing">
<span id="profiling"></span><h2>プロファイルとトレース (profiling and tracing)<a class="headerlink" href="#profiling-and-tracing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python インタプリタは、プロファイル: 分析 (profile) や実行のトレース: 追跡 (trace) といった機能を組み込むために低水準のサポートを提供しています。このサポートは、プロファイルやデバッグ、適用範囲分析 (coverage analysis) ツールなどに使われます。</p>
<p>Python 2.2 になってから、この機能の実装は実質的に作り直され、 C から呼び出すためのインタフェースが追加されました。この C
インタフェースは、プロファイルやトレース作業時に、 Python レベルの呼び出し可能オブジェクトが呼び出されることによるオーバヘッドを避け、直接 C
関数呼び出しが行えるようにしています。プロファイルやトレース機能の本質的な特性は変わっていません;
インタフェースではとレース関数をスレッドごとにインストールでき、トレース関数に報告される基本イベント (basic event) は以前のバージョンにおいて
Python レベルのトレース関数で報告されていたものと同じです。</p>
<dl class="type">
<dt id="Py_tracefunc">
int <tt class="descname">(*Py_tracefunc)</tt><big>(</big><a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em>, PyFrameObject<em>&nbsp;*frame</em>, int<em>&nbsp;what</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*arg</em><big>)</big><a class="headerlink" href="#Py_tracefunc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#PyEval_SetProfile" title="PyEval_SetProfile"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_SetProfile()</span></tt></a> および <a class="reference internal" href="#PyEval_SetTrace" title="PyEval_SetTrace"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_SetTrace()</span></tt></a>
を使って登録できるトレース関数の形式です。最初のパラメタはオブジェクトで、登録関数に <em>obj</em> として渡されます。 <em>frame</em>
はイベントが属している実行フレームオブジェクトで、 <em>what</em> は定数 <tt class="xref py py-const docutils literal"><span class="pre">PyTrace_CALL</span></tt>,
<tt class="xref py py-const docutils literal"><span class="pre">PyTrace_EXCEPTION</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">PyTrace_LINE</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">PyTrace_RETURN</span></tt>,
<tt class="xref py py-const docutils literal"><span class="pre">PyTrace_C_CALL</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">PyTrace_C_EXCEPTION</span></tt>,
あるいは <tt class="xref py py-const docutils literal"><span class="pre">PyTrace_C_RETURN</span></tt> のいずれかで、 <em>arg</em> は <em>what</em> の値によって以下のように異なります:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>what</em> の値</th>
<th class="head"><em>arg</em> の意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_CALL</span></tt></td>
<td>常に <em>NULL</em> です。</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_EXCEPTION</span></tt></td>
<td><a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> の返す例外情報です。</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_LINE</span></tt></td>
<td>常に <em>NULL</em> です。</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_RETURN</span></tt></td>
<td>呼び出し側に返される予定の値か、例外によって関数を抜ける場合は <em>NULL</em> です。</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_C_CALL</span></tt></td>
<td>呼び出される関数オブジェクト</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_C_EXCEPTION</span></tt></td>
<td>呼び出された関数オブジェクト</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">PyTrace_C_RETURN</span></tt></td>
<td>呼び出された関数オブジェクト</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="var">
<dt id="PyTrace_CALL">
int <tt class="descname">PyTrace_CALL</tt><a class="headerlink" href="#PyTrace_CALL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数やメソッドが新たに呼び出されたり、ジェネレータが新たなエントリの処理に入ったことを報告する際の、 <a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc"><tt class="xref c c-type docutils literal"><span class="pre">Py_tracefunc</span></tt></a> の <em>what</em>
の値です。イテレータやジェネレータ関数の生成は、対応するフレーム内の Python バイトコードに制御の委譲 (control transfer)
が起こらないため報告されないので注意してください。</p>
</dd></dl>

<dl class="var">
<dt id="PyTrace_EXCEPTION">
int <tt class="descname">PyTrace_EXCEPTION</tt><a class="headerlink" href="#PyTrace_EXCEPTION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>例外が送出された際の <a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc"><tt class="xref c c-type docutils literal"><span class="pre">Py_tracefunc</span></tt></a> の <em>what</em> の値です。現在実行されているフレームで例外がセットされ、何らかのバイトコードが処理された後に、 <em>what</em> にこの値がセットされた状態でコールバック関数が呼び出されます。</p>
<p>この結果、例外の伝播によって Python が呼び出しスタックを逆戻りする際に、各フレームから処理が戻るごとにコールバック関数が呼び出されます。トレース関数だけがこれらのイベントを受け取ります; プロファイラはこの種のイベントを必要としません。</p>
</dd></dl>

<dl class="var">
<dt id="PyTrace_LINE">
int <tt class="descname">PyTrace_LINE</tt><a class="headerlink" href="#PyTrace_LINE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>行番号イベントを報告するときに (プロファイル関数ではなく) トレース関数の <em>what</em> パラメタとして渡す値です。</p>
</dd></dl>

<dl class="var">
<dt id="PyTrace_RETURN">
int <tt class="descname">PyTrace_RETURN</tt><a class="headerlink" href="#PyTrace_RETURN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数呼び出しが例外の伝播なしに返るときに <a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc"><tt class="xref c c-type docutils literal"><span class="pre">Py_tracefunc</span></tt></a> 関数の <em>what</em> パラメタとして渡す値です。</p>
</dd></dl>

<dl class="var">
<dt id="PyTrace_C_CALL">
int <tt class="descname">PyTrace_C_CALL</tt><a class="headerlink" href="#PyTrace_C_CALL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C関数を呼び出す直前に <a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc"><tt class="xref c c-type docutils literal"><span class="pre">Py_tracefunc</span></tt></a> 関数の <em>what</em> パラメタとして渡す値です。</p>
</dd></dl>

<dl class="var">
<dt id="PyTrace_C_EXCEPTION">
int <tt class="descname">PyTrace_C_EXCEPTION</tt><a class="headerlink" href="#PyTrace_C_EXCEPTION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C関数が例外を送出したときに <a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc"><tt class="xref c c-type docutils literal"><span class="pre">Py_tracefunc</span></tt></a> 関数の <em>what</em> パラメタとして渡す値です。</p>
</dd></dl>

<dl class="var">
<dt id="PyTrace_C_RETURN">
int <tt class="descname">PyTrace_C_RETURN</tt><a class="headerlink" href="#PyTrace_C_RETURN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C関数から戻るときに <a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc"><tt class="xref c c-type docutils literal"><span class="pre">Py_tracefunc</span></tt></a> 関数の <em>what</em> パラメタとして渡す値です。</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_SetProfile">
void <tt class="descname">PyEval_SetProfile</tt><big>(</big><a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc">Py_tracefunc</a><em>&nbsp;func</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em><big>)</big><a class="headerlink" href="#PyEval_SetProfile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロファイル関数を <em>func</em> に設定します。 <em>obj</em> パラメタは関数の第一パラメタとして渡され、何らかの Python オブジェクトかまたは
<em>NULL</em> になります。プロファイル関数がスレッド状態を維持する必要があるなら、各々のスレッドに異なる <em>obj</em> を使うことで、状態を記憶しておく便利でスレッドセーフな場所を提供できます。プロファイル関数は、モニタされているイベントのうち、行番号イベントを除く全てのイベントに対して呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="PyEval_SetTrace">
void <tt class="descname">PyEval_SetTrace</tt><big>(</big><a class="reference internal" href="#Py_tracefunc" title="Py_tracefunc">Py_tracefunc</a><em>&nbsp;func</em>, <a class="reference internal" href="structures.html#PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em><big>)</big><a class="headerlink" href="#PyEval_SetTrace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>トレース関数を <em>func</em> にセットします。 <a class="reference internal" href="#PyEval_SetProfile" title="PyEval_SetProfile"><tt class="xref c c-func docutils literal"><span class="pre">PyEval_SetProfile()</span></tt></a> に似ていますが、トレース関数は行番号イベントを受け取る点が違います。</p>
</dd></dl>

</div>
<div class="section" id="advanced-debugger-support">
<span id="advanced-debugging"></span><h2>高度なデバッガサポート (advanced debugger support)<a class="headerlink" href="#advanced-debugger-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数は高度なデバッグツールでの使用のためだけのものです。</p>
<dl class="function">
<dt id="PyInterpreterState_Head">
<a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <tt class="descname">PyInterpreterState_Head</tt><big>(</big><big>)</big><a class="headerlink" href="#PyInterpreterState_Head" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタ状態オブジェクトからなるリストのうち、先頭にあるものを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyInterpreterState_Next">
<a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <tt class="descname">PyInterpreterState_Next</tt><big>(</big><a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em>&nbsp;*interp</em><big>)</big><a class="headerlink" href="#PyInterpreterState_Next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタ状態オブジェクトからなるリストのうち、 <em>interp</em> の次にあるものを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyInterpreterState_ThreadHead">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a> * <tt class="descname">PyInterpreterState_ThreadHead</tt><big>(</big><a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em>&nbsp;*interp</em><big>)</big><a class="headerlink" href="#PyInterpreterState_ThreadHead" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタ <em>interp</em> に関連付けられているスレッドからなるリストのうち、先頭にある <a class="reference internal" href="#PyThreadState" title="PyThreadState"><tt class="xref c c-type docutils literal"><span class="pre">PyThreadState</span></tt></a>
オブジェクトを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="PyThreadState_Next">
<a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a>* <tt class="descname">PyThreadState_Next</tt><big>(</big><a class="reference internal" href="#PyThreadState" title="PyThreadState">PyThreadState</a><em>&nbsp;*tstate</em><big>)</big><a class="headerlink" href="#PyThreadState_Next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>tstate</em> と同じ <a class="reference internal" href="#PyInterpreterState" title="PyInterpreterState"><tt class="xref c c-type docutils literal"><span class="pre">PyInterpreterState</span></tt></a> オブジェクトに属しているスレッド状態オブジェクトのうち、 <em>tstate</em>
の次にあるものを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="memory.html" title="メモリ管理"
             >次へ</a> |</li>
        <li class="right" >
          <a href="code.html" title="コードオブジェクト"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python/C API リファレンスマニュアル</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>