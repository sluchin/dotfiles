.. _tut-structures:

**********
データ構造
**********

この章では、すでに学んだことについてより詳しく説明するとともに、いくつか
新しいことを追加します。


.. _tut-morelists:

リスト型についてもう少し
========================

リストデータ型には、他にもいくつかメソッドがあります。リストオブジェクトの
すべてのメソッドを以下に示します。

.. method:: list.append(x)
   :noindex:

   リストの末尾に要素を一つ追加します。 ``a[len(a):] = [x]`` と等価です。

.. method:: list.extend(L)
   :noindex:

   指定したリスト中のすべての要素を対象のリストに追加し、リストを拡張します。
   ``a[len(a):] = L`` と等価です。

.. method:: list.insert(i, x)
   :noindex:

   指定した位置に要素を挿入します。第 1 引数は、リストのインデクスで、
   そのインデクスを持つ要素の直前に挿入が行われます。従って、
   ``a.insert(0, x)`` はリストの先頭に挿入を行います。
   また ``a.insert(len(a), x)`` は ``a.append(x)`` と等価です。

.. method:: list.remove(x)
   :noindex:

   リスト中で、値 *x* を持つ最初の要素を削除します。該当する項目がなければ
   エラーとなります。

.. method:: list.pop([i])
   :noindex:

   リスト中の指定された位置にある要素をリストから削除して、その要素を返します。
   インデクスが指定されなければ、 ``a.pop()`` はリストの末尾の要素を削除して
   返します。
   この場合も要素は削除されます。 (メソッドの用法 (signature) で *i* の
   両側にある角括弧は、この引数がオプションであることを表しているだけなので、
   角括弧を入力する必要はありません。この表記法は Python Library Reference
   の中で頻繁に見ることになるでしょう。)

.. method:: list.index(x)
   :noindex:

   リスト中で、値 *x* を持つ最初の要素のインデクスを返します。
   該当する項目がなければエラーとなります。

.. method:: list.count(x)
   :noindex:

   リストでの *x* の出現回数を返します。

.. method:: list.sort()
   :noindex:

   リストの項目を、インプレース演算 (in place、元のデータを演算結果で置き換えるやりかた) でソートします。

.. method:: list.reverse()
   :noindex:

   リストの要素を、インプレース演算で逆順にします。

以下にリストのメソッドをほぼ全て使った例を示します。

::

   >>> a = [66.25, 333, 333, 1, 1234.5]
   >>> print a.count(333), a.count(66.25), a.count('x')
   2 1 0
   >>> a.insert(2, -1)
   >>> a.append(333)
   >>> a
   [66.25, 333, -1, 333, 1, 1234.5, 333]
   >>> a.index(333)
   1
   >>> a.remove(333)
   >>> a
   [66.25, -1, 333, 1, 1234.5, 333]
   >>> a.reverse()
   >>> a
   [333, 1234.5, 1, 333, -1, 66.25]
   >>> a.sort()
   >>> a
   [-1, 1, 66.25, 333, 333, 1234.5]


.. _tut-lists-as-stacks:

リストをスタックとして使う
--------------------------

.. sectionauthor:: Ka-Ping Yee <ping@lfw.org>

リスト型のメソッドのおかげで、簡単にリストをスタックとして使えます。
スタックでは、最後に追加された要素が最初に取り出されます ("last-in, first-out")。
スタックの一番上に要素を追加するには :meth:`append` を使います。
スタックの一番上から要素を取り出すには :meth:`pop` をインデクスを
指定せずに使います。例えば以下のようにします。

::

   >>> stack = [3, 4, 5]
   >>> stack.append(6)
   >>> stack.append(7)
   >>> stack
   [3, 4, 5, 6, 7]
   >>> stack.pop()
   7
   >>> stack
   [3, 4, 5, 6]
   >>> stack.pop()
   6
   >>> stack.pop()
   5
   >>> stack
   [3, 4]


.. _tut-lists-as-queues:

リストをキューとして使う
------------------------

.. sectionauthor:: Ka-Ping Yee <ping@lfw.org>

リストをキュー (queue) として使うことも可能です。
この場合、最初に追加した要素を最初に取り出します ("first-in, first-out")。
しかし、リストでは効率的にこの目的を達成することが出来ません。
追加（append）や取り出し（pop）をリストの末尾に対しておこなうと速いのですが、
挿入（insert）や取り出し（pop）をリストの先頭に対しておこなうと遅くなってしまいます
（他の要素をひとつずつずらす必要があるからです）。

キューの実装には、 :class:`collections.deque` を使うと良いでしょう。
このクラスは良く設計されていて、高速な追加（append）と取り出し（pop）を
両端に対して実現しています。例えば以下のようにします。

::

   >>> from collections import deque
   >>> queue = deque(["Eric", "John", "Michael"])
   >>> queue.append("Terry")           # Terry arrives
   >>> queue.append("Graham")          # Graham arrives
   >>> queue.popleft()                 # The first to arrive now leaves
   'Eric'
   >>> queue.popleft()                 # The second to arrive now leaves
   'John'
   >>> queue                           # Remaining queue in order of arrival
   deque(['Michael', 'Terry', 'Graham'])


.. _tut-functional:

関数型のプログラミングツール
----------------------------

組み込み関数には、リストに対して使うと非常に便利なものが三つあります。
:func:`filter`, :func:`map`, :func:`reduce` です。

``filter(function, sequence)`` は、シーケンス *sequence* 中の要素 *item* から、
``function(item)`` が真となるような要素からなるシーケンスを返します。
もし *sequence* が :class:`string` か :class:`tuple` なら、返り値も
同じ型になります。そうでなければ :class:`list` になります。
例えば、次のコードは25までの素数を計算します。

::

   >>> def f(x): return x % 2 != 0 and x % 3 != 0
   ...
   >>> filter(f, range(2, 25))
   [5, 7, 11, 13, 17, 19, 23]

``map(function, sequence)`` は、シーケンス *sequence* の各要素 *item* に対して
``function(item)`` を呼び出し、その戻り値からなるリストを返します。
例えば、三乗された値の列を計算するには以下のようにします。

::

   >>> def cube(x): return x*x*x
   ...
   >>> map(cube, range(1, 11))
   [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

.. More than one sequence may be passed; the function must then have as many
   arguments as there are sequences and is called with the corresponding item from
   each sequence (or ``None`` if some sequence is shorter than another).  For
   example::

複数のシーケンスを渡すこともできます。その場合、第一引数の関数はシーケンスの
数と等しい数の引数を受け取る必要があり、各シーケンスの値が渡されます。
(幾つかのシーケンスが他のシーケンスよりも短かった場合は、その場所には ``None``
が渡されます。)
例です。

::

   >>> seq = range(8)
   >>> def add(x, y): return x+y
   ...
   >>> map(add, seq, seq)
   [0, 2, 4, 6, 8, 10, 12, 14]

``reduce(function, sequence)`` は単一の値を返します。この値は 2 つの引数を
とる関数 *function* をシーケンス *sequence* の最初の二つの要素を引数として
呼び出し、次にその結果とシーケンスの次の要素を引数にとり、以降これを
繰り返していきます。例えば、 1 から 10 までの数の総和を計算するには
以下のようにします。

::

   >>> def add(x,y): return x+y
   ...
   >>> reduce(add, range(1, 11))
   55

シーケンス中にただ一つしか要素がなければ、その値自体が返されます。
シーケンスが空なら、例外が送出されます。

3 つめの引数をわたして、初期値を指定することもできます。この場合、
空のシーケンスを渡すと初期値が返されます。それ以外の場合には、
まず初期値とシーケンス中の最初の要素に対して関数が適用され、次いでその結果と
シーケンスの次の要素に対して適用され、以降これが繰り返されます。
例えば以下のようになります。

::

   >>> def sum(seq):
   ...     def add(x,y): return x+y
   ...     return reduce(add, seq, 0)
   ...
   >>> sum(range(1, 11))
   55
   >>> sum([])
   0

実際には、上の例のように :func:`sum` を定義しないでください。
数値の合計は広く必要とされている操作なので、すでに組み込み関数
``sum(sequence)`` が提供されており、上の例と全く同様に動作します。

.. versionadded:: 2.3


リストの内包表記
----------------

リストの内包表記 (list comprehension) は、 :func:`map` や :func:`filter` や
:keyword:`lambda` を使わずにリストを生成するための簡潔な方法を提供しています。
内包表記によるリストの定義は、たいてい :func:`map`, :func:`filter`, :keyword:`lambda`
を使ってリストを生成するコードよりも明快になります。
リストの内包表記は、式、続いて :keyword:`for` 節、そしてその後ろに続くゼロ個以上の
:keyword:`for` 節または :keyword:`if` 節からなります。
結果として得られるリストの要素は、式を、それに続く :keyword:`for` と :keyword:`if`
節のコンテキストで評価した値になります。
式をタプルとして評価したいなら、丸括弧で囲わなければなりません。

::

   >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
   >>> [weapon.strip() for weapon in freshfruit]
   ['banana', 'loganberry', 'passion fruit']
   >>> vec = [2, 4, 6]
   >>> [3*x for x in vec]
   [6, 12, 18]
   >>> [3*x for x in vec if x > 3]
   [12, 18]
   >>> [3*x for x in vec if x < 2]
   []
   >>> [[x,x**2] for x in vec]
   [[2, 4], [4, 16], [6, 36]]
   >>> [x, x**2 for x in vec]  # エラー - タプルには丸かっこが必要
     File "<stdin>", line 1, in ?
       [x, x**2 for x in vec]
                  ^
   SyntaxError: invalid syntax
   >>> [(x, x**2) for x in vec]
   [(2, 4), (4, 16), (6, 36)]
   >>> vec1 = [2, 4, 6]
   >>> vec2 = [4, 3, -9]
   >>> [x*y for x in vec1 for y in vec2]
   [8, 6, -18, 16, 12, -36, 24, 18, -54]
   >>> # 訳注: 上記の内包表記をループで書きなおすと、こうなります。
   >>> L = []
   >>> for x in vec1:
   ...     for y in vec2:
   ...         L.append(x*y)
   ...
   >>> L
   [8, 6, -18, 16, 12, -36, 24, 18, -54]
   >>> [x+y for x in vec1 for y in vec2]
   [6, 5, -7, 8, 7, -5, 10, 9, -3]
   >>> [vec1[i]*vec2[i] for i in range(len(vec1))]
   [8, 12, -54]

.. note::
   訳注: 内包表記の中に :keyword:`for` や :keyword:`if` が複数回現れる場合、
   左側の :keyword:`for`, :keyword:`if` が、内包表記ではなくループで書いた場合の
   外側のブロックになります。
   上の例はまだ判りやすいですが、複雑な内包表記はすぐに読みにくくなってしまうので、
   その場合はループで書き下した方が良いでしょう。

リストの内包表記は :func:`map` よりもはるかに柔軟性があり、
複雑な式や入れ子になった関数でも利用できます。

::

   >>> [str(round(355/113.0, i)) for i in range(1, 6)]
   ['3.1', '3.14', '3.142', '3.1416', '3.14159']


ネストしたリストの内包表記
--------------------------
もし望むなら、リストの内包表記はネストさせることができます。
ネストしたリストの内包表記はとても強力な道具なのですが
-- 全ての強力な道具がそうであるように -- とにかく気を付けて使う必要があります。

1行を1つのリストに対応させた3つのリストからなるリストで、3行3列の行列を
表現した例を考えます。

::

   >>> mat = [
   ...        [1, 2, 3],
   ...        [4, 5, 6],
   ...        [7, 8, 9],
   ...       ]

ここで、行と列を入れ換えたいとしたときにリストの内包表記が使えます。 ::

    >>> print [[row[i] for row in mat] for i in [0, 1, 2]]
    [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

*ネストした* リストの内包表記は特に気を付けて使わなければなりません。

    リストの内包表記を怖がらずにネストするためには、右から左へ読んでください。

このコードの断片のより冗長なバージョンを見ると処理の流れがはっきりします。 ::

    for i in [0, 1, 2]:
        for row in mat:
            print row[i],
        print

実際には複雑な流れの式よりも組み込み関数を使う方が良いです。
この場合 :func:`zip` 関数が良い仕事をしてくれるでしょう。 ::

    >>> zip(*mat)
    [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

この行にあるアスタリスクの詳細については :ref:`tut-unpacking-arguments`
を参照してください。


.. _tut-del:

:keyword:`del` 文
=================

リストから要素を削除する際、値を指定する代わりにインデックスを指定する方法が
あります。それが :keyword:`del` 文です。これは :meth:`pop` メソッドと違い、
値を返しません。
:keyword:`del` 文はリストからスライスを除去したり、リスト全体を削除する
こともできます(以前はスライスに空のリストを代入して行っていました)。
例えば以下のようにします。

::

   >>> a
   [-1, 1, 66.25, 333, 333, 1234.5]
   >>> del a[0]
   >>> a
   [1, 66.25, 333, 333, 1234.5]
   >>> del a[2:4]
   >>> a
   [1, 66.25, 1234.5]
   >>> del a[:]
   >>> a
   []

:keyword:`del` は変数全体の削除にも使えます。

::

   >>> del a

この文の後で名前 ``a`` を参照すると、(別の値を ``a`` に代入するまで) エラーになります。
:keyword:`del` の別の用途についてはまた後で取り上げます。


.. _tut-tuples:

タプルとシーケンス
==================

リストや文字列には、インデクスやスライスを使った演算のように、数多くの共通の
性質があることを見てきました。これらは *シーケンス (sequence)* データ型
(:ref:`typesseq` を参照) の二つの例です。
Python はまだ進歩の過程にある言語なので、他のシーケンスデータ型が追加される
かもしれません。標準のシーケンス型はもう一つあります: *タプル (tuple)* 型です。

タプルはコンマで区切られたいくつかの値からなります。例えば以下のように書きます。

::

   >>> t = 12345, 54321, 'hello!'
   >>> t[0]
   12345
   >>> t
   (12345, 54321, 'hello!')
   >>> # タプルを入れ子にしてもよい
   ... u = t, (1, 2, 3, 4, 5)
   >>> u
   ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))

ご覧のように、出力ではタプルは常に丸括弧で囲われています。
これは、入れ子になったタプルが正しく解釈されるようにするためです。
入力の際には丸括弧なしでもかまいませんが、結局 (タプルがより大きな式の一部分の
場合) 大抵必要となります。

タプルの用途はたくさんあります。
例えば、(x, y) 座標対、データベースから取り出した従業員レコードなどです。
タプルは文字列と同じく、変更不能です。
タプルの個々の要素に代入を行うことはできません (スライスと連結を使って同じ
効果を実現することはできますが)。
リストのような変更可能なオブジェクトの入ったタプルを作成することも可能です。

問題は 0 個または 1 個の項目からなるタプルの構築です。
これらの操作を行うため、構文には特別な細工がされています。
空のタプルは空の丸括弧ペアで構築できます。
一つの要素を持つタプルは、値の後ろにコンマを続ける (単一の値を丸括弧で囲む
だけでは不十分です) ことで構築できます。
美しくはないけれども、効果的です。例えば以下のようにします。 ::

   >>> empty = ()
   >>> singleton = 'hello',    # <-- 末尾のコンマに注目
   >>> len(empty)
   0
   >>> len(singleton)
   1
   >>> singleton
   ('hello',)

文 ``t = 12345, 54321, 'hello!'`` は *タプルのパック (tuple packing)* の例です。
値 ``12345``, ``54321``, ``'hello!'`` が一つのタプルにパックされます。
逆の演算も可能です。

::

   >>> x, y, z = t

この操作は、 *シーケンスのアンパック (sequence unpacking)* とでも
呼ぶべきもので、右辺には全てのシーケンス型を使うことができます。
シーケンスのアンパックでは、左辺に列挙されている変数が、右辺のシーケンスの
長さと同じであることが要求されます。
複数同時の代入が実はタプルのパックとシーケンスのアンパックを
組み合わせたものに過ぎないことに注意してください。

.. XXX Add a bit on the difference between tuples and lists.


.. _tut-sets:

集合型
======

Python には、 *集合 (set)* を扱うためのデータ型もあります。
集合とは、重複する要素をもたない、順序づけられていない要素の集まりです。
Set オブジェクトは、結合 (union)、交差 (intersection)、差分 (difference)、
対称差 (symmetric difference)といった数学的な演算もサポートしています。

簡単なデモンストレーションを示します。 ::

   >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
   >>> fruit = set(basket)               # 重複のない集合を作成
   >>> fruit
   set(['orange', 'pear', 'apple', 'banana'])
   >>> 'orange' in fruit                 # 高速なメンバシップテスト
   True
   >>> 'crabgrass' in fruit
   False

   >>> # 二つの単語の文字を例にした集合間の演算
   ...
   >>> a = set('abracadabra')
   >>> b = set('alacazam')
   >>> a                                  # a 内の一意な文字
   set(['a', 'r', 'b', 'c', 'd'])
   >>> a - b                              # a にあって b にない文字
   set(['r', 'd', 'b'])
   >>> a | b                              # a か b にある文字
   set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])
   >>> a & b                              # a と b の双方にある文字
   set(['a', 'c'])
   >>> a ^ b                              # a または b の片方だけにある文字
   set(['r', 'd', 'b', 'm', 'z', 'l'])


.. _tut-dictionaries:

辞書
====

もう一つ、有用な型が Python に組み込まれています。
それは *辞書 (dictionary)* (:ref:`typesmapping` を参照)です。
辞書は他の言語にも "連想記憶 (associated memory)" や "連想配列
(associative array)" という名前で存在することがあります。
ある範囲の数でインデクス化されているシーケンスと異なり、辞書は *キー (key)*
でインデクス化されています。
このキーは何らかの変更不能な型になります。文字列、数値は常にキーにすることが
できます。
タプルは、文字列、数値、その他のタプルのみを含む場合はキーにすることができます。
直接、あるいは間接的に変更可能なオブジェクトを含むタプルはキーにできません。
リストをキーとして使うことはできません。
これは、リストにスライスやインデクス指定の代入を行ったり、 :meth:`append`
や :meth:`extend` のようなメソッドを使うと、インプレースで変更することが
できるためです。

辞書は順序付けのされていない *キー(key): 値(value)* のペアの集合であり、
キーが (辞書の中で)一意でければならない、と考えるとよいでしょう。
波括弧 (brace) のペア: ``{}`` は空の辞書を生成します。カンマで区切られた key:
value のペアを波括弧ペアの間に入れると、辞書の初期値となる key: value
が追加されます; この表現方法は出力時に辞書が書き出されるのと同じ方法です。

辞書での主な操作は、ある値を何らかのキーを付けて記憶することと、
キーを指定して値を取り出すことです。
``del`` で key: value のペアを削除することもできます。
すでに使われているキーを使って値を記憶すると、以前そのキーに関連づけられていた
値は忘れ去られてしまいます。
存在しないキーを使って値を取り出そうとするとエラーになります。

辞書オブジェクトの :meth:`keys` メソッドは、辞書で使われている全ての
キーからなるリストを適当な順番で返します (ソートされたリストが欲しい場合は、
このキーのリストに :meth:`sorted` を使ってください)。
ある単一のキーが辞書にあるかどうか調べるには、
:keyword:`in` キーワードを使います。

以下に、辞書を使った簡単な例を示します。

::

   >>> tel = {'jack': 4098, 'sape': 4139}
   >>> tel['guido'] = 4127
   >>> tel
   {'sape': 4139, 'guido': 4127, 'jack': 4098}
   >>> tel['jack']
   4098
   >>> del tel['sape']
   >>> tel['irv'] = 4127
   >>> tel
   {'guido': 4127, 'irv': 4127, 'jack': 4098}
   >>> tel.keys()
   ['guido', 'irv', 'jack']
   >>> 'guido' in tel
   True

:func:`dict` コンストラクタは、キーと値のペアのタプルを含むリストから辞書を
生成します。
キーと値のペアがあるパターンをなしているなら、リストの内包表現を使えば
キーと値のリストをコンパクトに指定できます。

::

   >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
   {'sape': 4139, 'jack': 4098, 'guido': 4127}
   >>> dict([(x, x**2) for x in (2, 4, 6)])     # リスト内包表現を利用
   {2: 4, 4: 16, 6: 36}

後ほど、 key, value ペアを :func:`dict` コンストラクタに渡すのにより適した、
ジェネレータ式について学習します。

キーが単純な文字列の場合、キーワード引数を使って定義する方が単純な場合も
あります。

::

   >>> dict(sape=4139, guido=4127, jack=4098)
   {'sape': 4139, 'jack': 4098, 'guido': 4127}


.. _tut-loopidioms:

ループのテクニック
==================

辞書に対してループを行う際、 :meth:`iteritems` メソッドを使うと、キーと
それに対応する値を同時に取り出せます。

::

   >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
   >>> for k, v in knights.iteritems():
   ...     print k, v
   ...
   gallahad the pure
   robin the brave

シーケンスにわたるループを行う際、 :func:`enumerate` 関数を使うと、要素の
インデックスと要素を同時に取り出すことができます。

::

   >>> for i, v in enumerate(['tic', 'tac', 'toe']):
   ...     print i, v
   ...
   0 tic
   1 tac
   2 toe

二つまたはそれ以上のシーケンス型を同時にループするために、関数 :func:`zip`
を使って各要素をひと組みにすることができます。

::

   >>> questions = ['name', 'quest', 'favorite color']
   >>> answers = ['lancelot', 'the holy grail', 'blue']
   >>> for q, a in zip(questions, answers):
   ...     print 'What is your {0}?  It is {1}.'.format(q, a)
   ...
   What is your name?  It is lancelot.
   What is your quest?  It is the holy grail.
   What is your favorite color?  It is blue.

シーケンスを逆方向に渡ってループするには、まずシーケンスの範囲を順方向に
指定し、次いで関数 :func:`reversed` を呼び出します。

::

   >>> for i in reversed(xrange(1,10,2)):
   ...     print i
   ...
   9
   7
   5
   3
   1

シーケンスをソートされた順序でループするには、 :func:`sorted` 関数を使います。
この関数は元の配列を変更せず、ソート済みの新たな配列を返します。

::

   >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
   >>> for f in sorted(set(basket)):
   ...     print f
   ...
   apple
   banana
   orange
   pear


.. _tut-conditions:

条件についてもう少し
====================

``while`` や ``if`` 文で使った条件 (condiction) には、値の比較だけでなく、
他の演算子も使うことができます、

比較演算子 ``in`` および ``not in`` は、ある値があるシーケンス中に存在するか
(または存在しないか) どうかを調べます。
演算子 ``is``  および ``is not`` は、二つのオブジェクトが実際に同じ
オブジェクトであるかどうかを調べます。
この比較は、リストのような変更可能なオブジェクトにだけ意味があります。
全ての比較演算子は同じ優先順位を持っており、ともに数値演算子よりも低い
優先順位となります。

.. note::
   訳注: ``is`` は、 ``is None`` のように、シングルトンの変更不能オブジェクトとの
   比較に用いる場合もあります。(「変更可能なオブジェクトにだけ意味があります」の
   部分を削除することを Doc-SIG に提案中。)

比較は連結させることができます。例えば、 ``a < b == c`` は、 ``a`` が ``b``
より小さく、かつ ``b`` と ``c`` が等しいかどうかをテストします。

ブール演算子 ``and`` や ``or`` で比較演算を組み合わせることができます。
そして、比較演算 (あるいは何らかのブール式) の結果の否定は ``not`` でとれます。
これらの演算子は全て、比較演算子よりも低い優先順位になっています。
``A and not B or C`` と ``(A and (not B)) or C`` が等価になるように、
ブール演算子の中で、 ``not`` の優先順位が最も高く、 ``or`` が最も低く
なっています。もちろん、丸括弧を使えば望みの組み合わせを表現できます。

ブール演算子 ``and`` と ``or`` は、いわゆる *短絡 (short-circuit)* 演算子です。
これらの演算子の引数は左から右へと順に評価され、結果が確定した時点で
評価を止めます。
例えば、 ``A`` と ``C`` は真で ``B`` が偽のとき、 ``A and B and C`` は式 ``C``
を評価しません。
一般に、短絡演算子の戻り値をブール値ではなくて一般的な値として用いると、
値は最後に評価された引数になります。

比較や他のブール式の結果を変数に代入することもできます。例えば、

::

   >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
   >>> non_null = string1 or string2 or string3
   >>> non_null
   'Trondheim'

Python では、C 言語と違って、式の内部で代入を行えないので注意してください。
C 言語のプログラマは不満に思うかもしれませんが、この仕様は、 C 言語プログラムで
遭遇する、式の中で ``==`` のつもりで ``=`` とタイプしてしまうといったありふれた
問題を回避します。


.. _tut-comparing:

シーケンスとその他の型の比較
============================

シーケンスオブジェクトは同じシーケンス型の他のオブジェクトと比較できます。
比較には *辞書的な (lexicographical)* 順序が用いられます。
まず、最初の二つの要素を比較し、その値が等しくなければその時点で比較結果が
決まります。
等しければ次の二つの要素を比較し、以降シーケンスの要素が尽きるまで続けます。
比較しようとする二つの要素がいずれも同じシーケンス型であれば、
そのシーケンス間での辞書比較を再帰的に行います。
二つのシーケンスの全ての要素の比較結果が等しくなれば、シーケンスは等しいと
みなされます。
片方のシーケンスがもう一方の先頭部分にあたる部分シーケンスならば、短い方の
シーケンスが小さいシーケンスとみなされます。
文字列に対する辞書的な順序づけには、個々の文字ごとに ASCII 順序を用います。
以下に、同じ型のオブジェクトを持つシーケンス間での比較を行った例を示します。

::

   (1, 2, 3)              < (1, 2, 4)
   [1, 2, 3]              < [1, 2, 4]
   'ABC' < 'C' < 'Pascal' < 'Python'
   (1, 2, 3, 4)           < (1, 2, 4)
   (1, 2)                 < (1, 2, -1)
   (1, 2, 3)             == (1.0, 2.0, 3.0)
   (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

違う型のオブジェクト間の比較は認められていることに注意してください。
比較結果は決定性がありますが、その決め方は、型は型の名前で順番づけられる、
という恣意的なものです。
従って、リスト (list) 型は常に文字列 (string) 型よりも小さく、文字列型は
常にタプル (tuple) よりも小さい、といった具合になります。 [#]_
型混合の数値の比較は、数値そのものに従って比較されるので、例えば 0 は 0.0
と等しい、という結果になります。

.. rubric:: 注記

.. [#] 異なる型のオブジェクトを比較するための規則を今後にわたって当てにしてはなりません。
   Python 言語の将来のバージョンでは変更されるかもしれません。

