.. _tut-classes:

******
クラス
******

.. Python's class mechanism adds classes to the language with a minimum of new
   syntax and semantics.  It is a mixture of the class mechanisms found in C++ and
   Modula-3.  As is true for modules, classes in Python do not put an absolute
   barrier between definition and user, but rather rely on the politeness of the
   user not to "break into the definition."  The most important features of classes
   are retained with full power, however: the class inheritance mechanism allows
   multiple base classes, a derived class can override any methods of its base
   class or classes, and a method can call the method of a base class with the same
   name.  Objects can contain an arbitrary amount of data.

Python は、他のプログラミング言語と比て、最小限の構文と意味付けを使って
クラスを言語に追加しています。
Python のクラスは、 C++ と Modula-3 のクラスメカニズムを混ぜたものです。
Python のクラス機構はオブジェクト指向プログラミングの標準的な機能を全て
提供しています。クラスの継承メカニズムは、複数の基底クラスを持つことができ、
派生クラスで基底クラスの任意のメソッドをオーバライドすることができます。
メソッドでは、基底クラスのメソッドを同じ名前で呼び出すことができます。
オブジェクトには任意の種類と数のデータを格納することができます。
モジュールと同じく、クラス機構も Python の動的な性質に従うように
設計されています。クラスは実行時に生成され、生成後に変更することができます。

C++ の用語で言えば、通常のクラスメンバ (データメンバも含む) は
(:ref:`tut-private` に書かれている例外を除いて) *public*
であり、メンバ関数はすべて *仮想関数(virtual)* です。
Module-3 にあるような、オブジェクトのメンバをメソッドから参照するための
短縮した記法は使えません:
メソッド関数の宣言では、オブジェクト自体を表す第一引数を明示せねばなりません。
第一引数のオブジェクトはメソッド呼び出しの際に暗黙の引数として渡されます。
Smalltalk に似て、クラスはそれ自体がオブジェクトです。
そのため、 import や名前変更といった操作が可能です。
C++ や Modula-3 と違って、ユーザーは組込み型を基底クラスにして拡張を行えます。
また、C++ とは同じで Modula-3 とは違う点として、特別な構文を伴うほとんどの
組み込み演算子 (算術演算子 (arithmetic operator) や添字表記)
はクラスインスタンスで使うために再定義できます。

.. (Lacking universally accepted terminology to talk about classes, I will make
   occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, since
   its object-oriented semantics are closer to those of Python than C++, but I
   expect that few readers have heard of it.)

(クラスに関して普遍的な用語定義がないので、 Smalltalk と C++
の用語を場合に応じて使っていくことにします。
C++ よりも Modula-3 の方がオブジェクト指向の意味論が Python に近いので、
Modula-3 の用語を使いたいのですが、ほとんどの読者は Modula-3 について
しらないでしょうから。)


.. _tut-object:

名前とオブジェクトについて
==============================

.. A Word About Names and Objects

.. Objects have individuality, and multiple names (in multiple scopes) can be bound
   to the same object.  This is known as aliasing in other languages.  This is
   usually not appreciated on a first glance at Python, and can be safely ignored
   when dealing with immutable basic types (numbers, strings, tuples).  However,
   aliasing has a possibly surprising effect on the semantics of Python code
   involving mutable objects such as lists, dictionaries, and most other types.
   This is usually used to the benefit of the program, since aliases behave like
   pointers in some respects.  For example, passing an object is cheap since only a
   pointer is passed by the implementation; and if a function modifies an object
   passed as an argument, the caller will see the change --- this eliminates the
   need for two different argument passing mechanisms as in Pascal.

オブジェクトには個体性があり、同一のオブジェクトに(複数のスコープから)
複数の名前を割り当てることができます。
この機能は他の言語では 別名づけ(ailias) として知られています。
Python を一見しただけでは、別名づけの重要性は分からないことが多く、
変更不能な基本型 (数値、文字列、タプル)を扱うときには無視して差し支えありません。
しかしながら、別名付けは、リストや辞書や他の多くの型など、変更可能な型を扱う
Python コード上で驚くべき効果があります。
別名付けはいくつかの点でポインタのように振舞い、このことは通常はプログラムに
利するように使われます。
例えば、オブジェクトの受け渡しは、実装上はポインタが渡されるだけなのでコストの
低い操作になります。
また、関数があるオブジェクトを引数として渡されたとき、関数の呼び出し側から
オブジェクトに対する変更を見ることができます --- これにより、 Pascal
にあるような二つの引数渡し機構をもつ必要をなくしています。


.. _tut-scopes:

Python のスコープと名前空間
===========================

クラスを紹介する前に、Python のスコープのルールについてあることを
話しておかなければなりません。
クラス定義は巧みなトリックを名前空間に施すので、
何が起こっているのかを完全に理解するには、スコープと名前空間が
どのように動作するかを理解する必要があります。
ちなみに、この問題に関する知識は全ての Python プログラマにとって有用です。

まず定義から始めましょう。

*名前空間 (namespace)* とは、名前からオブジェクトへの対応付け (mapping) です。
ほとんどの名前空間は、現状では Python の辞書として実装されていますが、
そのことは通常は (パフォーマンス以外では) 目立つことはないし、将来は変更されるかもしれません。
名前空間の例には、組込み名の集合 (:func:`abs` 等の関数や組込み例外名)、
モジュール内のグローバルな名前、関数を呼び出したときのローカルな名前があります。
オブジェクトの属性からなる集合もまた、ある意味では名前空間です。
名前空間について知っておくべき重要なことは、異なった名前空間にある名前の間には
全く関係がないということです。
例えば、二つの別々のモジュールの両方で関数 ``maximize``
という関数を定義することができ、定義自体は混同されることはありません ---
モジュールのユーザは名前の前にモジュール名をつけなければなりません。

ところで、 *属性* という言葉は、ドットに続く名前すべてに対して使っています ---
例えば式 ``z.real`` で、 ``real`` はオブジェクト ``z`` の属性です。
厳密にいえば、モジュール内の名前に対する参照は属性の参照です。
式 ``modname.funcname`` では、 ``modname`` はあるモジュールオブジェクトで、
``funcname`` はその属性です。
この場合には、モジュールの属性とモジュールの中で定義されている
グローバル名の間には、直接的な対応付けがされます。
これらの名前は同じ名前空間を共有しているのです！  [#]_

属性は読取り専用にも、書込み可能にもできます。
書込み可能であれば、属性に代入することができます。モジュール属性は書込み可能で、
``modname.the_answer = 42`` と書くことができます。書込み可能な属性は、
:keyword:`del` 文で削除することもできます。
例えば、 ``del modname.the_answer`` は、 ``modname``  で指定された
オブジェクトから属性 :attr:`the_answer` を除去します。

名前空間は様々な時点で作成され、その寿命も様々です。
組み込みの名前が入った名前空間は Python インタプリタが起動するときに作成され、
決して削除されることはありません。
モジュールのグローバルな名前空間は、モジュール定義が読み込まれたときに
作成されます。
通常、モジュールの名前空間は、インタプリタが終了するまで残ります。
インタプリタのトップレベルで実行された文は、スクリプトファイルから
読み出されたものでも対話的に読み出されたものでも、 :mod:`__main__` という名前の
モジュールの一部分であるとみなされるので、独自の名前空間を持つことになります。
(組み込みの名前は実際にはモジュール内に存在します。そのモジュールは
:mod:`__builtin__` と呼ばれています。)

関数のローカルな名前空間は、関数が呼び出されたときに作成され、関数から
戻ったときや、関数内で例外が送出され、かつ関数内で処理されなかった場合に
削除されます。
(実際には、忘れられる、と言ったほうが起きていることをよく表しています。)
もちろん、再帰呼出しのときには、各々の呼び出しで各自のローカルな
名前空間があります。

*スコープ (scope)* とは、ある名前空間が直接アクセスできるような、 Python
プログラムのテキスト上の領域です。
"直接アクセス可能" とは、修飾なしに (訳注: ``spam.egg`` ではなく単に ``egg``
のように) 名前を参照した際に、その名前空間から名前を見つけようと試みることを意味します。

スコープは静的に決定されますが、動的に使用されます。
実行中はいつでも、直接名前空間にアクセス可能な、少なくとも三つの入れ子になった
スコープがあります。

* 最初に探される、最も内側のスコープは、ローカルな名前を持っています。
* 外側の(enclosing)関数のスコープは、近いほうから順に探され、
  ローカルでもグローバルでもない名前を持っています。
* 次のスコープは、現在のモジュールのグローバルな名前を持っています。
* 一番外側の(最後に検索される)スコープはビルトイン名を持っています。

名前が global と宣言されている場合、その名前に対する参照や代入は全て、
モジュールのグローバルな名前の入った中間のスコープに対して直接行われます。
そうでない場合、最も内側のスコープより外側にある変数は全て読み出し専用と
なります。
(そのような変数に対する書き込みは、単に *新しい* ローカル変数をもっとも
内側のスコープで作成し、外部のスコープの値は変化しません)

通常、ローカルスコープは (プログラムテキスト上の) 現在の関数のローカルな名前を
参照します。関数の外側では、ローカルスコープはグローバルな名前空間と同じ
名前空間、モジュールの名前空間を参照します。
クラス定義では、ローカルスコープの中にもう一つ名前空間が置かれます。

スコープはテキスト上で決定されていると理解することが重要です。
モジュール内で定義される関数のグローバルなスコープは、
関数がどこから呼び出されても、どんな別名をつけて呼び出されても、
そのモジュールの名前空間になります。
反対に、実際の名前の検索は実行時に動的に行われます
--- とはいえ、言語の定義は、"コンパイル"  時の静的な名前解決の方向に
進化しているので、動的な名前解決に頼ってはいけません！
(事実、ローカルな変数は既に静的に決定されています。)

Python 特有の癖として、代入を行うと -- どの :keyword:`global` 文も有効でない
場合は -- 名前がいつも最も内側のスコープに入るというものがあります。
代入はデータのコピーを行いません --- 単に名前をオブジェクトに結びつける (bind)
だけです。
オブジェクトの削除でも同じです: ``del x`` は、 ``x`` をローカルスコープが
参照している名前空間から削除します。
実際、新たな名前を導入する操作は全てローカルスコープを用います。
とりわけ、 import 文や関数定義は、モジュールや関数の名前をローカルスコープに
結び付けます。(:keyword:`global` 文を使えば、特定の変数がグローバルスコープに
あることを示せます。)

.. _tut-firstclasses:

クラス初見
==========

クラスでは、新しい構文を少しと、三つの新たなオブジェクト型、
そして新たな意味付けをいくつか取り入れています。

.. _tut-classdefinition:

クラス定義の構文
----------------

クラス定義の最も単純な形式は、次のようになります。

::

   class ClassName:
       <文-1>
       .
       .
       .
       <文-N>

関数定義 (:keyword:`def` 文) と同様、クラス定義が効果をもつにはまず実行
しなければなりません。 (クラス定義を :keyword:`if`
文の分岐先や関数内部に置くことも、考え方としてはありえます。)

実際には、クラス定義の内側にある文は、通常は関数定義になりますが、他の文を
書くこともでき、それが役に立つこともあります --- これについては後で述べます。
クラス内の関数定義は通常、メソッドの呼び出し規約で決められた独特の形式の
引数リストを持ちます --- これについても後で述べます。

クラス定義に入ると、新たな名前空間が作成され、ローカルな名前空間として
使われます --- 従って、ローカルな変数に対する全ての代入はこの新たな名前空間に
入ります。
特に、関数定義を行うと、新たな関数の名前はこの名前空間に結び付けられます。

クラス定義から普通に (定義の終端に到達して) 抜けると、
*クラスオブジェクト (class object)* が生成されます。
クラスオブジェクトは、基本的にはクラス定義で作成された名前空間の内容をくるむ
ラッパ (wrapper) です。
クラスオブジェクトについては次の節で詳しく学ぶことにします。
(クラス定義に入る前に有効だった) 元のローカルスコープが復帰し、生成された
クラスオブジェクトは復帰したローカルスコープにクラス定義のヘッダで指定した名前
(上の例では :class:`ClassName`) で結び付けられます。


.. _tut-classobjects:

クラスオブジェクト
------------------

クラス・オブジェクトでは２種類の演算、属性参照とインスタンス生成を
サポートしています。

*属性参照 (attribute reference)* は、Python におけるすべての属性参照で
使われている標準的な構文、 ``obj.name`` を使います。
クラスオブジェクトが生成された際にクラスの名前空間にあった名前すべてが
有効な属性名です。従って、以下のようなクラス定義では、

::

   class MyClass:
       """A simple example class"""
       i = 12345
       def f(self):
           return 'hello world'

``MyClass.i`` と ``MyClass.f`` は妥当な属性参照であり、それぞれ整数と
関数オブジェクトを返します。
クラス属性に代入を行うこともできます。
従って、 ``MyClass.i`` の値を代入して変更できます。
``__doc__`` も有効な属性で、そのクラスに属している docstring、
この場合は ``"A simple example class"`` を返します。

クラスの *インスタンス生成 (instantiation)* には関数のような表記法を使います。
クラスオブジェクトのことを、単にクラスの新しいインスタンスを返す
パラメタを持たない関数かのように扱います。例えば (上記のクラスでいえば)、

::

   x = MyClass()

は、クラスの新しい *インスタンス (instance)* を生成し、そのオブジェクトを
ローカル変数 ``x`` へ代入します。

このクラスのインスタンス生成操作 (クラスオブジェクトの "呼出し") を行うと、
空のオブジェクトを生成します。
多くのクラスは、オブジェクトを作成する際に、カスタマイズされた特定の初期状態に
なってほしいと望んでいます。そのために、クラスには :meth:`__init__`
という名前の特別なメソッド定義することができます。例えば次のようにします。

::

   def __init__(self):
       self.data = []

クラスが :meth:`__init__` メソッドを定義している場合、クラスのインスタンスを
生成すると、新しく生成されたクラスインスタンスに対して自動的に :meth:`__init__`
を呼び出します。従って、この例では、新たな初期済みのインスタンスを次のように
して得ることができます。

::

   x = MyClass()

もちろん、より大きな柔軟性を持たせるために、 :meth:`__init__`  メソッドに複数の
引数をもたせることができます。
その場合、次の例のように、クラスのインスタンス生成操作に渡された引数は
:meth:`__init__` に渡されます。

::

   >>> class Complex:
   ...     def __init__(self, realpart, imagpart):
   ...         self.r = realpart
   ...         self.i = imagpart
   ...
   >>> x = Complex(3.0, -4.5)
   >>> x.r, x.i
   (3.0, -4.5)


.. _tut-instanceobjects:

インスタンスオブジェクト
------------------------

ところで、インスタンスオブジェクトを使うと何ができるのでしょうか？
インスタンスオブジェクトが理解できる唯一の操作は、属性の参照です。
有効な属性の名前には二種類(データ属性およびメソッド)あります。

*データ属性 (data attribute)* は、これは Smalltalk の "インスタンス変数" や
C++の "データメンバ" に相当します。データ属性を宣言する必要はありません。
ローカルな変数と同様に、これらの属性は最初に代入された時点で湧き出てきます。
例えば、上で生成した :class:`MyClass` のインスタンス ``x`` に対して、
次のコードを実行すると、値 ``16`` を印字し、 ``x`` の痕跡は残りません。

::

   x.counter = 1
   while x.counter < 10:
       x.counter = x.counter * 2
   print x.counter
   del x.counter

もうひとつのインスタンス属性は *メソッド (method)* です。メソッドとは、
オブジェクトに "属している"  関数のことです。(Python では、メソッドという
用語はクラスインスタンスだけのものではありません。
オブジェクト型にもメソッドを持つことができます。例えば、リストオブジェクトには、
append, insert, remove, sort などといったメソッドがあります。
とはいえ、以下では特に明記しない限り、クラスのインスタンスオブジェクトの
メソッドだけを意味するものとして使うことにします。)

.. index:: object: method

インスタンスオブジェクトで有効なメソッド名は、そのクラスによります。
定義により、クラスの全てのo関数オブジェクトである属性がインスタンス
オブジェクトの妥当なメソッド名に決まります。
従って、例では、 ``MyClass.f`` は関数なので、 ``x.f`` はメソッドの参照として
有効です。しかし、 ``MyClass.i`` は関数ではないので、 ``x.i`` はメソッドの参照
として有効ではありません。
``x.f`` は ``MyClass.f`` と同じものではありません --- 関数オブジェクトではなく、
*メソッドオブジェクト (method object)* です。


.. _tut-methodobjects:

メソッドオブジェクト
--------------------

普通、メソッドはバインドされた直後に呼び出されます。

::

   x.f()

:class:`MyClass` の例では、上のコードは文字列 ``'hello world'`` を返すでしょう。
しかしながら、必ずしもメソッドをその場で呼び出さなければならないわけでは
ありません。 ``x.f`` はメソッドオブジェクトであり、どこかに記憶しておいて
後で呼び出すことができます。例えば次のコードは、

::

   xf = x.f
   while True:
       print xf()

``hello world`` を時が終わるまで印字し続けるでしょう。

メソッドが呼び出されるときには実際には何が起きているのでしょうか？
:meth:`f` の関数定義では引数を一つ指定していたにもかかわらず、上の例では
``x.f`` が引数なしで呼び出されています。引数はどうなったのでしょうか？
たしか、引数が必要な関数を引数無しで呼び出すと、 Python が例外を
送出するはずです --- たとえその引数が実際には使われなくても…。

もう答は想像できているかもしれませんね。
メソッドについて特別なこととして、オブジェクトが関数の第1引数として渡されます。
例では、 ``x.f()`` という呼び出しは、 ``MyClass.f(x)`` と厳密に等価なものです。
一般に、 *n* 個の引数リストもったメソッドの呼出しは、そのメソッドの
オブジェクトを最初の引数の前に挿入した引数リストでメソッドに対応する関数を
呼び出すことと等価です。

もしまだメソッドの動作を理解できなければ、一度実装を見てみると事情がよく分かる
かもしれません。
データ属性ではないインスタンス属性が参照された時は、そのクラスが検索されます。
その名前が有効なクラス属性を表している関数オブジェクトなら、インスタンス
オブジェクトと見つかった関数オブジェクト (へのポインタ) を抽象オブジェクト、
すなわちメソッドオブジェクトにパックして作成します。
メソッドオブジェクトが引数リストと共に呼び出されるとき、インスタンスオブジェクトと
渡された引数リストから新しい引数リストを作成して、元の関数オブジェクトを
新しい引数リストで呼び出します。


.. _tut-remarks:

いろいろな注意点
================

データ属性は同じ名前のメソッド属性を上書きしてしまいます。
大規模なプログラムでみつけにくいバグを引き起こすことがあるこの偶然的な名前の
衝突を避けるには、衝突の可能性を最小限にするような規約を使うのが賢明です。
可能な規約としては、メソッド名を大文字で始める、データ属性名の先頭に短い
一意な文字列 (あるいはただの下線) をつける、またメソッドには動詞、
データ属性には名詞を用いる、などがあります。

データ属性は、メソッドから参照できると同時に、通常のオブジェクトのユーザ
("クライアント") からも参照できます。
言い換えると、クラスは純粋な抽象データ型として使うことができません。
実際、 Python では、データ隠蔽を補強するための機構はなにもありません ---
データの隠蔽はすべて規約に基づいています。
(逆に、C 言語で書かれた Python の実装では実装の詳細を完全に隠蔽し、
必要に応じてオブジェクトへのアクセスを制御できます。
この機構は C 言語で書かれた Python 拡張で使うことができます。)

クライアントはデータ属性を注意深く扱うべきです --- クライアントは、メソッドが
維持しているデータ属性の不変式を踏みにじり、台無しにするかもしれません。
クライアントは、名前の衝突が回避されている限り、メソッドの有効性に影響を
及ぼすことなくインスタンスに独自の属性を追加することができる、ということに
注意してください --- ここでも、名前付けの規約は頭痛の種を無くしてくれます。

メソッドの中から、データ属性を (または別のメソッドも！) 参照するための
短縮された記法はありません。
私は、この仕様がメソッドの可読性を高めていると感じています。
あるメソッドを眺めているときにローカルな変数とインスタンス変数を
はっきり区別できるからです。

よく、メソッドの最初の引数を ``self`` と呼びます。
この名前付けは単なる慣習でしかありません。 ``self`` という名前は、
Python では何ら特殊な意味を持ちません。
とはいえ、この慣行に従わないと、コードは他の Python プログラマにとってやや
読みにくいものとなります。
また、 *クラスブラウザ (class browser)* プログラムがこの慣行をあてにして
書かれているかもしれません。

クラス属性である関数オブジェクトはいずれも、そのクラスのインスタンスのための
メソッドを定義しています。
関数定義は、テキスト上でクラス定義の中に入っている必要はありません。
関数オブジェクトをクラスのローカルな変数の中に代入するのも OK です。
例えば以下のコードのようにします。

::

   # クラスの外側で定義された関数
   def f1(self, x, y):
       return min(x, x+y)

   class C:
       f = f1
       def g(self):
           return 'hello world'
       h = g

これで、 ``f`` 、 ``g`` 、および ``h`` は、すべて :class:`C` の属性であり
関数オブジェクトを参照しています。
従って、これら全ては、 :class:`C` のインスタンスのメソッドとなります ---
``h`` は ``g`` と全く等価です。これを実践しても、大抵は単にプログラムの読者に
混乱をもたらすだけなので注意してください。

メソッドは、 ``self`` 引数のメソッド属性を使って、他のメソッドを呼び出すことが
できます。

::

   class Bag:
       def __init__(self):
           self.data = []
       def add(self, x):
           self.data.append(x)
       def addtwice(self, x):
           self.add(x)
           self.add(x)

メソッドは、通常の関数と同じようにしてグローバルな名前を参照します。
(クラス自体はグローバルなスコープとして用いられることはありません。)
メソッドでグローバルなデータを使う良い理由はほとんどありませんが、
グローバルなスコープを使うべき場面は多々あります。
一つ挙げると、メソッド内から、グローバルなスコープに import された関数やモジュールや、
そのモジュール中で定義された関数やクラスを使うことができます。
通常、メソッドの入っているクラス自体はグローバルなスコープ内で定義されています。
次の節では、メソッドが自分のクラスを参照する理由として正当なものを見てみましょう。

.. The global scope associated... のくだりだが、グローバルスコープは
   関数定義のあるモジュールになる。とりあえず以下の訳を省いた状態にしておく。
   >あるメソッドに関連付けられたグローバルなスコープは、クラス定義の入っているモジュールになります。

個々の値はオブジェクトなので、 *クラス* (*型* とも言います) を持っています。
それは ``object.__class__`` に保持されています。

.. _tut-inheritance:

継承
====

言うまでもなく、継承の概念をサポートしない言語機能は "クラス" と
呼ぶに値しません。派生クラス (derived class) を定義する構文は次のように
なります。

::

   class DerivedClassName(BaseClassName):
       <文-1>
       .
       .
       .
       <文-N>

基底クラス (base class) の名前 :class:`BaseClassName` は、
派生クラス定義の入っているスコープで定義されていなければなりません。
基底クラス名のかわりに任意の式を入れることもできます。これは次の例のように、
基底クラスが別モジュールで定義されているときに便利なことがあります。

::

   class DerivedClassName(modname.BaseClassName):

派生クラス定義の実行は、基底クラスの場合と同じように進められます。
クラスオブジェクトが構築される時、基底クラスが記憶されます。
記憶された基底クラスは、属性参照を解決するために使われます。
要求された属性がクラスに見つからなかった場合、基底クラスに検索が進みます。
この規則は、基底クラスが他の何らかのクラスから派生したものであった場合、
再帰的に適用されます。

派生クラスのインスタンス化では、特別なことは何もありません。
``DerivedClassName()`` はクラスの新たなインスタンスを生成します。
メソッドの参照は次のようにしてい解決されます。
まず対応するクラス属性が検索されます。検索は、必要に応じ、基底クラス連鎖を下って
行われ、検索の結果として何らかの関数オブジェクトがもたらされた場合、
メソッド参照は有効なものとなります。

派生クラスは基底クラスのメソッドを上書き (override) することができます。
メソッドは同じオブジェクトの別のメソッドを呼び出す際に何ら特殊な権限を
持ちません。このため、ある基底クラスのメソッドが、同じ基底クラスで
定義されているもう一つのメソッド呼び出しを行っている場合、
派生クラスで上書きされた何らかのメソッドが呼び出されることになるかもしれません。
(C++ プログラマへ:  Python では、すべてのメソッドは事実上 ``virtual`` です。)

派生クラスで上書きしているメソッドでは、基底クラスの同名のメソッドを置き換える
のではなく、拡張したいのかもしれません。
基底クラスのメソッドを直接呼び出す簡単な方法があります。
単に ``BaseClassName.methodname(self, arguments)`` を呼び出すだけです。
この仕様は、場合によってはクライアントでも役に立ちます。
(この呼び出し方が動作するのは、基底クラスがグローバルスコープの ``BaseClassName``
という名前でアクセスできるときだけです。)

Python には継承に関係する 2 つの組み込み関数があります。

* :func:`isinstance` を使うとインスタンスの型が調べられます。
  ``isinstance(obj, int)`` は ``obj.__class__`` が :class:`int` や
  :class:`int` の派生クラスの場合に限り ``True`` になります。

* :func:`issubclass` を使うとクラスの継承関係が調べられます。
  :class:`bool` は :class:`int` のサブクラスなので ``issubclass(bool, int)``
  は ``True`` です。しかし、 :class:`unicode` は :class:`str`
  のサブクラスではない (単に共通の祖先 :class:`basestring`
  を共有している) ので ``issubclass(unicode, str)`` は ``False`` です。

.. _tut-multiple:

多重継承
--------

Python では、限られた形式の多重継承 (multiple inheritance) もサポートしています。
複数の基底クラスをもつクラス定義は次のようになります。

::

   class DerivedClassName(Base1, Base2, Base3):
       <文-1>
       .
       .
       .
       <文-N>

旧形式のクラスでは、名前解決規則は単に、深さ優先、左から右へ、だけです。
従って、ある属性が :class:`DerivedClassName` で見つからなければ
:class:`Base1` で検索され、次に :class:`Base1` の基底クラスで (再帰的に)
検索されます。それでも見つからなければはじめて :class:`Base2` で検索される、
といった具合です。

(人によっては、幅優先 (breadth first) --- :class:`Base2` と  :class:`Base3`
を検索してから :class:`Base1` の基底クラスで検索する ---  のほうが自然に
思うかもしれません。しかしながら、幅優先の検索では、 :class:`Base1` の特定の
属性のうち、実際に定義されているのが :class:`Base1` なのか、その基底クラス
なのかを知らなければ、 :class:`Base2` の属性との名前衝突がどんな結果を
もたらすのか分からないことになります。深さ優先規則では、 :class:`Base1` の直接の
属性と継承された属性とを区別しません。)

新スタイルクラス(:term:`new-style class`) では、協調的な :func:`super`
の呼び出しのためにメソッドの解決順序は動的に変更されます。
このアプローチは他の多重継承のある言語で call-next-method として知られており、
単一継承しかない言語の super 呼び出しよりも強力です。

新スタイルクラスについて、多重継承の全ての場合に 1 つかそれ以上のダイヤモンド継承
(少なくとも 1 つの祖先クラスに対し最も下のクラスから到達する経路が複数ある状態)
があるので、動的順序付けが必要です。
例えば、全ての新形式のクラスは :class:`object` を継承しているので、どの
多重継承でも :class:`object` へ到達するための道は複数存在します。
基底クラスが複数回アクセスされないようにするために、動的アルゴリズムで
検索順序を直列化し、各クラスで指定されている祖先クラスどうしの左から右への
順序は崩さず、各祖先クラスを一度だけ呼び出し、かつ一様になる (つまり
祖先クラスの順序に影響を与えずにサブクラス化できる) ようにします。
まとめると、これらの特徴のおかげで信頼性と拡張性のある多重継承したクラスを
設計することができるのです。
さらに詳細を知りたければ、 http://www.python.org/download/releases/2.3/mro/
を見てください。


.. _tut-private:

プライベート変数
================

オブジェクトの中からしかアクセス出来ない "プライベート" インスタンス変数は、
Python にはありません。
しかし、ほとんどの Python コードが従っている慣習があります。
アンダースコアで始まる名前 (例えば ``_spam``) は、 (関数であれメソッドであれ
データメンバであれ) 非 public なAPIとして扱います。
これらは、予告なく変更されるかもしれない実装の詳細として扱われるべきです。

クラスのプライベートメンバについて適切なユースケース(特にサブクラスで定義された名前との
衝突を避ける場合)があるので、 マングリング(:dfn:`name mangling`) と呼ばれる、
限定されたサポート機構があります。
``__spam`` (先頭に二個以上の下線文字、末尾に一個以下の下線文字) という形式の識別子は、
``_classname__spam`` へとテキスト置換されるようになりました。ここで
``classname`` は、現在のクラス名から先頭の下線文字をはぎとった名前になります。
このような難号化 (mangle) は、識別子の文法的な位置にかかわらず行われるので、
クラス定義内に現れた識別子全てに対して実行されます。

難号化の規則は主に不慮の事故を防ぐためのものだということに注意してください;
確信犯的な方法で、プライベートとされている変数にアクセスしたり変更することは依然として可能なのです。
デバッガのような特殊な状況では、この仕様は便利ですらあります。

``exec`` や ``eval()`` や ``execfile()`` へ渡されたコードでは、
呼出し元のクラス名を現在のクラスと見なさないことに注意してください。
この仕様は ``global`` 文の効果と似ており、その効果もまた同様に、
バイトコンパイルされたコードに制限されています。同じ制約が ``getattr()`` と
``setattr()`` と ``delattr()`` にも適用されます。
また、 ``__dict__`` を直接参照するときにも適用されます。

.. _tut-odds:

残りのはしばし
==============

Pascal の "レコード (record)" や、C 言語の "構造体 (struct)" のような、
名前つきのデータ要素を一まとめにするデータ型があると便利なことが
あります。空のクラス定義を使うとうまくできます。

::

   class Employee:
       pass

   john = Employee() # 空の従業員レコードを造る

   # レコードのフィールドを設定する
   john.name = 'John Doe'
   john.dept = 'computer lab'
   john.salary = 1000

ある特定の抽象データ型を要求する Python コードの断片に、そのデータ型の
メソッドをエミュレーションするクラスを代わりに渡すことができます。
例えば、ファイルオブジェクトから何らかのデータを構築する関数がある場合、
:meth:`read` と :meth:`readline` を持つクラスを定義して、ファイルではなく
文字列バッファからデータを取得するようにしておき、引数として渡すことができます。

.. コメントアウトされてる
.. (Unfortunately, this technique has its limitations: a class can't define
   operations that are accessed by special syntax such as sequence subscripting
   or arithmetic operators, and assigning such a "pseudo-file" to sys.stdin will
   not cause the interpreter to read further input from it.)

.. (残念なことに、このテクニックには限界があります: クラスにはシーケンスの
   添字アクセスや算術演算などの特殊構文でアクセスされる操作が定義できず、
   "疑似ファイル" を sys.stdin に代入してもそこからインタープリタに入力
   データを読み込ませることはできません。)

インスタンスメソッドオブジェクトにも属性があります。
``m.im_self`` はメソッド :meth:`m` の属しているインスタンスオブジェクトで、
``m.im_func`` はメソッドに対応する関数オブジェクトです。


.. _tut-exceptionclasses:

例外はクラスであってもよい
--------------------------

ユーザ定義の例外をクラスとして識別することもできます。
このメカニズムを使って、拡張可能な階層化された例外を作成することができます。

新しい二つの (意味付け的な) 形式の :keyword:`raise` 文があります。

::

   raise Class, instance

   raise instance

第一の形式では、 ``instance`` は :class:`Class` またはその派生クラスの
インスタンスでなければなりません。
第二の形式は以下の表記の短縮された記法です。

::

   raise instance.__class__, instance

:keyword:`except` 節のクラスは、例外と同じクラスか基底クラスのときに互換
(compatible)となります。
(逆方向では成り立ちません --- 派生クラスの例外がリストされている  except
節は基底クラスの例外と互換ではありません)。
例えば、次のコードは、 B, C, D を順序通りに出力します。

::

   class B:
       pass
   class C(B):
       pass
   class D(C):
       pass

   for cls in [B, C, D]:
       try:
           raise cls()
       except D:
           print "D"
       except C:
           print "C"
       except B:
           print "B"

except 節が逆に並んでいた場合 (``except B`` が最初にくる場合)、 B, B, B
と出力されるはずだったことに注意してください ---
最初に一致した except 節が駆動されるのです。

処理されないクラスの例外に対してエラーメッセージが出力されるとき、
まずクラス名が出力され、続いてコロン、スペース、最後に組み込み関数 :func:`str`
を使って文字列に変換したインスタンスが出力されます。


.. _tut-iterators:

イテレータ (iterator)
=====================

すでに気づいているでしょうが、 ``for`` 文を使うとほとんどのコンテナ
オブジェクトにわたってループを行うことができます。

::

   for element in [1, 2, 3]:
       print element
   for element in (1, 2, 3):
       print element
   for key in {'one':1, 'two':2}:
       print key
   for char in "123":
       print char
   for line in open("myfile.txt"):
       print line

こうしたアクセス方法は明確で、簡潔で、かつ便利なものです。イテレータの使用は Python
全体に普及していて、統一性をもたらしています。背後では、 ``for`` 文は
コンテナオブジェクトの :func:`iter` を呼び出しています。
この関数は :meth:`next` メソッドの定義されたイテレータオブジェクトを返します。
:meth:`next` メソッドは一度コンテナ内の要素に一度に一つづつアクセスします。
コンテナ内にアクセスすべき要素がなくなると、 :meth:`next` は
:exc:`StopIteration` 例外を送出し、 ``for`` ループを終了させます。
実際にどのように動作するかを以下の例に示します。

::

   >>> s = 'abc'
   >>> it = iter(s)
   >>> it
   <iterator object at 0x00A1DB50>
   >>> it.next()
   'a'
   >>> it.next()
   'b'
   >>> it.next()
   'c'
   >>> it.next()

   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
       it.next()
   StopIteration

イテレータプロトコルの背後にあるメカニズムを一度目にすれば、
自作のクラスにイテレータとしての振る舞いを追加するのは簡単です。
:meth:`__iter__` メソッドを定義して、 :meth:`next` メソッドを持つ
オブジェクトを返すようにしてください。クラス自体で :meth:`next`
を定義している場合、 :meth:`__iter__` では単に ``self`` を返すようにできます。

::

   class Reverse:
       """Iterator for looping over a sequence backwards."""
       def __init__(self, data):
           self.data = data
           self.index = len(data)
       def __iter__(self):
           return self
       def next(self):
           if self.index == 0:
               raise StopIteration
           self.index = self.index - 1
           return self.data[self.index]

::

   >>> rev = Reverse('spam')
   >>> iter(rev)
   <__main__.Reverse object at 0x00A1DB50>
   >>> for char in rev:
   ...     print char
   ...
   m
   a
   p
   s


.. _tut-generators:

ジェネレータ (generator)
========================

ジェネレータ(:term:`generator`)は、イテレータを作成するための簡潔で強力な
ツールです。
ジェネレータは通常の関数のように書かれますが、何らかのデータを返すときには
:keyword:`yield` 文を使います。
:meth:`next` が呼び出されるたびに、ジェネレータは以前に中断した処理を再開します
(ジェネレータは、全てのデータ値と最後にどの文が実行されたかを記憶しています)。
以下の例を見れば、ジェネレータがとても簡単に作成できることがわかります。

::

   def reverse(data):
       for index in range(len(data)-1, -1, -1):
           yield data[index]

::

   >>> for char in reverse('golf'):
   ...     print char
   ...
   f
   l
   o
   g

ジェネレータを使ってできることは、前節で記述したクラスベースのイテレータを
使ってもできます。ジェネレータを使うとコンパクトに記述できるのは、
:meth:`__iter__` と :meth:`next` メソッドが自動的に作成されるからです。

ジェネレータのもう一つの重要な機能は、呼び出しごとにローカル変数と実行状態が
自動的に保存されるということです。これにより、 ``self.index`` や
``self.data`` といったインスタンス変数を使ったアプローチよりも簡単に関数を
書くことができるようになります。

メソッドを自動生成したりプログラムの実行状態を自動保存するほかに、
ジェネレータは終了時に自動的に :exc:`StopIteration` を送出します。
これらの機能を組み合わせると、通常の関数を書くのと同じ労力で、
簡単にイテレータを生成できます。


.. _tut-genexps:

ジェネレータ式
==============

単純なジェネレータなら、式を使って簡潔にコードする方法があります。
リスト内包に似た構文の式ですが、各括弧ではなく丸括弧を使います。
ジェネレータ式は、関数の中でジェネレータをすぐに使いたいような
状況のために用意されています。ジェネレータ式はコンパクトですが、
完全なジェネレータに比べてちょっと融通の効かないところがありますが、
同じ内容を返すリスト内包よりはメモリに優しいことが多いという利点があります。

例::

   >>> sum(i*i for i in range(10))                 # 平方和を求める
   285

   >>> xvec = [10, 20, 30]
   >>> yvec = [7, 5, 3]
   >>> sum(x*y for x,y in zip(xvec, yvec))         # 内積を求める
   260

   >>> from math import pi, sin
   >>> sine_table = dict((x, sin(x*pi/180)) for x in range(0, 91))

   >>> unique_words = set(word  for line in page  for word in line.split())

   >>> valedictorian = max((student.gpa, student.name) for student in graduates)

   >>> data = 'golf'
   >>> list(data[i] for i in range(len(data)-1,-1,-1))
   ['f', 'l', 'o', 'g']



.. rubric:: 注記

.. [#] 例外が一つあります。モジュールオブジェクトには、秘密の読取り専用の属性
   :attr:`__dict__` があり、モジュールの名前空間を実装するために使われている
   辞書を返します; :attr:`__dict__` という名前は属性ですが、グローバルな名前では
   ありません。この属性を利用すると名前空間の実装に対する抽象化を侵すことに
   なるので、プログラムを検死するデバッガのような用途に限るべきです。

