

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. 新しい型を定義する &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python インタプリタの拡張と埋め込み" href="index.html" />
    <link rel="next" title="3. distutils による C および C++ 拡張モジュールのビルド" href="building.html" />
    <link rel="prev" title="1. C や C++ による Python の拡張" href="extending.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="3. distutils による C および C++ 拡張モジュールのビルド"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="extending.html" title="1. C や C++ による Python の拡張"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python インタプリタの拡張と埋め込み</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. 新しい型を定義する</a><ul>
<li><a class="reference internal" href="#dnt-basics">2.1. 基本的なこと</a><ul>
<li><a class="reference internal" href="#id4">2.1.1. 基本のサンプルにデータとメソッドを追加する</a></li>
<li><a class="reference internal" href="#id7">2.1.2. データ属性をこまかく制御する</a></li>
<li><a class="reference internal" href="#id9">2.1.3. 循環ガベージコレクションをサポートする</a></li>
<li><a class="reference internal" href="#id11">2.1.4. 他の型のサブクラスを作る</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dnt-type-methods">2.2. タイプメソッド</a><ul>
<li><a class="reference internal" href="#finalization">2.2.1. 最終化 (finalization) と解放</a></li>
<li><a class="reference internal" href="#id13">2.2.2. オブジェクト表現</a></li>
<li><a class="reference internal" href="#id14">2.2.3. 属性を管理する</a><ul>
<li><a class="reference internal" href="#generic-attribute-management">2.2.3.1. 総称的な属性を管理する</a></li>
<li><a class="reference internal" href="#id16">2.2.3.2. 特定の型に特化した属性の管理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">2.2.4. オブジェクトの比較</a></li>
<li><a class="reference internal" href="#id18">2.2.5. 抽象的なプロトコルのサポート</a></li>
<li><a class="reference internal" href="#weak-reference">2.2.6. 弱参照(Weak Reference)のサポート</a></li>
<li><a class="reference internal" href="#id19">2.2.7. その他いろいろ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="extending.html"
                        title="前の章へ">1. C や C++ による Python の拡張</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="building.html"
                        title="次の章へ">3. distutils による C および C++ 拡張モジュールのビルド</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/extending/newtypes.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="defining-new-types">
<span id="id1"></span><h1>2. 新しい型を定義する<a class="headerlink" href="#defining-new-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>前の章でふれたように、Python では拡張モジュールを書くプログラマが Python のコードから操作できる、新しい型を定義できるようになっています。ちょうど Python の中核にある文字列やリストをつくれるようなものです。</p>
<p>これはそんなにむずかしくはありません。拡張型のためのコードにはすべて、一定のパターンが存在しています。しかし始める前に、いくつか細かいことを理解しておく必要があるでしょう。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">Python 2.2 から、新しい型を定義する方法がかなり変わって (良くなって) います。この文書は Python 2.2 およびそれ以降で新しい型をどうやって定義するかについて述べています。古いバージョンの Python をサポートする必要がある場合は、 <a class="reference external" href="http://www.python.org/doc/versions/">この文書の古い版</a> を参照してください。</p>
</div>
<div class="section" id="dnt-basics">
<span id="id3"></span><h2>2.1. 基本的なこと<a class="headerlink" href="#dnt-basics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python ランタイムでは、すべての Python オブジェクトは <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a>
型の変数として扱います。 <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject</span></tt></a> はさほど大仰なオブジェクトではなく、単にオブジェクトに対する参照回数と、そのオブジェクトの「タイプオブジェクト (type object)」へのポインタを格納しているだけです。重要な役割を果たしているのはこのタイプオブジェクトです。つまりタイプオブジェクトは、例えばあるオブジェクトのある属性が参照されるとか、あるいは別のオブジェクトとの間で乗算を行うといったときに、どの (C の) 関数を呼び出すかを決定しているのです。これらの C 関数は「タイプメソッド
(type method)」と呼ばれ、  <tt class="docutils literal"><span class="pre">[].append</span></tt> のようなもの  (いわゆる「オブジェクトメソッド (object method)」)
とは区別しています。</p>
<p>なので、新しいオブジェクトの型を定義したいときは、新しいタイプオブジェクトを作成すればよいわけです。</p>
<p>この手のことは例を見たほうが早いでしょうから、ここに最小限の、しかし完全な、新しい型を定義するモジュールをあげておきます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;Python.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="cm">/* Type-specific fields go here. */</span>
<span class="p">}</span> <span class="n">noddy_NoddyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">noddy_NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*ob_size*/</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/*tp_name*/</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span> <span class="cm">/*tp_basicsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_itemsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_dealloc*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_print*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_compare*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_repr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_number*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_sequence*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_mapping*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_call*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_str*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_buffer*/</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/*tp_flags*/</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="cp">#ifndef PyMODINIT_FUNC	</span><span class="cm">/* declarations for DLL import/export */</span><span class="cp"></span>
<span class="cp">#define PyMODINIT_FUNC void</span>
<span class="cp">#endif</span>
<span class="n">PyMODINIT_FUNC</span>
<span class="nf">initnoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">noddy_NoddyType</span><span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule3</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">noddy_methods</span><span class="p">,</span>
                       <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">);</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>さしあたって覚えておくことは以上ですが、これで前の章からすこしは説明がわかりやすくなっていることと思います。</p>
<p>最初に習うのは、つぎのようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
<span class="p">}</span> <span class="n">noddy_NoddyObject</span><span class="p">;</span>
</pre></div>
</div>
<p>これが Noddy オブジェクトの内容です &#8212; このケースでは、ほかの Python オブジェクトが持っているものと何ら変わりはありません。つまり参照カウントと型オブジェクトへのポインタですね。これらは  <tt class="docutils literal"><span class="pre">PyObject_HEAD</span></tt> マクロによって展開されるメンバです。マクロを使う理由は、レイアウトを標準化するためと、デバッグ用ビルド時に特別なデバッグ用のメンバを定義できるようにするためです。この
<tt class="docutils literal"><span class="pre">PyObject_HEAD</span></tt> マクロの後にはセミコロンがないことに注意してください。セミコロンはすでにマクロ内に含まれています。うっかり後にセミコロンをつけてしまわないように気をつけて。これはお使いの機種では何の問題も起こらないかもしれませんが、機種によっては、おそらく問題になるのです!  (Windows 上では、MS Visual C
がこの手のエラーを出し、コンパイルできないことが知られています)</p>
<p>比較のため、以下に標準的な Python の整数型の定義を見てみましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">long</span> <span class="n">ob_ival</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyIntObject</span><span class="p">;</span>
</pre></div>
</div>
<p>では次にいってみます。かなめの部分、タイプオブジェクトです。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">noddy_NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*ob_size*/</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/*tp_name*/</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span> <span class="cm">/*tp_basicsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_itemsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_dealloc*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_print*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_compare*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_repr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_number*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_sequence*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_mapping*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_call*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_str*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_buffer*/</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/*tp_flags*/</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
<span class="p">};</span>
</pre></div>
</div>
<p><tt class="file docutils literal"><span class="pre">object.h</span></tt> の中にある <a class="reference internal" href="../c-api/type.html#PyTypeObject" title="PyTypeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></tt></a> の定義を見ると、実際にはここに挙げた以上の数のメンバがあるとわかるでしょう。これ以外のメンバは C コンパイラによってゼロに初期化されるので、必要な時を除いてふつうはそれらの値を明示的には指定せずにおきます。</p>
<p>次のものは非常に重要なので、とくに最初の最初に見ておきましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
</pre></div>
</div>
<p>これはちょっとぶっきらぼうですね。実際に書きたかったのはこうです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">)</span>
</pre></div>
</div>
<p>この場合、タイプオブジェクトの型は「type」という名前になりますが、これは厳密には C の基準に従っておらず、コンパイラによっては文句を言われます。幸いにも、このメンバは <a class="reference internal" href="../c-api/type.html#PyType_Ready" title="PyType_Ready"><tt class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></tt></a> が埋めてくれます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="mi">0</span><span class="p">,</span>                          <span class="cm">/* ob_size */</span>
</pre></div>
</div>
<p>ヘッダ中の <tt class="xref py py-attr docutils literal"><span class="pre">ob_size</span></tt> メンバは使われていません。これは歴史的な遺物であり、構造体中にこれが存在しているのは古いバージョンの
Python 用にコンパイルされた拡張モジュールとのバイナリ上の互換性を保つためです。ここにはつねにゼロを指定してください。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>              <span class="cm">/* tp_name */</span>
</pre></div>
</div>
<p>これは型の名前です。この名前はオブジェクトのデフォルトの表現形式と、いくつかのエラーメッセージ中で使われます。たとえば:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="n">noddy</span><span class="p">.</span><span class="n">new_noddy</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span><span class="o">:</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in</span> <span class="o">?</span>
<span class="nl">TypeError:</span> <span class="n">cannot</span> <span class="n">add</span> <span class="n">type</span> <span class="s">&quot;noddy.Noddy&quot;</span> <span class="n">to</span> <span class="n">string</span>
</pre></div>
</div>
<p>注意: この名前はドットで区切られた名前で、モジュール名と、そのモジュール内での型名を両方ふくんでいます。この場合のモジュールは <tt class="xref py py-mod docutils literal"><span class="pre">noddy</span></tt>
で、型の名前は <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> ですから、ここでの型名としては <tt class="xref py py-class docutils literal"><span class="pre">noddy.Noddy</span></tt> を指定するわけです。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span>  <span class="cm">/* tp_basicsize */</span>
</pre></div>
</div>
<p>これによって Python は <a class="reference internal" href="../c-api/allocation.html#PyObject_New" title="PyObject_New"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></tt></a> が呼ばれたときにどれくらいの量のメモリを割り当てればよいのか知ることができます。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">あなたのタイプを Python でサブクラス化可能にしたい場合、そのタイプが基底タイプと同じ <tt class="xref py py-attr docutils literal"><span class="pre">tp_basicsize</span></tt> をもっていると多重継承のときに問題が生じることがあります。そのタイプを Python のサブクラスにしたとき、その <tt class="xref py py-attr docutils literal"><span class="pre">__bases__</span></tt> リストにはあなたのタイプが最初にくるようにしなければなりません。さもないとエラーの発生なしにあなたのタイプの <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a>
メソッドを呼び出すことはできなくなります。この問題を回避するには、つねにあなたのタイプの <tt class="xref py py-attr docutils literal"><span class="pre">tp_basicsize</span></tt> をその基底タイプよりも大きくしておくことです。ほとんどの場合、あなたのタイプは <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> か、そうでなければ基底タイプにデータ用のメンバを追加したものでしょうから、したがって大きさはつねに増加するためこの条件は満たされています。</p>
</div>
<div class="highlight-c"><div class="highlight"><pre><span class="mi">0</span><span class="p">,</span>                          <span class="cm">/* tp_itemsize */</span>
</pre></div>
</div>
<p>これはリストや文字列などの可変長オブジェクトのためのものです。今のところ無視しましょう。</p>
<p>このあとのいくつかのメソッドは使わないのでとばして、クラスのフラグ (flags) には <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_DEFAULT" title="Py_TPFLAGS_DEFAULT"><tt class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_DEFAULT</span></tt></a> を入れます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/*tp_flags*/</span>
</pre></div>
</div>
<p>すべての型はフラグにこの定数を含めておく必要があります。これは現在のバージョンの Python で定義されているすべてのメンバを許可します。</p>
<p>この型の docstring は <tt class="xref py py-attr docutils literal"><span class="pre">tp_doc</span></tt> に入れます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
</pre></div>
</div>
<p>ここからタイプメソッドに入るわけですが。ここがあなたのオブジェクトが他と違うところです。でも今回のバージョンでは、これらはどれも実装しないでおき、あとでこの例をより面白いものに改造することにしましょう。</p>
<p>とりあえずやりたいのは、この <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> オブジェクトを新しく作れるようにすることです。オブジェクトの作成を許可するには、
<tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> の実装を提供する必要があります。今回は、 API 関数によって提供されるデフォルトの実装
<a class="reference internal" href="../c-api/type.html#PyType_GenericNew" title="PyType_GenericNew"><tt class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></tt></a> を使うだけにしましょう。これを単に <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> スロットに代入すればよいのですが、これは互換上の理由からできません。プラットフォームやコンパイラによっては、構造体メンバの初期化に別の場所で定義されている C の関数を代入することはできないのです。なので、この <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> の値はモジュール初期化用の関数で代入します。 <a class="reference internal" href="../c-api/type.html#PyType_Ready" title="PyType_Ready"><tt class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></tt></a>
を呼ぶ直前です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">noddy_NoddyType</span><span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>これ以外のタイプメソッドはすべて <em>NULL</em> です。これらについては後ほどふれます。</p>
<p>このファイル中にある他のものは、どれもおなじみでしょう。 <tt class="xref c c-func docutils literal"><span class="pre">initnoddy()</span></tt> のこれを除いて:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、上で <em>NULL</em> に指定していた  <tt class="xref py py-attr docutils literal"><span class="pre">ob_type</span></tt> などのいくつものメンバを埋めて、 <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt>
型を初期化します。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
</pre></div>
</div>
<p>これはこの型をモジュール中の辞書に埋め込みます。これで、 <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> クラスを呼べば <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> インスタンスを作れるようになりました:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">noddy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mynoddy</span> <span class="o">=</span> <span class="n">noddy</span><span class="p">.</span><span class="n">Noddy</span><span class="p">()</span>
</pre></div>
</div>
<p>これだけです! 残るはこれをどうやってビルドするかということです。上のコードを <tt class="file docutils literal"><span class="pre">noddy.c</span></tt> というファイルに入れて、以下のものを
<tt class="file docutils literal"><span class="pre">setup.py</span></tt> というファイルに入れましょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">from</span> <span class="n">distutils</span><span class="p">.</span><span class="n">core</span> <span class="n">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy.c&quot;</span><span class="p">])])</span>
</pre></div>
</div>
<p>そして、シェルから以下のように入力します。</p>
<div class="highlight-c"><pre>$ python setup.py build</pre>
</div>
<p>これでサブディレクトリの下にファイル <tt class="file docutils literal"><span class="pre">noddy.so</span></tt> が作成されます。このディレクトリに移動して Python を起動しましょう。
<tt class="docutils literal"><span class="pre">import</span> <span class="pre">noddy</span></tt> して Noddy オブジェクトで遊べるようになっているはずです。</p>
<p>そんなにむずかしくありません、よね?</p>
<p>もちろん、現在の Noddy 型はまだおもしろみに欠けています。何もデータを持ってないし、何もしてはくれません。継承してサブクラスを作ることさえできないのです。</p>
<div class="section" id="id4">
<h3>2.1.1. 基本のサンプルにデータとメソッドを追加する<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この基本のサンプルにデータとメソッドを追加してみましょう。ついでに、この型を基底クラスとしても利用できるようにします。ここでは新しいモジュール
<tt class="xref py py-mod docutils literal"><span class="pre">noddy2</span></tt> をつくり、以下の機能を追加します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;Python.h&gt;</span>
<span class="cp">#include &quot;structmember.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span> <span class="cm">/* first name */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>  <span class="cm">/* last name */</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>
        
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span> 
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> 
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;%s %s&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;OO&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">PyString_Format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*ob_size*/</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/*tp_name*/</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/*tp_basicsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_itemsize*/</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/*tp_dealloc*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_print*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_compare*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_repr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_number*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_sequence*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_mapping*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_call*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_str*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_buffer*/</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/*tp_flags*/</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">module_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="cp">#ifndef PyMODINIT_FUNC	</span><span class="cm">/* declarations for DLL import/export */</span><span class="cp"></span>
<span class="cp">#define PyMODINIT_FUNC void</span>
<span class="cp">#endif</span>
<span class="n">PyMODINIT_FUNC</span>
<span class="nf">initnoddy2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule3</span><span class="p">(</span><span class="s">&quot;noddy2&quot;</span><span class="p">,</span> <span class="n">module_methods</span><span class="p">,</span>
                       <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このバージョンでは、いくつもの変更をおこないます。</p>
<p>以下の include を追加します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;structmember.h&gt;</span>
</pre></div>
</div>
<p>すこしあとでふれますが、この include には属性を扱うための宣言が入っています。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> オブジェクトの構造体の名前は <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> に縮めることにします。タイプオブジェクト名は
<tt class="xref py py-class docutils literal"><span class="pre">NoddyType</span></tt> に縮めます。</p>
<p>これから <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> 型は 3つのデータ属性をもつようになります。 <em>first</em> 、 <em>last</em> 、および <em>number</em>
です。 <em>first</em> と  <em>last</em> 属性はファーストネームとラストネームを格納した Python 文字列で、  <em>number</em> 属性は整数の値です。</p>
<p>これにしたがうと、オブジェクトの構造体は次のようになります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>
</pre></div>
</div>
<p>いまや管理すべきデータができたので、オブジェクトの割り当てと解放に際してはより慎重になる必要があります。最低限、オブジェクトの解放メソッドが必要です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この関数は <tt class="xref py py-attr docutils literal"><span class="pre">tp_dealloc</span></tt> メンバに代入されます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="o">/</span> <span class="o">*</span><span class="n">tp_dealloc</span><span class="o">*</span> <span class="o">/</span>
</pre></div>
</div>
<p>このメソッドでやっているのは、ふたつの Python 属性の参照カウントを減らすことです。 <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> メンバと <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt>
メンバが <em>NULL</em> かもしれないため、ここでは <a class="reference internal" href="../c-api/refcounting.html#Py_XDECREF" title="Py_XDECREF"><tt class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></tt></a> を使いました。このあとそのオブジェクトのタイプメソッドである
<tt class="xref py py-attr docutils literal"><span class="pre">tp_free</span></tt> メンバを呼び出しています。ここではオブジェクトの型が <tt class="xref py py-class docutils literal"><span class="pre">NoddyType</span></tt> とは限らないことに注意してください。なぜなら、このオブジェクトはサブクラス化したインスタンスかもしれないからです。</p>
<p>ファーストネームとラストネームを空文字列に初期化しておきたいので、新しいメソッドを追加することにしましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>そしてこれを <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> メンバとしてインストールします:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
</pre></div>
</div>
<p>この新しいメンバはその型のオブジェクトを (初期化するのではなく) 作成する責任を負っています。Python ではこのメンバは <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a>
メソッドとして見えています。 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a> メソッドについての詳しい議論は &#8220;Unifying types and classes in
Python&#8221; という題名の論文を見てください。 new メソッドを実装する理由のひとつは、インスタンス変数の初期値を保証するためです。この例でやりたいのは
new メソッドが <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> メンバと  <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt> メンバの値を <em>NULL</em> でないようにするということです。もしこれらの初期値が <em>NULL</em> でもよいのであれば、先の例でやったように、new メソッドとして <a class="reference internal" href="../c-api/type.html#PyType_GenericNew" title="PyType_GenericNew"><tt class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></tt></a> を使うこともできたでしょう。 <a class="reference internal" href="../c-api/type.html#PyType_GenericNew" title="PyType_GenericNew"><tt class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></tt></a> はすべてのインスタンス変数のメンバを <em>NULL</em> にします。</p>
<p>この new メソッドは静的なメソッドで、インスタンスを生成するときにその型と、型が呼び出されたときの引数が渡され、新しいオブジェクトを作成して返します。new メソッドはつねに、あらかじめ固定引数 (positional argument) とキーワード引数を取りますが、これらのメソッドはしばしばそれらの引数は無視して初期化メソッドにそのまま渡します。new メソッドはメモリ割り当てのために
<tt class="xref py py-attr docutils literal"><span class="pre">tp_alloc</span></tt> メンバを呼び出します。 <tt class="xref py py-attr docutils literal"><span class="pre">tp_alloc</span></tt> をこちらで初期化する必要はありません。これは
<a class="reference internal" href="../c-api/type.html#PyType_Ready" title="PyType_Ready"><tt class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></tt></a> が基底クラス (デフォルトでは <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a>) をもとに埋めるものです。ほとんどの型ではデフォルトのメモリ割り当てを使っています。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">もし協力的な <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> (基底タイプの <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> または <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><tt class="xref py py-meth docutils literal"><span class="pre">__new__()</span></tt></a> を呼んでいるもの)
を作りたいのならば、実行時のメソッド解決順序をつかってどのメソッドを呼びだすかを決定しようとしては
<em>いけません</em> 。つねに呼び出す型を静的に決めておき、直接その <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> を呼び出すか、あるいは
<tt class="docutils literal"><span class="pre">type-&gt;tp_base-&gt;tp_new</span></tt> を経由してください。こうしないと、あなたが作成したタイプの Python サブクラスが他の Python
で定義されたクラスも継承している場合にうまく動かない場合があります。 (とりわけ、そのようなサブクラスのインスタンスを <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a>
を出さずに作ることが不可能になります。)</p>
</div>
<p>つぎに初期化用の関数を見てみましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは <tt class="xref py py-attr docutils literal"><span class="pre">tp_init</span></tt> メンバに代入されます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>         <span class="cm">/* tp_init */</span>
</pre></div>
</div>
<p>Python では、 <tt class="xref py py-attr docutils literal"><span class="pre">tp_init</span></tt> メンバは <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> メソッドとして見えています。このメソッドは、オブジェクトが作成されたあとに、それを初期化する目的で使われます。 new
メソッドとはちがって、初期化用のメソッドは必ず呼ばれるとは限りません。初期化用のメソッドは、インスタンスの初期値を提供するのに必要な引数を受けとります。このメソッドはつねに固定引数とキーワード引数を受けとります。</p>
<p>初期化メソッドは複数回呼び出される可能性があります。あなたのオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> メソッドは、誰にでも呼び出すことができるからです。このため、新しい値を代入するさいには特別な注意を払う必要があります。たとえば、 <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt>
メンバには以下のように代入したくなるかもしれません:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>しかしこのやり方は危険です。このタイプでは <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> メンバに入るオブジェクトをなにも限定していないので、どんなオブジェクトでもとり得てしまうからです。それはこのコードが <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> メンバにアクセスしようとする前に、そのデストラクタが呼び出されてしまうかもしれないのです。このような可能性からパラノイア的に身をまもるため、ほとんどの場合メンバへの代入は,その参照カウントを減らす前におこなってください。こうする必要がないのはどんな場合でしょうか?</p>
<ul class="simple">
<li>その参照カウントが 1 より大きいと確信できる場合。</li>
<li>そのオブジェクトの解放があなたのタイプのコードにコールバックするようなことが決してない場合 <a class="footnote-reference" href="#id20" id="id5">[1]</a> 。</li>
<li>ガベージコレクションがサポートされていない場合に <tt class="xref py py-attr docutils literal"><span class="pre">tp_dealloc</span></tt> ハンドラで参照カウントを減らすとき <a class="footnote-reference" href="#id21" id="id6">[2]</a> 。</li>
</ul>
<p>ここではインスタンス変数を属性として見えるようにしたいのですが、これにはいくつもの方法があります。もっとも簡単な方法は、メンバの定義を与えることです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>そして、この定義を <tt class="xref py py-attr docutils literal"><span class="pre">tp_members</span></tt> に入れましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
</pre></div>
</div>
<p>各メンバの定義はそれぞれ、メンバの名前、型、オフセット、アクセスフラグおよび docstring です。詳しくは後の &#8220;総称的な属性を管理する&#8221;
(<a class="reference internal" href="#generic-attribute-management"><em>総称的な属性を管理する</em></a>) の節をご覧ください。</p>
<p>この方法の欠点は、Python 属性に代入できるオブジェクトの型を制限する方法がないことです。ここではファーストネーム first とラストネーム last
に、ともに文字列が入るよう期待していますが、今のやり方ではどんな Python オブジェクトも代入できてしまいます。加えてこの属性は削除 (del)
できてしまい、その場合、 C のポインタには <em>NULL</em> が設定されます。たとえもしメンバが <em>NULL</em> 以外の値に初期化されるようにしてあったとしても、属性が削除されればメンバは <em>NULL</em> になってしまいます。</p>
<p>ここでは <tt class="xref py py-meth docutils literal"><span class="pre">name()</span></tt> と呼ばれるメソッドを定義しましょう。これはファーストネーム first とラストネーム last を連結した文字列をそのオブジェクトの名前として返します。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;%s %s&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;OO&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">PyString_Format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このメソッドは C 関数として実装され、 <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> (あるいは   <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> のサブクラス)
のインスタンスを第一引数として受けとります。メソッドはつねにそのインスタンスを最初の引数として受けとらなければなりません。しばしば固定引数とキーワード引数も受けとりますが、今回はなにも必要ないので、固定引数のタプルもキーワード引数の辞書も取らないことにします。このメソッドは
Python の以下のメソッドと等価です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">def</span> <span class="n">name</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
   <span class="k">return</span> <span class="s">&quot;%s %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">last</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> メンバと <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt> メンバがそれぞれ <em>NULL</em> かどうかチェックしなければならないことに注意してください。これらは削除される可能性があり、その場合値は <em>NULL</em> にセットされます。この属性の削除を禁止して、そこに入れられる値を文字列に限定できればなおいいでしょう。次の節ではこれについて扱います。</p>
<p>さて、メソッドを定義したので、ここでメソッド定義用の配列を作成する必要があります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>これを <tt class="xref py py-attr docutils literal"><span class="pre">tp_methods</span></tt> スロットに入れましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
</pre></div>
</div>
<p>ここでの <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><tt class="xref py py-const docutils literal"><span class="pre">METH_NOARGS</span></tt></a> フラグは、そのメソッドが引数を取らないことを宣言するのに使われています。</p>
<p>最後に、この型を基底クラスとして利用可能にしましょう。上のメソッドは注意ぶかく書かれているので、これはそのオブジェクトの型が作成されたり利用される場合についてどんな仮定も置いていません。なので、ここですべきことは <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><tt class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_BASETYPE</span></tt></a> をクラス定義のフラグに加えるだけです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="o">/</span> <span class="o">*</span><span class="n">tp_flags</span><span class="o">*</span> <span class="o">/</span>
</pre></div>
</div>
<p><tt class="xref c c-func docutils literal"><span class="pre">initnoddy()</span></tt> の名前を <tt class="xref c c-func docutils literal"><span class="pre">initnoddy2()</span></tt> に変更し、 <a class="reference internal" href="../c-api/allocation.html#Py_InitModule3" title="Py_InitModule3"><tt class="xref c c-func docutils literal"><span class="pre">Py_InitModule3()</span></tt></a>
に渡されるモジュール名を更新します。</p>
<p>さいごに <tt class="file docutils literal"><span class="pre">setup.py</span></tt> ファイルを更新して新しいモジュールをビルドします。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">from</span> <span class="n">distutils</span><span class="p">.</span><span class="n">core</span> <span class="n">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
         <span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy.c&quot;</span><span class="p">]),</span>
         <span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy2&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy2.c&quot;</span><span class="p">]),</span>
         <span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>2.1.2. データ属性をこまかく制御する<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この節では、 <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> クラスの例にあった <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> と  <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt>
の各属性にたいして、より精密な制御を提供します。以前のバージョンのモジュールでは、インスタンス変数の <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> と
<tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt> には文字列以外のものも代入できてしまい、あまつさえ削除まで可能でした。ここではこれらの属性が必ず文字列を保持しているようにしましょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;Python.h&gt;</span>
<span class="cp">#include &quot;structmember.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>
        
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|SSi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span> 
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> 
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_getfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_setfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the first attribute&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyString_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> 
                    <span class="s">&quot;The first attribute value must be a string&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>    

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_getlast</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_setlast</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the last attribute&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyString_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> 
                    <span class="s">&quot;The last attribute value must be a string&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
  <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>    

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyGetSetDef</span> <span class="n">Noddy_getseters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> 
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getfirst</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setfirst</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> 
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getlast</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setlast</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;%s %s&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;OO&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">PyString_Format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*ob_size*/</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/*tp_name*/</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/*tp_basicsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_itemsize*/</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/*tp_dealloc*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_print*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_compare*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_repr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_number*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_sequence*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_mapping*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_call*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_str*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_buffer*/</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/*tp_flags*/</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="n">Noddy_getseters</span><span class="p">,</span>           <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">module_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="cp">#ifndef PyMODINIT_FUNC	</span><span class="cm">/* declarations for DLL import/export */</span><span class="cp"></span>
<span class="cp">#define PyMODINIT_FUNC void</span>
<span class="cp">#endif</span>
<span class="n">PyMODINIT_FUNC</span>
<span class="nf">initnoddy3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule3</span><span class="p">(</span><span class="s">&quot;noddy3&quot;</span><span class="p">,</span> <span class="n">module_methods</span><span class="p">,</span>
                       <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> 属性と <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt> 属性をよりこまかく制御するためには、カスタムメイドの getter 関数と setter
関数を使います。以下は <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> 属性から値を取得する関数 (getter) と、この属性に値を格納する関数 (setter) です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Noddy_getfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">Noddy_setfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the first attribute&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyString_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                    <span class="s">&quot;The first attribute value must be a string&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>getter 関数には <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> オブジェクトと「閉包 (closure)」 (これは void型のポインタです)
が渡されます。今回のケースでは閉包は無視します。 (閉包とは定義データが渡される setter や getter の高度な利用をサポートするためのもので、これを使うとたとえば getter と setter をひとまとめにした関数に、閉包のデータにもとづいて属性を get するか set するか決めさせる、といったことができます。)</p>
<p>setter 関数には <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> オブジェクトと新しい値、そして閉包が渡されます。新しい値は
<em>NULL</em> かもしれず、その場合はこの属性が削除されます。ここでは属性が削除されたり、その値が文字列でないときにはエラーを発生させるようにします。</p>
<p>ここでは <tt class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></tt> 構造体の配列をつくります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyGetSetDef</span> <span class="n">Noddy_getseters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getfirst</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setfirst</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getlast</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setlast</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>そしてこれを <tt class="xref py py-attr docutils literal"><span class="pre">tp_getset</span></tt> スロットに登録します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Noddy_getseters</span><span class="p">,</span>           <span class="cm">/* tp_getset */</span>
</pre></div>
</div>
<p>これで属性の getter と setter が登録できました。</p>
<p><tt class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></tt> 構造体の最後の要素が上で説明した閉包です。今回は閉包は使わないので <em>NULL</em> を渡しています。</p>
<p>また、メンバ定義からはこれらの属性を除いておきましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>また、ここでは <tt class="xref py py-attr docutils literal"><span class="pre">tp_init</span></tt> ハンドラも渡されるものとして文字列のみを許可するように修正する必要があります  <a class="footnote-reference" href="#id22" id="id8">[3]</a>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|SSi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これらの変更によって、 <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> メンバと <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt> メンバが決して <em>NULL</em>
にならないと保証できました。これでほとんどすべてのケースから <em>NULL</em> 値のチェックを除けます。これは <a class="reference internal" href="../c-api/refcounting.html#Py_XDECREF" title="Py_XDECREF"><tt class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></tt></a> 呼び出しを
<a class="reference internal" href="../c-api/refcounting.html#Py_DECREF" title="Py_DECREF"><tt class="xref c c-func docutils literal"><span class="pre">Py_DECREF()</span></tt></a> 呼び出しに変えられることを意味します。唯一これを変えられないのはオブジェクト解放メソッド (deallocator)
で、なぜならここではコンストラクタによるメンバ初期化が失敗している可能性があるからです。</p>
<p>さて、先ほどもしたように、このモジュール初期化関数と初期化関数内にあるモジュール名を変更しましょう。そして <tt class="file docutils literal"><span class="pre">setup.py</span></tt>
ファイルに追加の定義をくわえます。</p>
</div>
<div class="section" id="id9">
<h3>2.1.3. 循環ガベージコレクションをサポートする<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python は循環ガベージコレクション機能をもっており、これは不要なオブジェクトを、たとえ参照カウントがゼロでなくても、発見することができます。これはオブジェクトの参照が循環しているときに起こりえます。たとえば以下の例を考えてください:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">del</span> <span class="n">l</span>
</pre></div>
</div>
<p>この例では、自分自身をふくむリストをつくりました。たとえこのリストを del しても、それは自分自身への参照をまだ持ちつづけますから、参照カウントはゼロにはなりません。嬉しいことに Python には循環ガベージコレクション機能がありますから、最終的にはこのリストが不要であることを検出し、解放できます。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> クラスの 2番目の例では、 <tt class="xref py py-attr docutils literal"><span class="pre">first</span></tt> 属性と <tt class="xref py py-attr docutils literal"><span class="pre">last</span></tt>
属性にどんなオブジェクトでも格納できるようになっていました。  <a class="footnote-reference" href="#id23" id="id10">[4]</a> 。つまり、 <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> オブジェクトの参照は循環しうるのです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">noddy2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">noddy2</span><span class="p">.</span><span class="n">Noddy</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">l</span>
</pre></div>
</div>
<p>これは実にばかげた例ですが、すくなくとも <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> クラスに循環ガベージコレクション機能のサポートを加える口実を与えてくれます。循環ガベージコレクションをサポートするには 2つのタイプスロットを埋め、これらのスロットを許可するようにクラス定義のフラグを設定する必要があります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;Python.h&gt;</span>
<span class="cp">#include &quot;structmember.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vret</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> 
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy_clear</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>
        
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span> 
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> 
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">PyString_FromString</span><span class="p">(</span><span class="s">&quot;%s %s&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">Py_BuildValue</span><span class="p">(</span><span class="s">&quot;OO&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">PyString_Format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*ob_size*/</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/*tp_name*/</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/*tp_basicsize*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_itemsize*/</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/*tp_dealloc*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_print*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_compare*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_repr*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_number*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_sequence*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_mapping*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_call*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_str*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_getattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_setattro*/</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/*tp_as_buffer*/</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span> <span class="cm">/*tp_flags*/</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">Noddy_traverse</span><span class="p">,</span>   <span class="cm">/* tp_traverse */</span>
    <span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">Noddy_clear</span><span class="p">,</span>           <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>		               <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">module_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="cp">#ifndef PyMODINIT_FUNC	</span><span class="cm">/* declarations for DLL import/export */</span><span class="cp"></span>
<span class="cp">#define PyMODINIT_FUNC void</span>
<span class="cp">#endif</span>
<span class="n">PyMODINIT_FUNC</span>
<span class="nf">initnoddy4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule3</span><span class="p">(</span><span class="s">&quot;noddy4&quot;</span><span class="p">,</span> <span class="n">module_methods</span><span class="p">,</span>
                       <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>traversal メソッドは循環した参照に含まれる可能性のある内部オブジェクトへのアクセスを提供します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vret</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>循環した参照に含まれるかもしれない各内部オブジェクトに対して、 traversal メソッドに渡された <tt class="xref c c-func docutils literal"><span class="pre">visit()</span></tt> 関数を呼びます。
<tt class="xref c c-func docutils literal"><span class="pre">visit()</span></tt> 関数は内部オブジェクトと、traversal メソッドに渡された追加の引数 <em>arg</em> を引数としてとります。この関数はこの値が非負の場合に返される整数の値を返します。</p>
<p>Python 2.4 以降では、visit 関数の呼び出しを自動化する <a class="reference internal" href="../c-api/gcsupport.html#Py_VISIT" title="Py_VISIT"><tt class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></tt></a> マクロが用意されています。
<a class="reference internal" href="../c-api/gcsupport.html#Py_VISIT" title="Py_VISIT"><tt class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></tt></a> を使えば、 <tt class="xref c c-func docutils literal"><span class="pre">Noddy_traverse()</span></tt> は次のように簡略化できます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">注意: <tt class="xref py py-attr docutils literal"><span class="pre">tp_traverse</span></tt> の実装で <a class="reference internal" href="../c-api/gcsupport.html#Py_VISIT" title="Py_VISIT"><tt class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></tt></a> を使うには、その引数に正確に <em>visit</em> および <em>arg</em>
という名前をつける必要があります。これは、この退屈な実装に統一性を導入することを促進します。</p>
</div>
<p>また、循環した参照に含まれた内部オブジェクトを消去するためのメソッドも提供する必要があります。オブジェクト解放用のメソッドを再実装して、このメソッドに使いましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy_clear</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></tt> 中での一時変数の使い方に注目してください。ここでは、一時変数をつかって各メンバの参照カウントを減らす前にそれらに
<em>NULL</em> を代入しています。これは次のような理由によります。すでにお話ししたように、もし参照カウントがゼロになると、このオブジェクトがコールバックされるようになってしまいます。さらに、いまやガベージコレクションをサポートしているため、ガベージコレクション時に実行されるコードについても心配しなくてはなりません。もしガベージコレクションが走っていると、あなたの <tt class="xref py py-attr docutils literal"><span class="pre">tp_traverse</span></tt> ハンドラが呼び出される可能性があります。メンバの参照カウントがゼロになった場合に、その値が <em>NULL</em> に設定されていないと <tt class="xref c c-func docutils literal"><span class="pre">Noddy_traverse()</span></tt> が呼ばれる機会はありません。</p>
<p>Python 2.4 以降では、注意ぶかく参照カウントを減らすためのマクロ <a class="reference internal" href="../c-api/refcounting.html#Py_CLEAR" title="Py_CLEAR"><tt class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></tt></a> が用意されています。
<a class="reference internal" href="../c-api/refcounting.html#Py_CLEAR" title="Py_CLEAR"><tt class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></tt></a> を使えば、 <tt class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></tt> は次のように簡略化できます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最後に、 <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><tt class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></tt></a> フラグをクラス定義のフラグに加えます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span> <span class="o">/</span> <span class="o">*</span><span class="n">tp_flags</span><span class="o">*</span> <span class="o">/</span>
</pre></div>
</div>
<p>これで完了です。 <tt class="xref py py-attr docutils literal"><span class="pre">tp_alloc</span></tt> スロットまたは <tt class="xref py py-attr docutils literal"><span class="pre">tp_free</span></tt> スロットが書かれていれば、それらを循環ガベージコレクションに使えるよう修正すればよいのです。ほとんどの拡張機能は自動的に提供されるバージョンを使うでしょう。</p>
</div>
<div class="section" id="id11">
<h3>2.1.4. 他の型のサブクラスを作る<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>既存の型を継承した新しい拡張型を作成することができます。組み込み型から継承するのは特に簡単です。必要な <tt class="xref py py-class docutils literal"><span class="pre">PyTypeObject</span></tt> を簡単に利用できるからです。それに比べて、 <tt class="xref py py-class docutils literal"><span class="pre">PyTypeObject</span></tt> 構造体を拡張モジュール間で共有するのは難しいです。</p>
<p>次の例では、ビルトインの <a class="reference internal" href="../library/functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a> 型を継承した <tt class="xref py py-class docutils literal"><span class="pre">Shoddy</span></tt> 型を作成しています。新しい型は通常のリスト型と完全に互換性がありますが、追加で内部のカウンタを増やす
<tt class="xref py py-meth docutils literal"><span class="pre">increment()</span></tt> メソッドを持っています。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">shoddy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">shoddy</span><span class="p">.</span><span class="n">Shoddy</span><span class="p">(</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span> <span class="n">s</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span> <span class="n">s</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
<span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;Python.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyListObject</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Shoddy</span><span class="p">;</span>


<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Shoddy_increment</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PyInt_FromLong</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Shoddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;increment&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Shoddy_increment</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;increment state counter&quot;</span><span class="p">)},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Shoddy_init</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyList_Type</span><span class="p">.</span><span class="n">tp_init</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">ShoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* ob_size */</span>
    <span class="s">&quot;shoddy.Shoddy&quot;</span><span class="p">,</span>         <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Shoddy</span><span class="p">),</span>          <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_compare */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
      <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span>   <span class="cm">/* tp_flags */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_iternext */</span>
    <span class="n">Shoddy_methods</span><span class="p">,</span>          <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Shoddy_init</span><span class="p">,</span>   <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_alloc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">initshoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

    <span class="n">ShoddyType</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule3</span><span class="p">(</span><span class="s">&quot;shoddy&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Shoddy module&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Shoddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>見てわかるように、ソースコードは前の節の <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> の時と非常に似ています。違う部分をそれぞれを見ていきます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyListObject</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Shoddy</span><span class="p">;</span>
</pre></div>
</div>
<p>継承した型のオブジェクトの最初の違いは、親クラスのオブジェクト構造が最初に必要なことです。基底型が既に <a class="reference internal" href="../c-api/structures.html#PyObject_HEAD" title="PyObject_HEAD"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_HEAD()</span></tt></a> を構造体の先頭に持っています。</p>
<p>Python オブジェクトが <tt class="xref py py-class docutils literal"><span class="pre">Shoddy</span></tt> 型のインスタンスだった場合、その <em>PyObject*</em> ポインタは <em>PyListObject*</em> にも <em>Shoddy*</em> にも安全にキャストできます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Shoddy_init</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyList_Type</span><span class="p">.</span><span class="n">tp_init</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
       <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この新しい型の <tt class="xref py py-attr docutils literal"><span class="pre">__init__</span></tt> メソッドで、基底型の <tt class="xref py py-attr docutils literal"><span class="pre">__init__</span></tt>
メソッドを呼び出している様子を見ることができます。</p>
<p>このパターンは、カスタムの <a class="reference internal" href="../library/new.html#module-new" title="new: ランタイム実装オブジェクトの作成のインターフェイス。 (撤廃)"><tt class="xref py py-attr docutils literal"><span class="pre">new</span></tt></a> と <tt class="xref py py-attr docutils literal"><span class="pre">dealloc</span></tt> メソッドを実装するときには重要です。継承した型の <a class="reference internal" href="../library/new.html#module-new" title="new: ランタイム実装オブジェクトの作成のインターフェイス。 (撤廃)"><tt class="xref py py-attr docutils literal"><span class="pre">new</span></tt></a> メソッドは、 <tt class="xref py py-attr docutils literal"><span class="pre">tp_alloc</span></tt> を使ってメモリを割り当てるべきではありません。それは基底型の <tt class="xref py py-attr docutils literal"><span class="pre">tp_new</span></tt> を呼出たときに処理されるからです。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">Shoddy</span></tt> 型のために <a class="reference internal" href="../c-api/type.html#PyTypeObject" title="PyTypeObject"><tt class="xref c c-func docutils literal"><span class="pre">PyTypeObject()</span></tt></a> を埋めるとき、
<tt class="xref c c-func docutils literal"><span class="pre">tp_base()</span></tt> スロットを見つけることができます。クロスプラットフォームのコンパイラに対応するために、直接そのスロットを <a class="reference internal" href="../c-api/list.html#PyList_Type" title="PyList_Type"><tt class="xref c c-func docutils literal"><span class="pre">PyList_Type()</span></tt></a>
で埋めてはいけません。代わりに、後でモジュールの <tt class="xref c c-func docutils literal"><span class="pre">init()</span></tt> 関数の中で行うことができます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyMODINIT_FUNC</span>
<span class="nf">initshoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

    <span class="n">ShoddyType</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Py_InitModule3</span><span class="p">(</span><span class="s">&quot;shoddy&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Shoddy module&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Shoddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="xref c c-func docutils literal"><span class="pre">PyType_Read()</span></tt> を呼ぶ前に、型の構造は <tt class="xref py py-attr docutils literal"><span class="pre">tp_base</span></tt> スロットは埋められていなければなりません。継承している新しい型を作るとき、 <tt class="xref py py-attr docutils literal"><span class="pre">tp_alloc</span></tt> スロットを <a class="reference internal" href="../c-api/type.html#PyType_GenericNew" title="PyType_GenericNew"><tt class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></tt></a>
で埋める必要はありません。 &#8211; 基底型のアロケート関数が継承されます。</p>
<p>その後、 <tt class="xref c c-func docutils literal"><span class="pre">PyType_Read()</span></tt> を呼んで、 <tt class="xref py py-class docutils literal"><span class="pre">Noddy</span></tt> の時と同じようにタイプオブジェクトをモジュールに追加します。</p>
</div>
</div>
<div class="section" id="dnt-type-methods">
<span id="id12"></span><h2>2.2. タイプメソッド<a class="headerlink" href="#dnt-type-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節ではさまざまな実装可能なタイプメソッドと、それらが何をするものであるかについて、ざっと説明します。</p>
<p>以下は <a class="reference internal" href="../c-api/type.html#PyTypeObject" title="PyTypeObject"><tt class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></tt></a> の定義です。デバッグビルドでしか使われないいくつかのメンバは省いてあります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
    <span class="kt">int</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>

    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="n">getattrfunc</span> <span class="n">tp_getattr</span><span class="p">;</span>
    <span class="n">setattrfunc</span> <span class="n">tp_setattr</span><span class="p">;</span>
    <span class="n">cmpfunc</span> <span class="n">tp_compare</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>

    <span class="cm">/* Method suites for standard classes */</span>

    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

    <span class="cm">/* More standard operations (here for binary compatibility) */</span>

    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
    <span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>
    <span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>

    <span class="cm">/* Functions to access object as input/output buffer */</span>
    <span class="n">PyBufferProcs</span> <span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

    <span class="cm">/* Flags to define presence of optional/expanded features */</span>
    <span class="kt">long</span> <span class="n">tp_flags</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span> <span class="cm">/* Documentation string */</span>

    <span class="cm">/* Assigned meaning in release 2.0 */</span>
    <span class="cm">/* call function for all accessible objects */</span>
    <span class="n">traverseproc</span> <span class="n">tp_traverse</span><span class="p">;</span>

    <span class="cm">/* delete references to contained objects */</span>
    <span class="n">inquiry</span> <span class="n">tp_clear</span><span class="p">;</span>

    <span class="cm">/* Assigned meaning in release 2.1 */</span>
    <span class="cm">/* rich comparisons */</span>
    <span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>

    <span class="cm">/* weak reference enabler */</span>
    <span class="kt">long</span> <span class="n">tp_weaklistoffset</span><span class="p">;</span>

    <span class="cm">/* Added in release 2.2 */</span>
    <span class="cm">/* Iterators */</span>
    <span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
    <span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>

    <span class="cm">/* Attribute descriptor and subclassing stuff */</span>
    <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">tp_descr_get</span><span class="p">;</span>
    <span class="n">descrsetfunc</span> <span class="n">tp_descr_set</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">tp_dictoffset</span><span class="p">;</span>
    <span class="n">initproc</span> <span class="n">tp_init</span><span class="p">;</span>
    <span class="n">allocfunc</span> <span class="n">tp_alloc</span><span class="p">;</span>
    <span class="n">newfunc</span> <span class="n">tp_new</span><span class="p">;</span>
    <span class="n">freefunc</span> <span class="n">tp_free</span><span class="p">;</span> <span class="cm">/* Low-level free-memory routine */</span>
    <span class="n">inquiry</span> <span class="n">tp_is_gc</span><span class="p">;</span> <span class="cm">/* For PyObject_IS_GC */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span> <span class="cm">/* method resolution order */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>

<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
<p><em>たくさんの</em> メソッドがありますね。でもそんなに心配する必要はありません。定義したい型があるなら、実装するのはこのうちのごくわずかですむことがほとんどです。</p>
<p>すでに予想されているでしょうが、これらの多様なハンドラについて、これからより詳しい情報を提供します。しかしこれらのメンバが構造体中で定義されている順番は無視します。というのは、これらのメンバの現れる順序は歴史的な遺産によるものだからです。型を初期化するさいに、これらのメンバを正しい順序で並べるよう、くれぐれも注意してください。ふつういちばん簡単なのは、必要なメンバがすべて含まれている (たとえそれらが <tt class="docutils literal"><span class="pre">0</span></tt>
に初期化されていても) 例をとってきて、自分の型に合わせるよう変更をくわえることです。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* 表示用 */</span>
</pre></div>
</div>
<p>これは型の名前です。前節で説明したように、これはいろいろな場面で現れ、ほとんどは診断用の目的で使われるものです。なので、そのような場面で役に立つであろう名前を選んでください。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* 割り当て用 */</span>
</pre></div>
</div>
<p>これらのメンバは、この型のオブジェクトが作成されるときにどれだけのメモリを割り当てればよいのかをランタイムに指示します。Python には可変長の構造体
(文字列やリストなどを想像してください) に対する組み込みのサポートがある程度あり、ここで <tt class="xref py py-attr docutils literal"><span class="pre">tp_itemsize</span></tt> メンバが使われます。これらについてはあとでふれます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span>
</pre></div>
</div>
<p>ここには Python スクリプトリファレンス <tt class="docutils literal"><span class="pre">obj.__doc__</span></tt> が doc string を返すときの文字列 (あるいはそのアドレス)
を入れます。</p>
<p>では次に、ほとんどの拡張型が実装するであろう基本的なタイプメソッドに入っていきます。</p>
<div class="section" id="finalization">
<h3>2.2.1. 最終化 (finalization) と解放<a class="headerlink" href="#finalization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-c" id="index-1"><div class="highlight"><pre><span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
</pre></div>
</div>
<p>型のインスタンスの参照カウントがゼロになり、 Python インタプリタがそれを潰して再利用したくなると、この関数が呼ばれます。解放すべきメモリをその型が保持していたり、それ以外にも実行すべき後処理がある場合は、それらをここに入れます。オブジェクトそれ自体もここで解放される必要があります。この関数の例は、以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">newdatatype_dealloc</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="p">);</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="index-2">解放用関数でひとつ重要なのは、処理待ちの例外にいっさい手をつけないことです。なぜなら、解放用の関数は Python
インタプリタがスタックを元の状態に戻すときに呼ばれることが多いからです。そして (通常の関数からの復帰でなく) 例外のためにスタックが巻き戻されるときは、すでに発生している例外から解放用関数を守るものはありません。解放用の関数がおこなう動作が追加の Python のコードを実行してしまうと、それらは例外が発生していることを検知するかもしれません。これはインタプリタが誤解させるエラーを発生させることにつながります。これを防ぐ正しい方法は、安全でない操作を実行する前に処理待ちの例外を保存しておき、終わったらそれを元に戻すことです。これは
<a class="reference internal" href="../c-api/exceptions.html#PyErr_Fetch" title="PyErr_Fetch"><tt class="xref c c-func docutils literal"><span class="pre">PyErr_Fetch()</span></tt></a> および <a class="reference internal" href="../c-api/exceptions.html#PyErr_Restore" title="PyErr_Restore"><tt class="xref c c-func docutils literal"><span class="pre">PyErr_Restore()</span></tt></a> 関数を使うことによって可能になります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">my_dealloc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">cbresult</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">err_type</span><span class="p">,</span> <span class="o">*</span><span class="n">err_value</span><span class="p">,</span> <span class="o">*</span><span class="n">err_traceback</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">have_error</span> <span class="o">=</span> <span class="n">PyErr_Occurred</span><span class="p">()</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">have_error</span><span class="p">)</span>
            <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">cbresult</span> <span class="o">=</span> <span class="n">PyObject_CallObject</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cbresult</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">PyErr_WriteUnraisable</span><span class="p">();</span>
        <span class="k">else</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">cbresult</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">have_error</span><span class="p">)</span>
            <span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">err_type</span><span class="p">,</span> <span class="n">err_value</span><span class="p">,</span> <span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>2.2.2. オブジェクト表現<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-3">Python では、オブジェクトの文字列表現を生成するのに 3つのやり方があります: <a class="reference internal" href="../library/repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a> 関数 (あるいはそれと等価なバッククォートを用いた表現) を使う方法、 <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a>  関数を使う方法、そして <a class="reference internal" href="../reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> 文を使う方法です。ほとんどのオブジェクトで <a class="reference internal" href="../reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> 文は <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> 関数と同じですが、必要な場合には特殊なケースとして
<tt class="xref c c-type docutils literal"><span class="pre">FILE*</span></tt> にも表示できます。 <tt class="xref c c-type docutils literal"><span class="pre">FILE*</span></tt> への表示は、効率が問題となっている場合で、一時的な文字列オブジェクトを作成してファイルに書き込むのでは効率が悪すぎることがプロファイリングからも明らかな場合にのみ使うべきです。</p>
<p>これらのハンドラはどれも必須ではありません。ほとんどの型ではせいぜい <tt class="xref py py-attr docutils literal"><span class="pre">tp_str</span></tt> ハンドラと <tt class="xref py py-attr docutils literal"><span class="pre">tp_repr</span></tt>
ハンドラを実装するだけですみます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>
<span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
<span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_repr</span></tt> ハンドラは呼び出されたインスタンスの文字列表現を格納した文字列オブジェクトを返す必要があります。簡単な例は以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_repr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyString_FromFormat</span><span class="p">(</span><span class="s">&quot;Repr-ified_newdatatype{{size:\%d}}&quot;</span><span class="p">,</span>
                               <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_repr</span></tt> ハンドラが指定されていなければ、インタプリタはその型の <tt class="xref py py-attr docutils literal"><span class="pre">tp_name</span></tt>
とそのオブジェクトの一意な識別値をもちいて文字列表現を作成します。</p>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_str</span></tt> ハンドラと <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> の関係は、上の <tt class="xref py py-attr docutils literal"><span class="pre">tp_repr</span></tt> ハンドラと <a class="reference internal" href="../library/repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a>
の関係に相当します。つまり、これは Python のコードがオブジェクトのインスタンスに対して <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a>
を呼び出したときに呼ばれます。この関数の実装は <tt class="xref py py-attr docutils literal"><span class="pre">tp_repr</span></tt> ハンドラのそれと非常に似ていますが、得られる文字列表現は人間が読むことを意図されています。 <tt class="xref py py-attr docutils literal"><span class="pre">tp_str</span></tt> が指定されていない場合、かわりに <tt class="xref py py-attr docutils literal"><span class="pre">tp_repr</span></tt> ハンドラが使われます。</p>
<p>以下は簡単な例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_str</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyString_FromFormat</span><span class="p">(</span><span class="s">&quot;Stringified_newdatatype{{size:\%d}}&quot;</span><span class="p">,</span>
                               <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>print ハンドラは Python がその型のインスタンスを「print する」必要のあるときに毎回呼ばれます。たとえば &#8216;node&#8217; が TreeNode
型のインスタンスだとすると、print ハンドラは Python が以下を実行したときに呼ばれます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">print</span> <span class="n">node</span>
</pre></div>
</div>
<p>flags 引数には <tt class="xref py py-const docutils literal"><span class="pre">Py_PRINT_RAW</span></tt> というフラグがあり、これはその文字列をクォートやおそらくはエスケープシーケンスの解釈もなしで表示することを指示します。</p>
<p>この print 関数は <tt class="xref c c-type docutils literal"><span class="pre">FILE*</span></tt> オブジェクトを引数としてとります。たぶん、ここに出力することになるでしょう。</p>
<p>print 関数の例は以下のようになります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">newdatatype_print</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">Py_PRINT_RAW</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;&lt;{newdatatype object--size: %d}&gt;&quot;</span><span class="p">,</span>
                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&lt;{newdatatype object--size: %d}&gt;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>2.2.3. 属性を管理する<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>属性をもつどのオブジェクトに対しても、その型は、それらオブジェクトの属性をどのように解決するか制御する関数を提供する必要があります。必要な関数としては、属性を (それが定義されていれば) 取り出すものと、もうひとつは属性に (それが許可されていれば) 値を設定するものです。属性を削除するのは特殊なケースで、この場合は新しい値としてハンドラに <em>NULL</em> が渡されます。</p>
<p>Python は 2つの属性ハンドラの組をサポートしています。属性をもつ型はどちらか一組を実装するだけでよく、それらの違いは一方の組が属性の名前を
<tt class="xref c c-type docutils literal"><span class="pre">char*</span></tt> として受け取るのに対してもう一方の組は属性の名前を <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a> として受け取る、というものです。それぞれの型はその実装にとって都合がよい方を使えます。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">getattrfunc</span>  <span class="n">tp_getattr</span><span class="p">;</span>        <span class="cm">/* char * バージョン */</span>
<span class="n">setattrfunc</span>  <span class="n">tp_setattr</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="n">getattrofunc</span> <span class="n">tp_getattrofunc</span><span class="p">;</span>   <span class="cm">/* PyObject * バージョン */</span>
<span class="n">setattrofunc</span> <span class="n">tp_setattrofunc</span><span class="p">;</span>
</pre></div>
</div>
<p>オブジェクトの属性へのアクセスがつねに (すぐあとで説明する) 単純な操作だけならば、 <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a> を使って属性を管理する関数として、総称的 (generic) な実装を使えます。特定の型に特化した属性ハンドラの必要性は Python 2.2 からほとんど完全になくなりました。しかし、多くの例はまだ、この新しく使えるようになった総称的なメカニズムを使うよう更新されてはいません。</p>
<div class="section" id="generic-attribute-management">
<span id="id15"></span><h4>2.2.3.1. 総称的な属性を管理する<a class="headerlink" href="#generic-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p>ほとんどの型は <em>単純な</em> 属性を使うだけです。では、どのような属性が単純だといえるのでしょうか? それが満たすべき条件はごくわずかです:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="../c-api/type.html#PyType_Ready" title="PyType_Ready"><tt class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></tt></a> が呼ばれたとき、すでに属性の名前がわかっていること。</li>
<li>属性を参照したり設定したりするときに、特別な記録のための処理が必要でなく、また参照したり設定した値に対してどんな操作も実行する必要がないこと。</li>
</ol>
<p>これらの条件は、属性の値や、値が計算されるタイミング、または格納されたデータがどの程度妥当なものであるかといったことになんら制約を課すものではないことに注意してください。</p>
<p><a class="reference internal" href="../c-api/type.html#PyType_Ready" title="PyType_Ready"><tt class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></tt></a> が呼ばれると、これはそのタイプオブジェクトに参照されている
3つのテーブルを使って、そのタイプオブジェクトの辞書中にデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><em class="xref std std-term">descriptor</em></a>) を作成します。各デスクリプタは、インスタンスオブジェクトの属性に対するアクセスを制御します。それぞれのテーブルはなくてもかまいません。もしこれら 3つがすべて <em>NULL</em> だと、その型のインスタンスはその基底型から継承した属性だけを持つことになります。また、 <tt class="xref py py-attr docutils literal"><span class="pre">tp_getattro</span></tt> および <tt class="xref py py-attr docutils literal"><span class="pre">tp_setattro</span></tt> が <em>NULL</em>
のままだった場合も、基底型にこれらの属性の操作がまかせられます。</p>
<p>テーブルはタイプオブジェクト中の 3つのメンバとして宣言されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_methods</span></tt> が <em>NULL</em> でない場合、これは <a class="reference internal" href="../c-api/structures.html#PyMethodDef" title="PyMethodDef"><tt class="xref c c-type docutils literal"><span class="pre">PyMethodDef</span></tt></a> 構造体への配列を指している必要があります。テーブル中の各エントリは、つぎのような構造体のインスタンスです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="p">{</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">ml_name</span><span class="p">;</span>       <span class="cm">/* メソッド名 */</span>
    <span class="n">PyCFunction</span>  <span class="n">ml_meth</span><span class="p">;</span>       <span class="cm">/* 実装する関数 */</span>
    <span class="kt">int</span>          <span class="n">ml_flags</span><span class="p">;</span>      <span class="cm">/* flags */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">ml_doc</span><span class="p">;</span>        <span class="cm">/* docstring */</span>
<span class="p">}</span> <span class="n">PyMethodDef</span><span class="p">;</span>
</pre></div>
</div>
<p>その型が提供する各メソッドについてひとつのエントリを定義する必要があります。基底型から継承してきたメソッドについてはエントリは必要ありません。これの最後には、配列の終わりを示すための見張り番 (sentinel) として追加のエントリがひとつ必要です。この場合、 <tt class="xref py py-attr docutils literal"><span class="pre">ml_name</span></tt>
メンバが sentinel として使われ、その値は <em>NULL</em> でなければなりません。</p>
<p>2番目のテーブルは、インスタンス中に格納されるデータと直接対応づけられた属性を定義するのに使います。いくつもの C の原始的な型がサポートされており、アクセスを読み込み専用にも読み書き可能にもできます。このテーブルで使われる構造体は次のように定義されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">doc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyMemberDef</span><span class="p">;</span>
</pre></div>
</div>
<p>このテーブルの各エントリに対してデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><em class="xref std std-term">descriptor</em></a>)が作成され、値をインスタンスの構造体から抽出しうる型に対してそれらが追加されます。 <a class="reference internal" href="../library/functions.html#type" title="type"><tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt></a>
メンバは <tt class="file docutils literal"><span class="pre">structmember.h</span></tt> ヘッダで定義された型のコードをひとつ含んでいる必要があります。この値は Python における値と
C における値をどのように変換しあうかを定めるものです。 <tt class="xref py py-attr docutils literal"><span class="pre">flags</span></tt> メンバはこの属性がどのようにアクセスされるかを制御するフラグを格納するのに使われます。</p>
<p>以下のフラグ用定数は <tt class="file docutils literal"><span class="pre">structmember.h</span></tt> で定義されており、これらはビットごとの OR を取って組み合わせられます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">READONLY</span></tt></td>
<td>絶対に変更できない。</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-const docutils literal"><span class="pre">RO</span></tt></td>
<td><tt class="xref py py-const docutils literal"><span class="pre">READONLY</span></tt> の短縮形。</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">READ_RESTRICTED</span></tt></td>
<td>制限モード (restricted mode) では参照できない。</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-const docutils literal"><span class="pre">WRITE_RESTRICTED</span></tt></td>
<td>制限モード (restricted mode) では変更できない。</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-const docutils literal"><span class="pre">RESTRICTED</span></tt></td>
<td>制限モード (restricted mode) では参照も変更もできない。</td>
</tr>
</tbody>
</table>
<p id="index-4"><tt class="xref py py-attr docutils literal"><span class="pre">tp_members</span></tt> を使ったひとつの面白い利用法は、実行時に使われるデスクリプタを作成しておき、単にテーブル中にテキストを置いておくことによって、この方法で定義されたすべての属性に doc string を関連付けられるようにすることです。アプリケーションはこのイントロスペクション用 API を使って、クラスオブジェクトからデスクリプタを取り出し、その
<tt class="xref py py-attr docutils literal"><span class="pre">__doc__</span></tt> 属性を使って doc string を得られます。</p>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_methods</span></tt> テーブルと同じように、ここでも <tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> メンバの値を <em>NULL</em> にした見張り用エントリが必要です。</p>
</div>
<div class="section" id="id16">
<h4>2.2.3.2. 特定の型に特化した属性の管理<a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>話を単純にするため、ここでは <tt class="xref c c-type docutils literal"><span class="pre">char*</span></tt> を使ったバージョンのみを示します。name パラメータの型はインターフェイスとして
<tt class="xref c c-type docutils literal"><span class="pre">char*</span></tt> を使うか <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a> を使うかの違いしかありません。この例では、上の総称的な例と同じことを効率的にやりますが、 Python 2.2 で追加された総称的な型のサポートを使わずにやります。これを紹介することは
2つの意味をもっています。ひとつはどうやって、古いバージョンの Python と互換性のあるやり方で、基本的な属性管理をおこなうか。そしてもうひとつはハンドラの関数がどのようにして呼ばれるのか。これで、たとえその機能を拡張する必要があるとき、何をどうすればいいかわかるでしょう。</p>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_getattr</span></tt> ハンドラはオブジェクトが属性への参照を要求するときに呼ばれます。これは、そのクラスの
<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></tt></a> メソッドが呼ばれるであろう状況と同じ状況下で呼び出されます。</p>
<p>これを処理するありがちな方法は、(1) 一連の関数 (下の例の  <tt class="xref c c-func docutils literal"><span class="pre">newdatatype_getSize()</span></tt> や
<tt class="xref c c-func docutils literal"><span class="pre">newdatatype_setSize()</span></tt>) を実装する、(2) これらの関数を記録したメソッドテーブルを提供する、そして (3)
そのテーブルの参照結果を返す getattr 関数を提供することです。メソッドテーブルはタイプオブジェクトの <tt class="xref py py-attr docutils literal"><span class="pre">tp_methods</span></tt> メンバと同じ構造を持っています。</p>
<p>以下に例を示します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">newdatatype_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;getSize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">newdatatype_getSize</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the current size.&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;setSize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">newdatatype_setSize</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
     <span class="s">&quot;Set the size.&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>           <span class="cm">/* 見張り */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_getattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Py_FindMethod</span><span class="p">(</span><span class="n">newdatatype_methods</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_setattr</span></tt> ハンドラは、クラスのインスタンスの <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></tt></a> または <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__delattr__()</span></tt></a>
メソッドが呼ばれるであろう状況で呼び出されます。ある属性が削除されるとき、3番目のパラメータは <em>NULL</em> になります。以下の例はたんに例外を発生させるものですが、もし本当にこれと同じことをしたいなら、 <tt class="xref py py-attr docutils literal"><span class="pre">tp_setattr</span></tt> ハンドラを
<em>NULL</em> に設定すべきです。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">newdatatype_setattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span> <span class="s">&quot;Read-only attribute: \%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id17">
<h3>2.2.4. オブジェクトの比較<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-c"><div class="highlight"><pre><span class="n">cmpfunc</span> <span class="n">tp_compare</span><span class="p">;</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_compare</span></tt> ハンドラは、オブジェクトどうしの比較が必要で、そのオブジェクトに要求された比較をおこなうのに適した特定の拡張比較メソッドが実装されていないときに呼び出されます。(これが定義されているとき、
<a class="reference internal" href="../c-api/object.html#PyObject_Compare" title="PyObject_Compare"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_Compare()</span></tt></a> または <a class="reference internal" href="../c-api/object.html#PyObject_Cmp" title="PyObject_Cmp"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_Cmp()</span></tt></a> が使われるとこれはつねに呼び出されます、また
Python で <a class="reference internal" href="../library/functions.html#cmp" title="cmp"><tt class="xref py py-func docutils literal"><span class="pre">cmp()</span></tt></a> が使われたときにも呼び出されます。) これは <a class="reference internal" href="../reference/datamodel.html#object.__cmp__" title="object.__cmp__"><tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt></a> メソッドに似ています。この関数はもし
<em>obj1</em> が <em>obj2</em> より「小さい」場合は <tt class="docutils literal"><span class="pre">-1</span></tt> を返し、それらが等しければ <tt class="docutils literal"><span class="pre">0</span></tt> 、そしてもし <em>obj1</em> が <em>obj2</em> より「大きい」場合は <tt class="docutils literal"><span class="pre">1</span></tt> を返す必要があります。 (以前は大小比較の結果として、任意の大きさの負または正の整数を返せましたが、 Python 2.2
以降ではこれはもう許されていません。将来的には、上にあげた以外の返り値は別の意味をもつ可能性があります。)</p>
<p><tt class="xref py py-attr docutils literal"><span class="pre">tp_compare</span></tt> ハンドラは例外を発生させられます。この場合、この関数は負の値を返す必要があります。呼び出した側は
<a class="reference internal" href="../c-api/exceptions.html#PyErr_Occurred" title="PyErr_Occurred"><tt class="xref c c-func docutils literal"><span class="pre">PyErr_Occurred()</span></tt></a> を使って例外を検査しなければなりません。</p>
<p>以下はサンプル実装です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">newdatatype_compare</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj1</span><span class="p">,</span> <span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">obj1</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span>
        <span class="n">obj2</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">obj1</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span>
             <span class="n">obj2</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h3>2.2.5. 抽象的なプロトコルのサポート<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python はいくつもの <em>抽象的な</em> “プロトコル”をサポートしています。これらを使用する特定のインターフェイスについては <a class="reference internal" href="../c-api/abstract.html#abstract"><em>抽象オブジェクトレイヤ (abstract objects layer)</em></a> で解説されています。</p>
<p>これら多数の抽象的なインターフェイスは、Python の実装が開発される初期の段階で定義されていました。とりわけ数値や辞書、そしてシーケンスなどのプロトコルは最初から Python の一部だったのです。それ以外のプロトコルはその後追加されました。型の実装にあるいくつかのハンドラルーチンに依存するようなプロトコルのために、古いプロトコルはハンドラの入ったオプションのブロックとして定義し、型オブジェクトから参照するようになりました。タイプオブジェクトの主部に追加のスロットをもつ新しいプロトコルについては、フラグ用のビットを立てることでそれらのスロットが存在しており、インタプリタがチェックすべきであることを指示できます。
(このフラグ用のビットは、そのスロットの値が非 <em>NULL</em> であることを示しているわけではありません。フラグはスロットの存在を示すのに使えますが、そのスロットはまだ埋まっていないかもしれないのです。)</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyNumberMethods</span>   <span class="n">tp_as_number</span><span class="p">;</span>
<span class="n">PySequenceMethods</span> <span class="n">tp_as_sequence</span><span class="p">;</span>
<span class="n">PyMappingMethods</span>  <span class="n">tp_as_mapping</span><span class="p">;</span>
</pre></div>
</div>
<p>お使いのオブジェクトを数値やシーケンス、あるいは辞書のようにふるまうようにしたいならば、それぞれに C の <a class="reference internal" href="../c-api/typeobj.html#PyNumberMethods" title="PyNumberMethods"><tt class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></tt></a>
構造体、 <a class="reference internal" href="../c-api/typeobj.html#PySequenceMethods" title="PySequenceMethods"><tt class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></tt></a> 構造体、または <a class="reference internal" href="../c-api/typeobj.html#PyMappingMethods" title="PyMappingMethods"><tt class="xref c c-type docutils literal"><span class="pre">PyMappingMethods</span></tt></a>  構造体のアドレスを入れます。これらに適切な値を入れても入れなくてもかまいません。これらを使った例は Python の配布ソースにある <tt class="file docutils literal"><span class="pre">Objects</span></tt> でみつけることができるでしょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、もし使うのならば、これはお使いの型のインスタンスのハッシュ番号を返すようにします。以下はやや的はずれな例ですが</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">long</span>
<span class="nf">newdatatype_hash</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、その型のインスタンスが「関数として呼び出される」ときに呼ばれます。たとえばもし <tt class="docutils literal"><span class="pre">obj1</span></tt> にそのインスタンスが入っていて、Python
スクリプトで <tt class="docutils literal"><span class="pre">obj1('hello')</span></tt> を実行したとすると、 <tt class="xref py py-attr docutils literal"><span class="pre">tp_call</span></tt> ハンドラが呼ばれます。</p>
<p>この関数は 3つの引数をとります:</p>
<ol class="arabic simple">
<li><em>arg1</em> にはその呼び出しの対象となる、そのデータ型のインスタンスが入ります。たとえば呼び出しが <tt class="docutils literal"><span class="pre">obj1('hello')</span></tt>
の場合、 <em>arg1</em> は <tt class="docutils literal"><span class="pre">obj1</span></tt> になります。</li>
<li><em>arg2</em> は呼び出しの引数を格納しているタプルです。ここから引数を取り出すには <a class="reference internal" href="../c-api/arg.html#PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> を使います。</li>
<li><em>arg3</em> はキーワード引数のための辞書です。これが <em>NULL</em> 以外でキーワード引数をサポートしているなら、 <a class="reference internal" href="../c-api/arg.html#PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></tt></a>
をつかって引数を取り出せます。キーワード引数をサポートしていないのにこれが <em>NULL</em> 以外の場合は、キーワード引数はサポートしていない旨のメッセージとともに <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> を発生させてください。</li>
</ol>
<p>以下はこの call 関数をてきとうに使った例です。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* call 関数の実装。</span>
<span class="cm"> *    obj1 : 呼び出しを受けるインスタンス。</span>
<span class="cm"> *    obj2 : 呼び出しのさいの引数を格納するタプル、この場合は 3つの文字列。</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_call</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg2</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg3</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;sss:call&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg3</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">PyString_FromFormat</span><span class="p">(</span>
        <span class="s">&quot;Returning -- value: [\%d] arg1: [\%s] arg2: [\%s] arg3: [\%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;\%s&quot;</span><span class="p">,</span> <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* バージョン 2.2 以降で追加 */</span>
<span class="cm">/* Iterators */</span>
<span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
<span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>
</pre></div>
</div>
<p>これらの関数はイテレータ用プロトコルをサポートします。オブジェクトが、その (ループ中に順に生成されていくかもしれない) 内容を巡回 (訳注:
イテレータでひとつずつ要素をたどっていくこと) するイテレータをサポートしたい場合は、 <tt class="docutils literal"><span class="pre">tp_iter</span></tt> ハンドラを実装する必要があります。
<tt class="docutils literal"><span class="pre">tp_iter</span></tt> ハンドラによって返されるオブジェクトは <tt class="docutils literal"><span class="pre">tp_iter</span></tt> と <tt class="docutils literal"><span class="pre">tp_iternext</span></tt> の両方を実装する必要があります。どちらのハンドラも、それが呼ばれたインスタンスをひとつだけ引数としてとり、新しい参照を返します。エラーが起きた場合には例外を設定してから
<em>NULL</em> を返す必要があります。</p>
<p>巡回可能な要素を表現するオブジェクトに対しては、 <tt class="docutils literal"><span class="pre">tp_iter</span></tt> ハンドラがイテレータオブジェクトを返す必要があります。イテレータオブジェクトは巡回中の状態を保持する責任をもっています。お互いに干渉しない複数のイテレータの存在を許すようなオブジェクト (リストやタプルがそうです) の場合は、新しいイテレータを作成して返す必要があります。 (巡回の結果生じる副作用のために) 一回だけしか巡回できないオブジェクトの場合は、それ自身への参照を返すようなハンドラと、 <tt class="docutils literal"><span class="pre">tp_iternext</span></tt> ハンドラも実装する必要があります。ファイルオブジェクトはそのようなイテレータの例です。</p>
<p>イテレータオブジェクトは両方のハンドラを実装する必要があります。 <tt class="docutils literal"><span class="pre">tp_iter</span></tt> ハンドラはそのイテレータへの新しい参照を返します
(これは破壊的にしか巡回できないオブジェクトに対する <tt class="docutils literal"><span class="pre">tp_iter</span></tt> ハンドラと同じです)。 <tt class="docutils literal"><span class="pre">tp_iternext</span></tt>
ハンドラはその次のオブジェクトがある場合、それへの新しい参照を返します。巡回が終端に達したときは例外を出さずに <em>NULL</em> を返してもいいですし、
<a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> を放出してもかまいません。例外を使わないほうがやや速度が上がるかもしれません。実際のエラーが起こったときには、例外を放出して <em>NULL</em> を返す必要があります。</p>
</div>
<div class="section" id="weak-reference">
<span id="weakref-support"></span><h3>2.2.6. 弱参照(Weak Reference)のサポート<a class="headerlink" href="#weak-reference" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pythonの弱参照実装のひとつのゴールは、どのような（数値のような弱参照による利益を得ない）タイプでもオーバーヘッドなしで弱参照のメカニズムに組み込めるようにすることです。</p>
<p>弱参照可能なオブジェクトの拡張では、弱参照メカニズムのために <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a> フィールドをインスタンス構造体に含む必要があります。これはオブジェクトのコンストラクタで <em>NULL</em> に初期化する必要があります。これは対応するタイプの
<tt class="xref py py-attr docutils literal"><span class="pre">tp_weaklistoffset</span></tt> フィールドをフィールドのオフセットに設定しなければいけません。たとえば、インスタンスタイプは以下の構造体で定義されます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">in_class</span><span class="p">;</span>       <span class="cm">/* The class object */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_dict</span><span class="p">;</span>        <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyInstanceObject</span><span class="p">;</span>
</pre></div>
</div>
<p>インスタンス用に静的に宣言されたタイプオブジェクトはこのように定義されます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyTypeObject</span> <span class="n">PyInstance_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="s">&quot;module.instance&quot;</span><span class="p">,</span>

    <span class="cm">/* Lots of stuff omitted for brevity... */</span>

    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>                         <span class="cm">/* tp_flags */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_richcompare */</span>
    <span class="n">offsetof</span><span class="p">(</span><span class="n">PyInstanceObject</span><span class="p">,</span> <span class="n">in_weakreflist</span><span class="p">),</span> <span class="cm">/* tp_weaklistoffset */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>タイプのコンストラクタは弱参照を <em>NULL</em> に初期化する責任があります:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_new</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Other initialization stuff omitted for brevity */</span>

    <span class="n">self</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>さらに、デストラクタは弱参照を消すために弱参照のマネージャを呼ぶ必要があります。これはデストラクタのどの処理よりも先に実施される必要がありますが、弱参照リストが <em>NULL</em> でない場合にだけ必要です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">instance_dealloc</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Allocate temporaries if needed, but do not begin</span>
<span class="cm">       destruction just yet.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">PyObject_ClearWeakRefs</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">inst</span><span class="p">);</span>

    <span class="cm">/* Proceed with object destruction normally. */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>2.2.7. その他いろいろ<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上にあげたほとんどの関数は、その値として <tt class="docutils literal"><span class="pre">0</span></tt> を与えれば省略できることを忘れないでください。それぞれの関数で提供しなければならない型の定義があり、これらは Python の include 用ディレクトリの <tt class="file docutils literal"><span class="pre">object.h</span></tt> というファイルにおさめられています。これは
Python の配布ソースに含まれています。</p>
<p>新しいデータ型に何らかのメソッドを実装するやりかたを学ぶには、以下の方法がおすすめです: Python の配布されているソースをダウンロードして展開する。 <tt class="file docutils literal"><span class="pre">Objects</span></tt> ディレクトリへ行き、C のソースファイルから「 <tt class="docutils literal"><span class="pre">tp_</span></tt> 欲しい名前」の文字列で検索する (たとえば
<tt class="docutils literal"><span class="pre">tp_print</span></tt> とか <tt class="docutils literal"><span class="pre">tp_compare</span></tt> のように)。こうすれば実装したい例がみつかるでしょう。</p>
<p>あるオブジェクトが、いま実装している型のインスタンスであるかどうかを確かめたい場合には、 <a class="reference internal" href="../c-api/object.html#PyObject_TypeCheck" title="PyObject_TypeCheck"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_TypeCheck()</span></tt></a>
関数を使ってください。使用例は以下のようなかんじです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyObject_TypeCheck</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyType</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;arg #1 not a mything&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>これはそのオブジェクトが文字列や実数などの基本タイプであるような時に成り立ちます。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>We relied ここで出てきたタイプではガベージコレクションをサポートしていないので、この例では <tt class="xref py py-attr docutils literal"><span class="pre">tp_dealloc</span></tt>
ハンドラに依存しています。このハンドラはそのタイプがたとえガベージコレクションをサポートしている場合でも、そのオブジェクトの「追跡を解除する」ために呼ばれることがありますが、これは高度な話題でありここでは扱いません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[3]</a></td><td>first および last メンバが文字列であるということはわかっているので、いまやそれらの参照カウントを減らすときにはそれほど注意する必要はないように思えるかもしれません。しかし文字列型のサブクラスは依然として受けつけられています。通常の文字列型ならば、解放時にあなたのオブジェクトがコールバックされることはありませんが、文字列型のサブクラスがそうしないという保証はありません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td>3番目のバージョンでさえ、循環を回避できるという保証はされていません。たとえ通常の文字列型なら循環しない場合でも、文字列型のサブクラスをとることが許されていれば、そのタイプでは循環が発生しうるからです。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="3. distutils による C および C++ 拡張モジュールのビルド"
             >次へ</a> |</li>
        <li class="right" >
          <a href="extending.html" title="1. C や C++ による Python の拡張"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python インタプリタの拡張と埋め込み</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>