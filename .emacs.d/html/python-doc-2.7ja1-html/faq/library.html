

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ライブラリと拡張 FAQ &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python よくある質問" href="index.html" />
    <link rel="next" title="拡張と埋め込み FAQ" href="extending.html" />
    <link rel="prev" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="extending.html" title="拡張と埋め込み FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python よくある質問</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">ライブラリと拡張 FAQ</a><ul>
<li><a class="reference internal" href="#id1">ライブラリ一般の質問</a></li>
<li><a class="reference internal" href="#id3">よくある作業</a></li>
<li><a class="reference internal" href="#id6">スレッド</a></li>
<li><a class="reference internal" href="#id11">入力と出力</a></li>
<li><a class="reference internal" href="#id16">ネットワーク/インターネットプログラミング</a></li>
<li><a class="reference internal" href="#id18">データベース</a></li>
<li><a class="reference internal" href="#id21">数学と数</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="design.html"
                        title="前の章へ">デザインと歴史 FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="extending.html"
                        title="次の章へ">拡張と埋め込み FAQ</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/faq/library.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="faq">
<h1><a class="toc-backref" href="#id23">ライブラリと拡張 FAQ</a><a class="headerlink" href="#faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#faq" id="id23">ライブラリと拡張 FAQ</a><ul>
<li><a class="reference internal" href="#id1" id="id24">ライブラリ一般の質問</a><ul>
<li><a class="reference internal" href="#x" id="id25">作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？</a></li>
<li><a class="reference internal" href="#math-py-socket-py-regex-py-etc" id="id26">math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？</a></li>
<li><a class="reference internal" href="#python-unix" id="id27">Python のスクリプトを Unix で実行可能にするにはどうしますか？</a></li>
<li><a class="reference internal" href="#python-curses-termcap" id="id28">Python には curses/termcap パッケージはありますか？</a></li>
<li><a class="reference internal" href="#python-c-onexit" id="id29">Python には C の onexit() に相当するものはありますか？</a></li>
<li><a class="reference internal" href="#id2" id="id30">シグナルハンドラが動かないのですがなぜですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3" id="id31">よくある作業</a><ul>
<li><a class="reference internal" href="#python" id="id32">Python のプログラムやコンポーネントをテストするにはどうしますか？</a></li>
<li><a class="reference internal" href="#id4" id="id33">Python のドキュメント文字列からドキュメントを生成するにはどうしますか？</a></li>
<li><a class="reference internal" href="#id5" id="id34">一度に一つの押鍵を取得するにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6" id="id35">スレッド</a><ul>
<li><a class="reference internal" href="#id7" id="id36">スレッドを使ったプログラムを書くにはどうしますか？</a></li>
<li><a class="reference internal" href="#id8" id="id37">スレッドが一つも実行されていないようです。なぜですか？</a></li>
<li><a class="reference internal" href="#id9" id="id38">たくさんのワーカースレッドに作業を割り振るにはどうしますか？</a></li>
<li><a class="reference internal" href="#id10" id="id39">グローバルな値のスレッドセーフな変更の種類は何ですか？</a></li>
<li><a class="reference internal" href="#global-interpreter-lock" id="id40">グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11" id="id41">入力と出力</a><ul>
<li><a class="reference internal" href="#id12" id="id42">ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問...)</a></li>
<li><a class="reference internal" href="#id13" id="id43">ファイルをコピーするにはどうしますか？</a></li>
<li><a class="reference internal" href="#id14" id="id44">バイナリデータを読み書きするにはどうしますか？</a></li>
<li><a class="reference internal" href="#os-popen-os-read" id="id45">os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？</a></li>
<li><a class="reference internal" href="#id15" id="id46">パイプを入力と出力の両方に接続してサブプロセスを動かすにはどうしますか？</a></li>
<li><a class="reference internal" href="#rs232" id="id47">シリアル (RS232) ポートにアクセスするにはどうしますか？</a></li>
<li><a class="reference internal" href="#sys-stdout-stdin-stderr" id="id48">sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id16" id="id49">ネットワーク/インターネットプログラミング</a><ul>
<li><a class="reference internal" href="#python-www" id="id50">Python の WWW ツールには何がありますか？</a></li>
<li><a class="reference internal" href="#cgi-method-post" id="id51">CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？</a></li>
<li><a class="reference internal" href="#html" id="id52">どのモジュールが HTML の生成の役に立ちますか？</a></li>
<li><a class="reference internal" href="#id17" id="id53">Python のスクリプトからメールを送るにはどうしますか？</a></li>
<li><a class="reference internal" href="#connect" id="id54">ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18" id="id55">データベース</a><ul>
<li><a class="reference internal" href="#id19" id="id56">Python にはデータベースパッケージへのインタフェースはありますか？</a></li>
<li><a class="reference internal" href="#id20" id="id57">Python で永続的なオブジェクトを実装するにはどうしますか？</a></li>
<li><a class="reference internal" href="#cpickle" id="id58">なぜ cPickle はこんなに遅いのですか？</a></li>
<li><a class="reference internal" href="#bsddb-or-anydbm" id="id59">bsddb (or anydbm) データベースが開かれたままプログラムがクラッシュすると、だめになってしまいます。なぜですか？</a></li>
<li><a class="reference internal" href="#berkeley-db-bsddb-bsddb-error-22-invalid-argument" id="id60">Berkeley DB ファイルを開こうとしましたが、bsddb が bsddb.error: (22, &#8216;Invalid argument&#8217;) を生じます。助けてください！ データを復元するにはどうしたら良いですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21" id="id61">数学と数</a><ul>
<li><a class="reference internal" href="#id22" id="id62">Python でランダムな数を生成するにはどうしますか？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id24">ライブラリ一般の質問</a><a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="x">
<h3><a class="toc-backref" href="#id25">作業 X を行うためのモジュールやアプリケーションを探すにはどうしますか？</a><a class="headerlink" href="#x" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/index.html#library-index"><em>the Library Reference</em></a> で関連した標準ライブラリモジュールがないか探してください。(いずれ、何が標準ライブラリにあるのかをおぼえて、この段階を飛ばせるようになるでしょう。)</p>
<p>サードパーティのパッケージについては、<a class="reference external" href="http://pypi.python.org/pypi">Python Package Index</a> を探したり、<a class="reference external" href="http://www.google.com">Google</a>
その他の Web サーチエンジンを試してください。&#8221;Python&#8221; に加えて一つか二つのキーワードで興味のある話題を検索すれば、たいてい役に立つものが見つかるでしょう。</p>
</div>
<div class="section" id="math-py-socket-py-regex-py-etc">
<h3><a class="toc-backref" href="#id26">math.py (socket.py, regex.py, etc.) のソースファイルはどこにありますか？</a><a class="headerlink" href="#math-py-socket-py-regex-py-etc" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールのソースファイルが見つからなかったら、それは C、C++、その他のコンパイルされた言語で実装され、ビルトインまたは動的にロードされるモジュールかもしれません。この場合、ソースファイルが存在しないか、
(Python のパスではなく) C のソースディレクトリのどこかに
mathmodule.c のようにあるかもしれません。</p>
<p>Python のモジュールには、(少なくとも) 3 種類あります:</p>
<ol class="arabic">
<li><p class="first">Python で書かれたモジュール (.py)。</p>
</li>
<li><p class="first">C で書かれ、動的にロードされるモジュール (.dll, .pyd, .so, .sl, etc)。</p>
</li>
<li><p class="first">C で書かれ、インタプリタにリンクされているモジュール。このリストを得るには、こうタイプしてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="python-unix">
<h3><a class="toc-backref" href="#id27">Python のスクリプトを Unix で実行可能にするにはどうしますか？</a><a class="headerlink" href="#python-unix" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つの条件があります :スクリプトファイルのモードが実行可能で、最初の行が
<tt class="docutils literal"><span class="pre">#!</span></tt> で始まり Python インタプリタのパスが続いていなければなりません。</p>
<p>前者は、<tt class="docutils literal"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">scriptfile</span></tt>、場合によっては <tt class="docutils literal"><span class="pre">chmod</span> <span class="pre">755</span> <span class="pre">scriptfile</span></tt>
を実行すればできます。</p>
<p>後者は、いくつかの方法でできます。最も単純な方法は、ファイルの最初の行に、プラットフォーム上の Python がインストールされているパス名を用いて、こう書くことです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/local/bin/python</span>
</pre></div>
</div>
<p>スクリプトが Python インタプリタのありかに依らないようにするために、
&#8220;env&#8221; プログラムを使えます。ほぼすべての Unix バリアントで、Python
インタプリタがユーザの $PATH ディレクトリにあれば、以下のようにできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
</pre></div>
</div>
<p>CGI スクリプトではこれを <em>しないでください</em>。 CGI スクリプトの $PATH 変数は往々にして小さすぎるので、インタプリタの実際のパス名を使わなくてはならないのです。</p>
<p>たまに、ユーザの環境がいっぱいすぎて /usr/bin/env プログラムが働かなかったり、
env プログラムが全く無かったりします。その場合、
(Alex Rezinsky による)以下の技法を試してください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#! /bin/sh</span>
<span class="sd">&quot;&quot;&quot;:&quot;</span>
<span class="sd">exec python $0 ${1+&quot;$@&quot;}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>これには、スクリプトの __doc__ 文字列を定義するというちょっとした欠点があります。しかし、これを付け足せば直せます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__doc__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;...Whatever...&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="python-curses-termcap">
<h3><a class="toc-backref" href="#id28">Python には curses/termcap パッケージはありますか？</a><a class="headerlink" href="#python-curses-termcap" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unix バリアントでは: 標準の Python ソース配布には、
<tt class="docutils literal"><span class="pre">Modules/</span></tt> サブディレクトリに curses モジュールが同梱されていますが、デフォルトではコンパイルされていません
(なお、Windows ディストリビューションでは使えません &#8211;
Windows 用の curses モジュールはありません)</p>
<p>curses モジュールには基礎的な curses の機能だけでなく、色や別の文字セットのサポート、パッド、マウスのサポートなど、ncurses や SYSV curses 由来の追加の関数も用意されています。これにより、このモジュールは BSD curses しか持っていないオペレーティングシステムとの互換性を持たないことになりますが、そのような現行の OS はなさそうです。</p>
<p>Windows では: <a class="reference external" href="http://effbot.org/zone/console-index.htm">the consolelib module</a> を使ってください。</p>
</div>
<div class="section" id="python-c-onexit">
<h3><a class="toc-backref" href="#id29">Python には C の onexit() に相当するものはありますか？</a><a class="headerlink" href="#python-c-onexit" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: 後始末関数の登録と実行。"><tt class="xref py py-mod docutils literal"><span class="pre">atexit</span></tt></a> モジュールは C の onexit と同じようなレジスタ関数を提供します。</p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id30">シグナルハンドラが動かないのですがなぜですか？</a><a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最もありがちな問題は、シグナルハンドラが間違った引数リストで宣言されていることです。これは次のように呼び出されます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
<p>だから、これは二つの引数で宣言されるべきです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id31">よくある作業</a><a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="python">
<h3><a class="toc-backref" href="#id32">Python のプログラムやコンポーネントをテストするにはどうしますか？</a><a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python には二つのテストフレームワークがついています。<a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a>
モジュールは 、モジュールの docstring から使用例を見つけてそれらを実行し、出力を docstring によって与えられた望まれる出力と比較します。</p>
<p><a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュールは、Java や Smalltalk のテストフレームワークを模した装飾されたテストフレームワークです。</p>
<p>テストには、プログラムを書くのに、簡単にテストできるように良いモジュール式デザインを使うのが役に立ちます。プログラムは、ほとんど全ての機能を関数かクラスメソッドにカプセル化させるべきです &#8211; そうすることでプログラムの起動が速くなる (ローカル変数のアクセスはグローバルなアクセスよりも速いから) という驚くべき嬉しい効果をもたらすこともあります。さらに、変化するグローバル変数はテストを行うのを非常に難しくするので、プログラムはそれに依らないようにしましょう。</p>
<p>プログラムの &#8220;global main logic&#8221; は、プログラムの main モジュールの最後に、次のようにシンプルに書くべきです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main_logic</span><span class="p">()</span>
</pre></div>
</div>
<p>一旦、関数とクラス動作を扱いやすいように集めてプログラムを構成したら、その動作を洗練させるようなテストを書きましょう。テストスイートには、それぞれの一連のテストを自動化したモジュールも関係します。それは大変そうですが、Python は簡潔で柔軟なので、驚くほど簡単です。テスト関数を&#8221;プロダクションコード&#8221;と並行して書くことにより、バグや設計上の欠陥を早く見つけることができるようになり、コードをもっとずっと快適に楽しく書けます。</p>
<p>プログラムのメインモジュールとして設計されたのではない &#8220;補助モジュール&#8221; には、モジュールの自己テストを含めるといいでしょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">self_test</span><span class="p">()</span>
</pre></div>
</div>
<p>複雑な外部インタフェースと作用し合うプログラムでさえ、外部インタフェースが使えない時でも、Python で実装された
&#8220;fake&#8221; インタフェースを使ってテストできます。</p>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id33">Python のドキュメント文字列からドキュメントを生成するにはどうしますか？</a><a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: ドキュメント生成とオンラインヘルプシステム"><tt class="xref py py-mod docutils literal"><span class="pre">pydoc</span></tt></a> モジュールで Python ソースコード内のドキュメント文字列から
HTML を生成できます。純粋に docstring から API ドキュメントを生成するには、他に <a class="reference external" href="http://epydoc.sf.net/">epydoc</a> という選択肢もあります。
<a class="reference external" href="http://sphinx.pocoo.org">Sphinx</a> も docstring の内容を含めることができます。</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id34">一度に一つの押鍵を取得するにはどうしますか？</a><a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unix バリアントでは: いくつかの方法があります。curses を使えば簡単ですが、
curses はかなり大きいモジュールなので習得するのが難しいです。ここに curses を使わない解決策を挙げます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">termios</span><span class="o">,</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

<span class="n">oldterm</span> <span class="o">=</span> <span class="n">termios</span><span class="o">.</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">newattr</span> <span class="o">=</span> <span class="n">termios</span><span class="o">.</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">newattr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">newattr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">termios</span><span class="o">.</span><span class="n">ICANON</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">termios</span><span class="o">.</span><span class="n">ECHO</span>
<span class="n">termios</span><span class="o">.</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCSANOW</span><span class="p">,</span> <span class="n">newattr</span><span class="p">)</span>

<span class="n">oldflags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_GETFL</span><span class="p">)</span>
<span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span> <span class="n">oldflags</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Got character&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">termios</span><span class="o">.</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCSAFLUSH</span><span class="p">,</span> <span class="n">oldterm</span><span class="p">)</span>
    <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span> <span class="n">oldflags</span><span class="p">)</span>
</pre></div>
</div>
<p>これを動かすためには、<a class="reference internal" href="../library/termios.html#module-termios" title="termios: POSIX スタイルの端末制御。 (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">termios</span></tt></a> と <a class="reference internal" href="../library/fcntl.html#module-fcntl" title="fcntl: fcntl() および ioctl() システムコール。 (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">fcntl</span></tt></a> モジュールが必要です。また、多分他でも動きますが、Linux でしかこれを試していません。このコードでは、文字は一文字づつ読みこまれ、印字されます。</p>
<p><a class="reference internal" href="../library/termios.html#termios.tcsetattr" title="termios.tcsetattr"><tt class="xref py py-func docutils literal"><span class="pre">termios.tcsetattr()</span></tt></a> は stdin の反響を止め、標準モードを使えなくします。
<tt class="xref py py-func docutils literal"><span class="pre">fcntl.fnctl()</span></tt> は、stdin のファイルディスクリプタフラグを取得し、それらをノンブロッキングモードに変えるのに使われます。stdin が空の時に読み込むのは <a class="reference internal" href="../library/exceptions.html#exceptions.IOError" title="exceptions.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> になるので、このエラーは補足され、無視されます。</p>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id35">スレッド</a><a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id36">スレッドを使ったプログラムを書くにはどうしますか？</a><a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/thread.html#module-thread" title="thread: 1つのインタープリタの中でのマルチスレッド制御"><tt class="xref py py-mod docutils literal"><span class="pre">thread</span></tt></a> モジュールではなく、必ず <a class="reference internal" href="../library/threading.html#module-threading" title="threading: 高水準のスレッドインタフェース"><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> モジュールを使ってください。<a class="reference internal" href="../library/threading.html#module-threading" title="threading: 高水準のスレッドインタフェース"><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a>
モジュールは、<a class="reference internal" href="../library/thread.html#module-thread" title="thread: 1つのインタープリタの中でのマルチスレッド制御"><tt class="xref py py-mod docutils literal"><span class="pre">thread</span></tt></a> モジュールで提供される低レベルな基本要素の、便利な抽象化を構成します。</p>
<p>Aahz は、役立つスレッディングのチュートリアルから成るスライドを揃えています。
<a class="reference external" href="http://www.pythoncraft.com/OSCON2001/">http://www.pythoncraft.com/OSCON2001/</a> を参照してください。</p>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id37">スレッドが一つも実行されていないようです。なぜですか？</a><a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メインスレッドが終了するとともに、全てのスレッドは終了されます。メインスレッドは速く働きすぎるので、スレッドには何をする時間も与えられません。</p>
<p>簡単な解決策は、プログラムの終わりに、スレッドが完了するのに十分な時間のスリープを加えることです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">print</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c"># &lt;----------------------------!</span>
</pre></div>
</div>
<p>しかし、実際は (ほとんどのプラットフォームでは) スレッドは並行して実行されるのではなく、一つづつ実行されるのです！ なぜなら、OS のスレッドスケジューラは、前のスレッドがブロックされるまで新しいスレッドを開始しないからです。</p>
<p>簡単に治すには、関数の実行の最初にちょっとスリープを加えることです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">thread_task</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span> <span class="c"># &lt;---------------------!</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">print</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">T</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/time.html#time.sleep" title="time.sleep"><tt class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></tt></a> による遅延をどれくらいとれば十分かを考えるより、セマフォ構造を使ったほうがいいです。一つのやり方は、
<a class="reference internal" href="../library/queue.html#module-Queue" title="Queue: 同期キュークラス"><tt class="xref py py-mod docutils literal"><span class="pre">Queue</span></tt></a> モジュールでキューオブジェクトを作り、それぞれのスレッドが終了するごとにキューにトークンを加えさせ、メインスレッドにスレッドがあるのと同じ数のトークンをキューから読み込ませるようにすることです。</p>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id38">たくさんのワーカースレッドに作業を割り振るにはどうしますか？</a><a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/queue.html#module-Queue" title="Queue: 同期キュークラス"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a> モジュールで、作業のリストを含むキューを作ってください。<a class="reference internal" href="../library/queue.html#Queue.Queue" title="Queue.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a> クラスはオブジェクトのリストを保持し、 <tt class="docutils literal"><span class="pre">.put(obj)</span></tt> で要素を加え、<tt class="docutils literal"><span class="pre">.get()</span></tt> で要素を返すことができます。ロッキングを引き受けるクラスは、全ての作業がちょうど一回づつ行われることを確実にしなければなりません。</p>
<p>ここにちょっとした例があります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">Queue</span><span class="o">,</span> <span class="nn">time</span>

<span class="c"># The worker thread gets jobs off the queue.  When the queue is empty, it</span>
<span class="c"># assumes there will be no more work and exits.</span>
<span class="c"># (Realistically workers will run until terminated.)</span>
<span class="k">def</span> <span class="nf">worker</span> <span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;Running worker&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span>
            <span class="k">print</span> <span class="s">&#39;queue empty&#39;</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Worker&#39;</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">currentThread</span><span class="p">(),</span>
            <span class="k">print</span> <span class="s">&#39;running with argument&#39;</span><span class="p">,</span> <span class="n">arg</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c"># Create queue</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="c"># Start a pool of 5 workers</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;worker </span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c"># Begin adding work to the queue</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c"># Give threads time to run</span>
<span class="k">print</span> <span class="s">&#39;Main thread sleeping&#39;</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>実行時には、以下のように出力されます:</p>
<blockquote>
<div>Running worker
Running worker
Running worker
Running worker
Running worker
Main thread sleeping
Worker &lt;Thread(worker 1, started 130283832797456)&gt; running with argument 0
Worker &lt;Thread(worker 2, started 130283824404752)&gt; running with argument 1
Worker &lt;Thread(worker 3, started 130283816012048)&gt; running with argument 2
Worker &lt;Thread(worker 4, started 130283807619344)&gt; running with argument 3
Worker &lt;Thread(worker 5, started 130283799226640)&gt; running with argument 4
Worker &lt;Thread(worker 1, started 130283832797456)&gt; running with argument 5
...</div></blockquote>
<p>詳細はモジュールのドキュメントを参照してください。
<tt class="docutils literal"><span class="pre">Queue</span></tt> クラスで多機能なインタフェースを使えます。</p>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id39">グローバルな値のスレッドセーフな変更の種類は何ですか？</a><a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>グローバルインタプリタロック (GIL) が内部で使われ、Python VM で一度に一つだけのスレッドが実行されることが保証されています。一般に、Python ではスレッド間の切り替えをバイトコード命令の間でのみ行います。切り替えの周期は、
<a class="reference internal" href="../library/sys.html#sys.setcheckinterval" title="sys.setcheckinterval"><tt class="xref py py-func docutils literal"><span class="pre">sys.setcheckinterval()</span></tt></a> で設定できます。したがって、それぞれのバイトコード命令、そしてそれぞれの命令が届く全ての C 実装コードは、
Python プログラムの観点からは、アトミックです。</p>
<p>このことから、理論上は、正確な勘定のためには PVM バイトコードの実装を理解することが必要です。実際上は、組み込みデータ型(整数、リスト、辞書、等)の、変数を共有する&#8221;アトミックそうな&#8221;演算は、実際にアトミックです。</p>
<p>例えば、以下の演算は全てアトミックです (L、L1、L2 はリスト、
D、D1、D2 は辞書、x、y はオブジェクト、i、j は整数です):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">L1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L2</span>
<span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">x</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">D1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">D2</span><span class="p">)</span>
<span class="n">D</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>これらは、アトミックではありません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>他のオブジェクトを置き換えるような演算は、そのオブジェクトの参照カウントがゼロになったときに <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> メソッドを呼び出すことがあり、これが影響を及ぼすかもしれません。これは特に、辞書やリストの大規模な更新に当てはまります。疑わしければ、mutex を使ってください！</p>
</div>
<div class="section" id="global-interpreter-lock">
<h3><a class="toc-backref" href="#id40">グローバルインタプリタロック (Global Interpreter Lock) を取り除くことはできないのですか？</a><a class="headerlink" href="#global-interpreter-lock" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マルチスレッド Python プログラムは事実上一つの CPU しか使えず、
(ほとんど) 全ての Python コードが グローバルインタプリタロック (GIL) が保持されている間しか作動しなくなるということで、GIL は、
Python をハイエンドなマルチプロセッササーバマシン上に配備する上で邪魔であると見なされがちです。</p>
<p>Python 1.5 の時代に、Greg Stein は GIL をきめ細かいロッキングで置き換える総合パッチ (&#8220;free threading&#8221; パッチ) セットを実装しました。残念ながら、(ロックがとても効率的な) Windows でさえ、標準的な
Python コードが、GIL を使ったインタプリタの 2 倍くらい遅くなりました。
Linux では、pthread ロックが効率的でないので、パフォーマンスの損失が更に酷いです。</p>
<p>その後、GIL を取り除くという案はたまに出てきますが、だれも予期される減速に対処する方法を見つけられず、スレッドを使わないユーザはこーどが半分の速度でしか動作しないのでは幸せではありません。Greg の
free threading パッチは、以降の Python バージョンには更新されていません。</p>
<p>これは、Python をマルチ CPU マシンで使いこなせないことを意味しません！作業を複数の <em>スレッド</em> ではなく、複数の <em>プロセッサ</em> に分けることを考えればいいのです。
C 拡張をうまく使うことも役に立ちます。C 拡張を使ってに時間のかかる作業を行わせれば、その実行のスレッドが C のコードにある間その拡張は
GIL を開放でき、他のスレッドに作業させることができます。</p>
<p>GIL を本当にグローバルにするより、インタプリタ状態ごとのロックにするべきという提案もあります。そして、インタプリタはオブジェクトを共有するべきではないということです。残念ながら、どちらも実現しないでしょう。多くのオブジェクトの実装は現在、グローバル状態を持っているので、実現はたいへんな大仕事になりそうです。例えば、小さな整数と短い文字列はキャッシュされます。このキャッシュはインタプリタ状態に動かされなくてはなりません。他のオブジェクト型は自身の自由変数リストを持っています。これらの自由変数リストはインタプリタ状態に動かされなくてはなりません。等々。</p>
<p>それどころか、その作業が終わる時が来るかもわかりません。なぜなら、サードパーティ拡張にも問題があるからです。サードパーティ拡張が書かれるペースは、インタプリタ状態にすべてのグローバル状態を格納するように変換できるペースよりも速いことでしょう。</p>
<p>そして最後に、一旦複数のインタプリタを状態を全く共有しないようにしたとして、それぞれのインタプリタを独立したプロセス上で動かしてなにが得られるというのでしょうか？</p>
</div>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id41">入力と出力</a><a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id42">ファイルを削除するにはどうしますか？ (その他、ファイルに関する質問...)</a><a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">os.remove(filename)</span></tt> または <tt class="docutils literal"><span class="pre">os.unlink(filename)</span></tt> を使ってください。ドキュメントは、<a class="reference internal" href="../library/os.html#module-os" title="os: 雑多なオペレーティングシステムインタフェース。"><tt class="xref py py-mod docutils literal"><span class="pre">os</span></tt></a> モジュールを参照してください。この二つの関数は同じものです。<tt class="xref py py-func docutils literal"><span class="pre">unlink()</span></tt> は単に、この関数の Unix システムコールの名称です。</p>
<p>ディレクトリを削除するには、<a class="reference internal" href="../library/os.html#os.rmdir" title="os.rmdir"><tt class="xref py py-func docutils literal"><span class="pre">os.rmdir()</span></tt></a> を使ってください。作成には
<a class="reference internal" href="../library/os.html#os.mkdir" title="os.mkdir"><tt class="xref py py-func docutils literal"><span class="pre">os.mkdir()</span></tt></a> を使ってください。<tt class="docutils literal"><span class="pre">os.makedirs(path)</span></tt> は <tt class="docutils literal"><span class="pre">path</span></tt> の中間のディレクトリの、存在しないものを作成します。<tt class="docutils literal"><span class="pre">os.removedirs(path)</span></tt> は中間のディレクトリが空である限り、それらを削除します。ディレクトリツリー全体とその中身全てを削除したいなら、<a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><tt class="xref py py-func docutils literal"><span class="pre">shutil.rmtree()</span></tt></a> を使ってください。</p>
<p>ファイルの名前を変更するには、<tt class="docutils literal"><span class="pre">os.rename(old_path,</span> <span class="pre">new_path)</span></tt> を使ってください。</p>
<p>ファイルを切り詰めるには、<tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">open(filename,</span> <span class="pre">&quot;r+&quot;)</span></tt> でファイルを開いてから、
<tt class="docutils literal"><span class="pre">f.truncate(offset)</span></tt> を使ってください。offset はデフォルトでは現在のシーク位置です。<a class="reference internal" href="../library/os.html#os.open" title="os.open"><tt class="xref py py-func docutils literal"><span class="pre">os.open()</span></tt></a> で開かれたファイルのために、
<tt class="docutils literal"><span class="pre">os.ftruncate(fd,</span> <span class="pre">offset)</span></tt> もあります。<tt class="docutils literal"><span class="pre">fd</span></tt> はファイルディスクリプタ
(小さな整数) です。</p>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: コピーを含む高レベルなファイル操作。"><tt class="xref py py-mod docutils literal"><span class="pre">shutil</span></tt></a> モジュールにも、<a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><tt class="xref py py-func docutils literal"><span class="pre">copyfile()</span></tt></a>、
<a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><tt class="xref py py-func docutils literal"><span class="pre">copytree()</span></tt></a>、<a class="reference internal" href="../library/shutil.html#shutil.rmtree" title="shutil.rmtree"><tt class="xref py py-func docutils literal"><span class="pre">rmtree()</span></tt></a> 等、ファイルに作用する関数がいくつか含まれます。</p>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id43">ファイルをコピーするにはどうしますか？</a><a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: コピーを含む高レベルなファイル操作。"><tt class="xref py py-mod docutils literal"><span class="pre">shutil</span></tt></a> モジュールには <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><tt class="xref py py-func docutils literal"><span class="pre">copyfile()</span></tt></a> 関数があります。なお、MacOS 9 ではリソースフォークやファインダー情報をコピーしません。</p>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id44">バイナリデータを読み書きするにはどうしますか？</a><a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複雑なバイナリデータ形式の読み書きには、<a class="reference internal" href="../library/struct.html#module-struct" title="struct: 文字列データをパックされたバイナリデータとして解釈する."><tt class="xref py py-mod docutils literal"><span class="pre">struct</span></tt></a> モジュールを使うのが一番です。これでバイナリデータ (通常は数) を含む文字列を取って、
Python オブジェクトに変換することができますし、その逆もできます。</p>
<p>例えば、以下のコードはファイルから 2 バイトの整数 2 個と 4 バイトの整数 1 個をビッグエンディアンフォーマットで読み込みます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">struct</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
   <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
   <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&quot;&gt;hhl&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>フォーマット中の &#8216;&gt;&#8217; はデータを強制的にビッグエンディアンにします。ファイルから、文字 &#8216;h&#8217; は一つの&#8221;整数&#8221;(2 バイト)を読み込み、文字 &#8216;l&#8217; は一つの&#8221;long 整数&#8221;を読み込みます。</p>
<p>より規則的なデータ (整数の、または浮動小数点数の均質なリスト等) には、
<a class="reference internal" href="../library/array.html#module-array" title="array: 一様な型を持つ数値からなる空間効率のよいアレイ。"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a> モジュールも使えます。</p>
</div>
<div class="section" id="os-popen-os-read">
<h3><a class="toc-backref" href="#id45">os.popen() によって作られたパイプで os.read() が使われていないようです。なぜですか？</a><a class="headerlink" href="#os-popen-os-read" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/os.html#os.read" title="os.read"><tt class="xref py py-func docutils literal"><span class="pre">os.read()</span></tt></a> は、開かれたファイルを表す小さな数であるファイルディスクリプタを取る低レベルな関数です。<a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><tt class="xref py py-func docutils literal"><span class="pre">os.popen()</span></tt></a> は、組み込みの <a class="reference internal" href="../library/functions.html#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> 関数が返すのと同じ型である高レベルなファイルオブジェクトを生成します。そうして、<a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><tt class="xref py py-func docutils literal"><span class="pre">os.popen()</span></tt></a> から n バイトを読み込むには、<tt class="docutils literal"><span class="pre">p.read(n)</span></tt> とする必要があります。</p>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id46">パイプを入力と出力の両方に接続してサブプロセスを動かすにはどうしますか？</a><a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/popen2.html#module-popen2" title="popen2: アクセス可能な I/O ストリームを持つ子プロセス生成。 (撤廃)"><tt class="xref py py-mod docutils literal"><span class="pre">popen2</span></tt></a> モジュールを使ってください。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">popen2</span>
<span class="n">fromchild</span><span class="p">,</span> <span class="n">tochild</span> <span class="o">=</span> <span class="n">popen2</span><span class="o">.</span><span class="n">popen2</span><span class="p">(</span><span class="s">&quot;command&quot;</span><span class="p">)</span>
<span class="n">tochild</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;input</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">tochild</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">fromchild</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</pre></div>
</div>
<p>警告: 一般的に、これをするのは賢くありません。子があなたからの入力を待ってブロックされている間、プロセスが子からの入力を待ってブロックされているというようなデッドロックを引き起こしやすいからです。これは、親が子がそれよりも多くのテキストを出力することを期待することにより、あるいはデータが書きださされないことで標準入出力バッファがスタックにあることにより起こります。Python の親はもちろん子に送るデータを出力を読み込む前に明示的に書きだすことができますが、子が素朴な C プログラムであると、それが対話的なものであってさえ、書き出しが通常自動的なものであるがゆえ、明示的に出力を書き出さないように書かれていることがあります。</p>
<p>なお、デッドロックは <tt class="xref py py-func docutils literal"><span class="pre">popen3()</span></tt> を使って標準出力や標準エラー出力を読み込むときにも起こりえます。これらのどちらかが内部バッファにとって大きすぎる (バッファサイズを増やしても役に立ちません) とき、もう片方を先に
<tt class="docutils literal"><span class="pre">read()</span></tt> すると、同じくデッドロックが起こります。</p>
<p>popen2 におけるバグの注釈: プログラムが <tt class="docutils literal"><span class="pre">wait()</span></tt> や <tt class="docutils literal"><span class="pre">waitpid()</span></tt> を呼び出さないかぎり、終了されていない子プロセスは取り除かれることがなく、いずれ popen2 を呼び出すときに、子プロセス数の制限のために失敗することがあります。<a class="reference internal" href="../library/os.html#os.waitpid" title="os.waitpid"><tt class="xref py py-func docutils literal"><span class="pre">os.waitpid()</span></tt></a> を <a class="reference internal" href="../library/os.html#os.WNOHANG" title="os.WNOHANG"><tt class="xref py py-data docutils literal"><span class="pre">os.WNOHANG</span></tt></a> オプションをつけて呼び出すことで、これを防げます。このような呼び出しをする場所は、
<tt class="docutils literal"><span class="pre">popen2</span></tt> を再び呼びだす前がいいです。</p>
<p>多くの場合、本当にやるべきことは、コマンドを通して少しのデータを実行し、結果を戻させることだけです。データの量がとても多いのでない限り、最も簡単な方法は、それを一時ファイルに書きこみ、一時ファイルと入力としてコマンドを実行することです。標準モジュール <a class="reference internal" href="../library/tempfile.html#module-tempfile" title="tempfile: 一時的なファイルやディレクトリを生成。"><tt class="xref py py-mod docutils literal"><span class="pre">tempfile</span></tt></a> は、一意の一時ファイル名を生成する <tt class="docutils literal"><span class="pre">mktemp()</span></tt> 関数をエクスポートします:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">Popen3</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a deadlock-safe version of popen that returns</span>
<span class="sd">    an object with errorlevel, out (a string) and err (a string).</span>
<span class="sd">    (capturestderr may not work under windows.)</span>
<span class="sd">    Example: print Popen3(&#39;grep spam&#39;,&#39;\n\nhere spam\n\n&#39;).out</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">command</span><span class="p">,</span><span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">capturestderr</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">outfile</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
        <span class="n">command</span><span class="o">=</span><span class="s">&quot;( </span><span class="si">%s</span><span class="s"> ) &gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="n">outfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">input</span><span class="p">:</span>
            <span class="n">infile</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
            <span class="nb">open</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="n">command</span><span class="o">=</span><span class="n">command</span><span class="o">+</span><span class="s">&quot; &lt;&quot;</span><span class="o">+</span><span class="n">infile</span>
        <span class="k">if</span> <span class="n">capturestderr</span><span class="p">:</span>
            <span class="n">errfile</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
            <span class="n">command</span><span class="o">=</span><span class="n">command</span><span class="o">+</span><span class="s">&quot; 2&gt;&quot;</span><span class="o">+</span><span class="n">errfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorlevel</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span><span class="s">&quot;r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">input</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">capturestderr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">errfile</span><span class="p">,</span><span class="s">&quot;r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">errfile</span><span class="p">)</span>
</pre></div>
</div>
<p>なお、多くの対話的プログラム (vi など) は、パイプで標準入出力を置き換えることがうまくいきません。このようなときは、パイプの代わりに擬似 tty (&#8220;pty&#8221;) を使わなければなりません。または、Don Libes の &#8220;expect&#8221; ライブラリへの Python
インタフェースを使うこともできます。expect へのインタフェースをする
Python 拡張は &#8220;expy&#8221; と呼ばれ、 <a class="reference external" href="http://expectpy.sourceforge.net">http://expectpy.sourceforge.net</a> から利用できます。expect のように働く pure Python な解決法は、
<a class="reference external" href="http://pypi.python.org/pypi/pexpect/">pexpect</a> です。</p>
</div>
<div class="section" id="rs232">
<h3><a class="toc-backref" href="#id47">シリアル (RS232) ポートにアクセスするにはどうしますか？</a><a class="headerlink" href="#rs232" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Win32、POSIX (Linux、BSD、など)、Jythonでは:</p>
<blockquote>
<div><a class="reference external" href="http://pyserial.sourceforge.net">http://pyserial.sourceforge.net</a></div></blockquote>
<p>Unix では、Mitch Chapman による Usenet の投稿を参照してください。</p>
<blockquote>
<div><a class="reference external" href="http://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com">http://groups.google.com/groups?selm=34A04430.CF9&#64;ohioee.com</a></div></blockquote>
</div>
<div class="section" id="sys-stdout-stdin-stderr">
<h3><a class="toc-backref" href="#id48">sys.stdout (stdin, stderr) を閉じようとしても実際に閉じられないのはなぜですか？</a><a class="headerlink" href="#sys-stdout-stdin-stderr" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のファイルオブジェクトは、
(ここで説明する中では) 低レベルな C ファイルディスクリプタの上にある、中レベルな抽象のレイヤである C ストリームのそのまた上にある、高レベルな抽象のレイヤです。</p>
<p>組み込みの <tt class="docutils literal"><span class="pre">open</span></tt> 関数によって生成されたほとんどのファイルオブジェクトでは、<tt class="docutils literal"><span class="pre">f.close()</span></tt> は Python ファイルオブジェクトが
Python の視点からは閉じられているものとする印をつけ、その下にある
C ファイルディスクリプタを閉じるように手配します。これは、<tt class="docutils literal"><span class="pre">f</span></tt> がガベージとなったときにも、<tt class="docutils literal"><span class="pre">f</span></tt> のデストラクタで自動的に起こります。</p>
<p>しかし、stdin、stdout、stderr は C で特別な立場が与えられていることから、
Python でも同様に特別に扱われます。<tt class="docutils literal"><span class="pre">sys.stdout.close()</span></tt> を実行すると、
Python レベルのファイルオブジェクトには閉じられているものとする印がつけられますが、C ファイルディスクリプタは <em>閉じられません</em>。</p>
<p>下にある C ファイルディスクリプタのうち、この三つのどれかを閉じるには、まず本当に閉じる必要があることを確かめるべきです (例えば、拡張モジュールの
I/O を混乱させてしまうかもしれません)。本当に必要ならば、
<tt class="docutils literal"><span class="pre">os.close</span></tt> を使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c"># close C&#39;s stdin stream</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># close C&#39;s stdout stream</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="c"># close C&#39;s stderr stream</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id49">ネットワーク/インターネットプログラミング</a><a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="python-www">
<h3><a class="toc-backref" href="#id50">Python の WWW ツールには何がありますか？</a><a class="headerlink" href="#python-www" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ライブラリリファレンスマニュアルの <a class="reference internal" href="../library/internet.html#internet"><em>インターネットプロトコルとその支援</em></a> と <a class="reference internal" href="../library/netdata.html#netdata"><em>インターネット上のデータの操作</em></a> という章を参照してください。</p>
<p><a class="reference external" href="http://wiki.python.org/moin/WebProgramming">http://wiki.python.org/moin/WebProgramming</a> で利用可能なフレームワークの概要が Paul Boddie によって整備されています。</p>
<p>Cameron Laird は、<a class="reference external" href="http://phaseit.net/claird/comp.lang.python/web_python">http://phaseit.net/claird/comp.lang.python/web_python</a> で
Python のウェブ技術に関する便利なページ群を整備しています。</p>
</div>
<div class="section" id="cgi-method-post">
<h3><a class="toc-backref" href="#id51">CGI フォームの発信 (METHOD=POST) を模倣するにはどうしますか？</a><a class="headerlink" href="#cgi-method-post" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>フォームを POST した結果のウェブページを取得したいです。簡単に取得するためのコードはあるでしょうか？</p>
<p>あります。これは urllib.request を利用した簡単な例です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/local/bin/python</span>

<span class="kn">import</span> <span class="nn">httplib</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>

<span class="c">### build the query string</span>
<span class="n">qs</span> <span class="o">=</span> <span class="s">&quot;First=Josephine&amp;MI=Q&amp;Last=Public&quot;</span>

<span class="c">### connect and send the server a path</span>
<span class="n">httpobj</span> <span class="o">=</span> <span class="n">httplib</span><span class="o">.</span><span class="n">HTTP</span><span class="p">(</span><span class="s">&#39;www.some-server.out-there&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putrequest</span><span class="p">(</span><span class="s">&#39;POST&#39;</span><span class="p">,</span> <span class="s">&#39;/cgi-bin/some-cgi-script&#39;</span><span class="p">)</span>
<span class="c">### now generate the rest of the HTTP headers...</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s">&#39;Accept&#39;</span><span class="p">,</span> <span class="s">&#39;*/*&#39;</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s">&#39;Connection&#39;</span><span class="p">,</span> <span class="s">&#39;Keep-Alive&#39;</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s">&#39;Content-type&#39;</span><span class="p">,</span> <span class="s">&#39;application/x-www-form-urlencoded&#39;</span><span class="p">)</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">putheader</span><span class="p">(</span><span class="s">&#39;Content-length&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">))</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">endheaders</span><span class="p">()</span>
<span class="n">httpobj</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span>
<span class="c">### find out what the server said in response...</span>
<span class="n">reply</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">hdrs</span> <span class="o">=</span> <span class="n">httpobj</span><span class="o">.</span><span class="n">getreply</span><span class="p">()</span>
<span class="k">if</span> <span class="n">reply</span> <span class="o">!=</span> <span class="mi">200</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">httpobj</span><span class="o">.</span><span class="n">getfile</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
</div>
<p>なお、一般にパーセントエンコードされた POST 演算では、クエリ文字列は必ず
<tt class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></tt> で引用されなくてはなりません。例えば name=&#8221;Guy Steele, Jr.&#8221; を送信するには:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;Guy Steele, Jr.&#39;</span><span class="p">})</span>
<span class="go">&#39;name=Guy+Steele%2C+Jr.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">quote</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="s">&quot;Guy Steele, Jr.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">&#39;Guy%20Steele,%20Jr.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">query_string</span> <span class="o">=</span> <span class="s">&quot;name=&quot;</span><span class="o">+</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">query_string</span>
<span class="go">&#39;name=Guy%20Steele,%20Jr.&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="html">
<h3><a class="toc-backref" href="#id52">どのモジュールが HTML の生成の役に立ちますか？</a><a class="headerlink" href="#html" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>さまざまなモジュールが利用できます:</p>
<ul class="simple">
<li>HTMLgen は全ての HTML 3.2 マークアップタグに対応するオブジェクトのクラスライブラリです。Python を書いていて、HTML ページを統合して web や
CGI フォームを生成したい時などに使えます。</li>
<li>DocumentTemplate および Zope Page Templates は、それぞれ Zope の一部であるシステムです。</li>
<li>Quixote&#8217;s PTL は Python の構文を使って文字列やテキストを組み立てます。</li>
</ul>
<p>その他のリンクは、<a class="reference external" href="http://wiki.python.org/moin/WebProgramming">Web Programming wiki pages</a> を参照してください。</p>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id53">Python のスクリプトからメールを送るにはどうしますか？</a><a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準ライブラリモジュール <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP プロトコルクライアント (ソケットが必要です)。"><tt class="xref py py-mod docutils literal"><span class="pre">smtplib</span></tt></a> を使ってください。</p>
<p>以下に示すのが、これを使ったごく単純な対話型のメール送信器です。このメソッドは SMTP リスナをサポートするホストならどこででも作動します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">smtplib</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;Enter message, end with ^D:&quot;</span><span class="p">)</span>
<span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="n">line</span>

<span class="c"># The actual mail send</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>Unix のみ、sendmail を使う方法もあります。sendmail プログラムのロケーションは、システムによって変わります。<tt class="docutils literal"><span class="pre">/usr/lib/sendmail</span></tt> のときもあれば、
<tt class="docutils literal"><span class="pre">/usr/sbin/sendmail</span></tt> のときもあります。sendmail のマニュアルページを見れば解ります。これはサンプルコードです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SENDMAIL</span> <span class="o">=</span> <span class="s">&quot;/usr/sbin/sendmail&quot;</span> <span class="c"># sendmail location</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> -t -i&quot;</span> <span class="o">%</span> <span class="n">SENDMAIL</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;To: receiver@example.com</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Subject: test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="c"># blank line separating headers from body</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Some text</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;some more text</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">sts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">if</span> <span class="n">sts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;Sendmail exit status&quot;</span><span class="p">,</span> <span class="n">sts</span>
</pre></div>
</div>
</div>
<div class="section" id="connect">
<h3><a class="toc-backref" href="#id54">ソケットの connect() メソッドでブロッキングされなくするにはどうしますか？</a><a class="headerlink" href="#connect" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>主に select モジュールがソケットの非同期の I/O を扱うのに使われます。</p>
<p>TCP 接続がブロッキングされないようにするために、ソケットをノンブロッキングモードに設定することが出来ます。そして <tt class="docutils literal"><span class="pre">connect()</span></tt>
したときに、即座に接続できるか、エラー番号を <tt class="docutils literal"><span class="pre">.errno</span></tt> として含む例外を受け取るかのどちらかになります。<tt class="docutils literal"><span class="pre">errno.EINPROGRESS</span></tt> は、接続が進行中であるが、まだ完了していないということを示します。異なる OS では異なる値が返されるので、あなたのシステムで何が返されるかを確かめておく必要があります。</p>
<p><tt class="docutils literal"><span class="pre">connect_ex()</span></tt> メソッドを使えば例外を生成しなくて済みます。これは単に
errno の値を返すでしょう。ポーリングのためには、後でまた <tt class="docutils literal"><span class="pre">connect_ex()</span></tt> を呼び出すことができます &#8211; 0 または <tt class="docutils literal"><span class="pre">errno.EISCONN</span></tt> は接続されたことを表します &#8211; または、選択するソケットにこれを渡して書き込み可能か調べることができます。</p>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id55">データベース</a><a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id56">Python にはデータベースパッケージへのインタフェースはありますか？</a><a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p><tt class="xref py py-mod docutils literal"><span class="pre">DBM</span></tt> や <tt class="xref py py-mod docutils literal"><span class="pre">GDBM</span></tt> のような、ディスクに基づくハッシュへのインタフェースも標準の Python に含まれています。ディスクに基づく軽量なリレーショナルデータベースを提供する
<a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><tt class="xref py py-mod docutils literal"><span class="pre">sqlite3</span></tt></a> モジュールもあります。</p>
<p>ほとんどの相対データベースがサポートされています。詳細は
<a class="reference external" href="http://wiki.python.org/moin/DatabaseProgramming">DatabaseProgramming wiki page</a> を参照してください。</p>
</div>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id57">Python で永続的なオブジェクトを実装するにはどうしますか？</a><a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Python オブジェクトからバイトストリームへの変換、およびその逆。"><tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt></a> ライブラリモジュールで、ごく一般的な方法でこれを解決できます (開かれたファイル、ソケット、ウィンドウのようなものを保管することはできませんが)。<a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python オブジェクトの永続化。"><tt class="xref py py-mod docutils literal"><span class="pre">shelve</span></tt></a> ライブラリモジュールは pickle と
(g)dbm を使い、任意の Python オブジェクトを含む永続的なマッピングを生成します。パフォーマンスを良くするために、<a class="reference internal" href="../library/pickle.html#module-cPickle" title="cPickle: pickle の高速バージョンですが、サブクラスはできません。"><tt class="xref py py-mod docutils literal"><span class="pre">cPickle</span></tt></a> モジュールを使うこともできます。</p>
<p>もっと不器用な方法は、pickle の妹分である marshal を使うことです。
<a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Python オブジェクトをバイト列に変換したり、その逆を (異なる制約条件下で) 行います。"><tt class="xref py py-mod docutils literal"><span class="pre">marshal</span></tt></a> モジュールは、再帰的でない標準の Python 型を、ファイルや文字列にとても高速に保存したり、元に戻したりする方法を提供します。
marshal では、インスタンスの保存や共有される参照の適切な処理などの派手なことはできませんが、極端に速く動作します。例えば、半メガバイトのデータに
3 分の 1 秒も掛からないでしょう。これは多くの場合、 pickle/shelve で
gdbm を使うというような、複雑な一般の方法に勝ります。</p>
</div>
<div class="section" id="cpickle">
<h3><a class="toc-backref" href="#id58">なぜ cPickle はこんなに遅いのですか？</a><a class="headerlink" href="#cpickle" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>pickle モジュールに使われているデフォルトのフォーマットは、読み込み可能な
pickle のための遅いものです。後方互換性は壊されますが、これを使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">largeString</span> <span class="o">=</span> <span class="s">&#39;z&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
<span class="n">myPickle</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">largeString</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="bsddb-or-anydbm">
<h3><a class="toc-backref" href="#id59">bsddb (or anydbm) データベースが開かれたままプログラムがクラッシュすると、だめになってしまいます。なぜですか？</a><a class="headerlink" href="#bsddb-or-anydbm" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>bsddb モジュール (やしばしば anydbm モジュール。優先的に bsddb を使うでしょうから) で書き込みのために開かれたデータベースは、データベースの
<tt class="docutils literal"><span class="pre">.close()</span></tt> メソッドで明示的に閉じられなければなりません。その基礎にあるライブラリは、ディスク上の形式に変換されて書き込まれるべきデータベースの中身を、キャッシュします。</p>
<p>新しい bsddb データベースを初期化したけれどプログラムのクラッシュ時までに何も書き込まれていないとき、長さ 0 のファイルで終わることになり、次にそのファイルが開かれたときに例外に出くわすでしょう。</p>
</div>
<div class="section" id="berkeley-db-bsddb-bsddb-error-22-invalid-argument">
<h3><a class="toc-backref" href="#id60">Berkeley DB ファイルを開こうとしましたが、bsddb が bsddb.error: (22, &#8216;Invalid argument&#8217;) を生じます。助けてください！ データを復元するにはどうしたら良いですか？</a><a class="headerlink" href="#berkeley-db-bsddb-bsddb-error-22-invalid-argument" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>慌てないでください！ あなたのデータはおそらく無事です。このエラーの一番ありがちな原因は、新しいバージョンの Berkeley DB ライブラリから古い Berkeley DB ファイルを開こうとすることです。</p>
<p>多くの Linux システムで、今では 3 種類全てのバージョンの Berkeley DB が利用できます。バージョン 1 から新しいバージョンに移行するには、
db_dump185 でデータベースのプレーンテキスト版をダンプしてください。バージョン 2 からバージョン 3 に移行するには、db_2dump でデータベースのプレーンテキスト版を生成してください。そのどちらの場合でも、db_load でコンピュータにインストールされている最新バージョンの新しいネイティブデータベースを生成してください。バージョン 3 の Berkeley DB がインストールされているなら、db2_load でネイティブのバージョン 2 のデータベースを生成できるでしょう。</p>
<p>Berkeley DB バージョン 1 のハッシュファイルコードにはデータを破壊する既知のバグがありますから、使うのをやめるべきです。</p>
</div>
</div>
<div class="section" id="id21">
<h2><a class="toc-backref" href="#id61">数学と数</a><a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id62">Python でランダムな数を生成するにはどうしますか？</a><a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準モジュールの <a class="reference internal" href="../library/random.html#module-random" title="random: よく知られている様々な分布をもつ擬似乱数を生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt></a> がランダムな数の生成器を実装しています。使い方は単純です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
</pre></div>
</div>
<p>これは区間 [0, 1) 内のランダムな浮動小数点数を返します。</p>
<p>このモジュールにはその他多くの特化した生成器もあります。例えば:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">randrange(a,</span> <span class="pre">b)</span></tt> は区間 [a, b) から整数を選びます。</li>
<li><tt class="docutils literal"><span class="pre">uniform(a,</span> <span class="pre">b)</span></tt> は区間 [a, b) から浮動小数点数を選びます。</li>
<li><tt class="docutils literal"><span class="pre">normalvariate(mean,</span> <span class="pre">sdev)</span></tt> は正規(ガウス)分布をサンプリングします。</li>
</ul>
<p>シーケンスに直接作用する高水準な関数もあります。例えば:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">choice(S)</span></tt> は与えられたシーケンスからランダムな要素を選びます。</li>
<li><tt class="docutils literal"><span class="pre">shuffle(L)</span></tt> はリストをインプレースにシャッフルします。すなわち、ランダムに並び替えます。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">Random</span></tt> クラスのインスタンスを生成して、複数の独立なランダムな数の生成器をつくることもできます。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="extending.html" title="拡張と埋め込み FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python よくある質問</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>