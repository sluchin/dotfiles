

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>デザインと歴史 FAQ &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python よくある質問" href="index.html" />
    <link rel="next" title="ライブラリと拡張 FAQ" href="library.html" />
    <link rel="prev" title="プログラミング FAQ" href="programming.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python よくある質問</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">デザインと歴史 FAQ</a><ul>
<li><a class="reference internal" href="#python">Python はなぜ文のグループ化にインデンテーションを使うのですか？</a></li>
<li><a class="reference internal" href="#id1">なぜ単純な算術演算が奇妙な結果になるのですか？</a></li>
<li><a class="reference internal" href="#id2">なぜ浮動小数点演算はこれほど不正確なのですか？</a></li>
<li><a class="reference internal" href="#id3">なぜ Python の文字列はイミュータブルなのですか？</a></li>
<li><a class="reference internal" href="#self">なぜメソッドの定義や呼び出しにおいて &#8216;self&#8217; を明示しなければならないのですか？</a></li>
<li><a class="reference internal" href="#id4">式中で代入ができないのはなぜですか？</a></li>
<li><a class="reference internal" href="#python-list-index-list-index">Python にメソッドを使う機能 (list.index()等) と関数を使う機能 (list.index()等) があるのはなぜですか？</a></li>
<li><a class="reference internal" href="#join">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></li>
<li><a class="reference internal" href="#id5">例外はどれくらい速いのですか？</a></li>
<li><a class="reference internal" href="#python-switch-case">Python に switch や case 文がないのはなぜですか？</a></li>
<li><a class="reference internal" href="#os">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></li>
<li><a class="reference internal" href="#id6">ラムダ式が文を含めないのはなぜですか？</a></li>
<li><a class="reference internal" href="#python-c">Python は C やその他の言語のように機械語にコンパイルできますか？</a></li>
<li><a class="reference internal" href="#id7">Python はメモリをどのように管理するのですか？</a></li>
<li><a class="reference internal" href="#id8">なぜ Python の終了時にすべてのメモリが開放されるわけではないのですか？</a></li>
<li><a class="reference internal" href="#id9">なぜタプルとリストという別のデータ型が用意されているのですか？</a></li>
<li><a class="reference internal" href="#id10">リストはどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="#id11">辞書はどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="#id12">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></li>
<li><a class="reference internal" href="#list-sort">なぜ list.sort() はソートされたリストを返さないのですか？</a></li>
<li><a class="reference internal" href="#id13">Python ではどのようにインタフェース仕様を特定し適用するのですか？</a></li>
<li><a class="reference internal" href="#id14">なぜオブジェクト間でデフォルト値が共有されるのですか？</a></li>
<li><a class="reference internal" href="#goto">なぜ goto が無いのですか？</a></li>
<li><a class="reference internal" href="#raw-r-strings">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></li>
<li><a class="reference internal" href="#with">属性の代入に &#8220;with&#8221; 文が使えないのはなぜですか？</a></li>
<li><a class="reference internal" href="#if-while-def-class">if/while/def/class 文にコロンが必要なのはなぜですか？</a></li>
<li><a class="reference internal" href="#id15">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="programming.html"
                        title="前の章へ">プログラミング FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="library.html"
                        title="次の章へ">ライブラリと拡張 FAQ</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/faq/design.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="faq">
<h1>デザインと歴史 FAQ<a class="headerlink" href="#faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="python">
<h2>Python はなぜ文のグループ化にインデンテーションを使うのですか？<a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Guido van Rossum の信じるところによれば、インデントによるグループ化は非常にエレガントで、平均的な Python プログラムを大いに読みやすくします。しばらくすればほとんどの人はこの特徴を気に入るようになります。</p>
<p>begin/end の括りがないので、構文解析器と人間の読者の間にグループ化の解釈の違いは起こりえません。時折、C のプログラマはこのようなコード片に出くわします:</p>
<div class="highlight-python"><pre>if (x &lt;= y)
        x++;
        y--;
z++;</pre>
</div>
<p>この条件文が真の時のみ実行されるのは <tt class="docutils literal"><span class="pre">x++</span></tt> 文だけですが、このインデンテーションでは誤解を招きます。経験を積んだ C プログラマでさえ、
<tt class="docutils literal"><span class="pre">y</span></tt> が <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt> の時にもデクリメントされるのはなぜか分からず長いこと立ち止まることがあるでしょう。</p>
<p>begin/end の括りがないので、Python はコーディングスタイルの対立が非常に起こりにくくなります。C では多様なカッコの置き方があります。一つのスタイルでのコードの読み書きに慣れてしまうと、他のスタイルを読むとき (あるいは書かなくてはならないとき) にむずむずするでしょう。</p>
<p>多くのコーディングスタイルは begin/end の括りにそれぞれ一行を使います。これではプログラムは冗長になって画面を浪費し、プログラムの見通しが悪くなります。一つの関数は一画面 (例えば 20 - 30 行) に収めるのが理想です。
20 行の Python は20行の C よりもはるかに多くのことができます。これは begin/end の括りがないからだけではありません &#8211; 宣言が不要なことや高レベルなデータ型もその理由です &#8211; が、インデンテーションに基づく構文は確かに役に立っています。</p>
</div>
<div class="section" id="id1">
<h2>なぜ単純な算術演算が奇妙な結果になるのですか？<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>次の質問を参照してください。</p>
</div>
<div class="section" id="id2">
<h2>なぜ浮動小数点演算はこれほど不正確なのですか？<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このような結果は、よく驚かれたり Python のバグであると考えられたりします:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">1.0</span>
<span class="go">0.199999999999999996</span>
</pre></div>
</div>
<p>でもこれはバグではありません。これは Python ではなく、その基底にある C のプラットフォームによる浮動小数点数の扱い方の問題で、究極には数を固定長の桁に書き下す際に生じたものです。</p>
<p>浮動小数点数の内部表現では一定数の二進数で十進数を示します。二進数では正確に表せない十進数もあり、僅かな丸め誤差を生じます。</p>
<p>十進数演算では、1/3 = 0.3333333333....... など、固定長の十進数では表せない数がたくさんあります。</p>
<p>基数が 2 のとき、1/2 = 0.1、1/4 = 0.01、1/8 = 0.001、などになります。
.2 は 2/10 と等しく、1/5 と等しいので、二進数の分数で
0.001100110011001... になります。</p>
<p>浮動小数点数には 32 か 64 ビットの精度しかないので、ある桁で切り捨てられ、十進数表示で 0.2 ではなく 0.199999999999999996 となります。</p>
<p>浮動小数点数の <tt class="docutils literal"><span class="pre">repr()</span></tt> 関数はすべての浮動小数点数 f に対して
<tt class="docutils literal"><span class="pre">eval(repr(f))</span> <span class="pre">==</span> <span class="pre">f</span></tt> が真となるのに必要なだけの桁を表示します。
<tt class="docutils literal"><span class="pre">str()</span></tt> 関数はそれより少ない桁を表示するので、より意図を汲んだ感覚的な数を得やすいです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.1</span> <span class="o">-</span> <span class="mf">0.9</span>
<span class="go">0.20000000000000007</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">1.1</span> <span class="o">-</span> <span class="mf">0.9</span>
<span class="go">0.2</span>
</pre></div>
</div>
<p>その結果、<tt class="docutils literal"><span class="pre">==</span></tt> による浮動小数点の演算結果の比較は間違いやすいです。僅かな不正確さだけで <tt class="docutils literal"><span class="pre">==</span></tt> が間違うこともあります。その代わりに、二つの数間の差があるしきい値よりも小さいことを調べなくてはなりません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.0000000000001</span>  <span class="c"># Tiny allowed error</span>
<span class="n">expected_result</span> <span class="o">=</span> <span class="mf">0.4</span>

<span class="k">if</span> <span class="n">expected_result</span><span class="o">-</span><span class="n">epsilon</span> <span class="o">&lt;=</span> <span class="n">computation</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">expected_result</span><span class="o">+</span><span class="n">epsilon</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>詳しくは、Python チュートリアルの <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><em>floating point arithmetic</em></a> の章を参照してください。</p>
</div>
<div class="section" id="id3">
<h2>なぜ Python の文字列はイミュータブルなのですか？<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これにはいくつかの利点があります。</p>
<p>一つはパフォーマンスです。文字列がイミュータブルなら、生成時に領域を割り当てることができるので、必要な記憶域は固定されて、変更されません。これはタプルとリストを区別する理由の一つでもあります。</p>
<p>別の利点は、Python で文字列が数と同じくらい &#8220;基本的&#8221; なものと考えられることです。8 という値を他の何かに変える手段が無いように、文字列 &#8220;eight&#8221; を他の何かに変える手段も無いのです。</p>
</div>
<div class="section" id="self">
<span id="why-self"></span><h2>なぜメソッドの定義や呼び出しにおいて &#8216;self&#8217; を明示しなければならないのですか？<a class="headerlink" href="#self" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このアイデアは Modula-3 から取り入れられました。これは様々な理由からとても便利だと言えます。</p>
<p>まず、扱っているのがローカル変数ではなく、メソッドやインスタンス属性なのだと分かりやすいです。<tt class="docutils literal"><span class="pre">self.x</span></tt> や <tt class="docutils literal"><span class="pre">self.meth()</span></tt> と書いてあれば、そのクラスの定義を憶えていなくても、それがインスタンス変数やメソッドであることは明白です。C++ では、(グローバルは滅多にないし、簡単に判別できるので) ローカル変数宣言されていないことからある程度わかるでしょう。&#8211; しかし Python にはローカル変数宣言がないので、クラス定義を調べて確かめなくてはなりません。C++ や Java のコーディングスタンダードに、インスタンス属性に
<tt class="docutils literal"><span class="pre">m_</span></tt> 接頭辞をつけるものがあるように、この明示性はそれらの言語でも役に立ちます。</p>
<p>第二に、特定のクラスからメソッドを明示的に参照や呼び出ししたい時に、特別な構文が必要なくなります。C++ では、派生クラスでオーバーライドされた基底クラスからメソッドを使うには、<tt class="docutils literal"><span class="pre">::</span></tt> 演算子を使わなければなりません。
&#8211; Python では、<tt class="docutils literal"><span class="pre">baseclass.methodname(self,</span> <span class="pre">&lt;argument</span> <span class="pre">list&gt;)</span></tt> と書けます。これは特に、<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> メソッドに便利ですし、派生クラスのメソッドが、基底クラスにある同じ名前のメソッドを拡張するために、基底クラスのメソッドをどうにかして呼び出したい時にも便利です。</p>
<p>最後に、インスタンス変数の、代入の構文の問題を解決できます。
Python のローカル変数は、関数の中で (global が明示的に宣言されることなく)
値が代入された変数 (と定義されています！) なので、インタプリタには、代入がローカル変数にではなくインスタンス変数にされたのだと判断する方法が必要で、構文を見るだけで分かる方が (効率が) 良いのです。
C++ ではその区別を宣言時に行いますが、Python では宣言がないので、この方法でしか区別できなかったら残念です。<tt class="docutils literal"><span class="pre">self.var</span></tt> を明示すればしっくりきます。同様に、インスタンス変数を使うためにも <tt class="docutils literal"><span class="pre">self.var</span></tt> と書かなければならないので、メソッドの中の self が付いていない名前への参照は、そのインスタンスのディレクトリを検索するまでもなくローカル変数とわかります。別の言い方をすれば、ローカル変数とインスタンス変数は二つの異なる名前空間に存在し、Python にどちらの名前空間を使うかを伝えなくてはならないのです。</p>
</div>
<div class="section" id="id4">
<h2>式中で代入ができないのはなぜですか？<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C や Perl に慣れた多くの人は、C のこの慣用句を使いたいと訴えます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="n">line</span> <span class="o">=</span> <span class="n">readline</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// do something with line</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python ではこう書かなくてはなりません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="o">...</span> <span class="c"># do something with line</span>
</pre></div>
</div>
<p>Python の式中での代入を許さない理由は、この構造によって起こる他の言語ではありがちで見つけづらいバグです:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// error handling</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="c1">// code that only works for nonzero x</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このエラーは単純なタイプミスで、 本当にやりたかったのは <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">0</span></tt> の比較ですが、<tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></tt> と書いてしまい、変数 <tt class="docutils literal"><span class="pre">x</span></tt> に 0 を代入しています。</p>
<p>提案された代替案はたくさんあります。多くの案はタイプ数を少し節約しますが、勝手だったり意味不明だったりする構文や予約語を使い、言語変更の提案の簡潔さの基準を満たしていません。構造の説明をされていない人間の読者に、正しい意味を直感的に示す物であるべきです。</p>
<p>面白いことに、熟練した Python プログラマは <tt class="docutils literal"><span class="pre">while</span> <span class="pre">True</span></tt> というイディオムを受け入れていて、式構造中の代入がなくてもそれほど苦労しないようです。
Python にそれを強く求めるのは新人だけです。</p>
<p>以下の方法でもこれを綴ることができて、魅力的そうですが、堅牢さでは &#8220;while True&#8221; を使う方法に劣ることが多いです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="k">while</span> <span class="n">line</span><span class="p">:</span>
    <span class="o">...</span> <span class="c"># do something with line...</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</pre></div>
</div>
<p>この方法の問題は、次の行を取得する方法を変えたくなったとき
(<tt class="docutils literal"><span class="pre">sys.stdin.readline()</span></tt> に変更したい時など) にプログラムの二箇所を変えなくてはならないことです &#8211;
二つ目の場所はループの最後に隠れています。</p>
<p>一番いいのはイテレータを使って、 <tt class="docutils literal"><span class="pre">for</span></tt> 文でオブジェクトを通してループさせることです。例えば、ファイルオブジェクトはイテレータプロトコルをサポートしているので、単純にこう書けます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span> <span class="c"># do something with line...</span>
</pre></div>
</div>
</div>
<div class="section" id="python-list-index-list-index">
<h2>Python にメソッドを使う機能 (list.index()等) と関数を使う機能 (list.index()等) があるのはなぜですか？<a class="headerlink" href="#python-list-index-list-index" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>歴史上の経緯が主な理由です。関数は型のグループに共通で、メソッドを持たないオブジェクト(タプル等)にも適用できるようにした操作に使われていました。オブジェクトの無定形な集合に容易に適用できる関数があることは、Python の関数的機能 (<tt class="docutils literal"><span class="pre">map()</span></tt>、<tt class="docutils literal"><span class="pre">apply()</span></tt> 等) を使うときにも便利です。</p>
<p>実際、<tt class="docutils literal"><span class="pre">len()</span></tt>、<tt class="docutils literal"><span class="pre">max()</span></tt>、<tt class="docutils literal"><span class="pre">min()</span></tt> を組み込み関数として実装することで、それぞれの型のメソッドとして実装するより少ないコードで済みます。個々のケースについては粗探しのしようがありますが、Python の一部であるし、根本的な変更をするには遅すぎます。これらの関数は、大規模なコードの破壊を避けるために残す必要があります。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">Python の文字列演算は、外部の関数からメソッド (<tt class="docutils literal"><span class="pre">string</span></tt> モジュール)
に移行しました。しかし、<tt class="docutils literal"><span class="pre">len()</span></tt> は関数のままです。</p>
</div>
</div>
<div class="section" id="join">
<h2>join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？<a class="headerlink" href="#join" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>文字列は Python 1.6 からメソッドが追加され、他の標準型と同じような機能が string モジュールの関数でいつでも使えるようになったことで、他の標準型に大きく近づきました。その新しいメソッドの多くは広く受け入れられましたが、一部のプログラマに不快を感じさせていると思われるものがこれで:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;4&#39;</span><span class="p">,</span> <span class="s">&#39;8&#39;</span><span class="p">,</span> <span class="s">&#39;16&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>結果はこうなります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;1, 2, 4, 8, 16&quot;</span>
</pre></div>
</div>
<p>この使い方には二つの議論があります。</p>
<p>一つ目は、「文字列リテラル (文字列定数) のメソッドを使うのは醜すぎる」というようなものです。確かにそうかも知れませんが、文字列リテラルは単なる固定された値に過ぎないというのが答えです。文字列に束縛された名前にメソッドが許されるなら、リテラルに使えないようにする理由はないでしょう。</p>
<p>二つ目の反対理由は、典型的には「シーケンスを文字列定数で結合させようとしているのだ」というものです。残念ながら、そうではないのです。いくつかの理由から <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><tt class="xref py py-meth docutils literal"><span class="pre">split()</span></tt></a> を文字列のメソッドとしておいた方がはるかに簡単です。これを見ると分かりやすいでしょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;1, 2, 4, 8, 16&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは文字列リテラルに与えられた分離子 (デフォルトでは空白文字) によって区切られた部分文字列を返すように指示しています。このとき、Unicode 文字列は Unicode 文字列のリストを返し、ASCII 文字列は
ASCII 文字列のリストを返すから、みんな幸せです。</p>
<p><a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> は、セパレータ文字列に、文字列のシーケンスをイテレートして隣り合う要素の間に自身を挿入するように指示しているので、文字列のメソッドです。このメソッドは、独自に定義された新しいクラスを含め、シーケンスの規則を満たすいかなる引数にも使えます。</p>
<p>これは文字列メソッドなので、Unicode 文字列にも 通常の ASCII 文字列にも使えます。 <tt class="docutils literal"><span class="pre">join()</span></tt> がシーケンス型のモジュールだったとしたら、そのシーケンス型はどちらの型の文字列を返すか、セパレータの型によって決めなければなりません。</p>
</div>
<div class="section" id="id5">
<h2>例外はどれくらい速いのですか？<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>try/except ブロックは極端に効率がいいです。実際に例外を補足するのは高価です。
Python 2.0 より前のバージョンでは、このイディオムが一般的でした:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>これは、辞書がほとんどの場合にキーを持っていると予想できるときにのみ意味をなします。そうでなければ、このように書きます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">mydict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">Python 2.0 以降では、<tt class="docutils literal"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">mydict.setdefault(key,</span> <span class="pre">getvalue(key))</span></tt>
のように書くことができます。</p>
</div>
</div>
<div class="section" id="python-switch-case">
<h2>Python に switch や case 文がないのはなぜですか？<a class="headerlink" href="#python-switch-case" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">if...</span> <span class="pre">elif...</span> <span class="pre">elif...</span> <span class="pre">else</span></tt> の繰り返しで簡単に同じことができます。
switch 文の構文に関する提案が幾つかありましたが、範囲検定をするべきか、あるいはどのようにするべきかについての合意は (まだ) 得られていません。現在の状況の完全な詳細は <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0275"><strong>PEP 275</strong></a> を参照してください。</p>
<p>非常に大きな数の選択肢から選ぶとき、値を呼び出す関数に対応づける辞書を作れます。例えば:</p>
<div class="highlight-python"><pre>def function_1(...):
    ...

functions = {'a': function_1,
             'b': function_2,
             'c': self.method_1, ...}

func = functions[value]
func()</pre>
</div>
<p>オブジェクトのメソッドを呼び出すには、さらに単純に
<a class="reference internal" href="../library/functions.html#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> 組み込み関数で特定の名前のメソッドを検索することが出来ます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visit_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">method_name</span> <span class="o">=</span> <span class="s">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="n">method</span><span class="p">()</span>
</pre></div>
</div>
<p>メソッドの名前にこの例の <tt class="docutils literal"><span class="pre">visit_</span></tt> のような接頭辞を使うことを勧めます。このような接頭辞がないと、信頼できないソースから値が与えられたときに、オブジェクトの任意のメソッドを呼び出す攻撃をされる可能性があります。</p>
</div>
<div class="section" id="os">
<h2>OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？<a class="headerlink" href="#os" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>答 1: 残念なことに、インタプリタは Python のスタックフレームごとに少なくとも一つの C のスタックフレームを push します。同様に、拡張もほとんどランダムなときに Python にコールバックすることがあります。よって、完全なスレッド実装には C のスレッドサポートが必要です。</p>
<p>答 2: 幸運なことに、完全に C スタックを使わないように再設計されたインタプリタ <a class="reference external" href="http://www.stackless.com">Stackless Python</a> があります。まだ実験的なものですが、将来性がありそうです。これは標準の
Python とバイナリ互換ですが、スタックレスの中核となるかどうかはまだわかりません &#8211; これはあまりに革命的すぎるかもしれません。</p>
</div>
<div class="section" id="id6">
<h2>ラムダ式が文を含めないのはなぜですか？<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の構文的な枠組みでは式の中にネストされた文を扱えないため、
Python のラムダ式は文を含めません。しかし、Python ではこれは深刻な問題ではありません。他の言語でのラムダ式が機能性を追加するものであるのと違い、Python でのラムダは関数を定義するのが面倒なときの速記法に過ぎません。</p>
<p>Python では関数はもとからファーストクラスオブジェクトであり、ローカルなスコープで宣言できます。よって、ローカルに宣言される関数ではなくラムダ式を使う利点はただ一つ、関数の名前を考えなくてもいいことです - でもその関数オブジェクトが代入されるのは
(ラムダ式が名前を空けたのとまさに同じ型のオブジェクトである)
ローカル変数です！</p>
</div>
<div class="section" id="python-c">
<h2>Python は C やその他の言語のように機械語にコンパイルできますか？<a class="headerlink" href="#python-c" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>簡単にはできません。Python の高水準データ型、動的な型付け、(<a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> や
<tt class="xref py py-func docutils literal"><span class="pre">exec()</span></tt> を使った) インタプリタの実行時呼び出しがあるということは、「コンパイルされた」Python のプログラムのほとんどが、<tt class="docutils literal"><span class="pre">x+1</span></tt> のような一見簡単な演算でさえ、Python のランタイムシステムへの呼び出しで成り立っているであろうことを意味します。</p>
<p>Python ニュースグループや過去の
<a class="reference external" href="http://python.org/community/workshops/">Python conferences</a> で説明されたいくつかのプロジェクトを見ると、現在の速度の向上は緩やかでしかない (たとえば 2 倍) ですが、このやり方はうまくいきそうです。
Jython は Java バイトコードにコンパイルするという同様の方法を使っています。
(Jim Hugunin の論証によれば、プログラム全体の解析と組み合わせることで、小さなデモプログラムでは 1000 倍の速度向上が見込めます。詳しくは
<a class="reference external" href="http://python.org/workshops/1997-10/proceedings/">1997 Python conference</a>
の議事録を参照してください。)</p>
<p>内部的には、Python のソースコードはいつもバイトコード表現に翻訳されていて、そのバイトコードが Python の仮想マシンによって実行されます。めったに変更されないモジュールの解析が繰り返されることによるオーバーヘッドを避けるため、このバイトコードはモジュールが解析されるたびに名前が &#8221;.pic&#8221; で終わるファイルに書きこまれます。対応する .py ファイルが変更されたとき、そのファイルは再び解析および翻訳されて
.pyc ファイルは書き直されます。</p>
<p>一旦 .pyc ファイルが読み込まれればパフォーマンスの差はなく、
.pyc ファイルから読み込まれたバイトコードも、直接の変換により生成されたバイトコードも全く同じです。唯一の違いは、.pyc ファイルからコードを読み込むのは .py ファイルを解析して翻訳するのよりも速いことなので、予めコンパイルされた .pyc ファイルがあると Python スクリプトの起動時間が改善します。必要なら、 Lib/compileall.py モジュールで、与えられたモジュール群の適切な .pyc ファイルを生成できます。</p>
<p>なお、Python によって実行されるメインスクリプトは、たとえそのファイル名が
.py で終わっていても、.pyc ファイルにコンパイルされません。バイトコードには変換されますが、そのバイトコードはファイルに保存されません。たいていメインスクリプトはとても短いので、これでも大きく速度を落とすことにはなりません。</p>
<p>Python と C のコードを様々な方法で混合して簡単にパフォーマンスを向上させるプログラムがいくつかあります。例えば
<a class="reference external" href="http://psyco.sourceforge.net/">Psyco</a>、
<a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex</a>、
<a class="reference external" href="http://pyinline.sourceforge.net/">PyInline</a>、
<a class="reference external" href="http://sourceforge.net/projects/py2cmod/">Py2Cmod</a>、
<a class="reference external" href="http://www.scipy.org/Weave">Weave</a>
を参照してください。</p>
</div>
<div class="section" id="id7">
<h2>Python はメモリをどのように管理するのですか？<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のメモリ管理の詳細は実装に依ります。Python の標準の C 実装は参照カウントを使って、アクセスできないオブジェクトを探します。また別のメカニズムも使って参照サイクルを集めます。これはサイクル検出アルゴリズムを定期的に実行し、アクセスできないサイクルを探し、それに含まれるオブジェクトを削除します。<a class="reference internal" href="../library/gc.html#module-gc" title="gc: 循環検出ガベージコレクタのインターフェース。"><tt class="xref py py-mod docutils literal"><span class="pre">gc</span></tt></a> モジュールの関数で、ガベージコレクションを実行し、デバッグ統計を取得し、コレクタのパラメタを変更できます。</p>
<p>Jython は Java ランタイムに頼るので、JVM のガベージコレクタが使われます。
Python のコードが参照カウントの実装の振る舞いに依るとき、この違いが微妙な移植問題を起こすことがあります。</p>
<p>循環性がなければ、Python プログラムはメモリを明示的に管理する必要はありません。</p>
<p>なぜ Python は伝統的なガベージコレクション体系を使わないのでしょうか？まず、それは C の標準的な機能ではないのでポータブルではありません。
(Boehm GC を例に取りましょう。これには <em>most</em> 有名なプラットフォームのためのアセンブリコードが含まれますが、全てには対応していませんし、ほとんど transparent ですが、完全に transparent ではありません。
Python を対応させるにはパッチが必要です。)</p>
<p>伝統的な GC は Python が他のアプリケーションに実装されるときにも問題となります。スタンドアロンの Python で動く限りでは、標準の malloc() と free() を GC ライブラリから提供されるものに置き換えても問題ありませんが、Python を実装したアプリケーションは Python のものではない <em>独自の</em> 代替品を使おうとするかもしれません。現在のようにすることで、Python は malloc() と free() が適切に実装されている限りどんなものにも対応させられます。</p>
<p>Jython では、以下の (CPython では通る) コードはおそらく、メモリを使い切るより遥かに前にファイルディスクリプタを使い果たすでしょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>現在の参照カウントとデストラクタのスキームを使えば、
f への新しい代入ごとに前のファイルは閉じられます。GC を使うのでは、これは保証されません。どんな Python の実装にも適用できるコードを書くには、明示的にファイルを閉じるか、<a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文を使いましょう。これは GC に関係なく働きます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>なぜ Python の終了時にすべてのメモリが開放されるわけではないのですか？<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python モジュールのグローバルな名前空間から参照されるオブジェクトは、
Python の終了時にメモリの割り当てを解除されるとは限りません。これは、循環参照があるときに起こりえます。開放できない C ライブラリ
(例えば、Purify のようなツールなどが当てはまります) によって割り当てられたいくらかのメモリも含まれます。しかし、Python は終了時にメモリをクリーンアップすることには積極的で、全ての各個オブジェクトを破棄しようとします。</p>
<p>再割り当て時に Python が特定のものを削除するように強制したいときは、
<a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: 後始末関数の登録と実行。"><tt class="xref py py-mod docutils literal"><span class="pre">atexit</span></tt></a> モジュールを使って削除を強制する関数を実行してください。</p>
</div>
<div class="section" id="id9">
<h2>なぜタプルとリストという別のデータ型が用意されているのですか？<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リストとタプルは、多くの点で似ていますが、一般には本質的に異なる方法で使われます。タプルは、Pascal のレコードや C の構造体と同様なものと考えられます。型が異なっても良い関連するデータの小さな集合で、グループとして演算されます。例えば、デカルト座標は 2 つや 3 つの数のタプルとして適切に表せます。</p>
<p>一方、リストは、もっと他の言語の配列に近いものです。全て同じ型の可変数のオブジェクトを持ち、それらが一つ一つ演算される傾向にあります。例えば、<tt class="docutils literal"><span class="pre">os.listdir('.')</span></tt> はカレントディレクトリ内にあるファイルの文字列表現のリストを返します。この出力を演算する関数は一般に、ディレクトリに一つや二つの別のファイルを加えても壊れません。</p>
<p>タプルはイミュータブルなので、一度タプルが生成されたら、そのどの要素も新しい値に置き換えられません。リストはミュータブルなので、リストの要素はいつでも変更できます。イミュータブルな要素だけが辞書のキーとして使えるので、リストではなくタプルだけがキーとして使えます。</p>
</div>
<div class="section" id="id10">
<h2>リストはどのように実装されているのですか？<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のリストは真の可変長配列であり、Lisp スタイルの連結リストではありません。この実装は、他のオブジェクトへの参照の連続した配列を使い、リストの頭部構造にこの配列へのポインタと配列の長さを保持します。</p>
<p>これにより、リストのインデクシング <tt class="docutils literal"><span class="pre">a[i]</span></tt> は、リストの大きさやインデクスの値に依存しないコストで演算できます。</p>
<p>要素が追加または挿入されるとき、この参照の配列は大きさが変更されます。要素追加の繰り返しのパフォーマンスを上げるために、少し工夫されています。配列が大きくなるとき、次の何回かは実際に大きさを変更する必要がないように、いくらかの追加の領域が割り当てられます。</p>
</div>
<div class="section" id="id11">
<h2>辞書はどのように実装されているのですか？<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の辞書は大きさを変更できるハッシュテーブルとして実装されています。
B 木にコンパイルされることで、ほとんどの条件下で (特に一般的な演算である)
探索のパフォーマンスが良くなりますし、実装も単純です。</p>
<p>辞書は、 <a class="reference internal" href="../library/functions.html#hash" title="hash"><tt class="xref py py-func docutils literal"><span class="pre">hash()</span></tt></a> ビルトイン関数で、辞書に保存されているそれぞれのキーに対応するハッシュコードを計算して働きます。このハッシュコードはキーに大きく依存します。例えば、&#8221;Python&#8221; のハッシュ値は -539294296 ですが、ビットが一つ違うだけの文字列 &#8220;python&#8221; のハッシュ値は 1142331976 です。そしてこのハッシュコードは、内部配列での値が保存される位置を計算するために使われます。保存しているキーのハッシュ値が異なるとすれば、一定の時間 - コンピュータサイエンスの記法で言えば O(1) - でキーを検索できることになります。また、キーのいかなる並び順も保たれていないことにもなり、配列を <tt class="docutils literal"><span class="pre">.keys()</span></tt> や <tt class="docutils literal"><span class="pre">.items()</span></tt> として横断すると、辞書の内容が任意の混乱した順序で出力されます。</p>
</div>
<div class="section" id="id12">
<h2>なぜ辞書のキーはイミュータブルでなくてはならないのですか？<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>辞書のハッシュテーブルの実装は、キーを見つけるために、キーから計算されたハッシュ値を使っています。もしキーがミュータブルなオブジェクトだったら、その値は変えられ、それによりハッシュ値も変わってしまいます。しかし、キーオブジェクトを変更したのが何者であれ、値が辞書のキーとして使われていたと気付けないので、辞書の中のエントリを適切な場所に動かせません。そうして、同じオブジェクトを探そうとしたときに、ハッシュ値が違うため見つかりません。古い値を探そうとしても、そのハッシュバイナリから見つかるオブジェクトの値は異なるでしょうから、これも見つかりません。</p>
<p>リストでインデクシングされた辞書が必要なら、まず単純にリストをタプルに変換してください。関数 <tt class="docutils literal"><span class="pre">tuple(L)</span></tt> は、リスト <tt class="docutils literal"><span class="pre">L</span></tt> と同じエントリのタプルを生成します。タプルはイミュータブルなので、辞書のキーとして使えます。</p>
<p>いくつかの受け入れられなかった提案:</p>
<ul>
<li><p class="first">アドレス (オブジェクト ID) のハッシュリスト。これは、同じ値の新しいリストを作っても見つからないので駄目です。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mydict</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span> <span class="s">&#39;12&#39;</span><span class="p">}</span>
<span class="k">print</span> <span class="n">mydict</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p>は、2 行目の <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></tt> の id が 1 行目のものと違うため、
KeyError 例外を起こします。要するに、辞書のキーは <a class="reference internal" href="../reference/expressions.html#is"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span></tt></a> ではなく、
<tt class="docutils literal"><span class="pre">==</span></tt> で比較されるべきです。</p>
</li>
<li><p class="first">リストをキーとして使うときにコピーを作る。リストはミュータブルなので、自分自身への参照を含むことができ、コードをコピーするときに無限ループにハマる可能性があるので、これは駄目です。</p>
</li>
<li><p class="first">リストをキーとして使うことを認めるが、ユーザにそれを変更させないように伝える。もしユーザが忘れたり、偶然にリストが変更されてしまったりしたら、追跡困難なバグの可能性を生じてしまいます。またこれは、<tt class="docutils literal"><span class="pre">d.keys()</span></tt> のすべての値は辞書のキーとして使えるという、辞書の重要な不変性も潰してしまいます。</p>
</li>
<li><p class="first">リストが一旦辞書のキーとして使われたら、読み込み専用のマークを付ける。問題は、値を変えられるのはトップレベルオブジェクトだけではないことです。リストを含むタプルもキーとして使えます。全てを辞書のキーとして導入すると、そこから到達可能な全てのオブジェクトに読み込み専用のマークを付ける必要があります - そして再び、自己参照オブジェクトが無限ループを引き起こします。</p>
</li>
</ul>
<p>必要ならばこれを回避する方法がありますが、自己責任のもとで行ってください。ミュータブルな構造を、<a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><tt class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></tt></a> と <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><tt class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></tt></a> メソッドの両方を持つクラスインスタンスに含めることができます。その時、辞書 (またはハッシュに基づく別の構造体) に属するような全てのラッパーオブジェクトのハッシュ値が、そのオブジェクトが辞書 (その他の構造体) 中にある間固定され続けることを確実にしてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ListWrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">=</span> <span class="n">the_list</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">the_list</span>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">98767</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">*</span><span class="mi">555</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">%</span> <span class="mi">9999999</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1001</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">%</span> <span class="mi">7777777</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">333</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>なお、リストのメンバーの中にハッシュ化できないものがある可能性や、算術オーバーフローの可能性から、ハッシュ計算は複雑になります。</p>
<p>さらに、そのオブジェクトが辞書に含まれるか否かにかかわらず、<tt class="docutils literal"><span class="pre">o1</span> <span class="pre">==</span> <span class="pre">o2</span></tt>
(すなわち <tt class="docutils literal"><span class="pre">o1.__eq__(o2)</span> <span class="pre">が真</span></tt>) ならばいつでも
<tt class="docutils literal"><span class="pre">hash(o1)</span> <span class="pre">==</span> <span class="pre">hash(o2)</span></tt> (すなわち <tt class="docutils literal"><span class="pre">o1.__hash__()</span> <span class="pre">==</span> <span class="pre">o2.__hash__</span></tt>)
でなくてはなりません。その制限に適合できなければ、辞書やその他のハッシュに基づく構造体は間違いを起こします。</p>
<p>この ListWrapper の例では、異常を避けるため、ラッパオブジェクトが辞書内にある限りラップされたリストが変更されてはなりません。この条件と満たせなかった時の結果について知恵を絞る覚悟がない限り、これをしてはいけません。よく考えてください。</p>
</div>
<div class="section" id="list-sort">
<h2>なぜ list.sort() はソートされたリストを返さないのですか？<a class="headerlink" href="#list-sort" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>パフォーマンスが問題となる状況では、ソートするためだけにリストのコピーを作るのは無駄が多いです。そこで、<tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> はインプレースにリストをソートします。このことを忘れないため、この関数はソートされたリストを返しません。こうすることで、ソートされたコピーが必要で、ソートされていないものも残しておきたいときに、うっかり上書きしてしまうようなことがなくなります。</p>
<p>Python 2.4 で、新しい関数 &#8211; <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><tt class="xref py py-func docutils literal"><span class="pre">sorted()</span></tt></a> &#8211; が追加されました。この関数は、与えられたイテレート可能から新しいリストを生成し、ソートして返します。例えば、辞書のキーをソートされた順序でイテレートする方法は:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mydict</span><span class="p">):</span>
    <span class="o">...</span> <span class="c"># do whatever with mydict[key]...</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>Python ではどのようにインタフェース仕様を特定し適用するのですか？<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C++ や Java のような言語が提供するような、モジュールに対するインタフェース仕様の特定は、モジュールのメソッドや関数の原型を表現します。インタフェースの特定がコンパイル時に適用されることが、大きなプログラムの構成に役立つと、広く感じられています。</p>
<p>Python 2.6 で、<a class="reference internal" href="../library/abc.html#module-abc" title="abc: PEP 3119 に基づいた抽象基底クラス"><tt class="xref py py-mod docutils literal"><span class="pre">abc</span></tt></a> モジュールが追加され、抽象基底クラス (Abstract Base Classes/ABCs) を定義できるようになりました。これにより、<a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a> や <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><tt class="xref py py-func docutils literal"><span class="pre">issubclass()</span></tt></a> を使って、あるインスタンスやクラスが特定の ABC を実装するかを調べられるようになりました。<a class="reference internal" href="../library/collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> モジュールによって、<tt class="xref py py-class docutils literal"><span class="pre">Iterable</span></tt>、
<tt class="xref py py-class docutils literal"><span class="pre">Container</span></tt> 、<tt class="xref py py-class docutils literal"><span class="pre">MutableMapping</span></tt> などの役立つ ABC が定義されています。</p>
<p>Python では、コンポーネントの適切なテスト規律によって、インタフェース仕様の多くの強みを活かせます。サブクラス化による問題を見つけるために使えるツール PyChecker もあります。</p>
<p>モジュールのための適切なテストスイートは、回帰テストを提供し、モジュールのインタフェース仕様や用例集としても役立ちます。多くの Python モジュールは、簡単な「自己テスト」を提供するスクリプトとして実行できます。複雑な外部インタフェースを使うモジュールさえ、外部インタフェースの細かい「スタブ」エミュレーションで単独にテストできることが多いです。<a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a> や <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュール、あるいはサードパーティのテストフレームワークで、モジュールのコードの全ての行に及ぶ徹底的なテストスイートを構成できます。</p>
<p>Python で大きくて複雑なアプリケーションを構築するとき、インタフェース仕様と同様に、適切なテスト規律も役立ちます。実際、インタフェース仕様ではテストできないプログラムの属性もあるので、それ以上にもなりえます。例えば、<tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt> メソッドは新しい要素をある内部リストの終わりに加えます。インタフェース仕様ではこの <tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt> の実装が実際にこれを行うかをテストできませんが、テストスイートならこの機能を簡単に確かめられます。</p>
<p>テストスイートを書くことはとても役に立ちますし、テストのしやすさという視点でコードを設計することにもつながります。テスト指向開発は、人気を増しつつある技法で、実際のコードを書き始める前に、最初からテストスイートの部品を書くことを求めます。もちろん、 Python で粗雑にテストケースを全く書かないこともできます。</p>
</div>
<div class="section" id="id14">
<h2>なぜオブジェクト間でデフォルト値が共有されるのですか？<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この種のバグがよく初心者プログラマに噛み付きます。この関数を考えてみてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>  <span class="c"># Danger: shared reference to one dict for all calls</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="o">...</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">mydict</span>
</pre></div>
</div>
<p>初めてこの関数を呼び出した時、<tt class="docutils literal"><span class="pre">mydict</span></tt> には一つの要素があります。二回目には、<tt class="docutils literal"><span class="pre">foo()</span></tt> が実行されるときに <tt class="docutils literal"><span class="pre">mydict</span></tt> には初めから一つの要素をすでに持っているので、<tt class="docutils literal"><span class="pre">mydict</span></tt> には二つの要素があります。</p>
<p>関数の呼び出しによって、デフォルトの値に対する新しいオブジェクトが作られるのだと予想しがちです。実はそうなりません。デフォルト値は、関数が定義されたときに一度だけ生成されます。この例の辞書のように、そのオブジェクトが変更されたとき、その後の関数の呼び出しは変更後のオブジェクトを参照します。</p>
<p>定義の時に、数、文字列、タプル、<tt class="docutils literal"><span class="pre">None</span></tt> など、イミュータブルなオブジェクトを使うと変更される危険がありません。辞書、リスト、クラスインスタンスなどのミュータブルなオブジェクトは混乱のもとです。</p>
<p>この性質から、ミュータブルなオブジェクトをデフォルト値として使わないプログラミング手法がいいです。代わりに、<tt class="docutils literal"><span class="pre">None</span></tt> をデフォルト値に使い、そのパラメタが <tt class="docutils literal"><span class="pre">None</span></tt> である時にだけ、関数の内部で新しいリスト/辞書/その他をつくるようにしてください。例えば、こう書かずに:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>こう書いてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mydict</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># create a new dict for local namespace</span>
</pre></div>
</div>
<p>この性質が便利なこともあります。時間のかかる計算を行う関数があるときに使われる一般的な技法は、関数が呼び出されるごとにパラメタと結果の値をキャッシュし、再び同じ値が要求されたらキャッシュされた値を返すというものです。これは &#8220;memoizing&#8221; と呼ばれ、このように実装されます:</p>
<div class="highlight-python"><pre># Callers will never provide a third parameter for this function.
def expensive (arg1, arg2, _cache={}):
    if (arg1, arg2) in _cache:
        return _cache[(arg1, arg2)]

    # Calculate the value
    result = ... expensive computation ...
    _cache[(arg1, arg2)] = result           # Store result in the cache
    return result</pre>
</div>
<p>デフォルト値の代わりに、辞書を含むグローバル変数も使えます。これは好みの問題です。</p>
</div>
<div class="section" id="goto">
<h2>なぜ goto が無いのですか？<a class="headerlink" href="#goto" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数の呼び出しをまたいでも動作する &#8220;構造化された goto&#8221; をまかなうものとして例外を使えます。C、Fortran、その他の言語での
&#8220;go&#8221; あるいは &#8220;goto&#8221; 構造の適切な用途は全て、例外で同じようなことををすれば便利であると、広く感じられています。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">label</span><span class="p">:</span> <span class="k">pass</span>  <span class="c"># declare a label</span>

<span class="k">try</span><span class="p">:</span>
     <span class="o">...</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">):</span> <span class="k">raise</span> <span class="n">label</span><span class="p">()</span>  <span class="c"># goto label</span>
     <span class="o">...</span>
<span class="k">except</span> <span class="n">label</span><span class="p">:</span>  <span class="c"># where to goto</span>
     <span class="k">pass</span>
<span class="o">...</span>
</pre></div>
</div>
<p>例外ではループ内へ跳ぶことはできませんが、どちらにしてもそれは goto の乱用と見なされるものです。使うのは控えてください。</p>
</div>
<div class="section" id="raw-r-strings">
<h2>なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？<a class="headerlink" href="#raw-r-strings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>正確には、奇数個のバックスラッシュで終わってはいけません。終わりの対になっていないバックスラッシュは、閉じ引用文字をエスケープし、終っていない文字列を残してしまいます。</p>
<p>raw 文字列は、独自にバックスラッシュの処理をしようとするプロセッサ
(主に正規表現エンジン) への入力を生成しやすいように設計されたものです。このようなプロセッサは、終端の対になっていないバックスラッシュを結局エラーとみなすので、raw 文字列はそれを認めません。その代わりに、バックスラッシュでエスケープすることで、引用文字を文字列として渡すことができます。r-string が意図された目的に使われるときに、この規則が役に立つのです。</p>
<p>Windows のパス名を構築するときには、Windows のシステムコールは普通のスラッシュも受け付けることを憶えておいてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;/mydir/file.txt&quot;</span><span class="p">)</span>  <span class="c"># works fine!</span>
</pre></div>
</div>
<p>DOS コマンドのパス名を構築するときには、例えばこの中のどれかを試してください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dir</span> <span class="o">=</span> <span class="s">r&quot;\this\is\my\dos\dir&quot;</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="s">r&quot;\this\is\my\dos\dir\ &quot;</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">this</span><span class="se">\\</span><span class="s">is</span><span class="se">\\</span><span class="s">my</span><span class="se">\\</span><span class="s">dos</span><span class="se">\\</span><span class="s">dir</span><span class="se">\\</span><span class="s">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="with">
<h2>属性の代入に &#8220;with&#8221; 文が使えないのはなぜですか？<a class="headerlink" href="#with" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python には、ブロックの実行を包む &#8216;with&#8217; 文があり、ブロックに入るときとブロックから出るときに、コードを呼び出します。以下のような構造を持つ言語があります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">obj</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>               <span class="c"># equivalent to obj.a = 1</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c"># obj.total = obj.total + 1</span>
</pre></div>
</div>
<p>Python では、このような構造は曖昧になるでしょう。</p>
<p>Object Pascal、Delphi、C++のような他の言語では、静的な型を使うので、曖昧な方法でも、どのメンバに代入されているのか分かります。これが静的型付けの要点です &#8211; コンパイラは <em>always</em> コンパイル時にすべての変数のスコープを知るのです。</p>
<p>Python は動的な型を使います。実行時にどの属性が参照されるか事前に分かりません。動作中にメンバ属性が追加あるいは除去されるかもしれません。これでは、単純に読むだけではどのアトリビュートが参照されているか分かりません。ローカルなのか、グローバルなのか、メンバ属性なのか。</p>
<p>例えば、以下の不完全なコード片を考えましょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">a</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<p>このコード片では、&#8221;a&#8221; は &#8220;x&#8221; というメンバ属性を持っていると仮定されています。しかし、Python ではインタプリタにはこの仮定を伝えられる仕組みはありません。
&#8220;a&#8221; が、例えば整数だったら、どうなってしまうでしょうか。
&#8220;x&#8221; という名前のグローバル変数があったら、それが with ブロックの中で使われるのでしょうか。この通り、Python の動的な特質から、このような選択はとても難しい物になっています。</p>
<p>しかし、&#8221;with&#8221; やそれに類する言語の機能の一番の利点 (コード量の削減) は、
Python では代入により簡単に手に入れられます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>こう書いてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ref</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
<span class="n">ref</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">ref</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">ref</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>Python では実行時に名前束縛が解決され、後者はその解決が一度で済むため、これには実行速度をあげる副作用もあります。</p>
</div>
<div class="section" id="if-while-def-class">
<h2>if/while/def/class 文にコロンが必要なのはなぜですか？<a class="headerlink" href="#if-while-def-class" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>主に可読性を高めるため (実験的な ABC 言語の結果の一つ) に、コロンが必要です:</p>
<div class="highlight-python"><pre>if a == b
    print a</pre>
</div>
<p>と:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">a</span>
</pre></div>
</div>
<p>を考えれば、後者のほうが少し読みやすいでしょう。さらに言えば、この FAQ の解答例は次のようになるでしょう。これは、英語の標準的な用法です。</p>
<p>他の小さな理由は、コロンによってエディタがシンタックスハイライトをしやすくなることです。手の込んだ解析をしなくても、コロンを探せばいつインデンテーションを増やすべきかを決められます。</p>
</div>
<div class="section" id="id15">
<h2>なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python では、リスト、タプル、辞書の最後の要素の後端にカンマをつけても良いことになっています:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,]</span>
<span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="s">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>  <span class="c"># last trailing comma is optional but good style</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを許すのには、いくつかの理由があります。</p>
<p>複数行にまたがるリスト、タプル、辞書にリテラル値を使っているとき、こうすれば前の行にカンマを加える必要がなくなるので、要素を加えやすくなります。構文エラーを引き起こすことなくエディタで行をソートできます。</p>
<p>間違えてカンマを落としてしまうと、診断しづらいエラーにつながります。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">&quot;fee&quot;</span><span class="p">,</span>
  <span class="s">&quot;fie&quot;</span>
  <span class="s">&quot;foo&quot;</span><span class="p">,</span>
  <span class="s">&quot;fum&quot;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>このリストには4つの要素があるように見えますが、実際には3つしかありません。&#8221;fee、&#8221;fiefoo&#8221;、&#8221;fum&#8221; です。いつもカンマを付けるようにすれば、この種のエラーが避けられます。</p>
<p>後端にカンマをつけても良いことにすれば、プログラムによるコード生成も簡単になります。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python よくある質問</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>