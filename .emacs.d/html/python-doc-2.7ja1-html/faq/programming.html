

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>プログラミング FAQ &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python よくある質問" href="index.html" />
    <link rel="next" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="prev" title="一般 Python FAQ" href="general.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python よくある質問</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#id1">一般的な質問</a></li>
<li><a class="reference internal" href="#id6">コア言語</a></li>
<li><a class="reference internal" href="#id17">数と文字列</a></li>
<li><a class="reference internal" href="#id24">シーケンス(タプル/リスト)</a></li>
<li><a class="reference internal" href="#id32">辞書</a></li>
<li><a class="reference internal" href="#id36">オブジェクト</a></li>
<li><a class="reference internal" href="#id46">モジュール</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="general.html"
                        title="前の章へ">一般 Python FAQ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="design.html"
                        title="次の章へ">デザインと歴史 FAQ</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/faq/programming.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="faq">
<h1><a class="toc-backref" href="#id50">プログラミング FAQ</a><a class="headerlink" href="#faq" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#faq" id="id50">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#id1" id="id51">一般的な質問</a><ul>
<li><a class="reference internal" href="#id2" id="id52">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a></li>
<li><a class="reference internal" href="#id3" id="id53">バグの発見や静的分析に役立つツールはありますか？</a></li>
<li><a class="reference internal" href="#python" id="id54">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a></li>
<li><a class="reference internal" href="#id4" id="id55">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a></li>
<li><a class="reference internal" href="#id5" id="id56">プログラムが遅すぎます。どうしたら速くなりますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6" id="id57">コア言語</a><ul>
<li><a class="reference internal" href="#unboundlocalerror" id="id58">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a></li>
<li><a class="reference internal" href="#id7" id="id59">Python のローカルとグローバル変数のルールは何ですか？</a></li>
<li><a class="reference internal" href="#id8" id="id60">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#import" id="id61">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a></li>
<li><a class="reference internal" href="#id9" id="id62">オプションパラメタやキーワードパラメタを関数から関数へ渡すにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id10" id="id63">パラメタを出力する関数 (参照渡し) はどのように書きますか？</a></li>
<li><a class="reference internal" href="#id11" id="id64">Python で高次関数はどのようにつくりますか？</a></li>
<li><a class="reference internal" href="#id12" id="id65">Python のオブジェクトはどのようにコピーしますか？</a></li>
<li><a class="reference internal" href="#id13" id="id66">オブジェクトのメソッドや属性はどのように見つけますか？</a></li>
<li><a class="reference internal" href="#id14" id="id67">コードはどのようにオブジェクトの名前を見つけるのですか？</a></li>
<li><a class="reference internal" href="#id15" id="id68">カンマ演算子はなぜ優先されるのですか？</a></li>
<li><a class="reference internal" href="#is-there-an-equivalent-of-c-s-ternary-operator" id="id69">Is there an equivalent of C&#8217;s &#8221;?:&#8221; ternary operator?</a></li>
<li><a class="reference internal" href="#id16" id="id70">Python で解し難いワンライナーを書くことはできますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17" id="id71">数と文字列</a><ul>
<li><a class="reference internal" href="#id18" id="id72">十六進数や八進数を指定するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id19" id="id73">なぜ -22 // 10 は -3 を返すのですか？</a></li>
<li><a class="reference internal" href="#id20" id="id74">文字列を数に変換するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id21" id="id75">数を文字列に変換するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id22" id="id76">文字列をインプレースに変更するにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id23" id="id77">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#perl-chomp" id="id78">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a></li>
<li><a class="reference internal" href="#scanf-sscanf" id="id79">scanf() や sscanf() と同等なものはありますか？</a></li>
<li><a class="reference internal" href="#unicodeerror-ascii-decoding-encoding-error-ordinal-not-in-range-128" id="id80">&#8216;UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)&#8217; とはどういう意味ですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id24" id="id81">シーケンス(タプル/リスト)</a><ul>
<li><a class="reference internal" href="#id25" id="id82">タプル、リスト間の変更はどのようにするのですか？</a></li>
<li><a class="reference internal" href="#id26" id="id83">インデクスが負の場合はどうなりますか？</a></li>
<li><a class="reference internal" href="#id27" id="id84">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id28" id="id85">リストから重複を取り除くにはどうしますか？</a></li>
<li><a class="reference internal" href="#id29" id="id86">Python で配列を作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#id30" id="id87">多次元のリストを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#id31" id="id88">オブジェクトのシーケンスにメソッドを適用するにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id32" id="id89">辞書</a><ul>
<li><a class="reference internal" href="#id33" id="id90">キーを安定した順序で表示する辞書を作るにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#id34" id="id91">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a></li>
<li><a class="reference internal" href="#id35" id="id92">リストを別のリストの値によってソートするにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id36" id="id93">オブジェクト</a><ul>
<li><a class="reference internal" href="#id37" id="id94">クラスとは何ですか？</a></li>
<li><a class="reference internal" href="#id38" id="id95">メソッドとは何ですか？</a></li>
<li><a class="reference internal" href="#self" id="id96">self とは何ですか？</a></li>
<li><a class="reference internal" href="#id39" id="id97">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a></li>
<li><a class="reference internal" href="#id40" id="id98">委譲とは何ですか？</a></li>
<li><a class="reference internal" href="#id41" id="id99">基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？</a></li>
<li><a class="reference internal" href="#id42" id="id100">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a></li>
<li><a class="reference internal" href="#id43" id="id101">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#id44" id="id102">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#spam-someclassname-spam" id="id103">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a></li>
<li><a class="reference internal" href="#del" id="id104">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a></li>
<li><a class="reference internal" href="#id45" id="id105">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id46" id="id106">モジュール</a><ul>
<li><a class="reference internal" href="#pyc" id="id107">.pyc ファイルを作るにはどうしますか？</a></li>
<li><a class="reference internal" href="#id47" id="id108">現在のモジュール名を知るにはどうしますか？</a></li>
<li><a class="reference internal" href="#id48" id="id109">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a></li>
<li><a class="reference internal" href="#import-x-y-z-module-x-z" id="id110">__import__(&#8216;x.y.z&#8217;) は &lt;module &#8216;x&#8217;&gt; を返しますが、z を得るためにはどうしますか？</a></li>
<li><a class="reference internal" href="#id49" id="id111">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id51">一般的な質問</a><a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id52">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a><a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>pdb モジュールは簡素にして十分な Python のコンソールモードデバッガです。これは Python の標準ライブラリに含まれているもので、
<a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: 対話的インタプリタのためのPythonデバッガ。"><tt class="xref py py-mod docutils literal"><span class="pre">ライブラリリファレンスマニュアルにドキュメントがあります</span></tt></a>。
pdb のコードを手本にして自分用のデバッガを書くこともできます。</p>
<p>Python に同梱されている統合開発環境の IDLE は 通常の Python の配布形態の一部 (普通は Tools/scripts/idle から利用可能) であり、グラフィカルなデバッガを含んでいます。IDLE デバッガのドキュメントは
<a class="reference external" href="http://www.python.org/idle/doc/idle2.html#Debugger">http://www.python.org/idle/doc/idle2.html#Debugger</a> にあります。</p>
<p>PythonWin は、pdb をベースとした GUI デバッガを含む Python IDE です。
Pythonwin デバッガは、ブレークポイントの色付けや非 Pythonwin プログラムのデバッグなどのたくさんの素敵な機能を持っています。Pythonwin は <a class="reference external" href="http://sourceforge.net/projects/pywin32/">Python
for Windows Extensions</a>
プロジェクトの一部、あるいは ActivePython ディストリビューション
(<a class="reference external" href="http://www.activestate.com/Products/ActivePython/index.html">http://www.activestate.com/Products/ActivePython/index.html</a> を参照) の一部として利用可能です。</p>
<p><a class="reference external" href="http://boa-constructor.sourceforge.net/">Boa Constructor</a> は、
wxWidgets を使った IDE と GUI ビルダーです。これは視覚フレームの作成と操作、オブジェクト検査、オブジェクトブラウザのような多くのビュー、継承構造、
doc string から生成される html ドキュメント、高度なデバッガ、総合ヘルプ、
Zope のサポートを提供します。</p>
<p><a class="reference external" href="http://www.die-offenbachs.de/eric/index.html">Eric</a> は
PyQt や Scintilla editing component をもとにした IDE です。</p>
<p>Pydb は標準のデバッガである pdb を人気のグラフィカルデバッガフロントエンドである DDD (Data Display Debugger) とともに使うために改変したものです。Pydb は <a class="reference external" href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a> に、
DDD は <a class="reference external" href="http://www.gnu.org/software/ddd">http://www.gnu.org/software/ddd</a> にあります。</p>
<p>商業のグラフィカルデバッガ付き Python IDE もあります。例えば:</p>
<ul class="simple">
<li>Wing IDE (<a class="reference external" href="http://wingware.com/">http://wingware.com/</a>)</li>
<li>Komodo IDE (<a class="reference external" href="http://www.activestate.com/Products/Komodo">http://www.activestate.com/Products/Komodo</a>)</li>
</ul>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id53">バグの発見や静的分析に役立つツールはありますか？</a><a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。</p>
<p>PyChecker は Python ソースコードのバグを発見しコードの複雑さとスタイルについて警告する静的解析ツールです。PyChecker は
<a class="reference external" href="http://pychecker.sf.net">http://pychecker.sf.net</a> から手に入ります。</p>
<p><a class="reference external" href="http://www.logilab.org/projects/pylint">Pylint</a> は、モジュールがコーディング標準を満たすかを調べ、プラグインを書いてカスタム機能を加えられるようにするツールです。PyChecker が行うバグチェックに加え、
Pylint は行の長さ、変数名が一貫しているか、宣言されたインタフェースが完全に実装されているか、などを確かめる追加の機能を提供します。
<a class="reference external" href="http://www.logilab.org/card/pylint_manual">http://www.logilab.org/card/pylint_manual</a> から Pylint の機能の一覧を見られます。</p>
</div>
<div class="section" id="python">
<h3><a class="toc-backref" href="#id54">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a><a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザがダウンロードや起動のために Python ディストリビューションをインストールしなくてもよいスタンドアロンプログラムのためだけなら、
Python を C コードにコンパイルできる必要はありません。プログラムに対して必要なモジュールを選び、そのモジュールを Python バイナリに束縛して一つの実行可能ファイルにまとめる多くのツールがあります。</p>
<p>一つは freeze ツールで、Python ソースツリーに <tt class="docutils literal"><span class="pre">Tools/freeze</span></tt> として含まれています。これは Python バイトコードを C 配列に変換します。すべてのモジュールを標準 Python モジュールにリンクされる新しいプログラムに埋め込む C コンパイラです。</p>
<p>これはあなたのソースの (両方の形式の) import 文を再帰的にスキャンして、
import されたモジュールを標準の Python パスと (組み込みモジュールのある)
ソースディレクトリから探します。そして Python で書かれたモジュールのバイトコードを C コード (marshal モジュールでコードオブジェクトに変換できる配列) に変換し、実際にそのプログラム内で使われている組み込みモジュールだけが含まれたカスタムメイドの設定ファイルを作成します。そして生成された C コードをコンパイルして Python インタプリタの残りとリンクし、元のスクリプトと全く同じように動作する自己充足的なバイナリを形成します。</p>
<p>もちろん、凍結には C コンパイラが必要です。C コンパイラを必要としない選択肢もあります。その一つは、Thomas Heller の py2exe (Windows 専用) です。</p>
<blockquote>
<div><a class="reference external" href="http://www.py2exe.org/">http://www.py2exe.org/</a></div></blockquote>
<p>他に、 Christian Tismer の <a class="reference external" href="http://starship.python.net/crew/pirx">SQFREEZE</a>
は、実行可能ファイルのバイトコードを探すことができる特別な Python
インタプリタにバイトコードを加えます。</p>
<p>その他のツールには、Fredrik Lundh の <a class="reference external" href="http://www.pythonware.com/products/python/squeeze">Squeeze</a> や Anthony Tuininga の
<a class="reference external" href="http://starship.python.net/crew/atuining/cx_Freeze/index.html">cx_Freeze</a>
などがあります。</p>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id55">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a><a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。標準ライブラリモジュールに求められるコーディングスタイルは <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a>
として文書化されています。</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id56">プログラムが遅すぎます。どうしたら速くなりますか？</a><a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般に、それは難しい質問です。Python コードを速くするためには、いろいろな手法があります。最終手段として一部を C で書き直す事も考えてください。</p>
<p>Python を自動的に C や x86 アセンブリ言語に変換できる場合もあります。この場合、速度を上げるためにコードを変更する必要はありません。</p>
<p><a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex</a> は
Python コードの少し変化した版を C 拡張にコンパイルでき、多様なプラットフォームで使えます。</p>
<p><a class="reference external" href="http://psyco.sourceforge.net">Psyco</a> は Python コードを x86 アセンブリ言語に変換する実行時コンパイラです。これを使うことが出来れば、重要な関数を劇的にスピードアップできます。</p>
<p>あとは、Python コードからもう少し速度を搾り出すための様々な手法について議論することになります。コード中の特定の関数が処理が集中するホットスポットで、最適化が必要であると認められない限り、<em>決して</em> いかなる最適化の手法も使わないでください。最適化はたいていコードを分かりづらくするので、分かりづらさのコスト (開発時間の延長とバグの可能性の増大) がそれに見合ったパフォーマンスの向上につながらないのであれば元が取れません。</p>
<p><a class="reference external" href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">performance tips</a>
に関するページが wiki にあります。</p>
<p>Guido van Rossum は <a class="reference external" href="http://www.python.org/doc/essays/list2str.html">http://www.python.org/doc/essays/list2str.html</a> で最適化に関する逸話を詳述しています。</p>
<p>なお、関数や(特に)メソッドの呼び出しはかなり高価です。インスタンス変数を
get や set したり他のメソッドを呼び出す程度の小さな関数がたくさんある純粋 OO インタフェースをデザインしているなら、インスタンス変数に直接アクセスするようなもっと直接的な方法も考えてみてください。また、どのプログラムが実行時間の大部分を占めているかを見つける標準モジュール
<a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><tt class="xref py py-mod docutils literal"><span class="pre">profile</span></tt></a> も参照してください (ちょっと忍耐できればの話ですが -
プロファイリングはそれ自体がプログラムを一桁ほど遅くしてしまいます)。</p>
<p>もちろん、他のプログラミングの経験から得られた多くの標準的な最適化の発見的手法は Python にもよく当てはまることが多いです。たとえば、出力装置に出力を送るときに、一度に少なく書くよりもむしろ多く書いたほうが、カーネルのシステムコールのオーバーヘッドを減らすことができて、速くなるでしょう。したがって、CGI スクリプトは &#8220;一発&#8221; ですべて書き出すもののほうが小さなたくさんの出力に分けて書き出すものよりも速くなるでしょう。</p>
<p>また、必ず Python のコアな機能を適切に使ってください。例えば、スライシングなら、リストや他のシーケンスオブジェクトを、高度に最適化された
C 実装で、インタプリタのメインループの一刻みで細切れにできます。こうして効果を得ることができる例は:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L2</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
    <span class="n">L2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>こう使えばずっと短く、ずっと速くできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">L1</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>  <span class="c"># &quot;list&quot; is redundant if L1 is a list.</span>
</pre></div>
</div>
<p>関数指向組み込み関数 <a class="reference internal" href="../library/functions.html#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a> や <a class="reference internal" href="../library/functions.html#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a> なども一つのタスクを実行するためのループを加速するのに便利であることに注意してください。例えば、二つのリストの要素を組み合わせるためには:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
</pre></div>
</div>
<p>また、正弦を一度に計算するには:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">[0.841470984808, 0.909297426826, 0.14112000806, -0.756802495308]</span>
</pre></div>
</div>
<p>このような場合には素早く演算が完了します。</p>
<p>その他の例には、<a class="reference internal" href="../library/stdtypes.html#string-methods"><em>文字列オブジェクトのメソッド</em></a>
<tt class="docutils literal"><span class="pre">join()</span></tt> 、<tt class="docutils literal"><span class="pre">split()</span></tt> などが挙げられます。</p>
<p>例えば s1..s7 が大きな (10K+) 文字列の時、<tt class="docutils literal"><span class="pre">&quot;&quot;.join([s1,s2,s3,s4,s5,s6,s7])</span></tt>
は単純に <tt class="docutils literal"><span class="pre">s1+s2+s3+s4+s5+s6+s7</span></tt> とするよりもはるかに速くなるでしょう。なぜなら、<tt class="docutils literal"><span class="pre">join()</span></tt> はすべてのコピーを一括して行うのに対し、「足し算」が多くの副演算を行うからです。文字列を扱うには、
<a class="reference internal" href="../library/stdtypes.html#string-methods"><em>文字列オブジェクトのメソッド</em></a> <tt class="docutils literal"><span class="pre">replace()</span></tt>、
<tt class="docutils literal"><span class="pre">format()</span></tt>  を使ってください。正規表現を使うのは、決まった文字列のパターンを使わない時だけにしてください。
<a class="reference internal" href="../library/stdtypes.html#string-formatting"><em>旧式の % 演算</em></a> <tt class="docutils literal"><span class="pre">string</span> <span class="pre">%</span> <span class="pre">tuple</span></tt> と
<tt class="docutils literal"><span class="pre">string</span> <span class="pre">%</span> <span class="pre">dictionary</span></tt> も使えます。</p>
<p>ソートには必ずビルトインオブジェクトの <tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> を使ってください。また、<a class="reference external" href="http://wiki.python.org/moin/HowTo/Sorting">sorting mini-HOWTO</a> の少し高度な使い方の例を参照してください。<tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> は、よほど極端な状況でない限り、他のソートの技術に勝ります。</p>
<p>「ループを関数やメソッドの中に入れ込む」というのも一般的な手法です。例えば、遅いプログラムがあって、Python の <tt class="docutils literal"><span class="pre">ff()</span></tt> 関数が何度も呼ばれていることがプロファイラで分かったとします。もし、<tt class="docutils literal"><span class="pre">ff()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span> <span class="c"># do something with x computing result...</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>が:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">list</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ff</span><span class="p">,</span> <span class="n">oldlist</span><span class="p">)</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">ff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="o">...</span> <span class="c"># do something with value...</span>
</pre></div>
</div>
<p>のようにループの中で呼ばれていることが多いなら、<tt class="docutils literal"><span class="pre">ff()</span></tt> を:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">ffseq</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="n">resultseq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="o">...</span> <span class="c"># do something with x computing result...</span>
        <span class="n">resultseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resultseq</span>
</pre></div>
</div>
<p>のように、また、上の二つの例を、<tt class="docutils literal"><span class="pre">list</span> <span class="pre">=</span> <span class="pre">ffseq(oldlist)</span></tt> と:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ffseq</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span> <span class="c"># do something with value...</span>
</pre></div>
</div>
<p>のように書き換えることによって、関数を呼ぶためのオーバーヘッドを省けることが多いです。</p>
<p><tt class="docutils literal"><span class="pre">ff(x)</span></tt> を一回だけ呼ぶ場合、 <tt class="docutils literal"><span class="pre">ffseq([x])[0]</span></tt> に直してしまうとちょっと不利になります。 もちろん、このテクニックがいつでも適切であるわけではありませんし、解決のための他の方法もあります。</p>
<p>関数やメソッドの探索の結果をローカル変数に明示的に保存すると少しパフォーマンスが良くなります。次のようなループ:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">token</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>は、繰り返しのたびに <tt class="docutils literal"><span class="pre">dict.get</span></tt> を求めています。 このメソッドが変わることがないのなら、少し速い実装は:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dict_get</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span>  <span class="c"># look up the method once</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">token</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>デフォルト引数は、実行時でなく、コンパイル時に値を一回で決めてしまうのに使えます。これは、プログラムの実行中に変化しない関数やオブジェクト、例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">degree_sin</span><span class="p">(</span><span class="n">deg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deg</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span>
</pre></div>
</div>
<p>を、次のように置き換えるときにのみ行えます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">degree_sin</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">sin</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">deg</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>
</pre></div>
</div>
<p>この手法はデフォルト引数が変えられないことを前提に使うので、ユーザーが API で混乱するおそれがないときのみ使えます。</p>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id57">コア言語</a><a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="unboundlocalerror">
<h3><a class="toc-backref" href="#id58">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a><a class="headerlink" href="#unboundlocalerror" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もともと動いていたコードが、関数の本体のどこかに代入文を加えるという変更をしたら UnboundLocalError を出すのには驚くかもしれません。</p>
<p>このコード:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>は動きますが、このコード:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>は UnboundLocalError になります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">UnboundLocalError</span>: <span class="n-Identifier">local variable &#39;x&#39; referenced before assignment</span>
</pre></div>
</div>
<p>これは、あるスコープの中で変数に代入を行うとき、その変数はそのスコープに対してローカルになり、外のスコープにある同じ名前の変数を隠すからです。
foo の最後の文が <tt class="docutils literal"><span class="pre">x</span></tt> に新しい値を代入しているので、コンパイラはこれをローカル変数であると認識します。その結果、先の <tt class="docutils literal"><span class="pre">print</span> <span class="pre">x</span></tt> が初期化されていないローカル変数を表示しようとして結果はエラーとなります。</p>
<p>上の例では、グローバルであると宣言することで外のスコープにアクセスできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foobar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>この明示的な宣言は (表面的には似ているクラスとインスタンス変数の例とは違って)
あなたは実際は他のスコープの変数の値を変えようとしているのだ、ということを知らせるのに必要です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span>
<span class="go">11</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id59">Python のローカルとグローバル変数のルールは何ですか？</a><a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python では、関数の中で参照のみされる変数は暗黙のうちにグローバルになります。関数の本体のどこかで新しい値が変数に代入されたなら、それはローカルであるとみなされます。関数の中で新しい値が一度でも代入されたらその変数は暗黙のうちにローカルであり、&#8217;global&#8217; は明示的に宣言しなければなりません。</p>
<p>最初はちょっと驚くでしょうが、少し考えると納得できます。一方では、代入された変数に <a class="reference internal" href="../reference/simple_stmts.html#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> を要求することで、意図しない副作用を防げます。他方では、グローバルな参照の度に <tt class="docutils literal"><span class="pre">global</span></tt> が要求されてしまうと、
<tt class="docutils literal"><span class="pre">global</span></tt> を使ってばかりになってしまいます。ビルトイン関数やインポートされたモジュールの内容を参照するたびにグローバル宣言をしなければならないのです。その乱雑さは副作用を特定するための <tt class="docutils literal"><span class="pre">global</span></tt> 宣言の便利さよりも重大です。</p>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id60">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a><a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一つのプログラムのモジュール間で情報を共有する正準な方法は、特別なモジュール (しばしば config や cfg と呼ばれる) を作ることです。単に設定モジュールをアプリケーションのすべてのモジュールにインポートしてください。このモジュールはグローバルな名前として使えます。それぞれのモジュールのただ一つのインスタンスがあるので、設定モジュールオブジェクトに対するいかなる変更も全体に反映されます。例えば:</p>
<p>config.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Default value of the &#39;x&#39; configuration setting</span>
</pre></div>
</div>
<p>mod.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>main.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">mod</span>
<span class="k">print</span> <span class="n">config</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>なお、同じ理由から、モジュールを使うということは、シングルトンデザインパターンを実装することの基礎でもあります。</p>
</div>
<div class="section" id="import">
<h3><a class="toc-backref" href="#id61">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a><a class="headerlink" href="#import" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般に、<tt class="docutils literal"><span class="pre">from</span> <span class="pre">modulename</span> <span class="pre">import</span> <span class="pre">*</span></tt> を使わないでください。使うとインポータの名前空間を混乱させてしまいます。この書式でインポートされるように設計された数少ないモジュールにすらこの構文を使わないようにする人もいます。そのように設計されたモジュールには <a class="reference internal" href="../library/tkinter.html#module-Tkinter" title="Tkinter: グラフィカルユーザインタフェースを実現する Tcl/Tk へのインタフェース"><tt class="xref py py-mod docutils literal"><span class="pre">Tkinter</span></tt></a> や <a class="reference internal" href="../library/threading.html#module-threading" title="threading: 高水準のスレッドインタフェース"><tt class="xref py py-mod docutils literal"><span class="pre">threading</span></tt></a> などがあります。</p>
<p>モジュールはファイルの先頭でインポートしてください。これによってコードが必要とする他のモジュールが明確になり、モジュール名がスコープに含まれるかどうかに迷わなくなります。行に一つのインポートにすると、モジュールのインポートの追加と削除が容易になりますが、行に複数のインポートにすると画面の領域が少なく済みます。</p>
<p>次の手順でモジュールをインポートするのが、良いプラクティスになります:</p>
<ol class="arabic simple">
<li>標準ライブラリモジュール &#8211; 例 <tt class="docutils literal"><span class="pre">sys</span></tt>、<tt class="docutils literal"><span class="pre">os</span></tt>、<tt class="docutils literal"><span class="pre">getopt</span></tt>、<tt class="docutils literal"><span class="pre">re</span></tt></li>
<li>サードパーティのライブラリモジュール (Python の site-packages
ディレクトリにあるもの) &#8211; 例 mx.DateTime、ZODB、PIL.Image、など</li>
<li>内部で開発したモジュール</li>
</ol>
<p>相対インポートは決して使わないでください。<tt class="docutils literal"><span class="pre">package.sub.m1</span></tt> モジュールのコードを書いていて、<tt class="docutils literal"><span class="pre">package.sub.m2</span></tt> をインポートしようとするとき、
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">m2</span></tt> とだけ書くのは、違反ではありませんがやらないでください。代わりに <tt class="docutils literal"><span class="pre">from</span> <span class="pre">package.sub</span> <span class="pre">import</span> <span class="pre">m2</span></tt> と書いてください。詳細は <span class="target" id="index-1"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> を参照してください。</p>
<p>循環参照の問題を避けるために、インポートを関数やクラスに移すことが必要なときもあります。Gordon McMillan によれば:</p>
<blockquote>
<div>循環参照は両方のモジュールが &#8220;import &lt;module&gt;&#8221; 形式のインポートを使っていれば大丈夫です。二つ目のモジュールが最初のモジュールから名前を確保しようとして (&#8220;from module import name&#8221;)、そのインポートがトップレベルにあると駄目です。最初のモジュールが二つ目のモジュールをインポートするのに忙しくて、最初のモジュールの名前が利用可能になっていないからです。</div></blockquote>
<p>この状況では、二つ目のモジュールが一つの関数の中でのみ使われているならば、そのインポートは簡単に関数の中に移せます。インポートが呼ばれたとき、最初のモジュールは初期化を完了していて、二つ目のモジュールは自分のインポートをできます。</p>
<p>プラットフォーム依存のモジュールがあるときには、インポートをトップレベルの外に動かすことも必要です。この場合、ファイルの先頭ではすべてのモジュールをインポートすることさえできないかもしれません。この場合は、対応するプラットフォームに合わせたコードで正しいモジュールをインポートすることを選ぶと良いです。</p>
<p>循環参照の問題を避けたりモジュールの初期化にかかる時間を減らしたりしたいなら、単にインポートを関数定義の中などのローカルなスコープに移してください。この手法は多くのインポートがプログラムがどのように実行されるかに依存しなくてよいときに特に有効です。ある関数の中でのみモジュールが使われるのなら、インポートをその関数の中に移すことを考えてもいいでしょう。なお、モジュールを読み込む最初の回はモジュールの初期化の時間のために高価になりえますが、複数回目にモジュールを読み込むのは事実上無料、辞書探索の数回のコストだけで済みます。モジュール名がスコープから外れてさえ、そのモジュールはおそらく
<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> から利用できるでしょう。</p>
<p>特定のクラスのインスタンスのみがあるモジュールを使っているなら、そのクラスの <tt class="docutils literal"><span class="pre">__init__</span></tt> メソッドでそのモジュールをインポートし、そこでインスタンス変数にそのモジュールを代入して、オブジェクトがある間そのモジュールがいつでも (インスタンス変数を経由して) 利用できるようにするのが合理的です。なお、インポートをクラスが初期化される時まで先送りにするためには、インポートはメソッドの中にないといけません。インポートをクラスの中に入れてもメソッドの外に出してしまうと、そのインポートはモジュールの初期化の時になされてしまいます。</p>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id62">オプションパラメタやキーワードパラメタを関数から関数へ渡すにはどうしたらいいですか？</a><a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数のパラメタリストに引数を <tt class="docutils literal"><span class="pre">*</span></tt> と <tt class="docutils literal"><span class="pre">**</span></tt> 指定子 (specifier) で集めてください。そうすれば、固定引数をタプルとして、キーワード引数を辞書として得られます。これで、他の関数を呼び出すときに <tt class="docutils literal"><span class="pre">*</span></tt> と <tt class="docutils literal"><span class="pre">**</span></tt> を使ってそれらの引数を渡せます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>あまりありませんが、Python の 2.0 以前のバージョンを考慮するときは、代わりに <a class="reference internal" href="../library/functions.html#apply" title="apply"><tt class="xref py py-func docutils literal"><span class="pre">apply()</span></tt></a> を使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="nb">apply</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id63">パラメタを出力する関数 (参照渡し) はどのように書きますか？</a><a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前提として、Python では引数は代入によって渡されます。代入はオブジェクトへの参照を作るだけなので、呼び出し元と呼び出し先にある引数名の間にエイリアスはありませんし、参照渡しそれ自体はありません。望む効果を得るためには幾つかの方法があります。</p>
<ol class="arabic">
<li><p class="first">結果のタプルを返すことによって:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">&#39;new-value&#39;</span>        <span class="c"># a and b are local names</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>              <span class="c"># assigned to new objects</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>            <span class="c"># return new values</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="s">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">func2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">print</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>                 <span class="c"># output: new-value 100</span>
</pre></div>
</div>
<p>これはたいてい一番明確な方法です。</p>
</li>
<li><p class="first">グローバル変数を使って。これはスレッドセーフでないので、推奨されません。</p>
</li>
<li><p class="first">ミュータブルな (インプレースに変更可能な) オブジェクトを渡すことによって:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;new-value&#39;</span>     <span class="c"># &#39;a&#39; references a mutable list</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c"># changes a shared object</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="n">func1</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">print</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="c"># output: new-value 100</span>
</pre></div>
</div>
</li>
<li><p class="first">変更される辞書に渡すことによって:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">func3</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;new-value&#39;</span>     <span class="c"># args is a mutable dictionary</span>
    <span class="n">args</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c"># change it in-place</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="s">&#39; old-value&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span>
<span class="n">func3</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">print</span> <span class="n">args</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">クラスインスタンスに値を同梱することによって:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">callByRef</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func4</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s">&#39;new-value&#39;</span>        <span class="c"># args is a mutable callByRef</span>
    <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c"># change object in-place</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">callByRef</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s">&#39;old-value&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
<span class="n">func4</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">print</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>このような複雑なことをする理由はめったに無いでしょう。</p>
</li>
</ol>
<p>一番の選択は、複数の結果を含むタプルを返すことです。</p>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id64">Python で高次関数はどのようにつくりますか？</a><a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つの方法があります: ネストされたスコープを使う方法と、呼び出し可能オブジェクトを使う方法です。例えば、<tt class="docutils literal"><span class="pre">a*x+b</span></tt> の値を計算する
<tt class="docutils literal"><span class="pre">f(x)</span></tt> 関数を返す <tt class="docutils literal"><span class="pre">linear(a,b)</span></tt> を定義したいとします。ネストされたスコープを使うと:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>また、呼び出し可能オブジェクトを使うと:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">linear</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>どちらの場合でも:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">taxes</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>とすれば、<tt class="docutils literal"><span class="pre">taxes(10e6)</span> <span class="pre">==</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">10e6</span> <span class="pre">+</span> <span class="pre">2</span></tt> となるような呼び出し可能オブジェクトを得られます。</p>
<p>呼び出し可能オブジェクトを使う方法は、少し遅くなり、わずかにコードが長くなるという短所があります。ですが、継承を使ってコーラブル同士で記号を共有することもできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">exponential</span><span class="p">(</span><span class="n">linear</span><span class="p">):</span>
    <span class="c"># __init__ inherited</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>オブジェクトはいくつかのメソッドに状態をカプセル化できます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">counter</span><span class="p">:</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">down</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">set</span>
</pre></div>
</div>
<p>ここで、<tt class="docutils literal"><span class="pre">inc()</span></tt>、<tt class="docutils literal"><span class="pre">dec()</span></tt> 、<tt class="docutils literal"><span class="pre">reset()</span></tt> は同じカウント変数を共有する関数のようにふるまいます。</p>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id65">Python のオブジェクトはどのようにコピーしますか？</a><a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的に、普通は <a class="reference internal" href="../library/copy.html#copy.copy" title="copy.copy"><tt class="xref py py-func docutils literal"><span class="pre">copy.copy()</span></tt></a> や <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><tt class="xref py py-func docutils literal"><span class="pre">copy.deepcopy()</span></tt></a> を試してください。何でもコピーできるとは限りませんが、たいていはできます。</p>
<p>もっと簡単にコピーできるオブジェクトもあります。辞書には <a class="reference internal" href="../library/stdtypes.html#dict.copy" title="dict.copy"><tt class="xref py py-meth docutils literal"><span class="pre">copy()</span></tt></a>
メソッドがあります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">newdict</span> <span class="o">=</span> <span class="n">olddict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>シーケンスはスライシングでコピーできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id66">オブジェクトのメソッドや属性はどのように見つけますか？</a><a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザー定義クラスのインスタンス x で、<tt class="docutils literal"><span class="pre">dir(x)</span></tt> はインスタンス属性とそのクラスで定義されたメソッドや属性を含む名前のアルファベット順リストを返します。</p>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id67">コードはどのようにオブジェクトの名前を見つけるのですか？</a><a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>概して、オブジェクトは本当は名前を持たないので、見つけることはできません。本質的には、代入とはいつも値に名前を束縛することです。<tt class="docutils literal"><span class="pre">def</span></tt> と <tt class="docutils literal"><span class="pre">class</span></tt> 文も同じですが、この場合は値はコーラブルです。以下のコードを考えてみましょう:</p>
<div class="highlight-python"><pre>class A:
    pass

B = A

a = B()
b = a
print b
&lt;__main__.A instance at 0x16D07CC&gt;
print a
&lt;__main__.A instance at 0x16D07CC&gt;</pre>
</div>
<p>おそらく、このクラスには名前があります。このクラスは二つの名前に縛られて、名前 B を通して呼び出されますが、それでもクラス A のインスタンスとして報告されるのです。しかし、両方の名前が同じ値に束縛されている以上、このインスタンスの名前が a か b か決めることはできないのです。</p>
<p>概して、コードにとってある値の「名前を知っている」事は重要ではありません。あなたがわざと内省的なコードを書いているのでない限り、方針を変えた方がいいかもしれないということになるでしょう。</p>
<p>comp.lang.python で、Fredrik Lundh はこの問題の答えとして素晴らしい喩えをしてくれました:</p>
<blockquote>
<div><p>玄関にいた猫の名前を知るのと同じ方法です: その猫 (オブジェクト) 自体はその名前を言うことができないし、それは実は問題ではありません &#8211;
その猫が何と呼ばれているかを知る唯一の方法は、すべての隣人 (名前空間) にその猫(オブジェクト)が何と呼ばれているかを聞くことです。</p>
<p>……そして、その猫が沢山の名前で知られていたり、逆に全く名前が全く無かったりしても驚かないでください！</p>
</div></blockquote>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id68">カンマ演算子はなぜ優先されるのですか？</a><a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カンマは Python では演算子ではありません。このセッションを考えてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;a&quot;</span> <span class="ow">in</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span>
<span class="go">(False, &#39;a&#39;)</span>
</pre></div>
</div>
<p>カンマは演算子ではなく、式の分離子なので、上の式は次の式と同じように評価されます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s">&quot;a&quot;</span> <span class="ow">in</span> <span class="s">&quot;b&quot;</span><span class="p">),</span> <span class="s">&quot;a&quot;</span>
</pre></div>
</div>
<p>次のようには評価されません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;a&quot;</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>他のさまざまな演算子(<tt class="docutils literal"><span class="pre">=</span></tt>、<tt class="docutils literal"><span class="pre">+=</span></tt> など)も同じです。これらは真の演算子ではありませんが、代入文の構文上のデリミタです。</p>
</div>
<div class="section" id="is-there-an-equivalent-of-c-s-ternary-operator">
<h3><a class="toc-backref" href="#id69">Is there an equivalent of C&#8217;s &#8221;?:&#8221; ternary operator?</a><a class="headerlink" href="#is-there-an-equivalent-of-c-s-ternary-operator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい、この機能は Python 2.5 で追加されました。構文は以下のようになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="k">if</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span>

<span class="n">small</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>2.5 以前のバージョンに関しては、答えは「いいえ」です。</p>
<p>多くのケースでは <tt class="docutils literal"><span class="pre">a</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">or</span> <span class="pre">c</span></tt> で <tt class="docutils literal"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></tt> の代わりをできますが、これでは漏れがあります。<em>b</em> が 0 (あるいは空、または <tt class="docutils literal"><span class="pre">None</span></tt> &#8211; 偽となるものすべて) のとき、<em>c</em> が代わりに選ばれてしまいます。多くの場合にはコードからこれが起こらないと解ります( 例えば、<em>b</em> が定数だったり、決して偽にならない型だったりするので) が、これは大体問題になり得ます。</p>
<p>Tim Peters (who wishes it was Steve Majewski) は次の解決策を提案しました。
<tt class="docutils literal"><span class="pre">(a</span> <span class="pre">and</span> <span class="pre">[b]</span> <span class="pre">or</span> <span class="pre">[c])[0]</span></tt>。<tt class="docutils literal"><span class="pre">[b]</span></tt> は一つの要素を持つリストであり、決して偽とならないので、間違った経路を通りません。だから <tt class="docutils literal"><span class="pre">[0]</span></tt> を全体に適用すれば、本当に欲しかった <em>b</em> または <em>c</em> が得られます。醜いですが、&#8217;if&#8217; を使って書き換えるのがどうしても不便な特殊な場合には、これで目的が達成できます。</p>
<p>一番の方法はたいてい、単純に <tt class="docutils literal"><span class="pre">if...else</span></tt> 文を書くことです。あるいは、
<tt class="docutils literal"><span class="pre">?:</span></tt> 演算子を関数として実装する方法もあります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">on_true</span><span class="p">,</span> <span class="n">on_false</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">on_true</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_true</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_true</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">on_false</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_false</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_false</span><span class="p">()</span>
</pre></div>
</div>
<p>たいてい、b と c は <tt class="docutils literal"><span class="pre">q(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></tt> のように直接渡すことになります。
b や c が評価されるべきでないとき、評価を避けるには、
<tt class="docutils literal"><span class="pre">q(a,</span> <span class="pre">lambda:</span> <span class="pre">b,</span> <span class="pre">lambda:</span> <span class="pre">c)</span></tt> のようにラムダ関数に包んでください。</p>
<p><em>なぜ</em> Python に if-then-else 式が無いのかは問われていました。答えはいくつかあります。多くの言語はそれ無しで十分なこと、読みにくいコードになりやすいこと、十分「Pythonic」な構文が見当たらないこと、標準ライブラリには if-then-else 式で表すとコードが分かりやすくなるような箇所がほとんどないことです。</p>
<p>2002年、いくつかの構文の選択肢を提案する <span class="target" id="index-2"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> が書かれ、コミュニティはこの論点について投票を行いました。多くの人はそれぞれある構文を好み、また他の構文を嫌いました。投票者の多くが、自分の嫌いな構文を取り入れるくらいなら、三項演算子を取り入れないほうがいいと考えました。</p>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id70">Python で解し難いワンライナーを書くことはできますか？</a><a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>はい。そういうものはたいてい、<a class="reference internal" href="../reference/expressions.html#lambda"><tt class="xref std std-keyword docutils literal"><span class="pre">lambda</span></tt></a> の中に <a class="reference internal" href="../reference/expressions.html#lambda"><tt class="xref std std-keyword docutils literal"><span class="pre">lambda</span></tt></a> がネストされています。Ulf Bartelt による下の３つの例を見てください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="c"># Primes &lt; 1000</span>
<span class="k">print</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">*</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span>
<span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)))</span>

<span class="c"># First 10 Fibonacci numbers</span>
<span class="k">print</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">),</span>
<span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="c"># Mandelbrot set</span>
<span class="k">print</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="p">,</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="p">,</span><span class="n">IM</span><span class="p">,</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="p">:</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span>
<span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="k">lambda</span> <span class="n">yc</span><span class="p">,</span><span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">IM</span><span class="p">,</span>
<span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">:</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">xc</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">yc</span><span class="o">=</span><span class="n">yc</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span>
<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="o">&gt;=</span><span class="mf">4.0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">xc</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">yc</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="nb">chr</span><span class="p">(</span>
<span class="mi">64</span><span class="o">+</span><span class="n">F</span><span class="p">(</span><span class="n">Ru</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Ro</span><span class="o">-</span><span class="n">Ru</span><span class="p">)</span><span class="o">/</span><span class="n">Sx</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sx</span><span class="p">))):</span><span class="n">L</span><span class="p">(</span><span class="n">Iu</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Io</span><span class="o">-</span><span class="n">Iu</span><span class="p">)</span><span class="o">/</span><span class="n">Sy</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sy</span>
<span class="p">))))(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="c">#    \___ ___/  \___ ___/  |   |   |__ lines on screen</span>
<span class="c">#        V          V      |   |______ columns on screen</span>
<span class="c">#        |          |      |__________ maximum of &quot;iterations&quot;</span>
<span class="c">#        |          |_________________ range on y axis</span>
<span class="c">#        |____________________________ range on x axis</span>
</pre></div>
</div>
<p>よい子はまねしないでね！</p>
</div>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id71">数と文字列</a><a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id72">十六進数や八進数を指定するにはどうしたらいいですか？</a><a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>八進数を指定するには、八進数での値の先頭に 0 と &#8220;o&#8221; (小文字または大文字) を加えてください。たとえば、変数 &#8220;a&#8221; に八進数での &#8220;10&#8221; (十進数での&#8221;8&#8221;) を代入するには、こう打ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="n">o10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">8</span>
</pre></div>
</div>
<p>十六進数も簡単です。ただ十六進数での値の先頭に 0 と &#8220;x&#8221; (小文字または大文字)
を加えてください。十六進数は小文字でも大文字でも指定できます。たとえば、Python インタプリタで:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xa5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">165</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mh">0XB2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">178</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id73">なぜ -22 // 10 は -3 を返すのですか？</a><a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></tt> が <tt class="docutils literal"><span class="pre">j</span></tt> と同じ符号であってほしいことに基づいています。それに加えて以下のようにもしたいとすると:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>整数除算は床を返すことになります。C にも C の一貫性があって、<tt class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></tt> が
<tt class="docutils literal"><span class="pre">i</span></tt> と同じ符号を持つように <tt class="docutils literal"><span class="pre">i</span> <span class="pre">//</span> <span class="pre">j</span></tt> を丸めています。</p>
<p><tt class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></tt> は、<tt class="docutils literal"><span class="pre">j</span></tt> が負の時には実際にはほとんど使いません。<tt class="docutils literal"><span class="pre">j</span></tt> が正なら、たくさん使います。その事実上すべての場合、<tt class="docutils literal"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></tt> は <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">0</span></tt> となる方が便利です。時計が 10 時を指している時、その 200 時間前は何時でしょうか。
<tt class="docutils literal"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">2</span></tt> となるのが便利です。<tt class="docutils literal"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">-10</span></tt> は噛み付きかねないバグです。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">Python 2 では、  <tt class="docutils literal"><span class="pre">__future__.division</span></tt> が有効でなければ、
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></tt> は <tt class="docutils literal"><span class="pre">a</span> <span class="pre">//</span> <span class="pre">b</span></tt> と同じ結果を返します。これは &#8220;古典的な (classic)&#8221; 除算とも呼ばれます。</p>
</div>
</div>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id74">文字列を数に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数に変換するには、組み込みの <a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a> 型コンストラクタを使ってください。例えば、<tt class="docutils literal"><span class="pre">int('144')</span> <span class="pre">==</span> <span class="pre">144</span></tt> です。同様に、<a class="reference internal" href="../library/functions.html#float" title="float"><tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt></a> は浮動小数点に変換します。例えば、<tt class="docutils literal"><span class="pre">float('144')</span> <span class="pre">==</span> <span class="pre">144.0</span></tt> です。</p>
<p>デフォルトでは、これらは数を十進数として解釈するので、<tt class="docutils literal"><span class="pre">int('0o144')</span></tt> や
<tt class="docutils literal"><span class="pre">int('0x144')</span></tt> は <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を送出します。<tt class="docutils literal"><span class="pre">int(string,</span> <span class="pre">base)</span></tt> はオプションの第二引数をとって変換元の基数にします。つまり <tt class="docutils literal"><span class="pre">int('0x144',</span> <span class="pre">16)</span>
<span class="pre">==</span> <span class="pre">324</span></tt> です。基数が 0 と指定された場合、その数は Python の基準によって解釈されます。先頭が &#8216;0o&#8217; なら 八進数で、&#8216;0x&#8217; なら十六進数を表します。</p>
<p>文字列を数に変換するだけのために <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> を使わないでください。
<a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> は特に遅いですし、セキュリティ上のリスクもあります。求められない副作用を持つような Python の式を渡そうとする人がいるかも知れません。例えば、あなたのホームディレクトリを消去する
<tt class="docutils literal"><span class="pre">__import__('os').system(&quot;rm</span> <span class="pre">-rf</span> <span class="pre">$HOME&quot;)</span></tt> を渡そうとする人がいるかも知れません。</p>
<p><a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> にも数を Python の式として解釈する機能があります。だから例えば、<tt class="docutils literal"><span class="pre">eval('09')</span></tt> は構文エラー起こします。Python は &#8216;0&#8217; で始まる数を八進数 (基数 8) とみなすからです。</p>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id75">数を文字列に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>例えば、144 という数を &#8216;144&#8217; という文字列に変換したいなら、組み込みの型コンストラクタ <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> を使ってください。十六進数や八進数にしたければ、組み込み関数の <a class="reference internal" href="../library/functions.html#hex" title="hex"><tt class="xref py py-func docutils literal"><span class="pre">hex()</span></tt></a> や <a class="reference internal" href="../library/functions.html#oct" title="oct"><tt class="xref py py-func docutils literal"><span class="pre">oct()</span></tt></a> を使ってください。装飾された形式にするには、<a class="reference internal" href="../library/string.html#formatstrings"><em>書式指定文字列の文法</em></a> の項を参照してください。例えば、
<tt class="docutils literal"><span class="pre">&quot;{:04d}&quot;.format(144)</span></tt> は <tt class="docutils literal"><span class="pre">'0144'</span></tt> になり、<tt class="docutils literal"><span class="pre">&quot;{:.3f}&quot;.format(1/3)</span></tt> は
<tt class="docutils literal"><span class="pre">'0.333'</span></tt> になります。文字列に <a class="reference internal" href="../library/stdtypes.html#string-formatting"><em>% 演算子</em></a> を使うこともできます。詳細はライブラリリファレンスの解説を参照してください。</p>
</div>
<div class="section" id="id22">
<h3><a class="toc-backref" href="#id76">文字列をインプレースに変更するにはどうしたらいいですか？</a><a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>文字列はイミュータブルなので、変更することはできません。それができるオブジェクトを作るには、その文字列をリストに変換してみるか、array モジュールを使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Hello, world&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">[&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;,&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">&quot;there!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;Hello, there!&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">array(&#39;c&#39;, &#39;Hello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;y&#39;</span> <span class="p">;</span> <span class="k">print</span> <span class="n">a</span>
<span class="go">array(&#39;c&#39;, &#39;yello world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
<span class="go">&#39;yello, world&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h3><a class="toc-backref" href="#id77">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a><a class="headerlink" href="#id23" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>様々なテクニックがあります。</p>
<ul>
<li><p class="first">一番いいのは、文字列を関数に対応させる辞書を使うことです。このテクニックの一番の利点は、文字列が関数の名前と同じ必要がないことです。この方法は
case 構造をエミュレートするための一番のテクニックでもあります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;go&#39;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s">&#39;stop&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>  <span class="c"># Note lack of parens for funcs</span>

<span class="n">dispatch</span><span class="p">[</span><span class="n">get_input</span><span class="p">()]()</span>  <span class="c"># Note trailing parens to call function</span>
</pre></div>
</div>
</li>
<li><p class="first">組み込み関数の <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> を使う方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">foo</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">)()</span>
</pre></div>
</div>
<p>なお、<a class="reference internal" href="../library/functions.html#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> はクラス、クラスインスタンス、モジュールなど、どんなオブジェクトにも使えます。</p>
<p>これは標準ライブラリでも何箇所か使われています。このように:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">do_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">do_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">,</span> <span class="s">&#39;do_&#39;</span> <span class="o">+</span> <span class="n">opname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a> や <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> を使って関数名を決める方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">myFunc</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;myFunc&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">fname</span><span class="p">]</span>
<span class="n">f</span><span class="p">()</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>ノート: <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> の使用は遅いし危険です。もしあなたが文字列の内容を絶対的に支配できなければ、任意の関数を実行されるようにする文字列を渡す人がいるかも知れません。</p>
</li>
</ul>
</div>
<div class="section" id="perl-chomp">
<h3><a class="toc-backref" href="#id78">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a><a class="headerlink" href="#perl-chomp" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 2.2 から、<tt class="docutils literal"><span class="pre">S.rstrip(&quot;\r\n&quot;)</span></tt> を使って文字列 <tt class="docutils literal"><span class="pre">S</span></tt> の終端から他の空白文字を取り除くことなくすべての行末記号を取り除くことができるようになりました。文字列 <tt class="docutils literal"><span class="pre">S</span></tt> が複数行を表し、終端に空行があるとき、そのすべての空行も取り除かれます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;line 1 </span><span class="se">\r\n</span><span class="s">&quot;</span>
<span class="gp">... </span>         <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span>
<span class="gp">... </span>         <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\r</span><span class="s">&quot;</span><span class="p">)</span>
<span class="go">&#39;line 1 &#39;</span>
</pre></div>
</div>
<p>これは典型的に一度に一行ずつテキストを読みたい時にのみ使われるので、
<tt class="docutils literal"><span class="pre">S.rstrip()</span></tt> をこの方法で使うとうまくいきます。</p>
<p>古いバージョンの Python では、部分的な代用品が二つあります:</p>
<ul class="simple">
<li>すべての終端の空白文字を取り除きたいなら、文字列オブジェクトの <tt class="docutils literal"><span class="pre">rstrip()</span></tt>
メソッドを使ってください。これは改行記号一つだけでなく、すべての終端の空白文字を取り除きます。</li>
<li>そうでなく、文字列 <tt class="docutils literal"><span class="pre">S</span></tt> に一行しか無いなら、<tt class="docutils literal"><span class="pre">S.splitlines()[0]</span></tt> を使ってください。</li>
</ul>
</div>
<div class="section" id="scanf-sscanf">
<h3><a class="toc-backref" href="#id79">scanf() や sscanf() と同等なものはありますか？</a><a class="headerlink" href="#scanf-sscanf" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>そのようなものはありません。</p>
<p>簡単な入力解析で、多くの場合に一番簡単な方法は、文字列オブジェクトの
<a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><tt class="xref py py-meth docutils literal"><span class="pre">split()</span></tt></a> メソッドで行を空白文字で区切られた単語に分け、十進数の文字列を <a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a> や <a class="reference internal" href="../library/functions.html#float" title="float"><tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt></a> で数値に変換することです。
<tt class="docutils literal"><span class="pre">split()</span></tt> にはオプションの &#8220;sep&#8221; 変数があり、行に空白文字以外の区切りを使っているときに便利です。</p>
<p>もっと複雑な入力解析をしたいなら、C の <tt class="xref c c-func docutils literal"><span class="pre">sscanf()</span></tt> よりも正規表現の方が便利ですし、この処理に向いています。</p>
</div>
<div class="section" id="unicodeerror-ascii-decoding-encoding-error-ordinal-not-in-range-128">
<h3><a class="toc-backref" href="#id80">&#8216;UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)&#8217; とはどういう意味ですか？</a><a class="headerlink" href="#unicodeerror-ascii-decoding-encoding-error-ordinal-not-in-range-128" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このエラーは、あなたの Python インストールが 7-bit ASCII 文字列しか扱えないことを表します。この問題を扱うには二つの方法があります。</p>
<p>あなたのプログラムが、任意の文字セットエンコーディングのデータを扱わなければならないなら、一般に、アプリケーションが起動する環境によってデータのエンコーディングが特定されます。例えば、email や web 入力を扱うプログラムは、概して文字セットエンコーディング情報を Content-Type ヘッダから見つけます。これに使うことで、入力データを
Unicode に正しく変換できます。 <tt class="docutils literal"><span class="pre">value</span></tt> によって参照される文字列が
UTF-8 でエンコードされているとすれば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">value</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;utf-8&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>は Unicode オブジェクトを返します。データが UTF-8 に正しく変換されないなら、上記の呼び出しは <a class="reference internal" href="../library/exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><tt class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></tt></a> 例外を送出します。</p>
<p>非 ASCII データを持つ文字列だけを Unicode に変換すればいいなら、まず ASCII エンコーディングを仮定して変換し、失敗したら Unicode オブジェクトを生成すればいいです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;ascii&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;utf-8&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># value was valid ASCII data</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>デフォルトのエンコーディングは、Python ライブラリの一部である
<tt class="docutils literal"><span class="pre">sitecustomize.py</span></tt> と呼ばれるファイルで設定できます。しかし、Python 全体におけるデフォルトのエンコーディングを変えてしまうことは、サードパーティ拡張モジュールの失敗につながるのでお勧めできません。</p>
<p>なお、Windows には、 &#8220;mbcs&#8221; として知られるエンコーディングがあり、これはあなたのロケールに依存するエンコーディイングを使います。多くの場合、特に COM で作業をするとき、これが使うのに適したデフォルトのエンコーディングです。</p>
</div>
</div>
<div class="section" id="id24">
<h2><a class="toc-backref" href="#id81">シーケンス(タプル/リスト)</a><a class="headerlink" href="#id24" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id25">
<h3><a class="toc-backref" href="#id82">タプル、リスト間の変更はどのようにするのですか？</a><a class="headerlink" href="#id25" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>型コンストラクタ <tt class="docutils literal"><span class="pre">tuple(seq)</span></tt> はすべてのシーケンス (実際には、すべてのイテラブル) を同じ要素、同じ順序のタプルに変換します。</p>
<p>例えば、 <tt class="docutils literal"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></tt> は <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></tt> を与え、<tt class="docutils literal"><span class="pre">tuple('abc')</span></tt> は
<tt class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></tt> を与えます。引数がタプルなら、コピーを作らずに引数のオブジェクトそのものを返すので、あるオブジェクトが既にタプルになっているか確信が持てないのなら、<a class="reference internal" href="../library/functions.html#tuple" title="tuple"><tt class="xref py py-func docutils literal"><span class="pre">tuple()</span></tt></a> を呼ぶのが手軽です。</p>
<p>型コンストラクタ <tt class="docutils literal"><span class="pre">list(seq)</span></tt> はすべてのシーケンスあるいはイテラブルを同じ要素、同じ順序のリストに変換します。例えば、<tt class="docutils literal"><span class="pre">list(''''(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></tt> は
<tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt> を与え、 <tt class="docutils literal"><span class="pre">list('abc')</span></tt> は <tt class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></tt> を与えます。引数がリストなら、<tt class="docutils literal"><span class="pre">seq[:]</span></tt> と同様にコピーを作ります。</p>
</div>
<div class="section" id="id26">
<h3><a class="toc-backref" href="#id83">インデクスが負の場合はどうなりますか？</a><a class="headerlink" href="#id26" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のシーケンスは正の数と負の数でインデクスされます。正の数では、
0 が最初のインデクス、 1 が 2 番目のインデクス、以下も同様です。負のインデクスでは、-1 が最後のインデクス、 -2 が最後から 2 番目のインデクス、以下も同様です。<tt class="docutils literal"><span class="pre">seq[-n]</span></tt> は <tt class="docutils literal"><span class="pre">seq[len(seq)-n]</span></tt> と同じだと考えてください。</p>
<p>負のインデクスを使うと便利なことがあります。例えば、<tt class="docutils literal"><span class="pre">S[:-1]</span></tt> は文字列の最後以外のすべての文字を表すので、文字列の末尾の改行を取り除くときに便利です。</p>
</div>
<div class="section" id="id27">
<h3><a class="toc-backref" href="#id84">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a><a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 2.4 で追加された <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><tt class="xref py py-func docutils literal"><span class="pre">reversed()</span></tt></a> を使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span> <span class="c"># do something with x...</span>
</pre></div>
</div>
<p>これは元のシーケンスをいじるのではなく、逆順の新しいコピーを作ってイテレートさせます。</p>
<p>Python 2.3 では、拡張スライス構文を使います:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="o">...</span> <span class="c"># do something with x...</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3><a class="toc-backref" href="#id85">リストから重複を取り除くにはどうしますか？</a><a class="headerlink" href="#id28" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python Cookbook の長い議論に多くの方法があるので参照してください:</p>
<blockquote>
<div><a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560</a></div></blockquote>
<p>リストを並び替えて構わないのなら、ソートした上でリストの最初から最後までを調べ、次のように重複を削除してください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">mylist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>リストのすべての要素が辞書のキーとして使える (つまり、すべての要素がハッシュ可能) なら、おそらくこのほうが速いです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<p>Python 2.5 以降なら、代わりに次のようにできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mylist</span><span class="p">))</span>
</pre></div>
</div>
<p>リストを集合に変換するときに重複は取り除かれるので、それをリストに戻せばいいのです。</p>
</div>
<div class="section" id="id29">
<h3><a class="toc-backref" href="#id86">Python で配列を作るにはどうしますか？</a><a class="headerlink" href="#id29" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リストを使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="s">&quot;this&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot;an&quot;</span><span class="p">,</span> <span class="s">&quot;array&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>リストの時間計算量は C や Pascal の配列と同じです。大きな違いは、
Python のリストは多くの異なる型のオブジェクトを含めることです。</p>
<p><tt class="docutils literal"><span class="pre">array</span></tt> モジュールにも固定された型を簡潔に表現する配列を作るためのメソッドがありますが、リストよりもインデクスが遅いです。また、
Numeric 拡張その他でも、様々な特徴をもつ配列的な構造体が定義されています。</p>
<p>Lisp 方式の連結リストを得るのに、タプルを使ってコンスセルをエミュレートできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lisp_list</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;like&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s">&quot;this&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s">&quot;example&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>ミュータブルな必要があるなら、タプルではなくリストを使いましょう。lisp の
car にあたるものが <tt class="docutils literal"><span class="pre">lisp_list[0]</span></tt> で、cdr にあたるものが <tt class="docutils literal"><span class="pre">lisp_list[1]</span></tt>
です。本当に必要だと確信できるとき以外はこれはしないでください。たいてい、これは Python のリストを使うよりも非常に遅いですから。</p>
</div>
<div class="section" id="id30">
<h3><a class="toc-backref" href="#id87">多次元のリストを作るにはどうしますか？</a><a class="headerlink" href="#id30" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このようにして多次元の配列を作ろうとしてしまったことがあるでしょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>これを表示したときには問題なさそうに見えます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[None, None], [None, None], [None, None]]</span>
</pre></div>
</div>
<p>しかし値を代入すると、その値が複数の場所に現れてしまいます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[5, None], [5, None], [5, None]]</span>
</pre></div>
</div>
<p>これは、<tt class="docutils literal"><span class="pre">*</span></tt> を使ったリストの複製がコピーを作らず、存在するオブジェクトへの参照を作るだけだからです。この <tt class="docutils literal"><span class="pre">*3</span></tt> は長さ 2 の同じリストへの参照を含むリストを作ります。一つの列に対する変更はすべての列に現れますが、これが望んだ結果であることはまずないでしょう。</p>
<p>おすすめの方法は、最初に望んだ長さのリストを作り、それから新しく作ったリストでそれぞれの要素を埋めていくことです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p>これは長さ 2 の異なるリスト 3 つを含むリストを生成します。リスト内包表記も使えます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
<p>また、行列データ型を提供している拡張も使えます。<a class="reference external" href="http://numpy.scipy.org/">Numeric Python</a> が特に有名です。</p>
</div>
<div class="section" id="id31">
<h3><a class="toc-backref" href="#id88">オブジェクトのシーケンスにメソッドを適用するにはどうしますか？</a><a class="headerlink" href="#id31" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リスト内包表記を使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
</pre></div>
</div>
<p>より一般的には、以下の関数を試すことができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">method_map</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">arguments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;method_map([a,b], &quot;meth&quot;, (1,2)) gives [a.meth(1,2), b.meth(1,2)]&quot;&quot;&quot;</span>
    <span class="n">nobjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
    <span class="n">methods</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">getattr</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">*</span><span class="n">nobjects</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">apply</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="p">[</span><span class="n">arguments</span><span class="p">]</span><span class="o">*</span><span class="n">nobjects</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id32">
<h2><a class="toc-backref" href="#id89">辞書</a><a class="headerlink" href="#id32" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id33">
<h3><a class="toc-backref" href="#id90">キーを安定した順序で表示する辞書を作るにはどうしたらいいですか？</a><a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>できません。辞書はキーを予測できない順序で保存しているので、辞書の要素が表示される順序もまた予測できないのです。</p>
<p>ファイルに印字可能なバージョンを保存し、変更を加えてから他の印字された辞書と比較したい時に苛立たしいかもしれません。この場合は、<tt class="docutils literal"><span class="pre">pprint</span></tt> モジュールで辞書を整形して表示してください。要素がキーでソートされて表されます。</p>
<p>もっと複雑な解決策は、<tt class="docutils literal"><span class="pre">dict</span></tt> のサブクラスとして <tt class="docutils literal"><span class="pre">SortedDict</span></tt> クラスを作り、それに予測可能な順序で自身を表示させることです。そのようなクラスの単純な実装の一つは:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SortedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;{!r}: {!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;{{{}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

    <span class="n">__str__</span> <span class="o">=</span> <span class="n">__repr__</span>
</pre></div>
</div>
<p>これは完璧な解法とは程遠いですが、多くの状況でうまく働くでしょう。最大の欠点は、辞書のある値がまた辞書であった場合に、それらの値はどんな特定の順序でも表示されないことです。</p>
</div>
<div class="section" id="id34">
<h3><a class="toc-backref" href="#id91">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a><a class="headerlink" href="#id34" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Perl コミュニティの Randal Schwartz の作とされるこのテクニックは、リストの要素を、それぞれの要素をその「ソート値」に対応付けるメトリックによってソートします。Python では、単に <tt class="docutils literal"><span class="pre">sort()</span></tt> メソッドに <tt class="docutils literal"><span class="pre">key</span></tt> 引数を使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Isorted</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:]</span>
<span class="n">Isorted</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]))</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">key</span></tt> 引数はPython 2.4 で追加されたもので、古いバージョンでこのようなソートをするにはリスト内包表記でやればすごく簡単です。文字列のリストをその大文字の値でソートするには:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tmp1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span>  <span class="c"># Schwartzian transform</span>
<span class="n">tmp1</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">Usorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp1</span><span class="p">]</span>
</pre></div>
</div>
<p>それぞれの文字列の 10-15 の場所から展開されたサブフィールドの整数値によってソートするには:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tmp2</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]),</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span>  <span class="c"># Schwartzian transform</span>
<span class="n">tmp2</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">Isorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp2</span><span class="p">]</span>
</pre></div>
</div>
<p>なお、Isorted はこのようにしても計算されます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">intfield</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">Icmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">intfield</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">intfield</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>

<span class="n">Isorted</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:]</span>
<span class="n">Isorted</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Icmp</span><span class="p">)</span>
</pre></div>
</div>
<p>しかし、このメソッドは <tt class="docutils literal"><span class="pre">intfield()</span></tt> を L の要素ごとに何度も呼び出すので、シュワルツ変換よりも遅いです。</p>
</div>
<div class="section" id="id35">
<h3><a class="toc-backref" href="#id92">リストを別のリストの値によってソートするにはどうしますか？</a><a class="headerlink" href="#id35" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>二つのリストを混ぜあわせてタプルのイテレータにしてから、必要な要素を選んでください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;what&quot;</span><span class="p">,</span> <span class="s">&quot;I&#39;m&quot;</span><span class="p">,</span> <span class="s">&quot;sorting&quot;</span><span class="p">,</span> <span class="s">&quot;by&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;something&quot;</span><span class="p">,</span> <span class="s">&quot;else&quot;</span><span class="p">,</span> <span class="s">&quot;to&quot;</span><span class="p">,</span> <span class="s">&quot;sort&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span>
<span class="go">[(&quot;I&#39;m&quot;, &#39;else&#39;), (&#39;by&#39;, &#39;sort&#39;), (&#39;sorting&#39;, &#39;to&#39;), (&#39;what&#39;, &#39;something&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">[&#39;else&#39;, &#39;sort&#39;, &#39;to&#39;, &#39;something&#39;]</span>
</pre></div>
</div>
<p>最後の段階の別のやり方は:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>これのほうが読みやすいと、最後のリスト内包表記ではなくこれを使いたくなるかもしれません。しかし、これは長いリストではほぼ二倍の時間がかかります。なぜでしょうか。まず、<tt class="docutils literal"><span class="pre">append()</span></tt> 演算はメモリを割り当て直す必要があり、それを避けるために毎回ちょっと工夫していますが、それでも避けられないことがあるので、少し時間がかかるのです。二つ目に、&#8221;result.append&#8221; には属性探索が余計に必要で、三つ目に、これらすべての関数を呼ぶ必要があることで速度が落ちてしまいます。</p>
</div>
</div>
<div class="section" id="id36">
<h2><a class="toc-backref" href="#id93">オブジェクト</a><a class="headerlink" href="#id36" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id37">
<h3><a class="toc-backref" href="#id94">クラスとは何ですか？</a><a class="headerlink" href="#id37" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラスは、class 文の実行で生成される特殊なオブジェクトです。クラスオブジェクトはインスタンスオブジェクトを生成するためのテンプレートとして使われ、あるデータ型に特有のデータ (attribute/属性) とコード (メソッド) の両方を内蔵しています。</p>
<p>新しいクラスを一つ以上の他のクラス (新しいクラスの基底クラスと呼ばれます) に基づいて作ることもできます。この新しいクラスは、基底クラスから属性とメソッドを継承します。これにより、オブジェクトモデルを継承で連続的に洗練できます。メールボックスへの基本的なアクセサを提供する一般的な <tt class="docutils literal"><span class="pre">Mailbox</span></tt> クラスを作って、それからいろいろな特定のメールボックスの形式を扱う <tt class="docutils literal"><span class="pre">MboxMailbox</span></tt>、
<tt class="docutils literal"><span class="pre">MaildirMailbox</span></tt>、<tt class="docutils literal"><span class="pre">OutlookMailbox</span></tt> のようなサブクラスを作れるのです。</p>
</div>
<div class="section" id="id38">
<h3><a class="toc-backref" href="#id95">メソッドとは何ですか？</a><a class="headerlink" href="#id38" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メソッドは、オブジェクト <tt class="docutils literal"><span class="pre">x</span></tt> が持つ関数で、通常 <tt class="docutils literal"><span class="pre">x.name(arguments...)</span></tt>
として呼び出されるものです。メソッドはクラス定義の中で関数として定義されます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span>
</pre></div>
</div>
</div>
<div class="section" id="self">
<h3><a class="toc-backref" href="#id96">self とは何ですか？</a><a class="headerlink" href="#self" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>self はメソッドの第一引数に慣習的につけられる名前にすぎません。
<tt class="docutils literal"><span class="pre">meth(self,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></tt> として定義されたメソッドは、その定義がなされたクラスのインスタンス <tt class="docutils literal"><span class="pre">x</span></tt> に対して <tt class="docutils literal"><span class="pre">x.meth(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></tt> として呼び出されます。呼び出されたメソッドは、<tt class="docutils literal"><span class="pre">meth(x,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></tt> が呼ばれたものと考えます。</p>
<p><a class="reference internal" href="design.html#why-self"><em>なぜメソッドの定義や呼び出しにおいて &#8216;self&#8217; を明示しなければならないのですか？</em></a> も参照してください。</p>
</div>
<div class="section" id="id39">
<h3><a class="toc-backref" href="#id97">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a><a class="headerlink" href="#id39" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビルトイン関数 <tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">cls)</span></tt> を使ってください。クラスのタプルを与えて <tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">(class1,</span> <span class="pre">class2,</span> <span class="pre">...))</span></tt> のようにすれば、あるオブジェクトが任意の数のクラスのオブジェクトであるかを調べられますし、
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">str)</span></tt> や <tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">(int,</span> <span class="pre">long,</span> <span class="pre">float,</span> <span class="pre">complex))</span></tt> のようにすれば、Python のビルトイン型のオブジェクトであるかも調べられます。</p>
<p>なお、大部分のプログラムでは、<a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a> をユーザー定義のクラスに何度も使うべきではありません。クラスを自分で開発するときに、適切なオブジェクト指向スタイルは、特定の振る舞いをカプセル化するクラスのメソッドを定義するものであって、オブジェクトのクラスを調べてそのクラスに応じて違うことをするものではありません。例えば、何かをする関数があったとして:</p>
<div class="highlight-python"><pre>def search(obj):
    if isinstance(obj, Mailbox):
        # ... code to search a mailbox
    elif isinstance(obj, Document):
        # ... code to search a document
    elif ...</pre>
</div>
<p>よりよいアプローチは、<tt class="docutils literal"><span class="pre">search()</span></tt> メソッドをすべてのクラスに定義して、それをただ呼び出すことです:</p>
<div class="highlight-python"><pre>class Mailbox:
    def search(self):
        # ... code to search a mailbox

class Document:
    def search(self):
        # ... code to search a document

obj.search()</pre>
</div>
</div>
<div class="section" id="id40">
<h3><a class="toc-backref" href="#id98">委譲とは何ですか？</a><a class="headerlink" href="#id40" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>委譲 (delegation) とは、オブジェクト指向のテクニック (デザインパターンとも呼ばれる) の一つです。オブジェクト <tt class="docutils literal"><span class="pre">x</span></tt> があって、そのメソッドのうちただ一つの振る舞いを変えたいとしましょう。新しいクラスを作成し、変えたいメソッドだけを新しく実装し、他のすべてのメソッドを <tt class="docutils literal"><span class="pre">x</span></tt> の対応するメソッドに委譲する新しいクラスを作れます。</p>
<p>Python プログラマは簡単に委譲を実装できます。例えば、以下のクラスは、ファイルのように振る舞いながらすべての文字を大文字に変換するクラスを実装します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UpperOut</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span> <span class="o">=</span> <span class="n">outfile</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <tt class="docutils literal"><span class="pre">UpperOut</span></tt> クラスは <tt class="docutils literal"><span class="pre">write()</span></tt> メソッドを定義しなおして、引数の文字列を大文字に変換してから基礎となる <tt class="docutils literal"><span class="pre">self._outfile.write()</span></tt>
メソッドを呼び出すようにします。その他すべてのメソッドは基礎となる
<tt class="docutils literal"><span class="pre">self._outfile</span></tt> オブジェクトに移譲されます。この委譲は <tt class="docutils literal"><span class="pre">__getattr__</span></tt>
メソッドを通してなされます。属性の制御の詳細は <a class="reference internal" href="../reference/datamodel.html#attribute-access"><em>言語リファレンス</em></a> を参照してください。</p>
<p>なお、一般的に委譲はトリッキーになりがちです。属性が設定される時には読み出される時と同様に、そのクラスに <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></tt></a> メソッドを定義する必要があり、それには細心の注意が必要です。 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></tt></a> の基本的な実装はおおよそ以下のようになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>たいてい、<a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></tt></a> 実装は <tt class="docutils literal"><span class="pre">self.__dict__</span></tt> を変更して、無限再帰を起こすことなくローカルな状態を保存するようにしなければなりません。</p>
</div>
<div class="section" id="id41">
<h3><a class="toc-backref" href="#id99">基底クラスで定義されたメソッドを、そのクラスをオーバーライドした派生クラスから呼び出すにはどうしますか？</a><a class="headerlink" href="#id41" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>組み込みの <a class="reference internal" href="../library/functions.html#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> 関数を使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Derived</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>
</pre></div>
</div>
<p>旧スタイルクラスを使っているなら:
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">Derived(Base):</span> <span class="pre">...</span></tt> のようなクラス定義で、
<tt class="docutils literal"><span class="pre">Base.meth(self,</span> <span class="pre">arguments...)</span></tt> とすれば、<tt class="docutils literal"><span class="pre">Base</span></tt> (または <tt class="docutils literal"><span class="pre">Base</span></tt> の基底クラス) で定義された <tt class="docutils literal"><span class="pre">meth()</span></tt> メソッドを呼び出せます。ここで、
<tt class="docutils literal"><span class="pre">Base.meth</span></tt> は束縛されていないメソッドなので、<tt class="docutils literal"><span class="pre">self</span></tt> 引数を渡す必要があります。</p>
</div>
<div class="section" id="id42">
<h3><a class="toc-backref" href="#id100">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a><a class="headerlink" href="#id42" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>基底クラスのエイリアス (alias) を定義し、先にそれに本当の基底クラスを代入しておいてから、クラス定義の中でそのエイリアスを使うといいかもしれません。そうすればエイリアスに代入する値を変変えるだけで済みます。ちなみに、この手法は使用する基底クラスを動的に選びたいとき (使えるリソースに依るとき等) にも便利です。例:</p>
<div class="highlight-python"><pre>BaseAlias = &lt;real base class&gt;

class Derived(BaseAlias):
    def meth(self):
        BaseAlias.meth(self)
        ...</pre>
</div>
</div>
<div class="section" id="id43">
<h3><a class="toc-backref" href="#id101">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a><a class="headerlink" href="#id43" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>(C++ や Java の意味で) 静的なデータも静的なメソッドも Python でサポートされています。</p>
<p>静的なデータを作るには、単純にクラス属性を定義してください。その属性に新しい値を代入するには、代入するクラス名を明示する必要があります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># number of times C.__init__ called</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">getcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>  <span class="c"># or return self.count</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">c</span></tt> そのものや <tt class="docutils literal"><span class="pre">c.__class__</span></tt> から <tt class="docutils literal"><span class="pre">C</span></tt> にいたるパス探索経路上のクラスによってオーバーライドされない限り、<tt class="docutils literal"><span class="pre">c.count</span></tt> も <tt class="docutils literal"><span class="pre">isinstance(c,</span> <span class="pre">C)</span></tt>
であるすべての <tt class="docutils literal"><span class="pre">c</span></tt> に対する <tt class="docutils literal"><span class="pre">C.count</span></tt> を参照します。</p>
<p>注意: C のメソッド内では、 <tt class="docutils literal"><span class="pre">self.count</span> <span class="pre">=</span> <span class="pre">42</span></tt> のような代入は <tt class="docutils literal"><span class="pre">self</span></tt> 自身の辞書に &#8220;count&#8221; という名前の新しくて関係ないインスタンスを作ります。クラスの静的なデータの再束縛には、メソッド内であるか否かにかかわらず、いつもクラスを指定しなければなりません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">314</span>
</pre></div>
</div>
<p>静的メソッドは Python 2.2 以降で使えます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c"># No &#39;self&#39; parameter!</span>
        <span class="o">...</span>
    <span class="n">static</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">static</span><span class="p">)</span>
</pre></div>
</div>
<p>Python 2.4 のデコレータを使って、以下のようにも書けます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c"># No &#39;self&#39; parameter!</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>しかし、静的メソッドの効果を得るもっと簡単な方法は、単にモジュールレベル関数を使うことです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">getcount</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>
</pre></div>
</div>
<p>モジュールあたりに一つのクラスを定義するように (あるいはクラス組織を厳密に関連させるように) コードが構成されているなら、これで必要なカプセル化ができます。</p>
</div>
<div class="section" id="id44">
<h3><a class="toc-backref" href="#id102">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a><a class="headerlink" href="#id44" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この質問の答えはすべてのメソッドについて言えることですが、この質問はだいたい以下の構造の文脈から出てきます。</p>
<p>C++ では、このように書けます:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Argument is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python では、一つのコンストラクタでデフォルトの引数を使ってすべての場合に対応するように書かなければなりません。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;No arguments&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Argument is&quot;</span><span class="p">,</span> <span class="n">i</span>
</pre></div>
</div>
<p>これで完全に等価とは言えませんが、実用上は十分に近いです。</p>
<p>長さが変えられる引数のリストを試すには、例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>これと同じやり方がすべてのメソッド定義で使えます。</p>
</div>
<div class="section" id="spam-someclassname-spam">
<h3><a class="toc-backref" href="#id103">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a><a class="headerlink" href="#spam-someclassname-spam" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>先頭にアンダースコアが二つ付いた変数名は、クラスのプライベートな変数を、
&#8220;マングル化&#8221;という単純かつ効率のいい方法で定義します。<tt class="docutils literal"><span class="pre">__spam</span></tt> のような形式 (先頭に二つ以上、末尾にもしあっても一つのアンダースコアがある) のすべての識別子は、<tt class="docutils literal"><span class="pre">classname</span></tt> が先頭のアンダースコアをすべて削除した現在のクラス名とすれば、<tt class="docutils literal"><span class="pre">_classname__spam</span></tt> のように文字上で置換えられます。</p>
<p>これはプライベートであることを保証するものではありません。これでも外部のユーザが &#8220;_classname__spam&#8221; 属性に直接アクセスできますし、プライベートな変数はオブジェクトの <tt class="docutils literal"><span class="pre">__dict__</span></tt> から見えます。多くの Python プログラマはわざわざプライベートな変数名を使おうとなど考えません。</p>
</div>
<div class="section" id="del">
<h3><a class="toc-backref" href="#id104">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a><a class="headerlink" href="#del" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかの可能性があります。</p>
<p>del 文は必ずしも <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> を呼び出すとは限りません &#8211; これは単純にオブジェクトの参照カウントを減らすもので、カウントがゼロになったときに
<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> が呼び出されます。</p>
<p>データ構造が循環リンク (子のそれぞれが親の参照を持ち、親のそれぞれが子のリストを持つツリーなど) を含む場合、その参照カウントは決して 0 にはなりません。時々、Python はこのようなサイクルを検出するアルゴリズムを実行しますが、データ構造への参照がなくなってからこのガベージコレクタが実行されるまでいくらか時間が掛かるかもしれないので、 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> メソッドは不便な予測できないときに呼び出されるかもしれません。これは問題を再生しようとするときに不便です。さらに悪いことに、オブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> メソッドが実行される順序は任意です。 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><tt class="xref py py-func docutils literal"><span class="pre">gc.collect()</span></tt></a> を起動して収集を強制することができますが、オブジェクトが決して回収されないような本当に病的な場合も
<em>あります</em>。</p>
<p>周期的なコレクタにかかわらず、オブジェクトに <tt class="docutils literal"><span class="pre">close()</span></tt> メソッドを明示的に定義し、使い終わったらいつでも呼び出せるようにするのはいいことです。そうすれば <tt class="docutils literal"><span class="pre">close()</span></tt> メソッドはサブオブジェクトへの参照をする属性を取り除いてくれます。<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> を直接呼び出さないでください &#8211;
<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> は <tt class="docutils literal"><span class="pre">close()</span></tt> を呼び出すでしょうし、<tt class="docutils literal"><span class="pre">close()</span></tt> なら同じオブジェクトに対して複数回呼ばれてもいいことが保証されているでしょう。</p>
<p>循環参照を避ける他の方法は、 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: 弱参照と弱辞書のサポート。"><tt class="xref py py-mod docutils literal"><span class="pre">weakref</span></tt></a> モジュールを使って、参照カウントを増やすことなくオブジェクトを示すことです。例えばツリー構造は、親と
(必要なら！) 兄弟に弱参照を使うべきです。</p>
<p>except 節で例外を捕まえた関数内でオブジェクトがローカル変数であったたなら、そのオブジェクトへの参照が関数のスタックフレーム内でスタックトレース内に含まれることで存在する可能性があります。通常、 <a class="reference internal" href="../library/sys.html#sys.exc_clear" title="sys.exc_clear"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_clear()</span></tt></a> を呼び出せば、最後に記録された例外を消去することで対処してくれます。</p>
<p>最後に、<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><tt class="xref py py-meth docutils literal"><span class="pre">__del__()</span></tt></a> メソッドが例外を発生させた場合、警告のメッセージが
<a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><tt class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></tt></a> に書きこまれます。</p>
</div>
<div class="section" id="id45">
<h3><a class="toc-backref" href="#id105">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a><a class="headerlink" href="#id45" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python はクラス (やビルトイン型) のすべてのインスタンスをたどりません。クラスのコンストラクタにそれぞれのインスタンスへの弱参照のリストを作らせることですべてのインスタンスをたどらせられます。</p>
</div>
</div>
<div class="section" id="id46">
<h2><a class="toc-backref" href="#id106">モジュール</a><a class="headerlink" href="#id46" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="pyc">
<h3><a class="toc-backref" href="#id107">.pyc ファイルを作るにはどうしますか？</a><a class="headerlink" href="#pyc" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールが最初にインポートされるとき (またはソースが現在コンパイルされているファイルよりも新しいとき)、コンパイルされたコードを含む <tt class="docutils literal"><span class="pre">.pyc</span></tt> ファイルが
<tt class="docutils literal"><span class="pre">.py</span></tt> ファイルと同じディレクトリに作られるでしょう。</p>
<p><tt class="docutils literal"><span class="pre">.pyc</span></tt> ファイルが作られないとしたら、ディレクトリの許可の問題があるかもしれません。たとえばこれは、web サーバなどでテストするときのように、開発のときと違うユーザとして起動するときなどに起こりえます。モジュールをインポートしたときに Python がコンパイルされたモジュールをディレクトリに書き込むための条件 (許可、容量の空き、etc...) が揃っていれば、.pyc ファイルの生成は自動的に行われます。</p>
<p>トップレベルのスクリプトで Python を起動するときにはインポートは考慮されず、
<tt class="docutils literal"><span class="pre">.pyc</span></tt> は生成されません。例えば、トップレベルモジュール <tt class="docutils literal"><span class="pre">abc.py</span></tt> があって、他のモジュール <tt class="docutils literal"><span class="pre">xyz.py</span></tt> をインポートするようになっているとき、abc を起動すると、xyz のインポート時に <tt class="docutils literal"><span class="pre">xyz.pyc</span></tt> が生成されますが、<tt class="docutils literal"><span class="pre">abc.py</span></tt> はインポートされないので <tt class="docutils literal"><span class="pre">abc.pyc</span></tt> ファイルは生成されません。</p>
<p>abc.pyc が必要なら &#8211; つまり、インポートされないモジュールの .pic ファイルを生成するためには &#8211; <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Python ソースファイルからバイトコードファイルを生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">py_compile</span></tt></a> や <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: ディレクトリに含まれる Python ソースファイルを、一括してバイトコンパイルします。"><tt class="xref py py-mod docutils literal"><span class="pre">compileall</span></tt></a> モジュールが利用できます。</p>
<p><a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Python ソースファイルからバイトコードファイルを生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">py_compile</span></tt></a> モジュールは手動で任意のモジュールをコンパイルできます。やり方の一つは、このモジュールの <tt class="docutils literal"><span class="pre">compile()</span></tt> 関数をインタラクティブに実行することです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_compile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">py_compile</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;abc.py&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>これで <tt class="docutils literal"><span class="pre">abc.py</span></tt> と同じロケーション(オプション変数の <tt class="docutils literal"><span class="pre">cfile</span></tt> で変更することもできます)に <tt class="docutils literal"><span class="pre">.pyc</span></tt> ファイルが書き込まれます。</p>
<p><a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: ディレクトリに含まれる Python ソースファイルを、一括してバイトコンパイルします。"><tt class="xref py py-mod docutils literal"><span class="pre">compileall</span></tt></a> モジュールを使えば自動的に一つや複数のディレクトリのすべてのファイルをコンパイルできます。シェルプロンプトから <tt class="docutils literal"><span class="pre">compileall.py</span></tt> を起動して、コンパイルしたいファイルを含むディレクトリのパスを指定してください:</p>
<div class="highlight-python"><pre>python -m compileall .</pre>
</div>
</div>
<div class="section" id="id47">
<h3><a class="toc-backref" href="#id108">現在のモジュール名を知るにはどうしますか？</a><a class="headerlink" href="#id47" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールは前もって定義されたグローバル変数 <tt class="docutils literal"><span class="pre">__name__</span></tt> を検索することで自身の名前を決定できます。この値が <tt class="docutils literal"><span class="pre">'__main__'</span></tt> であるとき、そのプログラムはスクリプトとして実行されています。インポートされることによって使われる大抵のモジュールはコマンドラインインタフェースや自己テストも提供していて、
<tt class="docutils literal"><span class="pre">__name__</span></tt> をチェックしてからそのコードだけを実行します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;Running test...&#39;</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h3><a class="toc-backref" href="#id109">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a><a class="headerlink" href="#id48" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のモジュールがあったとしましょう:</p>
<p>foo.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar_var</span>
<span class="n">foo_var</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>bar.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo_var</span>
<span class="n">bar_var</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>問題はインタプリタが以下の段階を実行することです:</p>
<ul class="simple">
<li>main が foo をインポートする</li>
<li>foo の空のグローバルが生成される</li>
<li>foo がコンパイルされ実行を始める</li>
<li>foo が bar をインポートする</li>
<li>bar の空のグローバルが生成される</li>
<li>bar がコンパイルされ実行を始める</li>
<li>bar  が foo をインポートする(すでに foo という名前のモジュールがあるので no-op となる)</li>
<li>bar.foo_var = foo.foo_var</li>
</ul>
<p>この最後の段階は失敗します。Python が <tt class="docutils literal"><span class="pre">foo</span></tt> を解釈し終わっていなくて、
<tt class="docutils literal"><span class="pre">foo</span></tt> のグローバルなシンボルの辞書はまだ空ですから。</p>
<p><tt class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></tt> を使って、グローバルコードの <tt class="docutils literal"><span class="pre">foo.foo_var</span></tt> にアクセスしようとしたときにも、これと同じことが起こります。</p>
<p>この問題には (少なくとも) 三つの解決策があります。</p>
<p>Guido van Rossum は <tt class="docutils literal"><span class="pre">from</span> <span class="pre">&lt;module&gt;</span> <span class="pre">import</span> <span class="pre">...</span></tt> を全く使わないで、すべてのコードを関数の中に入れることを勧めています。グローバル変数とクラス変数の初期化は定数とビルトイン関数のみで行われるべきです。これでインポートされたすべてのモジュールは <tt class="docutils literal"><span class="pre">&lt;module&gt;.&lt;name&gt;</span></tt> として参照されることになります。</p>
<p>Jim Roskind はそれぞれのモジュールに対して以下の順に進めることを提案しています:</p>
<ul class="simple">
<li>エクスポート (インポートされた基底クラスを必要としないグローバル、関数、クラス)</li>
<li><tt class="docutils literal"><span class="pre">import</span></tt> 文</li>
<li>アクティブなコード (インポートされた値によって初期化されるグローバルを含む)</li>
</ul>
<p>インポートが奇妙な場所に現れることから van Rossum はこの方法をそれほど好みませんが、これは有効です。</p>
<p>Matthias Urlichs は第一に再帰インポートが必要ないようにコードを構築しなおすことを推奨しています。</p>
<p>これらの解決策はそれぞれ両立させることもできます。</p>
</div>
<div class="section" id="import-x-y-z-module-x-z">
<h3><a class="toc-backref" href="#id110">__import__(&#8216;x.y.z&#8217;) は &lt;module &#8216;x&#8217;&gt; を返しますが、z を得るためにはどうしますか？</a><a class="headerlink" href="#import-x-y-z-module-x-z" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>こうしてみてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">__import__</span><span class="p">(</span><span class="s">&#39;x.y.z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">z</span>
</pre></div>
</div>
<p>もっと現実的には、こうするべきかもしれません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">import_module()</span></tt></a> という便利な関数があるので、
<a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: Convenience wrappers for __import__"><tt class="xref py py-mod docutils literal"><span class="pre">importlib</span></tt></a> を参照してください。</p>
</div>
<div class="section" id="id49">
<h3><a class="toc-backref" href="#id111">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a><a class="headerlink" href="#id49" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>効率と一貫性上の理由から、Python はモジュールが最初にインポートされた時にのみモジュールファイルを読み込みます。そうしないと、たくさんのモジュールでできていて、それぞれが同じ基本モジュールをインポートしているようなプログラムでは、その基本モジュールの解析と再解析が繰り返されることになります。変更されさたモジュールの再読込を強制するには、こうしてください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">modname</span>
<span class="nb">reload</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>
</pre></div>
</div>
<p>注意:この手法は 100%安全とは言えません。とりわけ:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">modname</span> <span class="kn">import</span> <span class="n">some_objects</span>
</pre></div>
</div>
<p>のような文を含むモジュールは、インポートされたオブジェクトの古いバージョンを使い続けます。そのモジュールにクラス定義が含まれていたら、存在するクラスインスタンスは新しいクラス定義を使うようにアップデート <em>されません</em>。これによって以下の矛盾した振舞いがなされえます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>                <span class="c"># Create an instance of C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">reload</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
<span class="go">&lt;module &#39;cls&#39; from &#39;cls.pyc&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>       <span class="c"># isinstance is false?!?</span>
<span class="go">False</span>
</pre></div>
</div>
<p>この問題の性質は、クラスオブジェクトを印字することで明らかになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">__class__</span>
<span class="go">&lt;class cls.C at 0x7352a0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cls</span><span class="o">.</span><span class="n">C</span>
<span class="go">&lt;class cls.C at 0x4198d0&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python よくある質問</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>