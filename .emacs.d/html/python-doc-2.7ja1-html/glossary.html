

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>用語集 &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="about.html" />
    <link rel="copyright" title="著作権" href="copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="index.html" />
    <link rel="next" title="このドキュメントについて" href="about.html" />
    <link rel="prev" title="このドキュメントについて" href="faq/jptranslation.html" />
    <link rel="shortcut icon" type="image/png" href="_static/py.png" />
    <script type="text/javascript" src="_static/copybutton.js"></script>
    
    <script type="text/javascript" src="_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="about.html" title="このドキュメントについて"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="faq/jptranslation.html" title="このドキュメントについて"
             accesskey="P">前へ</a> |</li>
        <li><img src="_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="index.html">Python 2.7ja1 documentation</a> &raquo;</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>前のトピックへ</h4>
  <p class="topless"><a href="faq/jptranslation.html"
                        title="前の章へ">このドキュメントについて</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="about.html"
                        title="次の章へ">このドキュメントについて</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/glossary.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="glossary">
<span id="id1"></span><h1>用語集<a class="headerlink" href="#glossary" title="このヘッドラインへのパーマリンク">¶</a></h1>
<dl class="glossary docutils">
<dt id="term-"><tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt></dt>
<dd>インタラクティブシェルにおける、デフォルトのPythonプロンプト。インタラクティブに実行されるコードサンプルとしてよく出てきます。</dd>
<dt id="term-1"><tt class="docutils literal"><span class="pre">...</span></tt></dt>
<dd>インタラクティブシェルにおける、インデントされたコードブロックや対応する括弧(丸括弧()、角括弧[]、curly brace{})の内側で表示されるデフォルトのプロンプト。</dd>
<dt id="term-to3">2to3</dt>
<dd><p class="first">Python 2.x のコードを Python 3.x のコードに変換するツール。ソースコードを解析して、その解析木を巡回(traverse)して、非互換なコードの大部分を処理する。</p>
<p class="last">2to3 は、 <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: the 2to3 library"><tt class="xref py py-mod docutils literal"><span class="pre">lib2to3</span></tt></a> モジュールとして標準ライブラリに含まれています。スタンドアローンのツールとして使うときのコマンドは <tt class="file docutils literal"><span class="pre">Tools/scripts/2to3</span></tt>
として提供されています。 <a class="reference internal" href="library/2to3.html#to3-reference"><em>2to3 - Python 2 から 3 への自動コード変換</em></a> を参照してください。</p>
</dd>
<dt id="term-abstract-base-class">abstract base class</dt>
<dd>(抽象基底クラス) <a class="reference internal" href="library/collections.html#abstract-base-classes"><em>ABCs - abstract base classes</em></a> は <a class="reference internal" href="#term-duck-typing"><em class="xref std std-term">duck-typing</em></a>
を補完するもので、 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><tt class="xref py py-func docutils literal"><span class="pre">hasattr()</span></tt></a> などの別のテクニックでは不恰好になる場合にインタフェースを定義する方法を提供します。
Pythonは沢山のビルトインABCsを、(<a class="reference internal" href="library/collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> モジュールで)データ構造、
(<a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: 数の抽象基底クラス (Complex, Real, Integral など)"><tt class="xref py py-mod docutils literal"><span class="pre">numbers</span></tt></a> モジュールで)数値型、(<a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><tt class="xref py py-mod docutils literal"><span class="pre">io</span></tt></a> モジュールで)ストリーム型で提供いています。
<a class="reference internal" href="library/abc.html#module-abc" title="abc: PEP 3119 に基づいた抽象基底クラス"><tt class="xref py py-mod docutils literal"><span class="pre">abc</span></tt></a> モジュールを利用して独自のABCを作成することもできます。</dd>
<dt id="term-argument">argument</dt>
<dd><p class="first">(引数)
関数やメソッドに渡された値。関数の中では、名前の付いたローカル変数に代入されます。</p>
<p>関数やメソッドは、その定義中に位置指定引数(positional arguments, 訳注: <tt class="docutils literal"><span class="pre">f(1,</span> <span class="pre">2)</span></tt>
のように呼び出し側で名前を指定せず、引数の位置に引数の値を対応付けるもの)
とキーワード引数(keyword arguments, 訳注: <tt class="docutils literal"><span class="pre">f(a=1,</span> <span class="pre">b=2)</span></tt> のように、引数名に引数の値を対応付けるもの)の両方を持つことができます。位置指定引数とキーワード引数は可変長です。関数定義や呼び出しは、 <tt class="docutils literal"><span class="pre">*</span></tt> を使って、不定数個の位置指定引数をシーケンス型に入れて受け取ったり渡したりすることができます。同じく、キーワード引数は <tt class="docutils literal"><span class="pre">**</span></tt> を使って、辞書に入れて受け取ったり渡したりできます。</p>
<p class="last">引数リスト内では任意の式を使うことができ、その式を評価した値が渡されます。</p>
</dd>
<dt id="term-attribute">attribute</dt>
<dd>(属性)
オブジェクトに関連付けられ、ドット演算子を利用して名前で参照される値。例えば、オブジェクト <em>o</em> が属性 <em>a</em> を持っているとき、その属性は
<em>o.a</em> で参照されます。</dd>
<dt id="term-bdfl">BDFL</dt>
<dd>慈悲ぶかき独裁者 (Benevolent Dictator For Life) の略です。
Python の作者、 <a class="reference external" href="http://www.python.org/~guido/">Guido van Rossum</a>
のことです。</dd>
<dt id="term-bytecode">bytecode</dt>
<dd><p class="first">(バイトコード)
Pythonのソースコードはバイトコードへとコンパイルされます。バイトコードはPythonプログラムのインタプリタ内部での形です。バイトコードはまた、 <tt class="docutils literal"><span class="pre">.pyc</span></tt> や <tt class="docutils literal"><span class="pre">.pyo</span></tt> ファイルにキャッシュされ、同じファイルを二度目に実行した際により高速に実行できるようにします
(ソースコードからバイトコードへの再度のコンパイルは回避されます)。このバイトコードは、各々のバイトコードに対応するサブルーチンを呼び出すような
&#8220;仮想計算機(<a class="reference internal" href="#term-virtual-machine"><em class="xref std std-term">virtual machine</em></a>)&#8221; で動作する &#8220;中間言語 (intermediate language)&#8221; といえます。</p>
<p class="last">バイトコードの命令一覧は <a class="reference internal" href="library/dis.html#bytecodes"><em>dis モジュール</em></a>
にあります。</p>
</dd>
<dt id="term-class">class</dt>
<dd>(クラス)
ユーザー定義オブジェクトを作成するためのテンプレート。クラス定義は普通、そのクラスのインスタンス上の操作をするメソッドの定義を含みます。</dd>
<dt id="term-classic-class">classic class</dt>
<dd>(旧スタイルクラス)
<a class="reference internal" href="library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> を継承していないクラス全てを指します。新スタイルクラス(<a class="reference internal" href="#term-new-style-class"><em class="xref std std-term">new-style class</em></a>) も参照してください。旧スタイルクラスはPython 3.0で削除されます。</dd>
<dt id="term-coercion">coercion</dt>
<dd>(型強制)
同じ型の2つの引数を要する演算の最中に、ある型のインスタンスを別の型に暗黙のうちに変換することです。例えば、 <tt class="docutils literal"><span class="pre">int(3.15)</span></tt> は浮動小数点数を整数の <tt class="docutils literal"><span class="pre">3</span></tt> にします。しかし、 <tt class="docutils literal"><span class="pre">3+4.5</span></tt> の場合、各引数は型が異なっていて(一つは整数、一つは浮動小数点数)、加算をする前に同じ型に変換しなければいけません。そうでないと、 <tt class="docutils literal"><span class="pre">TypeError</span></tt> 例外が投げられます。
2つの被演算子間の型強制は組み込み関数の <tt class="docutils literal"><span class="pre">coerce</span></tt> を使って行えます。従って、 <tt class="docutils literal"><span class="pre">3+4.5</span></tt> は <tt class="docutils literal"><span class="pre">operator.add(*coerce(3,</span> <span class="pre">4.5))</span></tt> を呼び出すことに等しく、
<tt class="docutils literal"><span class="pre">operator.add(3.0,</span> <span class="pre">4.5)</span></tt> という結果になります。型強制を行わない場合、たとえ互換性のある型であっても、すべての引数はプログラマーが、単に <tt class="docutils literal"><span class="pre">3+4.5</span></tt> とするのではなく、
<tt class="docutils literal"><span class="pre">float(3)+4.5</span></tt> というように、同じ型に正規化しなければいけません。</dd>
<dt id="term-complex-number">complex number</dt>
<dd><p class="first">(複素数)
よく知られている実数系を拡張したもので、すべての数は実部と虚部の和として表されます。虚数は虚数単位元(<tt class="docutils literal"><span class="pre">-1</span></tt> の平方根)に実数を掛けたもので、一般に数学では <tt class="docutils literal"><span class="pre">i</span></tt>
と書かれ、工業では <tt class="docutils literal"><span class="pre">j</span></tt> と書かれます。</p>
<p>Pythonは複素数に組込みで対応し、後者の表記を取っています。虚部は末尾に <tt class="docutils literal"><span class="pre">j</span></tt> をつけて書きます。例えば、 <tt class="docutils literal"><span class="pre">3+1j</span></tt> となります。
<a class="reference internal" href="library/math.html#module-math" title="math: 数学関数(sin() など)。"><tt class="xref py py-mod docutils literal"><span class="pre">math</span></tt></a> モジュールの複素数版を利用するには、 <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: 複素数のための数学関数です。"><tt class="xref py py-mod docutils literal"><span class="pre">cmath</span></tt></a> を使います。</p>
<p class="last">複素数の使用はかなり高度な数学の機能です。必要性を感じなければ、ほぼ間違いなく無視してしまってよいでしょう。</p>
</dd>
<dt id="term-context-manager">context manager</dt>
<dd><p class="first">(コンテキストマネージャー)
<a class="reference internal" href="reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文で扱われる、環境を制御するオブジェクト。
<a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><tt class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></tt></a> と <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><tt class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></tt></a> メソッドを定義することで作られる。</p>
<p class="last"><span class="target" id="index-1"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> を参照。</p>
</dd>
<dt id="term-cpython">CPython</dt>
<dd><a class="reference external" href="http://python.org">python.org</a> で配布されている、Python
プログラミング言語の基準となる実装。
&#8220;CPython&#8221; という単語は、この実装を Jython や IronPython といった他の実装と区別する必要が有る場合に利用されます。</dd>
<dt id="term-decorator">decorator</dt>
<dd><p class="first">(デコレータ)
関数を返す関数。通常、 <tt class="docutils literal"><span class="pre">&#64;wrapper</span></tt> という文法によって関数を変換するのに利用されます。デコレータの一般的な利用レとして、 <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a> と
<a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><tt class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></tt></a> があります。</p>
<p>デコレータの文法はシンタックスシュガーです。次の2つの関数定義は意味的に同じものです。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="last">デコレータについてのより詳しい情報は、
<a class="reference internal" href="reference/compound_stmts.html#function"><em>the documentation for function definition</em></a>
を参照してください。</p>
</dd>
<dt id="term-descriptor">descriptor</dt>
<dd>(デスクリプタ)
メソッド <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a>, <a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><tt class="xref py py-meth docutils literal"><span class="pre">__set__()</span></tt></a>, あるいは <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><tt class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></tt></a>
が定義されている <em>新スタイル (new-style)</em> のオブジェクトです。あるクラス属性がデスクリプタである場合、その属性を参照するときに、そのデスクリプタに束縛されている特別な動作を呼び出します。通常、get,set,deleteのために <em>a.b</em> と書くと、 <em>a</em> のクラス辞書内でオブジェクト
<em>b</em> を検索しますが、 <em>b</em> がデスクリプタの場合にはデスクリプタで定義されたメソッドを呼び出します。デスクリプタの理解は、 Python を深く理解する上で鍵となります。というのは、デスクリプタこそが、関数、メソッド、プロパティ、クラスメソッド、静的メソッド、そしてスーパクラスの参照といった多くの機能の基盤だからです。</dd>
<dt id="term-dictionary">dictionary</dt>
<dd>(辞書)
任意のキーを値に対応付ける連想配列です。
<a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><tt class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></tt></a> メソッドと <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><tt class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></tt></a> メソッドを実装した任意のオブジェクトをキーにできます。
Perl ではハッシュ(hash)と呼ばれています。</dd>
<dt id="term-docstring">docstring</dt>
<dd>クラス、関数、モジュールの最初の式となっている文字列リテラルです。実行時には無視されますが、コンパイラによって識別され、そのクラス、関数、モジュールの <tt class="xref py py-attr docutils literal"><span class="pre">__doc__</span></tt> 属性として保存されます。イントロスペクションできる（訳注: 属性として参照できる）ので、オブジェクトのドキュメントを書く正しい場所です。</dd>
<dt id="term-duck-typing">duck-typing</dt>
<dd>あるオブジェクトが正しいインタフェースを持っているかどうかを確かめるのにオブジェクトの型をチェックしないプログラミングスタイル。代わりに、シンプルにオブジェクトのメソッドが呼ばれたり属性が使われたりします。（「もしそれがアヒルのようにみえて、ガチョウのように鳴けば、それはアヒルである」）インタフェースを型より重視することで、上手くデザインされたコードは
(polymorphicな置換を許可することによって)柔軟性を増すことができます。
duck-typing は <a class="reference internal" href="library/functions.html#type" title="type"><tt class="xref py py-func docutils literal"><span class="pre">type()</span></tt></a> や <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a> を避けます。
(ただし、duck-typing を抽象ベースクラス(<a class="reference internal" href="#term-abstract-base-class"><em class="xref std std-term">abstract base class</em></a>)で補完することもできます。)
その代わりに <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><tt class="xref py py-func docutils literal"><span class="pre">hasattr()</span></tt></a> テストや <a class="reference internal" href="#term-eafp"><em class="xref std std-term">EAFP</em></a> プログラミングを利用します。</dd>
<dt id="term-eafp">EAFP</dt>
<dd>「認可をとるより許しを請う方が容易  (easier to ask for forgiveness than permission、マーフィーの法則)」の略です。 Python で広く使われているコーディングスタイルでは、通常は有効なキーや属性が存在するものと仮定し、その仮定が誤っていた場合に例外を捕捉します。この簡潔で手早く書けるコーディングスタイルには、 <a class="reference internal" href="reference/compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> 文および
<a class="reference internal" href="reference/compound_stmts.html#except"><tt class="xref std std-keyword docutils literal"><span class="pre">except</span></tt></a> 文がたくさんあるのが特徴です。このテクニックは、C のような言語でよく使われている <a class="reference internal" href="#term-lbyl"><em class="xref std std-term">LBYL</em></a> スタイルと対照的なものです。</dd>
<dt id="term-expression">expression</dt>
<dd>(式)
何かの値に評価される、一つづきの構文(a piece of syntax).
言い換えると、リテラル、名前、属性アクセス、演算子や関数呼び出しといった、値を返す式の要素の組み合わせ。他の多くの言語と違い、Pythonは言語の全ての構成要素が式というわけではありません。
<a class="reference internal" href="reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> や <a class="reference internal" href="reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> のように、式にはならない、文(<a class="reference internal" href="#term-statement"><em class="xref std std-term">statement</em></a>)
もあります。代入も式ではなく文です。</dd>
<dt id="term-extension-module">extension module</dt>
<dd>(拡張モジュール)
CやC++で書かれたモジュール。ユーザーコードやPythonのコアとやりとりするために、
PythonのC APIを利用します。</dd>
<dt id="term-file-object">file object</dt>
<dd><p class="first">内部リソースに対してファイル由来の API (read() や write() のようなメソッド) を持つオブジェクト。作成された方法に応じて、ファイルオブジェクトはディスクや他のストレージ上のファイルやコミュニュケーション機器
(例えば標準入出力、メモリ上のバッファ、ソケット、パイプなど)
に対するアクセスを仲介します。ファイルオブジェクトは file-like object やストリームなどと呼ばれます。</p>
<p class="last">ファイルオブジェクトには3つの種類があります:
バイナリファイル、バイナリバッファ、テキストふぁいる。これらのインターフェースは io モジュール内で定義されています。ファイルオブジェクトを作成する標準的な方法は open() 関数を利用することです。</p>
</dd>
<dt id="term-file-like-object">file-like object</dt>
<dd>file object の別名</dd>
<dt id="term-finder">finder</dt>
<dd>モジュールの <a class="reference internal" href="#term-loader"><em class="xref std std-term">loader</em></a> を探すオブジェクト。
<tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> という名前のメソッドを実装していなければなりません。詳細については <span class="target" id="index-4"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> を参照してください。</dd>
<dt id="term-floor-division">floor division</dt>
<dd>一番近い小さい整数に丸める数学除算。floor division 演算子は <tt class="docutils literal"><span class="pre">//</span></tt> です。例えば、 <tt class="docutils literal"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></tt> は <tt class="docutils literal"><span class="pre">2</span></tt> になり、 float の true division の結果
<tt class="docutils literal"><span class="pre">2.75</span></tt> と異なります。
<tt class="docutils literal"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></tt> は <tt class="docutils literal"><span class="pre">-2.75</span></tt> を <em>小さい方に</em> 丸めるので <tt class="docutils literal"><span class="pre">-3</span></tt>
になることに注意してください。 <span class="target" id="index-5"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a> を参照してください。</dd>
<dt id="term-function">function</dt>
<dd>(関数)
呼び出し側に値を返す、一連の文。ゼロ個以上の引数を受け取り、それを関数の本体を実行するときに諒できます。
<a class="reference internal" href="#term-argument"><em class="xref std std-term">argument</em></a> や <a class="reference internal" href="#term-method"><em class="xref std std-term">method</em></a> も参照してください。</dd>
<dt id="term-future">__future__</dt>
<dd><p class="first">互換性のない新たな機能を現在のインタプリタで有効にするためにプログラマが利用できる擬似モジュールです。例えば、式 <tt class="docutils literal"><span class="pre">11/4</span></tt> は現状では <tt class="docutils literal"><span class="pre">2</span></tt>
になります。この式を実行しているモジュールで</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
</pre></div>
</div>
<p>を行って <em>真の除算操作 (true division)</em> を有効にすると、式 <tt class="docutils literal"><span class="pre">11/4</span></tt> は
<tt class="docutils literal"><span class="pre">2.75</span></tt> になります。実際に <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: future 文の定義"><tt class="xref py py-mod docutils literal"><span class="pre">__future__</span></tt></a> モジュールを import
してその変数を評価すれば、新たな機能が初めて追加されたのがいつで、いつデフォルトの機能になる予定かわかります。</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">garbage collection</dt>
<dd>(ガベージコレクション)
もう使われなくなったメモリを開放する処理。
Pythonは、Pythonは参照カウントと循環参照を見つけて破壊する循環参照コレクタを使ってガベージコレクションを行います。</dd>
<dt id="term-generator">generator</dt>
<dd>(ジェネレータ)
イテレータを返す関数です。通常の関数に似ていますが、 <a class="reference internal" href="reference/simple_stmts.html#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> 文を使わず、代わりに
for ループで使ったり <a class="reference internal" href="library/functions.html#next" title="next"><tt class="xref py py-func docutils literal"><span class="pre">next()</span></tt></a> 関数で1つずつ取り出せる値の列を生成するために <a class="reference internal" href="reference/simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文を使います。
<a class="reference internal" href="reference/simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文に到達するたびに関数の実行は実行状態(ローカル変数や実行中の try 文などを含む)を保存して中断されます。ジェネレータが再開されるとき、(通常の関数が実行の度に初期状態から開始するのに対して)中断した状態から実行を開始します。</dd>
<dt id="term-generator-expression">generator expression</dt>
<dd><p class="first">(ジェネレータ式)
イテレータを返す式です。普通の式に、ループ変を定義している <a class="reference internal" href="reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 式、範囲、そして省略可能な
<a class="reference internal" href="reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> 式がつづいているように見えます。こうして構成された式は、外側の関数に対して値を生成します。:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-gil">GIL</dt>
<dd>グローバルインタプリタロック(<a class="reference internal" href="#term-global-interpreter-lock"><em class="xref std std-term">global interpreter lock</em></a>)を参照してください。</dd>
<dt id="term-global-interpreter-lock">global interpreter lock</dt>
<dd><p class="first">(グローバルインタプリタロック)
<a class="reference internal" href="#term-cpython"><em class="xref std std-term">CPython</em></a> インタプリタが利用している、同時に複数のスレッドが Python
のバイトコード(<a class="reference internal" href="#term-bytecode"><em class="xref std std-term">bytecode</em></a>) を実行しないようにする仕組み。これによりオブジェクトモデル(<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> などの重要な組み込み型を含む)が暗黙的に並列アクセスに対して安全になるので、 CPython の実装をシンプルにできます。インタプリタ全体をロックすることで、マルチプロセッサマシンが生じる並列化のコストに対して、楽にインタプリタをマルチスレッド化できます。</p>
<p>ただし、標準あるいは外部のいくつかの拡張モジュールは、圧縮やハッシュ計算などの計算の重い処理をしているときにGILを解放するように設計されています。また、I/O処理をするときもGILは解放されます。</p>
<p class="last">過去に &#8220;自由なマルチスレッド化&#8221; したインタプリタ (供用されるデータを細かい粒度でロックする) が開発されましたが、一般的なシングルプロセッサの場合のパフォーマンスが悪かったので成功しませんでした。このパフォーマンスの問題を克服しようとすると、実装がより複雑になり保守コストが増加すると考えられています。</p>
</dd>
<dt id="term-hashable">hashable</dt>
<dd><p class="first">(ハッシュ可能)
<em>ハッシュ可能</em> なオブジェクトとは、生存期間中変わらないハッシュ値を持ち
(<a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><tt class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></tt></a> メソッドが必要)、他のオブジェクトと比較ができる
(<a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><tt class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></tt></a> か <a class="reference internal" href="reference/datamodel.html#object.__cmp__" title="object.__cmp__"><tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt></a> メソッドが必要) オブジェクトです。同値なハッシュ可能オブジェクトは必ず同じハッシュ値を持つ必要があります。</p>
<p>辞書のキーや集合型のメンバーは、内部でハッシュ値を使っているので、ハッシュ可能オブジェクトである必要があります。</p>
<p>Python の全ての不変(<a class="reference internal" href="#term-immutable"><em class="xref std std-term">immutable</em></a>)なビルドインオブジェクトはハッシュ可能です。リストや辞書といった変更可能なコンテナ型はハッシュ可能ではありません。</p>
<p class="last">ユーザー定義クラスのインスタンスはデフォルトでハッシュ可能です。それらは、比較すると常に不等で、ハッシュ値は <a class="reference internal" href="library/functions.html#id" title="id"><tt class="xref py py-func docutils literal"><span class="pre">id()</span></tt></a> になります。</p>
</dd>
<dt id="term-idle">IDLE</dt>
<dd>Python の組み込み開発環境 (Integrated DeveLopment Environment) です。
IDLE は Pythonの標準的な配布物についてくる基本的な機能のエディタとインタプリタ環境です。</dd>
<dt id="term-immutable">immutable</dt>
<dd>(不変オブジェクト)
固定の値を持ったオブジェクトです。変更不能なオブジェクトには、数値、文字列、およびタプルなどがあります。これらのオブジェクトは値を変えられません。別の値を記憶させる際には、新たなオブジェクトを作成しなければなりません。不変オブジェクトは、固定のハッシュ値が必要となる状況で重要な役割を果たします。辞書におけるキーがその例です。</dd>
<dt id="term-integer-division">integer division</dt>
<dd>(整数除算)
剰余を考慮しない数学的除算です。例えば、式 <tt class="docutils literal"><span class="pre">11/4</span></tt> は現状では <tt class="docutils literal"><span class="pre">2.75</span></tt> ではなく
<tt class="docutils literal"><span class="pre">2</span></tt> になります。これは <em>切り捨て除算 (floor division)</em> とも呼ばれます。二つの整数間で除算を行うと、結果は (端数切捨て関数が適用されて)  常に整数になります。しかし、被演算子の一方が (<a class="reference internal" href="library/functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a> のような) 別の数値型の場合、演算の結果は共通の型に型強制されます (型強制(<a class="reference internal" href="#term-coercion"><em class="xref std std-term">coercion</em></a>)参照)。例えば、浮動小数点数で整数を除算すると結果は浮動小数点になり、場合によっては端数部分を伴います。 <tt class="docutils literal"><span class="pre">//</span></tt> 演算子を
<tt class="docutils literal"><span class="pre">/</span></tt> の代わりに使うと、整数除算を強制できます。
<a class="reference internal" href="#term-future"><em class="xref std std-term">__future__</em></a> も参照してください。</dd>
<dt id="term-importer">importer</dt>
<dd>モジュールを探してロードするオブジェクト。 <a class="reference internal" href="#term-finder"><em class="xref std std-term">finder</em></a> と <a class="reference internal" href="#term-loader"><em class="xref std std-term">loader</em></a>
のどちらでもあるオブジェクト。</dd>
<dt id="term-interactive">interactive</dt>
<dd>(対話的)
Python には対話的インタプリタがあり、文や式をインタプリタのプロンプトに入力すると即座に実行されて結果を見ることができます。
<tt class="docutils literal"><span class="pre">python</span></tt> と何も引数を与えずに実行してください。(コンピュータのメインメニューから
Pythonの対話的インタプリタを起動できるかもしれません。)
対話的インタプリタは、新しいあアイデアを試してみたり、モジュールやパッケージの中を覗いてみる(<tt class="docutils literal"><span class="pre">help(x)</span></tt> を覚えておいてください)
のに非常に便利なツールです。</dd>
<dt id="term-interpreted">interpreted</dt>
<dd>Python はインタプリタ形式の言語であり、コンパイラ言語の対極に位置します。
(バイトコードコンパイラがあるために、この区別は曖昧ですが。)
ここでのインタプリタ言語とは、ソースコードのファイルを、まず実行可能形式にしてから実行させるといった操作なしに、直接実行できることを意味します。インタプリタ形式の言語は通常、コンパイラ形式の言語よりも開発／デバッグのサイクルは短いものの、プログラムの実行は一般に遅いです。対話的(<a class="reference internal" href="#term-interactive"><em class="xref std std-term">interactive</em></a>)も参照してください。</dd>
<dt id="term-iterable">iterable</dt>
<dd><p class="first">(反復可能オブジェクト)
要素を一つずつ返せるオブジェクトです。</p>
<p>反復可能オブジェクトの例には、(<a class="reference internal" href="library/functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, <a class="reference internal" href="library/functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="library/functions.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> といった)
全てのシーケンス型や、 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> や <a class="reference internal" href="library/functions.html#file" title="file"><tt class="xref py py-class docutils literal"><span class="pre">file</span></tt></a> といった幾つかの非シーケンス型、あるいは <a class="reference internal" href="reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> か <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> メソッドを実装したクラスのインスタンスが含まれます。</p>
<p>反復可能オブジェクトは <a class="reference internal" href="reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループ内やその他多くのシーケンス
(訳注: ここでのシーケンスとは、シーケンス型ではなくただの列という意味)が必要となる状況
(<a class="reference internal" href="library/functions.html#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a>, <a class="reference internal" href="library/functions.html#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a>, ...) で利用できます。</p>
<p class="last">反復可能オブジェクトを組み込み関数 <a class="reference internal" href="library/functions.html#iter" title="iter"><tt class="xref py py-func docutils literal"><span class="pre">iter()</span></tt></a> の引数として渡すと、オブジェクトに対するイテレータを返します。このイテレータは一連の値を引き渡す際に便利です。反復可能オブジェクトを使う際には、通常 <a class="reference internal" href="library/functions.html#iter" title="iter"><tt class="xref py py-func docutils literal"><span class="pre">iter()</span></tt></a> を呼んだり、イテレータオブジェクトを自分で扱う必要はありません。
<tt class="docutils literal"><span class="pre">for</span></tt> 文ではこの操作を自動的に行い、無名の変数を作成してループの間イテレータを記憶します。イテレータ(<a class="reference internal" href="#term-iterator"><em class="xref std std-term">iterator</em></a>) シーケンス(<a class="reference internal" href="#term-sequence"><em class="xref std std-term">sequence</em></a>),
およびジェネレータ(<a class="reference internal" href="#term-generator"><em class="xref std std-term">generator</em></a>)も参照してください。</p>
</dd>
<dt id="term-iterator">iterator</dt>
<dd><p class="first">一連のデータ列 (stream) を表現するオブジェクトです。イテレータの <a class="reference internal" href="library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドを繰り返し呼び出すと、データ列中の要素を一つずつ返します。後続のデータがなくなると、データの代わりに <a class="reference internal" href="library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> 例外を送出します。その時点で、イテレータオブジェクトは全てのオブジェクトを出し尽くしており、それ以降は <a class="reference internal" href="library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> を何度呼んでも <a class="reference internal" href="library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> を送出します。イテレータは、そのイテレータオブジェクト自体を返す <a class="reference internal" href="reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a>
メソッドを実装しなければならなくなっており、そのため全てのイテレータは他の反復可能オブジェクトを受理できるほとんどの場所で利用できます。著しい例外は複数の反復を行うようなコードです。
(<a class="reference internal" href="library/functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a> のような) コンテナオブジェクトでは、 <a class="reference internal" href="library/functions.html#iter" title="iter"><tt class="xref py py-func docutils literal"><span class="pre">iter()</span></tt></a>
関数にオブジェクトを渡したり、 <a class="reference internal" href="reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループ内で使うたびに、新たな未使用のイテレータを生成します。このイテレータをさらに別の場所でイテレータとして使おうとすると、前回のイテレーションパスで使用された同じイテレータオブジェクトを返すため、空のコンテナのように見えます。</p>
<p class="last">より詳細な情報は <a class="reference internal" href="library/stdtypes.html#typeiter"><em>イテレータ型</em></a> にあります。</p>
</dd>
<dt id="term-key-function">key function</dt>
<dd><p class="first">(キー関数)
キー関数、あるいは照合関数とは、ソートや順序比較のための値を返す呼び出し可能オブジェクト(callable)です。例えば、 <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><tt class="xref py py-func docutils literal"><span class="pre">locale.strxfrm()</span></tt></a> をキー関数に使えば、ロケール依存のソートの慣習にのっとったソートキーを返します。</p>
<p>Python には要素がどのように順序付けられたりグループ化されたりするかを制御するためにキー関数を受け付けるいくつかのツールがあります。例えば、 <a class="reference internal" href="library/functions.html#min" title="min"><tt class="xref py py-func docutils literal"><span class="pre">min()</span></tt></a>, <a class="reference internal" href="library/functions.html#max" title="max"><tt class="xref py py-func docutils literal"><span class="pre">max()</span></tt></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><tt class="xref py py-func docutils literal"><span class="pre">sorted()</span></tt></a>, <tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt>,
<a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><tt class="xref py py-func docutils literal"><span class="pre">heapq.nsmallest()</span></tt></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><tt class="xref py py-func docutils literal"><span class="pre">heapq.nlargest()</span></tt></a>, <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><tt class="xref py py-func docutils literal"><span class="pre">itertools.groupby()</span></tt></a>
です。</p>
<p>キー関数を作る方法がいくつかあります。例えば、 <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><tt class="xref py py-meth docutils literal"><span class="pre">str.lower()</span></tt></a> メソッドをキー関数として使って大文字小文字を区別しないソートができます。
(訳注: インスタンスメソッドはクラス経由でアクセスすると関数にもなります。この例では、 <tt class="docutils literal"><span class="pre">'FOO'.lower()</span></tt> と <tt class="docutils literal"><span class="pre">str.lower('FOO')</span></tt> が同じになる事を利用しています。)</p>
<p class="last">他には、アドホックにキー関数を作るために <tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></tt>
のように <a class="reference internal" href="reference/expressions.html#lambda"><tt class="xref std std-keyword docutils literal"><span class="pre">lambda</span></tt></a> 式を使うことができます。また、 <a class="reference internal" href="library/operator.html#module-operator" title="operator: 標準演算子に対応する関数"><tt class="xref py py-mod docutils literal"><span class="pre">operator</span></tt></a> モジュールは <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><tt class="xref py py-func docutils literal"><span class="pre">attrgetter()</span></tt></a>,
<a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><tt class="xref py py-func docutils literal"><span class="pre">itemgetter()</span></tt></a>, <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><tt class="xref py py-func docutils literal"><span class="pre">methodcaller()</span></tt></a> というキー関数コンストラクタを提供いしています。キー関数の作り方、使い方に関する例は、 <a class="reference internal" href="howto/sorting.html#sortinghowto"><em>Sorting HOW TO</em></a>
を参照してください。</p>
</dd>
<dt id="term-keyword-argument">keyword argument</dt>
<dd>(キーワード引数)
呼び出し時に、 <tt class="docutils literal"><span class="pre">variable_name=</span></tt> が手前にある引数。変数名は、その値が関数内のどのローカル変数に渡されるかを指定します。キーワード引数として辞書を受け取ったり渡したりするために <tt class="docutils literal"><span class="pre">**</span></tt>
を使うことができます。 <a class="reference internal" href="#term-argument"><em class="xref std std-term">argument</em></a> も参照してください。</dd>
<dt id="term-lambda">lambda</dt>
<dd>(ラムダ)
無名のインライン関数で、関数が呼び出されたときに評価される1つの式
(<a class="reference internal" href="#term-expression"><em class="xref std std-term">expression</em></a>) を持ちます。ラムダ関数を作る構文は、 <tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">[arguments]:</span> <span class="pre">expression</span></tt> です。</dd>
<dt id="term-lbyl">LBYL</dt>
<dd>「ころばぬ先の杖」 (look before you leap) の略です。このコーディングスタイルでは、呼び出しや検索を行う前に、明示的に前提条件
(pre-condition) 判定を行います。
<em>EAFP</em> アプローチと対照的で、 <a class="reference internal" href="reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> 文がたくさん使われるのが特徴的です。</dd>
<dt id="term-list">list</dt>
<dd>(リスト)
Python のビルトインのシーケンス型(<a class="reference internal" href="#term-sequence"><em class="xref std std-term">sequence</em></a>)です。リストという名前ですが、リンクリストではなく、他の言語で言う配列(array)と同種のもので、要素へのアクセスは O(1) です。</dd>
<dt id="term-list-comprehension">list comprehension</dt>
<dd>(リスト内包表記)
シーケンス内の全てあるいは一部の要素を処理して、その結果からなるリストを返す、コンパクトな書き方です。
<tt class="docutils literal"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">[&quot;0x%02x&quot;</span> <span class="pre">%</span> <span class="pre">x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></tt>
とすると、 0 から 255 までの偶数を 16進数表記 (0x..) した文字列からなるリストを生成します。
<a class="reference internal" href="reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> 節はオプションです。 <a class="reference internal" href="reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> 節がない場合、
<tt class="docutils literal"><span class="pre">range(256)</span></tt> の全ての要素が処理されます。</dd>
<dt id="term-loader">loader</dt>
<dd>モジュールをロードするオブジェクト。
<tt class="xref py py-meth docutils literal"><span class="pre">load_module()</span></tt> という名前のメソッドを定義していなければなりません。詳細は <span class="target" id="index-8"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> を参照してください。</dd>
<dt id="term-mapping">mapping</dt>
<dd>(マップ、マッピング)
任意のキーに対する検索をサポートしていて、 <tt class="xref py py-class docutils literal"><span class="pre">Mapping</span></tt> か <tt class="xref py py-class docutils literal"><span class="pre">MutableMapping</span></tt>
の <a class="reference internal" href="library/collections.html#abstract-base-classes"><em>抽象基底クラス</em></a> を実装しているコンテナオブジェクト。例えば、 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><tt class="xref py py-class docutils literal"><span class="pre">collections.defaultdict</span></tt></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><tt class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></tt></a>,
<a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><tt class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></tt></a> はマップ型です。</dd>
<dt id="term-metaclass">metaclass</dt>
<dd>(メタクラス)
クラスのクラスです。クラス定義は、クラス名、クラスの辞書と、基底クラスのリストを作ります。メタクラスは、それら3つを引数として受け取り、クラスを作る責任を負います。ほとんどのオブジェクト指向言語は(訳注:メタクラスの)デフォルトの実装を提供しています。
Pythonはカスタムのメタクラスを作成できる点が特別です。ほとんどのユーザーに取って、メタクラスは全く必要のないものです。しかし、一部の場面では、メタクラスは強力でエレガントな方法を提供します。たとえば属性アクセスのログを取ったり、スレッドセーフ性を追加したり、オブジェクトの生成を追跡したり、シングルトンを実装するなど、多くの場面で利用されます。</dd>
<dt id="term-method">method</dt>
<dd>クラス内で定義された関数。クラス属性として呼び出された場合、メソッドはインスタンスオブジェクトを第一引数(<a class="reference internal" href="#term-argument"><em class="xref std std-term">argument</em></a>) として受け取ります(この第一引数は普段
<tt class="docutils literal"><span class="pre">self</span></tt> と呼ばれます)。
<a class="reference internal" href="#term-function"><em class="xref std std-term">function</em></a> と <a class="reference internal" href="#term-nested-scope"><em class="xref std std-term">nested scope</em></a> も参照してください。</dd>
<dt id="term-method-resolution-order">method resolution order</dt>
<dd>メソッド解決順序 (Method Resolution Order) はメンバの探索時の基底クラスの探索順序です。
Python 2.3 の Method Resolution Order を参照して下さい。</dd>
<dt id="term-mro">MRO</dt>
<dd>method resolution order を参照して下さい。</dd>
<dt id="term-mutable">mutable</dt>
<dd>(変更可能オブジェクト)
変更可能なオブジェクトは、 <a class="reference internal" href="library/functions.html#id" title="id"><tt class="xref py py-func docutils literal"><span class="pre">id()</span></tt></a> を変えることなく値を変更できます。変更不能 (<a class="reference internal" href="#term-immutable"><em class="xref std std-term">immutable</em></a>) も参照してください。</dd>
<dt id="term-named-tuple">named tuple</dt>
<dd><p class="first">(名前付きタプル)
タプルに似ていて、インデックスによりアクセスする要素に名前付き属性としてもアクセス出来るクラス。
(例えば、 <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><tt class="xref py py-func docutils literal"><span class="pre">time.localtime()</span></tt></a> はタプルに似たオブジェクトを返し、その <em>year</em> には <tt class="docutils literal"><span class="pre">t[0]</span></tt> のようなインデックスによるアクセスと、
<tt class="docutils literal"><span class="pre">t.tm_year</span></tt> のような名前付き要素としてのアクセスが可能です。)</p>
<p class="last">名前付きタプルには、 <a class="reference internal" href="library/time.html#time.struct_time" title="time.struct_time"><tt class="xref py py-class docutils literal"><span class="pre">time.struct_time</span></tt></a> のようなビルトイン型もありますし、通常のクラス定義によって作成することもできます。名前付きタプルを <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><tt class="xref py py-func docutils literal"><span class="pre">collections.namedtuple()</span></tt></a> ファクトリ関数で作成することもできます。最後の方法で作った名前付きタプルには自動的に、
<tt class="docutils literal"><span class="pre">Employee(name='jones',</span> <span class="pre">title='programmer')</span></tt> のような自己ドキュメント表現(self-documenting
representation) 機能が付いてきます。</p>
</dd>
<dt id="term-namespace">namespace</dt>
<dd>(名前空間)
変数を記憶している場所です。名前空間は辞書を用いて実装されています。名前空間には、ローカル、グローバル、組み込み名前空間、そして (メソッド内の)
オブジェクトのネストされた名前空間があります。例えば、関数 <tt class="xref py py-func docutils literal"><span class="pre">__builtin__.open()</span></tt> と <a class="reference internal" href="library/os.html#os.open" title="os.open"><tt class="xref py py-func docutils literal"><span class="pre">os.open()</span></tt></a>
は名前空間で区別されます。名前空間はまた、ある関数をどのモジュールが実装しているかをはっきりさせることで、可読性やメンテナンス性に寄与します。例えば、 <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><tt class="xref py py-func docutils literal"><span class="pre">random.seed()</span></tt></a>, <a class="reference internal" href="library/itertools.html#itertools.izip" title="itertools.izip"><tt class="xref py py-func docutils literal"><span class="pre">itertools.izip()</span></tt></a> と書くことで、これらの関数がそれぞれ
<a class="reference internal" href="library/random.html#module-random" title="random: よく知られている様々な分布をもつ擬似乱数を生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt></a> モジュールや <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: 効率的なループ実行のためのイテレータ生成関数。"><tt class="xref py py-mod docutils literal"><span class="pre">itertools</span></tt></a>
モジュールで実装されていることがはっきりします。</dd>
<dt id="term-nested-scope">nested scope</dt>
<dd>(ネストされたスコープ)
外側で定義されている変数を参照する機能。具体的に言えば、ある関数が別の関数の中で定義されている場合、内側の関数は外側の関数中の変数を参照できます。ネストされたスコープは変数の参照だけができ、変数の代入はできないので注意してください。変数の代入は、常に最も内側のスコープにある変数に対する書き込みになります。同様に、グローバル変数を使うとグローバル名前空間の値を読み書きします。</dd>
<dt id="term-new-style-class">new-style class</dt>
<dd><p class="first">(新スタイルクラス)
<a class="reference internal" href="library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> から継承したクラス全てを指します。これには <a class="reference internal" href="library/functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a> や <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>
のような全ての組み込み型が含まれます。 <a class="reference internal" href="reference/datamodel.html#__slots__" title="__slots__"><tt class="xref py py-meth docutils literal"><span class="pre">__slots__()</span></tt></a>, デスクリプタ、プロパティ、
<a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> といった、
Python の新しい機能を使えるのは新スタイルクラスだけです。</p>
<p class="last">より詳しい情報は <a class="reference internal" href="reference/datamodel.html#newstyle"><em>新スタイルと旧スタイル</em></a> を参照してください。</p>
</dd>
<dt id="term-object">object</dt>
<dd>状態(属性や値)と定義された振る舞い(メソッド)をもつ全てのデータ。もしくは、全ての新スタイルクラス(<a class="reference internal" href="#term-new-style-class"><em class="xref std std-term">new-style class</em></a>)
の基底クラスのこと。</dd>
<dt id="term-positional-argument">positional argument</dt>
<dd>(位置指定引数)
引数のうち、呼び出すときの順序で、関数やメソッドの中のどの名前に代入されるかが決定されるもの。複数の位置指定引数を、関数定義側が受け取ったり、渡したりするために、
<tt class="docutils literal"><span class="pre">*</span></tt> を使うことができます。
<a class="reference internal" href="#term-argument"><em class="xref std std-term">argument</em></a> も参照してください。</dd>
<dt id="term-python-3000">Python 3000</dt>
<dd>Pythonの次のメジャーバージョンである Python 3.0 のニックネームです。
(Python 3 が遠い将来の話だった頃に作られた言葉です。)
&#8220;Py3k&#8221; と略されることもあります。</dd>
<dt id="term-pythonic">Pythonic</dt>
<dd><p class="first">他の言語で一般的な考え方で書かれたコードではなく、Python の特に一般的なイディオムに繋がる、考え方やコード。例えば、Python の一般的なイディオムに iterable の要素を <a class="reference internal" href="reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a>
文を使って巡回することです。この仕組を持たない言語も多くあるので、Python
に慣れ親しんでいない人は数値のカウンターを使うかもしれません。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>これと対照的な、よりきれいな Pythonic な方法はこうなります。</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">piece</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">reference count</dt>
<dd>(参照カウント)
あるオブジェクトに対する参照の数。参照カウントが0になったとき、そのオブジェクトは破棄されます。参照カウントは通常は Python のコード上には現れませんが、
<a class="reference internal" href="#term-cpython"><em class="xref std std-term">CPython</em></a> 実装の重要な要素です。
<a class="reference internal" href="library/sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a> モジュールは、プログラマーが任意のオブジェクトの参照カウントを知るための <tt class="xref py py-func docutils literal"><span class="pre">getrefcount()</span></tt> 関数を提供しています。</dd>
<dt id="term-slots">__slots__</dt>
<dd>新スタイルクラス(<a class="reference internal" href="#term-new-style-class"><em class="xref std std-term">new-style class</em></a>)内で、インスタンス属性の記憶に必要な領域をあらかじめ定義しておき、それとひきかえにインスタンス辞書を排除してメモリの節約を行うための宣言です。これはよく使われるテクニックですが、正しく動作させるのには少々手際を要するので、例えばメモリが死活問題となるようなアプリケーション内にインスタンスが大量に存在するといった稀なケースを除き、使わないのがベストです。</dd>
<dt id="term-sequence">sequence</dt>
<dd>(シーケンス)
特殊メソッド <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> で整数インデックスによる効率的な要素へのアクセスをサポートし、 <a class="reference internal" href="library/functions.html#len" title="len"><tt class="xref py py-meth docutils literal"><span class="pre">len()</span></tt></a> で長さを返すような反復可能オブジェクト(<a class="reference internal" href="#term-iterable"><em class="xref std std-term">iterable</em></a>)です。組み込みシーケンス型には、 <a class="reference internal" href="library/functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, <a class="reference internal" href="library/functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="library/functions.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a>, <a class="reference internal" href="library/functions.html#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a>
などがあります。
<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> は <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> と <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><tt class="xref py py-meth docutils literal"><span class="pre">__len__()</span></tt></a> もサポートしますが、検索の際に任意の変更不能(<a class="reference internal" href="#term-immutable"><em class="xref std std-term">immutable</em></a>)なキーを使うため、シーケンスではなくマップ (mapping) とみなされているので注意してください。</dd>
<dt id="term-slice">slice</dt>
<dd>(スライス)
多くの場合、シーケンス(<a class="reference internal" href="#term-sequence"><em class="xref std std-term">sequence</em></a>)の一部を含むオブジェクト。スライスは、添字記号 <tt class="docutils literal"><span class="pre">[]</span></tt> で数字の間にコロンを書いたときに作られます。例えば、 <tt class="docutils literal"><span class="pre">variable_name[1:3:5]</span></tt> です。添字記号は <a class="reference internal" href="library/functions.html#slice" title="slice"><tt class="xref py py-class docutils literal"><span class="pre">slice</span></tt></a> オブジェクトを内部で利用しています。
(もしくは、古いバージョンの、 <a class="reference internal" href="reference/datamodel.html#object.__getslice__" title="object.__getslice__"><tt class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></tt></a> と <a class="reference internal" href="reference/datamodel.html#object.__setslice__" title="object.__setslice__"><tt class="xref py py-meth docutils literal"><span class="pre">__setslice__()</span></tt></a>
を利用します。)</dd>
<dt id="term-special-method">special method</dt>
<dd>(特殊メソッド)
ある型に対する特定の動作をするために、 Python から暗黙的に呼ばれるメソッド。この種類のメソッドは、メソッド名の最初と最後にアンダースコア2つを持ちます。特殊メソッドについては <a class="reference internal" href="reference/datamodel.html#specialnames"><em>特殊メソッド名</em></a> で解説されています。</dd>
<dt id="term-statement">statement</dt>
<dd>(文)
文は一種のコードブロックです。文は <a class="reference internal" href="#term-expression"><em class="xref std std-term">expression</em></a> か、それ以外のキーワードにより構成されます。例えば <a class="reference internal" href="reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><tt class="xref std std-keyword docutils literal"><span class="pre">while</span></tt></a>, <a class="reference internal" href="reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> は文です。</dd>
<dt id="term-triple-quoted-string">triple-quoted string</dt>
<dd>(三重クォート文字列)
3つの連続したクォート記号(&#8221;)かアポストロフィー(&#8216;)で囲まれた文字列。通常の(一重)クォート文字列に比べて表現できる文字列に違いはありませんが、幾つかの理由で有用です。
1つか2つの連続したクォート記号をエスケープ無しに書くことができますし、行継続文字(\)を使わなくても複数行にまたがることができるので、ドキュメンテーション文字列を書く時に特に便利です。</dd>
<dt id="term-type">type</dt>
<dd>(型)
Python のオブジェクトの型は、そのオブジェクトの種類を決定します。全てのオブジェクトは型を持っています。オブジェクトの型は、 <tt class="xref py py-attr docutils literal"><span class="pre">__class__</span></tt> 属性からアクセスしたり、
<tt class="docutils literal"><span class="pre">type(obj)</span></tt> で取得することができます。</dd>
<dt id="term-view">view</dt>
<dd>(ビュー)
<a class="reference internal" href="library/stdtypes.html#dict.viewkeys" title="dict.viewkeys"><tt class="xref py py-meth docutils literal"><span class="pre">dict.viewkeys()</span></tt></a>, <a class="reference internal" href="library/stdtypes.html#dict.viewvalues" title="dict.viewvalues"><tt class="xref py py-meth docutils literal"><span class="pre">dict.viewvalues()</span></tt></a>, <a class="reference internal" href="library/stdtypes.html#dict.viewitems" title="dict.viewitems"><tt class="xref py py-meth docutils literal"><span class="pre">dict.viewitems()</span></tt></a>
が返すオブジェクトのことを辞書ビュー(dictionary view)と呼びます。これらはベースとなる辞書の変更を反映する、遅延シーケンスです。辞書ビューを完全なリストにするには <tt class="docutils literal"><span class="pre">list(dictview)</span></tt> としてください。
<a class="reference internal" href="library/stdtypes.html#dict-views"><em>辞書ビューオブジェクト</em></a> を参照してください。</dd>
<dt id="term-virtual-machine">virtual machine</dt>
<dd>(仮想マシン)
ソフトウェアにより定義されたコンピュータ。
Python の仮想マシンは、バイトコードコンパイラが出力したバイトコード
(<a class="reference internal" href="#term-bytecode"><em class="xref std std-term">bytecode</em></a>)を実行します。</dd>
<dt id="term-zen-of-python">Zen of Python</dt>
<dd>(Pythonの悟り)
Python を理解し利用する上での導きとなる、Python の設計原則と哲学をリストにしたものです。対話プロンプトで &#8220;<tt class="docutils literal"><span class="pre">import</span> <span class="pre">this</span></tt>&#8221; とするとこのリストを読めます。</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="about.html" title="このドキュメントについて"
             >次へ</a> |</li>
        <li class="right" >
          <a href="faq/jptranslation.html" title="このドキュメントについて"
             >前へ</a> |</li>
        <li><img src="_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="index.html">Python 2.7ja1 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>