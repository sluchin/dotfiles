

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>20.2. cgi — CGI (ゲートウェイインタフェース規格) のサポート &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="20. インターネットプロトコルとその支援" href="internet.html" />
    <link rel="next" title="20.3. cgitb — CGI スクリプトのトレースバック管理機構" href="cgitb.html" />
    <link rel="prev" title="20.1. webbrowser — 便利なウェブブラウザコントローラー" href="webbrowser.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="cgitb.html" title="20.3. cgitb — CGI スクリプトのトレースバック管理機構"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="webbrowser.html" title="20.1. webbrowser — 便利なウェブブラウザコントローラー"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="internet.html" accesskey="U">20. インターネットプロトコルとその支援</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">20.2. <tt class="docutils literal"><span class="pre">cgi</span></tt> &#8212; CGI (ゲートウェイインタフェース規格) のサポート</a><ul>
<li><a class="reference internal" href="#id1">20.2.1. はじめに</a></li>
<li><a class="reference internal" href="#cgi">20.2.2. cgi モジュールを使う</a></li>
<li><a class="reference internal" href="#id2">20.2.3. 高水準インタフェース</a></li>
<li><a class="reference internal" href="#id4">20.2.4. 古いクラス群</a></li>
<li><a class="reference internal" href="#functions-in-cgi-module">20.2.5. 関数</a></li>
<li><a class="reference internal" href="#cgi-security">20.2.6. セキュリティへの配慮</a></li>
<li><a class="reference internal" href="#cgi-unix">20.2.7. CGI スクリプトを Unix システムにインストールする</a></li>
<li><a class="reference internal" href="#id7">20.2.8. CGI スクリプトをテストする</a></li>
<li><a class="reference internal" href="#id8">20.2.9. CGI スクリプトをデバッグする</a></li>
<li><a class="reference internal" href="#id9">20.2.10. よくある問題と解決法</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="webbrowser.html"
                        title="前の章へ">20.1. <tt class="docutils literal"><span class="pre">webbrowser</span></tt> &#8212; 便利なウェブブラウザコントローラー</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="cgitb.html"
                        title="次の章へ">20.3. <tt class="docutils literal"><span class="pre">cgitb</span></tt> &#8212; CGI スクリプトのトレースバック管理機構</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/cgi.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-cgi">
<span id="cgi-cgi"></span><h1>20.2. <a class="reference internal" href="#module-cgi" title="cgi: PythonスクリプトをCGIとして実行するためのヘルパー"><tt class="xref py py-mod docutils literal"><span class="pre">cgi</span></tt></a> &#8212; CGI (ゲートウェイインタフェース規格) のサポート<a class="headerlink" href="#module-cgi" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">ゲートウェイインタフェース規格 (CGI) に準拠したスクリプトをサポートするためのモジュールです。</p>
<p>このモジュールでは、 Python で CGI スクリプトを書く際に使える様々なユーティリティを定義しています。</p>
<div class="section" id="id1">
<h2>20.2.1. はじめに<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="cgi-intro">CGI スクリプトは、HTTP サーバによって起動され、通常は HTML の <tt class="docutils literal"><span class="pre">&lt;FORM&gt;</span></tt> または <tt class="docutils literal"><span class="pre">&lt;ISINDEX&gt;</span></tt> エレメントを通じてユーザが入力した内容を処理します。</p>
<p>ほとんどの場合、CGI スクリプトはサーバ上の特殊なディレクトリ <tt class="file docutils literal"><span class="pre">cgi-bin</span></tt> の下に置きます。HTTP サーバは、まずスクリプトを駆動するためのシェルの環境変数に、リクエストの全ての情報  (クライアントのホスト名、リクエストされている URL、クエリ文字列、その他諸々)
を設定し、スクリプトを実行した後、スクリプトの出力をクライアントに送信します。</p>
<p>スクリプトの入力端もクライアントに接続されていて、この経路を通じてフォームデータを読み込むこともあります。それ以外の場合には、フォームデータは URL
の一部分である「クエリ文字列」を介して渡されます。このモジュールでは、上記のケースの違いに注意しつつ、 Python
スクリプトに対しては単純なインタフェースを提供しています。このモジュールではまた、スクリプトをデバッグするためのユーティリティも多数提供しています。また、最近はフォームを経由したファイルのアップロードをサポートしています (ブラウザ側がサポートしていればです)。</p>
<p>CGI スクリプトの出力は 2 つのセクションからなり、空行で分割されています。最初のセクションは複数のヘッダからなり、後続するデータがどのようなものかをクライアントに通知します。最小のヘッダセクションを生成するための Python のコードは以下のようなものです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;Content-Type: text/html&quot;</span>     <span class="c"># 以降のデータが HTML であることを示す行</span>
<span class="k">print</span>                               <span class="c"># ヘッダ部の終了を示す空行</span>
</pre></div>
</div>
<p>二つ目のセクションは通常、ヘッダやインラインイメージ等の付属したテキストをうまくフォーマットして表示できるようにした HTML です。以下に単純な HTML
を出力する Python コードを示します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;&lt;TITLE&gt;CGI script output&lt;/TITLE&gt;&quot;</span>
<span class="k">print</span> <span class="s">&quot;&lt;H1&gt;This is my first CGI script&lt;/H1&gt;&quot;</span>
<span class="k">print</span> <span class="s">&quot;Hello, world!&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="cgi">
<span id="using-the-cgi-module"></span><h2>20.2.2. cgi モジュールを使う<a class="headerlink" href="#cgi" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>先頭には <tt class="docutils literal"><span class="pre">import</span> <span class="pre">cgi</span></tt> と書いてください。 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">cgi</span> <span class="pre">import</span> <span class="pre">*</span></tt> と書いてはなりません &#8212;
このモジュールでは、以前のバージョンとの互換性を持たせるため、内部で呼び出す名前を多数定義しており、それらをユーザの名前空間に存在させる必要はないからです。</p>
<p>新たにスクリプトを書く際には、以下の行を付加するかどうか検討してください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cgitb</span>
<span class="n">cgitb</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
</pre></div>
</div>
<p>これによって、特別な例外処理が有効にされ、エラーが発生した際にブラウザ上に詳細なレポートを出力するようになります。ユーザにスクリプトの内部を見せたくないのなら、以下のようにしてレポートをファイルに保存できます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cgitb</span>
<span class="n">cgitb</span><span class="o">.</span><span class="n">enable</span><span class="p">(</span><span class="n">display</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">logdir</span><span class="o">=</span><span class="s">&quot;/tmp&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>スクリプトを開発する際には、この機能はとても役に立ちます。 <a class="reference internal" href="cgitb.html#module-cgitb" title="cgitb: 設定可能な、CGI スクリプトのトレースバック処理機構です。"><tt class="xref py py-mod docutils literal"><span class="pre">cgitb</span></tt></a> が生成する報告はバグを追跡するためにかかる時間を大幅に減らせるような情報を提供してくれます。スクリプトをテストし終わり、正確に動作することを確認したら、いつでも <tt class="docutils literal"><span class="pre">cgitb</span></tt>
の行を削除できます。</p>
<p>入力されたフォームデータを取得するには、 <tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> クラスを使うのが最良の方法です。このモジュールで定義されている他のクラスのほとんどは以前のバージョンとの互換性のためのものです。インスタンス生成は引数なしで必ず
1 度だけ行います。これにより、標準入力または環境変数からフォームの内容を読み出します (どちらから読み出すかは、複数の環境変数の値が CGI 標準に従ってどう設定されているかで決まります)。インスタンスが標準入力を使うかもしれないので、インスタンス生成を行うのは一度だけにしなければなりません。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> のインスタンスは Python の辞書のようにインデクスを使って参照できます。
<a class="reference internal" href="../reference/expressions.html#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> 演算子を使って包含検査でき、辞書の標準メソッド <tt class="xref py py-meth docutils literal"><span class="pre">keys()</span></tt> や組み込み関数 <a class="reference internal" href="functions.html#len" title="len"><tt class="xref py py-func docutils literal"><span class="pre">len()</span></tt></a> もサポートしています。空の文字列を含むフォームのフィールドは無視され、辞書には入りません; そういった値を保持するには、
<tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> のインスタンスを生成する時にオプションの  <em>keep_blank_values</em> キーワード引数を true
に設定してください。</p>
<p>例えば、以下のコード (<em class="mailheader">Content-Type</em> ヘッダと空行はすでに出力された後とします) は <tt class="docutils literal"><span class="pre">name</span></tt> および
<tt class="docutils literal"><span class="pre">addr</span></tt>  フィールドが両方とも空の文字列に設定されていないか調べます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">form</span> <span class="o">=</span> <span class="n">cgi</span><span class="o">.</span><span class="n">FieldStorage</span><span class="p">()</span>
<span class="k">if</span> <span class="s">&quot;name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">form</span> <span class="ow">or</span> <span class="s">&quot;addr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">form</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;&lt;H1&gt;Error&lt;/H1&gt;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;Please fill in the name and addr fields.&quot;</span>
    <span class="k">return</span>
<span class="k">print</span> <span class="s">&quot;&lt;p&gt;name:&quot;</span><span class="p">,</span> <span class="n">form</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
<span class="k">print</span> <span class="s">&quot;&lt;p&gt;addr:&quot;</span><span class="p">,</span> <span class="n">form</span><span class="p">[</span><span class="s">&quot;addr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
<span class="o">...</span><span class="n">further</span> <span class="n">form</span> <span class="n">processing</span> <span class="n">here</span><span class="o">...</span>
</pre></div>
</div>
<p>ここで、 <tt class="docutils literal"><span class="pre">form[key]</span></tt> で参照される各フィールドはそれ自体が <tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> (または
<tt class="xref py py-class docutils literal"><span class="pre">MiniFieldStorage</span></tt> 。フォームのエンコードによって変わります) のインスタンスです。インスタンスの属性
<tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> の内容は対応するフィールドの値で、文字列になります。 <tt class="xref py py-meth docutils literal"><span class="pre">getvalue()</span></tt> メソッドはこの文字列値を直接返します。
<tt class="xref py py-meth docutils literal"><span class="pre">getvalue()</span></tt> の 2 つめの引数にオプションの値を与えると、リクエストされたキーが存在しない場合に返すデフォルトの値になります。</p>
<p>入力されたフォームデータに同じ名前のフィールドが二つ以上あれば、 <tt class="docutils literal"><span class="pre">form[key]</span></tt> で得られるオブジェクトは
<tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> や <tt class="xref py py-class docutils literal"><span class="pre">MiniFieldStorage</span></tt> のインスタンスではなく、そうしたインスタンスのリストになります。この場合、 <tt class="docutils literal"><span class="pre">form.getvalue(key)</span></tt> も同様に、文字列からなるリストを返します。もしこうした状況が起きうると思うなら
(HTML のフォームに同じ名前をもったフィールドが複数含まれているのなら) 、組み込み関数 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a>
を使って、返された値が単一のインスタンスかインスタンスのリストかどうか調べてください。例えば、以下のコードは任意の数のユーザ名フィールドを結合し、コンマで分割された文字列にします:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">value</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span><span class="s">&quot;username&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="c"># Multiple username fields specified</span>
    <span class="n">usernames</span> <span class="o">=</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># Single or no username field specified</span>
    <span class="n">usernames</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>フィールドがアップロードされたファイルを表している場合、 <tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> 属性や <tt class="xref py py-func docutils literal"><span class="pre">getvalue()</span></tt>
メソッドを使ってフィールドの値にアクセスすると、ファイルの内容を全て文字列としてメモリ上に読み込んでしまいます。これは望ましくない機能かもしれません。アップロードされたファイルがあるかどうかは <tt class="xref py py-attr docutils literal"><span class="pre">filename</span></tt> 属性および <tt class="xref py py-attr docutils literal"><span class="pre">file</span></tt>
属性のいずれかで調べられます。その後、以下のようにして <tt class="xref py py-attr docutils literal"><span class="pre">file</span></tt> 属性から落ち着いてデータを読み出せます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fileitem</span> <span class="o">=</span> <span class="n">form</span><span class="p">[</span><span class="s">&quot;userfile&quot;</span><span class="p">]</span>
<span class="k">if</span> <span class="n">fileitem</span><span class="o">.</span><span class="n">file</span><span class="p">:</span>
    <span class="c"># It&#39;s an uploaded file; count lines</span>
    <span class="n">linecount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">fileitem</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">linecount</span> <span class="o">=</span> <span class="n">linecount</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>アップロードされたファイルの内容を取得している間にエラーが発生した場合
(例えば、ユーザーがバックやキャンセルボタンで submit を中断した場合)、そのフィールドのオブジェクトの <tt class="xref py py-attr docutils literal"><span class="pre">done</span></tt> 属性には -1 が設定されます。</p>
<p>現在ドラフトとなっているファイルアップロードの標準仕様では、一つのフィールドから (再帰的な <em class="mimetype">multipart/*</em>
エンコーディングを使って) 複数のファイルがアップロードされる可能性を受け入れています。この場合、アイテムは辞書形式の
<tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> アイテムとなります。複数ファイルかどうかは <tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt> 属性が
<em class="mimetype">multipart/form-data</em> (または <em class="mimetype">multipart/*</em> にマッチする他の MIME 型)
になっているかどうかを調べれば判別できます。この場合、トップレベルのフォームオブジェクトと同様にして再帰的に個別処理できます。</p>
<p>フォームが「古い」形式で入力された場合 (クエリ文字列または単一の <em class="mimetype">application/x-www-form-urlencoded</em>
データで入力された場合)、データ要素の実体は <tt class="xref py py-class docutils literal"><span class="pre">MiniFieldStorage</span></tt> クラスのインスタンスになります。この場合、 <tt class="xref py py-attr docutils literal"><span class="pre">list</span></tt> 、 <tt class="xref py py-attr docutils literal"><span class="pre">file</span></tt> 、および <tt class="xref py py-attr docutils literal"><span class="pre">filename</span></tt> 属性は常に <tt class="docutils literal"><span class="pre">None</span></tt>
になります。</p>
<p>フォームがPOSTによって送信され、クエリー文字列も持っていた場合、
<tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> と <tt class="xref py py-class docutils literal"><span class="pre">MiniFieldStorage</span></tt> の両方が含まれます。</p>
</div>
<div class="section" id="id2">
<h2>20.2.3. 高水準インタフェース<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p>前節では CGI フォームデータを <tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> クラスを使って読み出す方法について解説しました。この節では、フォームデータを分かりやすく直感的な方法で読み出せるようにするために追加された、より高水準のインタフェースについて記述します。このインタフェースは前節で説明した技術を撤廃するものではありません &#8212; 例えば、前節の技術は依然としてファイルのアップロードを効率的に行う上で便利です。</p>
<p>このインタフェースは 2 つの単純なメソッドからなります。このメソッドを使えば、一般的な方法でフォームデータを処理でき、ある名前のフィールドに入力された値が一つなのかそれ以上なのかを心配する必要がなくなります。</p>
<p>前節では、一つのフィールド名に対して二つ以上の値が入力されるかもしれない場合には、常に以下のようなコードを書くよう学びました:</p>
<div class="highlight-python"><pre>item = form.getvalue("item")
if isinstance(item, list):
    # The user is requesting more than one item.
else:
    # The user is requesting only one item.</pre>
</div>
<p>こういった状況は、例えば以下のように、同じ名前を持った複数のチェックボックスからなるグループがフォームに入っているような場合によく起きます:</p>
<div class="highlight-python"><pre>&lt;input type="checkbox" name="item" value="1" /&gt;
&lt;input type="checkbox" name="item" value="2" /&gt;</pre>
</div>
<p>しかしながら、ほとんどの場合、あるフォーム中で特定の名前を持ったコントロールはただ一つしかないので、その名前に関連付けられた値はただ一つしかないはずだと考えるでしょう。そこで、スクリプトには例えば以下のようなコードを書くでしょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span><span class="s">&quot;user&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
</pre></div>
</div>
<p>このコードの問題点は、クライアント側がスクリプトにとって常に有効な入力を提供するとは期待できないところにあります。例えば、もし好奇心旺盛なユーザがもう一つの
<tt class="docutils literal"><span class="pre">user=foo</span></tt> ペアをクエリ文字列に追加したら、 <tt class="docutils literal"><span class="pre">getvalue('user')</span></tt> メソッドは文字列ではなくリストを返すため、このスクリプトはクラッシュするでしょう。リストに対して <a class="reference internal" href="stdtypes.html#str.upper" title="str.upper"><tt class="xref py py-meth docutils literal"><span class="pre">upper()</span></tt></a> メソッドを呼び出すと、引数が有効でない (リスト型はその名前のメソッドを持っていない) ため、例外 <a class="reference internal" href="exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> を送出します。</p>
<p>従って、フォームデータの値を読み出しには、得られた値が単一の値なのか値のリストなのかを常に調べるコードを使うのが適切でした。これでは煩わしく、より読みにくいスクリプトになってしまいます。</p>
<p>ここで述べる高水準のインタフェースで提供している <tt class="xref py py-meth docutils literal"><span class="pre">getfirst()</span></tt> や <tt class="xref py py-meth docutils literal"><span class="pre">getlist()</span></tt>
メソッドを使うと、もっと便利にアプローチできます。</p>
<dl class="method">
<dt id="cgi.FieldStorage.getfirst">
<tt class="descclassname">FieldStorage.</tt><tt class="descname">getfirst</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cgi.FieldStorage.getfirst" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フォームフィールド <em>name</em> に関連付けられた値をつねに一つだけ返す軽量メソッドです。同じ名前で 1 つ以上の値がポストされている場合、このメソッドは最初の値だけを返します。フォームから値を受信する際の値の並び順はブラウザ間で異なる可能性があり、特定の順番であるとは期待できないので注意してください。  <a class="footnote-reference" href="#id10" id="id3">[1]</a></p>
<p>指定したフォームフィールドや値がない場合、このメソッドはオプションの引数 <em>default</em> を返します。このパラメタを指定しない場合、標準の値は
<tt class="docutils literal"><span class="pre">None</span></tt> に設定されます。</p>
</dd></dl>

<dl class="method">
<dt id="cgi.FieldStorage.getlist">
<tt class="descclassname">FieldStorage.</tt><tt class="descname">getlist</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#cgi.FieldStorage.getlist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドはフォームフィールド <em>name</em> に関連付けられた値を常にリストにして返します。 <em>name</em> に指定したフォームフィールドや値が存在しない場合、このメソッドは空のリストを返します。値が一つだけ存在する場合、要素を一つだけ含むリストを返します。</p>
</dd></dl>

<p>これらのメソッドを使うことで、以下のようにナイスでコンパクトにコードを書けます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cgi</span>
<span class="n">form</span> <span class="o">=</span> <span class="n">cgi</span><span class="o">.</span><span class="n">FieldStorage</span><span class="p">()</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">getfirst</span><span class="p">(</span><span class="s">&quot;user&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>    <span class="c"># This way it&#39;s safe.</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">form</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>20.2.4. 古いクラス群<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="deprecated">
<span class="versionmodified">バージョン 2.6 で撤廃: </span>これらのクラスは、 <a class="reference internal" href="#module-cgi" title="cgi: PythonスクリプトをCGIとして実行するためのヘルパー"><tt class="xref py py-mod docutils literal"><span class="pre">cgi</span></tt></a> モジュールの以前のバージョンに入っており、以前のバージョンとの互換性のために現在もサポートされています。
新しいアプリケーションでは <tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> クラスを使うべきです。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">SvFormContentDict</span></tt> は単一の値しか持たないフォームデータの内容を辞書として記憶します;
このクラスでは、各フィールド名はフォーム中に一度しか現れないと仮定しています。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">FormContentDict</span></tt> は複数の値を持つフォームデータの内容を辞書として記憶します (フォーム要素は値のリストです);
フォームが同じ名前を持ったフィールドを複数含む場合に便利です。</p>
<p>他のクラス (<tt class="xref py py-class docutils literal"><span class="pre">FormContent</span></tt> 、 <tt class="xref py py-class docutils literal"><span class="pre">InterpFormContentDict</span></tt>) は非常に古いアプリケーションとの後方互換性のために存在します。</p>
</div>
<div class="section" id="functions-in-cgi-module">
<span id="id5"></span><h2>20.2.5. 関数<a class="headerlink" href="#functions-in-cgi-module" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>より細かく CGI をコントロールしたり、このモジュールで実装されているアルゴリズムを他の状況で利用したい場合には、以下の関数が便利です。</p>
<dl class="function">
<dt id="cgi.parse">
<tt class="descclassname">cgi.</tt><tt class="descname">parse</tt><big>(</big><em>fp</em><span class="optional">[</span>, <em>keep_blank_values</em><span class="optional">[</span>, <em>strict_parsing</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cgi.parse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>環境変数、またはファイルからからクエリを解釈します (ファイルは標準で <tt class="docutils literal"><span class="pre">sys.stdin</span></tt> になります) <em>keep_blank_values</em>
および <em>strict_parsing</em> パラメタはそのまま <a class="reference internal" href="urlparse.html#urlparse.parse_qs" title="urlparse.parse_qs"><tt class="xref py py-func docutils literal"><span class="pre">urlparse.parse_qs()</span></tt></a> に渡されます。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.parse_qs">
<tt class="descclassname">cgi.</tt><tt class="descname">parse_qs</tt><big>(</big><em>qs</em><span class="optional">[</span>, <em>keep_blank_values</em><span class="optional">[</span>, <em>strict_parsing</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cgi.parse_qs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数はこのモジュールでは廃止予定です。代わりに <a class="reference internal" href="urlparse.html#urlparse.parse_qs" title="urlparse.parse_qs"><tt class="xref py py-func docutils literal"><span class="pre">urlparse.parse_qs()</span></tt></a> を利用してください。この関数は後方互換性のためだけに残されています。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.parse_qsl">
<tt class="descclassname">cgi.</tt><tt class="descname">parse_qsl</tt><big>(</big><em>qs</em><span class="optional">[</span>, <em>keep_blank_values</em><span class="optional">[</span>, <em>strict_parsing</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cgi.parse_qsl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数はこのモジュールでは廃止予定です。代わりに <a class="reference internal" href="urlparse.html#urlparse.parse_qsl" title="urlparse.parse_qsl"><tt class="xref py py-func docutils literal"><span class="pre">urlparse.parse_qsl()</span></tt></a> を利用してください。この関数は後方互換性のためだけに残されています。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.parse_multipart">
<tt class="descclassname">cgi.</tt><tt class="descname">parse_multipart</tt><big>(</big><em>fp</em>, <em>pdict</em><big>)</big><a class="headerlink" href="#cgi.parse_multipart" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(ファイル入力のための) <em class="mimetype">multipart/form-data</em> 型の入力を解釈します。引数は入力ファイルを示す <em>fp</em> と
<em class="mailheader">Content-Type</em> ヘッダ内の他のパラメタを含む辞書 <em>pdict</em> です。</p>
<p><a class="reference internal" href="urlparse.html#urlparse.parse_qs" title="urlparse.parse_qs"><tt class="xref py py-func docutils literal"><span class="pre">urlparse.parse_qs()</span></tt></a> と同じく辞書を返します。辞書のキーはフィールド名で、対応する値は各フィールドの値でできたリストです。この関数は簡単に使えますが、数メガバイトのデータがアップロードされると考えられる場合にはあまり適していません &#8212; その場合、より柔軟性のある
<tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt> を代りに使ってください。</p>
<p>マルチパートデータがネストしている場合、各パートを解釈できないので注意してください &#8212; 代りに <tt class="xref py py-class docutils literal"><span class="pre">FieldStorage</span></tt>
を使ってください。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.parse_header">
<tt class="descclassname">cgi.</tt><tt class="descname">parse_header</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#cgi.parse_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(<em class="mailheader">Content-Type</em> のような) MIME ヘッダを解釈し、ヘッダの主要値と各パラメタからなる辞書にします。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.test">
<tt class="descclassname">cgi.</tt><tt class="descname">test</tt><big>(</big><big>)</big><a class="headerlink" href="#cgi.test" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メインプログラムから利用できる堅牢性テストを行う CGI スクリプトです。最小の HTTP ヘッダと、HTML フォームからスクリプトに供給された全ての情報を書式化して出力します。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.print_environ">
<tt class="descclassname">cgi.</tt><tt class="descname">print_environ</tt><big>(</big><big>)</big><a class="headerlink" href="#cgi.print_environ" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シェル変数を HTML に書式化して出力します。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.print_form">
<tt class="descclassname">cgi.</tt><tt class="descname">print_form</tt><big>(</big><em>form</em><big>)</big><a class="headerlink" href="#cgi.print_form" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フォームを HTML に初期化して出力します。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.print_directory">
<tt class="descclassname">cgi.</tt><tt class="descname">print_directory</tt><big>(</big><big>)</big><a class="headerlink" href="#cgi.print_directory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のディレクトリを HTML に書式化して出力します。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.print_environ_usage">
<tt class="descclassname">cgi.</tt><tt class="descname">print_environ_usage</tt><big>(</big><big>)</big><a class="headerlink" href="#cgi.print_environ_usage" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>意味のある (CGI の使う) 環境変数を HTML で出力します。</p>
</dd></dl>

<dl class="function">
<dt id="cgi.escape">
<tt class="descclassname">cgi.</tt><tt class="descname">escape</tt><big>(</big><em>s</em><span class="optional">[</span>, <em>quote</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cgi.escape" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列 <em>s</em> 中の文字 <tt class="docutils literal"><span class="pre">'&amp;'</span></tt> 、 <tt class="docutils literal"><span class="pre">'&lt;'</span></tt> 、および  <tt class="docutils literal"><span class="pre">'&gt;'</span></tt> を HTML で正しく表示できる文字列に変換します。それらの文字が中に入っているかもしれないようなテキストを出力する必要があるときに使ってください。オプションの引数 <em>quote</em>
の値が真であれば、二重引用符文字 (<tt class="docutils literal"><span class="pre">&quot;</span></tt>) も変換します; この機能は <tt class="docutils literal"><span class="pre">&lt;a</span> <span class="pre">href=&quot;...&quot;&gt;</span></tt> のように二重引用符で区切られた
HTML の属性値を出力に含めるのに役立ちます。単引用符は変換されないことに注意して下さい。</p>
<p>クオートされる値が単引用符か二重引用符、またはその両方を含む可能性がある場合は、代りに
<a class="reference internal" href="xml.sax.utils.html#module-xml.sax.saxutils" title="xml.sax.saxutils: SAX とともに使う有用な関数とクラスです。"><tt class="xref py py-mod docutils literal"><span class="pre">xml.sax.saxutils</span></tt></a> の <a class="reference internal" href="xml.sax.utils.html#xml.sax.saxutils.quoteattr" title="xml.sax.saxutils.quoteattr"><tt class="xref py py-func docutils literal"><span class="pre">quoteattr()</span></tt></a> 関数を検討してください。</p>
</dd></dl>

</div>
<div class="section" id="cgi-security">
<span id="id6"></span><h2>20.2.6. セキュリティへの配慮<a class="headerlink" href="#cgi-security" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-1">重要なルールが一つあります: ( 関数 <a class="reference internal" href="os.html#os.system" title="os.system"><tt class="xref py py-func docutils literal"><span class="pre">os.system()</span></tt></a>  または <a class="reference internal" href="os.html#os.popen" title="os.popen"><tt class="xref py py-func docutils literal"><span class="pre">os.popen()</span></tt></a> 、またはその他の同様の機能によって )
外部プログラムを呼び出すなら、クライアントから受信した任意の文字列をシェルに渡していないことをよく確かめてください。これはよく知られているセキュリティホールであり、これによって Web  のどこかにいる悪賢いハッカーが、だまされやすい CGI スクリプトに任意のシェルコマンドを実行させてしまえます。URL の一部やフィールド名でさえも信用してはいけません。CGI へのリクエストはあなたの作ったフォームから送信されるとは限らないからです！</p>
<p>安全な方法をとるために、フォームから入力された文字をシェルに渡す場合、文字列に入っているのが英数文字、ダッシュ、アンダースコア、およびピリオドだけかどうかを確認してください。</p>
</div>
<div class="section" id="cgi-unix">
<h2>20.2.7. CGI スクリプトを Unix システムにインストールする<a class="headerlink" href="#cgi-unix" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>あなたの使っている HTTP サーバのドキュメントを読んでください。そしてローカルシステムの管理者と一緒にどのディレクトリに CGI スクリプトをインストールすべきかを調べてください; 通常これはサーバのファイルシステムツリー内の <tt class="file docutils literal"><span class="pre">cgi-bin</span></tt> ディレクトリです。</p>
<p>あなたのスクリプトが &#8220;others&#8221; によって読み取り可能および実行可能であることを確認してください; Unix ファイルモードは 8 進表記で
<tt class="docutils literal"><span class="pre">0755</span></tt> です (<tt class="docutils literal"><span class="pre">chmod</span> <span class="pre">0755</span> <span class="pre">filename</span></tt> を使ってください)。スクリプトの最初の行の 1 カラム目が、 <tt class="docutils literal"><span class="pre">#!</span></tt>
で開始し、その後に Python インタプリタへのパス名が続いていることを確認してください。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/local/bin/python</span>
</pre></div>
</div>
<p>Python インタプリタが存在し、&#8221;others&#8221; によって実行可能であることを確かめてください。</p>
<p>あなたのスクリプトが読み書きしなければならないファイルが全て &#8220;others&#8221; によって読み出しや書き込み可能であることを確かめてください &#8212;
読み出し可能のファイルモードは <tt class="docutils literal"><span class="pre">0644</span></tt> で、書き込み可能のファイルモードは <tt class="docutils literal"><span class="pre">0666</span></tt> になるはずです。これは、セキュリティ上の理由から、
HTTP サーバがあなたのスクリプトを特権を全く持たないユーザ &#8220;nobody&#8221; の権限で実行するからです。この権限下では、誰でもが読める
(書ける、実行できる) ファイルしか読み出し (書き込み、実行) できません。スクリプト実行時のディレクトリや環境変数のセットもあなたがログインしたときの設定と異なります。特に、実行ファイルに対するシェルの検索パス (<span class="target" id="index-2"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt>) や Python のモジュール検索パス
(<span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a>)が何らかの値に設定されていると期待してはいけません。</p>
<p>モジュールを Python の標準設定におけるモジュール検索パス上にないディレクトリからロードする必要がある場合、他のモジュールを取り込む前にスクリプト内で検索パスを変更できます。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;/usr/home/joe/lib/python&quot;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;/usr/local/lib/python&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(この方法では、最後に挿入されたディレクトリが最初に検索されます！)</p>
<p>非 Unix システムにおける説明は変わるでしょう; あなたの使っている HTTP サーバのドキュメントを調べてください (普通は CGI スクリプトに関する節があります)。</p>
</div>
<div class="section" id="id7">
<h2>20.2.8. CGI スクリプトをテストする<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>残念ながら、 CGI スクリプトは普通、コマンドラインから起動しようとしても動きません。また、コマンドラインから起動した場合には完璧に動作するスクリプトが、不思議なことにサーバからの起動では失敗することがあります。しかし、スクリプトをコマンドラインから実行してみなければならない理由が一つあります: もしスクリプトが文法エラーを含んでいれば、Python インタプリタはそのプログラムを全く実行しないため、 HTTP
サーバはほとんどの場合クライアントに謎めいたエラーを送信するからです。</p>
<p>スクリプトが構文エラーを含まないのにうまく動作しないなら、次の節に読み進むしかありません。</p>
</div>
<div class="section" id="id8">
<h2>20.2.9. CGI スクリプトをデバッグする<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">何よりもまず、些細なインストール関連のエラーでないか確認してください &#8212; 上の CGI スクリプトのインストールに関する節を注意深く読めば時間を大いに節約できます。もしインストールの手続きを正しく理解しているか不安なら、このモジュールのファイル (<tt class="file docutils literal"><span class="pre">cgi.py</span></tt>)
をコピーして、CGI スクリプトとしてインストールしてみてください。このファイルはスクリプトとして呼び出すと、スクリプトの実行環境とフォームの内容を
HTML フォームに出力します。正しいモードなどをフォームに与えて、リクエストを送ってみてください。標準的な <tt class="file docutils literal"><span class="pre">cgi-bin</span></tt>
ディレクトリにインストールされていれば、以下のような URL をブラウザに入力してリクエストを送信できるはずです:</p>
<div class="highlight-python"><pre>http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&amp;addr=At+Home</pre>
</div>
<p>もしタイプ 404 のエラーになるなら、サーバはスクリプトを発見できないでいます &#8211; おそらくあなたはスクリプトを別のディレクトリに入れる必要があるのでしょう。他のエラーになるなら、先に進む前に解決しなければならないインストール上の問題があります。もし実行環境の情報とフォーム内容
(この例では、各フィールドはフィールド名 &#8220;addr&#8221; に対して値 &#8220;At Home&#8221;、およびフィールド名 &#8220;name&#8221; に対して &#8220;Joe Blow&#8221; )
が綺麗にフォーマットされて表示されるなら、 <tt class="file docutils literal"><span class="pre">cgi.py</span></tt> スクリプトは正しくインストールされています。同じ操作をあなたの自作スクリプトに対して行えば、スクリプトをデバッグできるようになるはずです。</p>
<p>次のステップでは <a class="reference internal" href="#module-cgi" title="cgi: PythonスクリプトをCGIとして実行するためのヘルパー"><tt class="xref py py-mod docutils literal"><span class="pre">cgi</span></tt></a> モジュールの <a class="reference internal" href="test.html#module-test" title="test"><tt class="xref py py-func docutils literal"><span class="pre">test()</span></tt></a> 関数を呼び出すことになります: メインプログラムコードを以下の 1 行、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cgi</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>と置き換えてください。この操作で <tt class="file docutils literal"><span class="pre">cgi.py</span></tt> ファイル自体をインストールした時と同じ結果を出力するはずです。</p>
<p>通常の Python スクリプトが例外を処理しきれずに送出した場合 (様々な理由: モジュール名のタイプミス、ファイルが開けなかった、など)、 Python
インタプリタはナイスなトレースバックを出力して終了します。 Python インタプリタはあなたの CGI スクリプトが例外を送出した場合にも同様に振舞うので、トレースバックは大抵HTTP サーバのいずれかのログファイルに残るかまったく無視されるかです。</p>
<p>幸運なことに、あなたが自作のスクリプトで <em>何らかの</em> コードを実行できるようになったら、 <a class="reference internal" href="cgitb.html#module-cgitb" title="cgitb: 設定可能な、CGI スクリプトのトレースバック処理機構です。"><tt class="xref py py-mod docutils literal"><span class="pre">cgitb</span></tt></a> モジュールを使って簡単にトレースバックをブラウザに送信できます。まだそうでないなら、以下の2行:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cgitb</span><span class="p">;</span>
<span class="n">cgitb</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
</pre></div>
</div>
<p>をスクリプトの先頭に追加してください。そしてスクリプトを再度走らせます; 問題が発生すれば、クラッシュの原因を見出せるような詳細な報告を読めます。</p>
<p><a class="reference internal" href="cgitb.html#module-cgitb" title="cgitb: 設定可能な、CGI スクリプトのトレースバック処理機構です。"><tt class="xref py py-mod docutils literal"><span class="pre">cgitb</span></tt></a> モジュールのインポートに問題がありそうだと思うなら、(組み込みモジュールだけを使った) もっと堅牢なアプローチを取れます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
<span class="k">print</span> <span class="s">&quot;Content-Type: text/plain&quot;</span>
<span class="k">print</span>
<span class="o">...</span><span class="n">your</span> <span class="n">code</span> <span class="n">here</span><span class="o">...</span>
</pre></div>
</div>
<p>このコードは Python インタプリタがトレースバックを出力することに依存しています。出力のコンテント型はプレーンテキストに設定されており、全ての
HTML 処理を無効にしています。スクリプトがうまく動作する場合、生の HTML コードがクライアントに表示されます。スクリプトが例外を送出する場合、最初の
2 行が出力された後、トレースバックが表示されます。HTML の解釈は行われないので、トレースバックを読めるはずです。</p>
</div>
<div class="section" id="id9">
<h2>20.2.10. よくある問題と解決法<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul class="simple">
<li>ほとんどの HTTP サーバはスクリプトの実行が完了するまで CGI からの出力をバッファします。このことは、スクリプトの実行中にクライアントが進捗状況報告を表示できないことを意味します。</li>
<li>上のインストールに関する説明を調べましょう。</li>
<li>HTTP サーバのログファイルを調べましょう。(別のウィンドウで  <tt class="docutils literal"><span class="pre">tail</span> <span class="pre">-f</span> <span class="pre">logfile</span></tt> を実行すると便利かもしれません！)</li>
<li>常に <tt class="docutils literal"><span class="pre">python</span> <span class="pre">script.py</span></tt> などとして、スクリプトが構文エラーでないか調べましょう。</li>
<li>スクリプトに構文エラーがないなら、 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">cgitb;</span> <span class="pre">cgitb.enable()</span></tt> をスクリプトの先頭に追加してみましょう。</li>
<li>外部プログラムを起動するときには、スクリプトがそのプログラムを見つけられるようにしましょう。これは通常、絶対パス名を使うことを意味します &#8212;
<span class="target" id="index-5"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt> は普通、あまり CGI スクリプトにとって便利でない値に設定されています。</li>
<li>外部のファイルを読み書きする際には、CGI スクリプトを動作させるときに使われる userid でファイルを読み書きできるようになっているか確認しましょう: userid は通常、Web サーバを動作させている userid か、Web サーバの <tt class="docutils literal"><span class="pre">suexec</span></tt>
機能で明示的に指定している userid になります。</li>
<li>CGI スクリプトを set-uid モードにしてはいけません。これはほとんどのシステムで動作せず、セキュリティ上の信頼性もありません。</li>
</ul>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>最近のバージョンの HTML 仕様ではフィールドの値を供給する順番を取り決めてはいますが、ある HTTP リクエストがその取り決めに準拠したブラウザから受信したものかどうか、そもそもブラウザから送信されたものかどうかの判別は退屈で間違いやすいので注意してください。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="cgitb.html" title="20.3. cgitb — CGI スクリプトのトレースバック管理機構"
             >次へ</a> |</li>
        <li class="right" >
          <a href="webbrowser.html" title="20.1. webbrowser — 便利なウェブブラウザコントローラー"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="internet.html" >20. インターネットプロトコルとその支援</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>