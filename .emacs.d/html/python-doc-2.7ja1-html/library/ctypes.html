

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>15.18. ctypes — Pythonのための外部関数ライブラリ &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="15. 汎用オペレーティングシステムサービス" href="allos.html" />
    <link rel="next" title="16. オプションのオペレーティングシステムサービス" href="someos.html" />
    <link rel="prev" title="15.17. errno — 標準の errno システムシンボル" href="errno.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="someos.html" title="16. オプションのオペレーティングシステムサービス"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="errno.html" title="15.17. errno — 標準の errno システムシンボル"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="allos.html" accesskey="U">15. 汎用オペレーティングシステムサービス</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">15.18. <tt class="docutils literal"><span class="pre">ctypes</span></tt> &#8212; Pythonのための外部関数ライブラリ</a><ul>
<li><a class="reference internal" href="#ctypes">15.18.1. ctypesチュートリアル</a><ul>
<li><a class="reference internal" href="#ctypes-loading-dynamic-link-libraries">15.18.1.1. 動的リンクライブラリをロードする</a></li>
<li><a class="reference internal" href="#dll">15.18.1.2. ロードしたdllから関数にアクセスする</a></li>
<li><a class="reference internal" href="#ctypes-calling-functions">15.18.1.3. 関数を呼び出す</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types">15.18.1.4. 基本のデータ型</a></li>
<li><a class="reference internal" href="#ctypes-calling-functions-continued">15.18.1.5. 続・関数を呼び出す</a></li>
<li><a class="reference internal" href="#ctypes-calling-functions-with-own-custom-data-types">15.18.1.6. 自作のデータ型とともに関数を呼び出す</a></li>
<li><a class="reference internal" href="#ctypes-specifying-required-argument-types">15.18.1.7. 要求される引数の型を指定する (関数プロトタイプ)</a></li>
<li><a class="reference internal" href="#ctypes-return-types">15.18.1.8. 戻り値の型</a></li>
<li><a class="reference internal" href="#ctypes-passing-pointers">15.18.1.9. ポインタを渡す(または、パラメータの参照渡し)</a></li>
<li><a class="reference internal" href="#ctypes-structures-unions">15.18.1.10. 構造体と共用体</a></li>
<li><a class="reference internal" href="#ctypes-structureunion-alignment-byte-order">15.18.1.11. 構造体/共用体アライメントとバイトオーダー</a></li>
<li><a class="reference internal" href="#ctypes-bit-fields-in-structures-unions">15.18.1.12. 構造体と共用体におけるビットフィールド</a></li>
<li><a class="reference internal" href="#ctypes-arrays">15.18.1.13. 配列</a></li>
<li><a class="reference internal" href="#ctypes-pointers">15.18.1.14. ポインタ</a></li>
<li><a class="reference internal" href="#ctypes-type-conversions">15.18.1.15. 型変換</a></li>
<li><a class="reference internal" href="#ctypes-incomplete-types">15.18.1.16. 不完全型</a></li>
<li><a class="reference internal" href="#ctypes-callback-functions">15.18.1.17. コールバック関数</a></li>
<li><a class="reference internal" href="#ctypes-accessing-values-exported-from-dlls">15.18.1.18. dllからエクスポートされている値へアクセスする</a></li>
<li><a class="reference internal" href="#ctypes-surprises">15.18.1.19. 予期しないこと</a></li>
<li><a class="reference internal" href="#ctypes-variable-sized-data-types">15.18.1.20. 可変サイズのデータ型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-ctypes-reference">15.18.2. ctypesリファレンス</a><ul>
<li><a class="reference internal" href="#ctypes-finding-shared-libraries">15.18.2.1. 共有ライブラリを見つける</a></li>
<li><a class="reference internal" href="#ctypes-loading-shared-libraries">15.18.2.2. 共有ライブラリをロードする</a></li>
<li><a class="reference internal" href="#ctypes-foreign-functions">15.18.2.3. 外部関数</a></li>
<li><a class="reference internal" href="#ctypes-function-prototypes">15.18.2.4. 関数プロトタイプ</a></li>
<li><a class="reference internal" href="#ctypes-utility-functions">15.18.2.5. ユーティリティ関数</a></li>
<li><a class="reference internal" href="#ctypes-data-types">15.18.2.6. データ型</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">15.18.2.7. 基本データ型</a></li>
<li><a class="reference internal" href="#ctypes-structured-data-types">15.18.2.8. 標準データ型</a></li>
<li><a class="reference internal" href="#ctypes-arrays-pointers">15.18.2.9. 配列とポインタ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="errno.html"
                        title="前の章へ">15.17. <tt class="docutils literal"><span class="pre">errno</span></tt> &#8212; 標準の errno システムシンボル</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="someos.html"
                        title="次の章へ">16. オプションのオペレーティングシステムサービス</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/ctypes.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-ctypes">
<span id="ctypes-python"></span><h1>15.18. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> &#8212; Pythonのための外部関数ライブラリ<a class="headerlink" href="#module-ctypes" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は Python のための外部関数ライブラリです。このライブラリは
C と互換性のあるデータ型を提供し、動的リンク/共有ライブラリ内の関数呼び出しを可能にします。動的リンク/共有ライブラリを純粋な Python でラップするために使うことができます。</p>
<div class="section" id="ctypes">
<span id="ctypes-ctypes-tutorial"></span><h2>15.18.1. ctypesチュートリアル<a class="headerlink" href="#ctypes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>注意: このチュートリアルのコードサンプルは動作確認のために <a class="reference internal" href="doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a>
を使います。コードサンプルの中には Linux、 Windows、あるいは Mac OS X
上で異なる動作をするものがあるため、サンプルのコメントに doctest 命令を入れてあります。</p>
<p>注意: いくつかのコードサンプルで ctypes の <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> 型を参照しています。 32 ビットシステムにおいてこの型は <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><tt class="xref py py-class docutils literal"><span class="pre">c_long</span></tt></a> 型のエイリアスです。そのため、 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> 型を想定しているときに
<a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><tt class="xref py py-class docutils literal"><span class="pre">c_long</span></tt></a> が表示されたとしても、混乱しないようにしてください &#8212;
実際には同じ型なのです。</p>
<div class="section" id="ctypes-loading-dynamic-link-libraries">
<span id="id1"></span><h3>15.18.1.1. 動的リンクライブラリをロードする<a class="headerlink" href="#ctypes-loading-dynamic-link-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>動的リンクライブラリをロードするために、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は <em>cdll</em> をエクスポートします。
Windows では <em>windll</em> と <em>oledll</em> オブジェクトをエクスポートします。</p>
<p>これらのオブジェクトの属性としてライブラリにアクセスすることでライブラリをロードします。 <em>cdll</em> は標準 <tt class="docutils literal"><span class="pre">cdecl</span></tt> 呼び出し規約を用いて関数をエクスポートしているライブラリをロードします。それに対して、 <em>windll</em>
ライブラリは <tt class="docutils literal"><span class="pre">stdcall</span></tt> 呼び出し規約を用いる関数を呼び出します。
<em>oledll</em> も <tt class="docutils literal"><span class="pre">stdcall</span></tt> 呼び出し規約を使いますが、関数が Windows
<tt class="xref c c-type docutils literal"><span class="pre">HRESULT</span></tt> エラーコードを返すことを想定しています。このエラーコードは関数呼び出しが失敗したとき、
<tt class="xref py py-class docutils literal"><span class="pre">WindowsError</span></tt> 例外を自動的に送出させるために使われます。</p>
<p>Windows用の例ですが、 <tt class="docutils literal"><span class="pre">msvcrt</span></tt> はほとんどの標準 C 関数が含まれている
MS 標準 C ライブラリであり、 cdecl 呼び出し規約を使うことに注意してください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows では通常の <tt class="docutils literal"><span class="pre">.dll</span></tt> ファイル拡張子を自動的に追加します。</p>
<p>Linux ではライブラリをロードするために拡張子を <em>含む</em> ファイル名を指定する必要があるので、ロードしたライブラリに対する属性アクセスはできません。
dll ローダーの <tt class="xref py py-meth docutils literal"><span class="pre">LoadLibrary()</span></tt> メソッドを使うか、コンストラクタを呼び出して CDLL のインスタンスを作ることでライブラリをロードするかのどちらかを行わなければなりません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s">&quot;libc.so.6&quot;</span><span class="p">)</span> <span class="c"># doctest: +LINUX</span>
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s">&quot;libc.so.6&quot;</span><span class="p">)</span>     <span class="c"># doctest: +LINUX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                         <span class="c"># doctest: +LINUX</span>
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="dll">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>15.18.1.2. ロードしたdllから関数にアクセスする<a class="headerlink" href="#dll" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>dll オブジェクトの属性として関数にアクセスします:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n-Identifier">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="nc">AttributeError</span>: <span class="n-Identifier">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">kernel32</span></tt> や <tt class="docutils literal"><span class="pre">user32</span></tt> のような win32 システム dll は、多くの場合関数の UNICODE バージョンに加えて ANSI バージョンもエクスポートすることに注意してください。 UNICODE バージョンは後ろに <tt class="docutils literal"><span class="pre">W</span></tt> が付いた名前でエクスポートされ、 ANSI バージョンは <tt class="docutils literal"><span class="pre">A</span></tt> が付いた名前でエクスポートされます。与えられたモジュールの <em>モジュールハンドル</em> を返す win32
<tt class="docutils literal"><span class="pre">GetModuleHandle</span></tt> 関数は次のような C プロトタイプを持ちます。
UNICODE バージョンが定義されているかどうかにより <tt class="docutils literal"><span class="pre">GetModuleHandle</span></tt>
としてどちらか一つを公開するためにマクロが使われます:</p>
<div class="highlight-python"><pre>/* ANSI version */
HMODULE GetModuleHandleA(LPCSTR lpModuleName);
/* UNICODE version */
HMODULE GetModuleHandleW(LPCWSTR lpModuleName);</pre>
</div>
<p><em>windll</em> は魔法を使ってどちらか一つを選ぶようなことはしません。
<tt class="docutils literal"><span class="pre">GetModuleHandleA</span></tt> もしくは <tt class="docutils literal"><span class="pre">GetModuleHandleW</span></tt> を明示的に指定して必要とするバージョンにアクセスし、文字列かユニコード文字列を使ってそれぞれ呼び出さなければなりません。</p>
<p>時には、 dll が関数を <tt class="docutils literal"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></tt> のような Python 識別子として有効でない名前でエクスポートすることがあります。このような場合に関数を取り出すには、 <a class="reference internal" href="functions.html#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> を使わなければなりません。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows では、名前ではなく序数によって関数をエクスポートする dll もあります。こうした関数には序数を使って dll オブジェクトにインデックス指定することでアクセスします:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n-Identifier">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="nc">AttributeError</span>: <span class="n-Identifier">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-calling-functions">
<span id="id2"></span><h3>15.18.1.3. 関数を呼び出す<a class="headerlink" href="#ctypes-calling-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらの関数は他の Python 呼び出し可能オブジェクトと同じように呼び出すことができます。この例では <tt class="docutils literal"><span class="pre">time()</span></tt> 関数 (Unixエポックからのシステム時間を秒単位で返す) と、 <tt class="docutils literal"><span class="pre">GetModuleHandleA()</span></tt> 関数 (win32モジュールハンドルを返す)
を使います。</p>
<p>この例は両方の関数を NULL ポインタとともに呼び出します (<tt class="docutils literal"><span class="pre">None</span></tt> を
NULL ポインタとして使う必要があります):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c"># doctest: +SKIP</span>
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は引数の数を間違えたり、あるいは呼び出し規約を間違えた関数呼び出しからあなたを守ろうとします。残念ながら、これは Windows でしか機能しません。関数が返った後にスタックを調べることでこれを行います。したがって、エラーは発生しますが、その関数は呼び出された <em>後です</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">()</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>同じ例外が <tt class="docutils literal"><span class="pre">cdecl</span></tt> 呼び出し規約を使って <tt class="docutils literal"><span class="pre">stdcall</span></tt> 関数を呼び出したときに送出されますし、逆の場合も同様です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;spam&quot;</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正しい呼び出し規約を知るためには、呼び出したい関数についての C ヘッダファイルもしくはドキュメントを見なければなりません。</p>
<p>Windows では、関数が無効な引数とともに呼び出された場合の一般保護例外によるクラッシュを防ぐために、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は win32 構造化例外処理を使います:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">WindowsError: exception</span>: <span class="n-Identifier">access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>しかし、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> を使って Python をクラッシュさせる方法は十分なほどあるので、よく注意すべきです。</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt> 、整数、長整数、バイト文字列およびユニコード文字列だけが、こうした関数呼び出しにおいてパラメータとして直接使えるネイティブの
Python オブジェクトです。 <tt class="docutils literal"><span class="pre">None</span></tt> は C の <tt class="docutils literal"><span class="pre">NULL</span></tt> ポインタとして渡され、バイト文字列とユニコード文字列はそのデータを含むメモリブロックへのポインタ (<tt class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> または <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></tt>) として渡されます。
Python 整数と Python 長整数はプラットホームのデフォルトの C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> 型として渡され、その値は C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> 型に合うようにマスクされます。</p>
<p>他のパラメータ型をもつ関数呼び出しに移る前に、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> データ型についてさらに学ぶ必要があります。</p>
</div>
<div class="section" id="ctypes-fundamental-data-types">
<span id="id3"></span><h3>15.18.1.4. 基本のデータ型<a class="headerlink" href="#ctypes-fundamental-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> はたくさんの C と互換性のあるデータ型を定義しています :</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="41%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ctypes の型</th>
<th class="head">C の型</th>
<th class="head">Python の型</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><tt class="xref py py-class docutils literal"><span class="pre">c_bool</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">_Bool</span></tt></td>
<td>bool (1)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><tt class="xref py py-class docutils literal"><span class="pre">c_char</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">char</span></tt></td>
<td>1文字の文字列</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><tt class="xref py py-class docutils literal"><span class="pre">c_wchar</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt></td>
<td>1文字のユニコード文字列</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><tt class="xref py py-class docutils literal"><span class="pre">c_byte</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">char</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><tt class="xref py py-class docutils literal"><span class="pre">c_ubyte</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><tt class="xref py py-class docutils literal"><span class="pre">c_short</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">short</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><tt class="xref py py-class docutils literal"><span class="pre">c_ushort</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">int</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><tt class="xref py py-class docutils literal"><span class="pre">c_uint</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><tt class="xref py py-class docutils literal"><span class="pre">c_long</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">long</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><tt class="xref py py-class docutils literal"><span class="pre">c_ulong</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><tt class="xref py py-class docutils literal"><span class="pre">c_longlong</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">__int64</span></tt> または
<tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><tt class="xref py py-class docutils literal"><span class="pre">c_ulonglong</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">__int64</span></tt> または
<tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt></td>
<td>整数/長整数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><tt class="xref py py-class docutils literal"><span class="pre">c_float</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">float</span></tt></td>
<td>浮動小数点数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><tt class="xref py py-class docutils literal"><span class="pre">c_double</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">double</span></tt></td>
<td>浮動小数点数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><tt class="xref py py-class docutils literal"><span class="pre">c_longdouble</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">longdouble</span></tt></td>
<td>浮動小数点数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><tt class="xref py py-class docutils literal"><span class="pre">c_char_p</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> (NUL 終端)</td>
<td>文字列または <tt class="docutils literal"><span class="pre">None</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><tt class="xref py py-class docutils literal"><span class="pre">c_wchar_p</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></tt> (NUL 終端)</td>
<td>ユニコードまたは <tt class="docutils literal"><span class="pre">None</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><tt class="xref py py-class docutils literal"><span class="pre">c_void_p</span></tt></a></td>
<td><tt class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt></td>
<td>整数/長整数または <tt class="docutils literal"><span class="pre">None</span></tt></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li>コンストラクタは任意のオブジェクトをその真偽値として受け取ります。</li>
</ol>
<p>これら全ての型はその型を呼び出すことによって作成でき、オプションとして型と値が合っている初期化子を指定することができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_char_p</span><span class="p">(</span><span class="s">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_char_p(&#39;Hello, World&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>これらの型は変更可能であり、値を後で変更することもできます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>新しい値をポインタ型 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><tt class="xref py py-class docutils literal"><span class="pre">c_char_p</span></tt></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><tt class="xref py py-class docutils literal"><span class="pre">c_wchar_p</span></tt></a> および
<a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><tt class="xref py py-class docutils literal"><span class="pre">c_void_p</span></tt></a> のインスタンスへ代入すると、変わるのは指している
<em>メモリ位置</em> であって、メモリブロックの <em>内容ではありません</em>
(これは当然で、なぜなら、 Python 文字列は変更不可能だからです):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">c_s</span>
<span class="go">c_char_p(&#39;Hello, World&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">c_s</span>
<span class="go">c_char_p(&#39;Hi, there&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span>                 <span class="c"># 最初の文字列は変更されていない</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>しかし、変更可能なメモリを指すポインタであることを想定している関数へそれらを渡さないように注意すべきです。もし変更可能なメモリブロックが必要なら、 ctypes には <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><tt class="xref py py-func docutils literal"><span class="pre">create_string_buffer()</span></tt></a> 関数があり、いろいろな方法で作成することできます。現在のメモリブロックの内容は <tt class="docutils literal"><span class="pre">raw</span></tt> プロパティを使ってアクセス (あるいは変更) することができます。もし現在のメモリブロックに NUL 終端文字列としてアクセスしたいなら、 <tt class="docutils literal"><span class="pre">value</span></tt> プロパティを使ってください:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c"># 3バイトのバッファを作成、NULで初期化される</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>
<span class="go">3 &#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>      <span class="c"># NUL終端文字列を含むバッファを作成</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>
<span class="go">6 &#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># 10バイトのバッファを作成</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>
<span class="go">10 &#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>
<span class="go">10 &#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><tt class="xref py py-func docutils literal"><span class="pre">create_string_buffer()</span></tt></a> 関数は初期の ctypes リリースにあった
<tt class="xref py py-func docutils literal"><span class="pre">c_string()</span></tt> 関数だけでなく、 (エイリアスとしてはまだ利用できる)
<tt class="xref py py-func docutils literal"><span class="pre">c_buffer()</span></tt> 関数をも置き換えるものです。
C の型 <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> のユニコード文字を含む変更可能なメモリブロックを作成するには、 <a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><tt class="xref py py-func docutils literal"><span class="pre">create_unicode_buffer()</span></tt></a> 関数を使ってください。</p>
</div>
<div class="section" id="ctypes-calling-functions-continued">
<span id="id4"></span><h3>15.18.1.5. 続・関数を呼び出す<a class="headerlink" href="#ctypes-calling-functions-continued" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>printf は <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><tt class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></tt></a> では <em>なく</em> 、本物の標準出力チャンネルへプリントすることに注意してください。したがって、これらの例はコンソールプロンプトでのみ動作し、 <em>IDLE</em> や <em>PythonWin</em> では動作しません。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %S</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">u&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s"> bottles of beer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%f</span><span class="s"> bottles of beer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ArgumentError: argument 2: exceptions.TypeError</span>: <span class="n-Identifier">Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>前に述べたように、必要な C のデータ型へ変換できるようにするためには、整数、文字列およびユニコード文字列を除くすべての Python 型を対応する
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> 型でラップしなければなりません。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;An int </span><span class="si">%d</span><span class="s">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-calling-functions-with-own-custom-data-types">
<span id="id5"></span><h3>15.18.1.6. 自作のデータ型とともに関数を呼び出す<a class="headerlink" href="#ctypes-calling-functions-with-own-custom-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>自作のクラスのインスタンスを関数引数として使えるように、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a>
引数変換をカスタマイズすることもできます。
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は <tt class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></tt> 属性を探し出し、関数引数として使います。もちろん、整数、文字列もしくはユニコードの中の一つでなければなりません。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s"> bottles of beer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>インスタンスのデータを <tt class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></tt> インスタンス変数の中に入れたくない場合には、そのデータを利用できるようにする <a class="reference internal" href="functions.html#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a>
を定義することができます。</p>
</div>
<div class="section" id="ctypes-specifying-required-argument-types">
<span id="id6"></span><h3>15.18.1.7. 要求される引数の型を指定する (関数プロトタイプ)<a class="headerlink" href="#ctypes-specifying-required-argument-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> 属性を設定することによって、 DLL からエクスポートされている関数に要求される引数の型を指定することができます。</p>
<p><tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> は C データ型のシーケンスでなければなりません (この場合 <tt class="docutils literal"><span class="pre">printf</span></tt> 関数はおそらく良い例ではありません。なぜなら、引数の数が可変であり、フォーマット文字列に依存した異なる型のパラメータを取るからです。一方では、この機能の実験にはとても便利です)。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;String &#39;</span><span class="si">%s</span><span class="s">&#39;, Int </span><span class="si">%d</span><span class="s">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>(C の関数のプロトタイプのように) 書式を指定すると互換性のない引数型になるのを防ぎ、引数を有効な型へ変換しようとします。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s"> </span><span class="si">%d</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ArgumentError: argument 2: exceptions.TypeError</span>: <span class="n-Identifier">wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%d</span><span class="s"> </span><span class="si">%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>関数呼び出しへ渡す自作のクラスを定義した場合には、 <tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> シーケンスの中で使えるようにするために、そのクラスに <tt class="xref py py-meth docutils literal"><span class="pre">from_param()</span></tt> クラスメソッドを実装しなければなりません。
<tt class="xref py py-meth docutils literal"><span class="pre">from_param()</span></tt> クラスメソッドは関数呼び出しへ渡された Python オブジェクトを受け取り、型チェックもしくはこのオブジェクトが受け入れ可能であると確かめるために必要なことはすべて行ってから、オブジェクト自身、
<tt class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></tt> 属性、あるいは、この場合に C 関数引数として渡したい何かの値を返さなければなりません。繰り返しになりますが、その返される結果は整数、文字列、ユニコード、
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> インスタンス、あるいは <tt class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></tt> 属性をもつオブジェクトであるべきです。</p>
</div>
<div class="section" id="ctypes-return-types">
<span id="id7"></span><h3>15.18.1.8. 戻り値の型<a class="headerlink" href="#ctypes-return-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは、関数は C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> を返すと仮定されます。他の戻り値の型を指定するには、関数オブジェクトの <tt class="xref py py-attr docutils literal"><span class="pre">restype</span></tt> 属性に設定します。</p>
<p>さらに高度な例として、 <tt class="docutils literal"><span class="pre">strchr</span></tt> 関数を使います。この関数は文字列ポインタと char を受け取り、文字列へのポインタを返します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">))</span> <span class="c"># doctest: +SKIP</span>
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span> <span class="c"># c_char_pは文字列へのポインタ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">))</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>上の <tt class="docutils literal"><span class="pre">ord(&quot;x&quot;)</span></tt> 呼び出しを避けたいなら、 <tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> 属性を設定することができます。二番目の引数が一文字の Python 文字列から C の char へ変換されます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="s">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ArgumentError: argument 2: exceptions.TypeError</span>: <span class="n-Identifier">one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>外部関数が整数を返す場合は、 <tt class="xref py py-attr docutils literal"><span class="pre">restype</span></tt> 属性として呼び出し可能な
Python オブジェクト (例えば、関数またはクラス) を使うこともできます。呼び出し可能オブジェクトは C 関数が返す <em>整数</em> とともに呼び出され、この呼び出しの結果は関数呼び出しの結果として使われるでしょう。これはエラーの戻り値をチェックして自動的に例外を送出させるために役に立ちます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">&quot;something silly&quot;</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n-Identifier">ValidHandle</span>
<span class="nc">WindowsError</span>: <span class="n-Identifier">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">WinError</span></tt> はエラーコードの文字列表現を得るために Windows の
<tt class="docutils literal"><span class="pre">FormatMessage()</span></tt> api を呼び出し、例外を <em>返す</em> 関数です。
<tt class="docutils literal"><span class="pre">WinError</span></tt> はオプションでエラーコードパラメータを取ります。このパラメータが使われない場合は、エラーコードを取り出すために
<a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><tt class="xref py py-func docutils literal"><span class="pre">GetLastError()</span></tt></a> を呼び出します。</p>
<p><tt class="xref py py-attr docutils literal"><span class="pre">errcheck</span></tt> 属性によってもっと強力なエラーチェック機構を利用できることに注意してください。詳細はリファレンスマニュアルを参照してください。</p>
</div>
<div class="section" id="ctypes-passing-pointers">
<span id="id8"></span><h3>15.18.1.9. ポインタを渡す(または、パラメータの参照渡し)<a class="headerlink" href="#ctypes-passing-pointers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>時には、 C api 関数がパラメータのデータ型として <em>ポインタ</em> を想定していることがあります。おそらくパラメータと同一の場所に書き込むためか、もしくはそのデータが大きすぎて値渡しできない場合です。これは <em>パラメータ
の参照渡し</em> としても知られています。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><tt class="xref py py-func docutils literal"><span class="pre">byref()</span></tt></a> 関数をエクスポートしており、パラメータを参照渡しするために使用します。 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><tt class="xref py py-func docutils literal"><span class="pre">pointer()</span></tt></a> 関数を使っても同じ効果が得られます。しかし、 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><tt class="xref py py-func docutils literal"><span class="pre">pointer()</span></tt></a> は本当のポインタオブジェクトを構築するためより多くの処理を行うことから、 Python 側でポインタオブジェクト自体を必要としないならば <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><tt class="xref py py-func docutils literal"><span class="pre">byref()</span></tt></a> を使う方がより高速です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\000</span><span class="s">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">0 0.0 &#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="s">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">1 3.1400001049 &#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-structures-unions">
<span id="id9"></span><h3>15.18.1.10. 構造体と共用体<a class="headerlink" href="#ctypes-structures-unions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>構造体と共用体は <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> モジュールに定義されている
<a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><tt class="xref py py-class docutils literal"><span class="pre">Structure</span></tt></a> および <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><tt class="xref py py-class docutils literal"><span class="pre">Union</span></tt></a> ベースクラスからの派生クラスでなければなりません。それぞれのサブクラスは <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> 属性を定義する必要があります。 <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> は <em>フィールド名</em> と <em>フィールド型</em>
を持つ <em>2要素タプル</em> のリストでなければなりません。</p>
<p>フィールド型は <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> か他の <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> 型 (構造体、共用体、配列、ポインタ) から派生した <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> 型である必要があります。</p>
<p><em>x</em> と <em>y</em> という名前の二つの整数からなる簡単な POINT 構造体の例です。コンストラクタで構造体の初期化する方法の説明にもなっています。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>また、さらに複雑な構造体を構成することができます。 Structure はそれ自体がフィールド型に構造体を使うことで他の構造体を内部に持つことができます。</p>
<p><em>upperleft</em> と <em>lowerright</em> という名前の二つの POINT を持つ RECT
構造体です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>入れ子になった構造体はいくつかの方法を用いてコンストラクタで初期化することができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>フィールド <a class="reference internal" href="../glossary.html#term-descriptor"><em class="xref std std-term">descriptor</em></a> (記述子)は <em>クラス</em> から取り出せます。デバッグするときに役に立つ情報を得ることができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">POINT</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">POINT</span><span class="o">.</span><span class="n">y</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-structureunion-alignment-byte-order">
<span id="id10"></span><h3>15.18.1.11. 構造体/共用体アライメントとバイトオーダー<a class="headerlink" href="#ctypes-structureunion-alignment-byte-order" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは、 Structure と Union のフィールドは C コンパイラが行うのと同じ方法でアライメントされています。サブクラスを定義するときに
<a class="reference internal" href="#ctypes._pack_" title="ctypes._pack_"><tt class="xref py py-attr docutils literal"><span class="pre">_pack_</span></tt></a> クラス属性を指定することでこの動作を変えることは可能です。このクラス属性には正の整数を設定する必要があり、フィールドの最大アライメントを指定します。これは MSVC で <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></tt> が行っていること同じです。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は Structure と Union に対してネイティブのバイトオーダーを使います。ネイティブではないバイトオーダーの構造体を作成するには、
<a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><tt class="xref py py-class docutils literal"><span class="pre">BigEndianStructure</span></tt></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><tt class="xref py py-class docutils literal"><span class="pre">LittleEndianStructure</span></tt></a>,
<tt class="xref py py-class docutils literal"><span class="pre">BigEndianUnion</span></tt> および <tt class="xref py py-class docutils literal"><span class="pre">LittleEndianUnion</span></tt>
ベースクラスの中の一つを使います。これらのクラスにポインタフィールドを持たせることはできません。</p>
</div>
<div class="section" id="ctypes-bit-fields-in-structures-unions">
<span id="id11"></span><h3>15.18.1.12. 構造体と共用体におけるビットフィールド<a class="headerlink" href="#ctypes-bit-fields-in-structures-unions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビットフィールドを含む構造体と共用体を作ることができます。ビットフィールドは整数フィールドに対してのみ作ることができ、ビット幅は
<a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> タプルの第三要素で指定します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Int</span><span class="o">.</span><span class="n">first_16</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Int</span><span class="o">.</span><span class="n">second_16</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-arrays">
<span id="id12"></span><h3>15.18.1.13. 配列<a class="headerlink" href="#ctypes-arrays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Array はシーケンスであり、決まった数の同じ型のインスタンスを持ちます。</p>
<p>推奨されている配列の作成方法はデータ型に正の整数を掛けることです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>ややわざとらしいデータ型の例になりますが、他のものに混ざって 4 個の
POINT がある構造体です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>               <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>               <span class="p">(</span><span class="s">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">)</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>インスタンスはクラスを呼び出す通常の方法で作成します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span>
</pre></div>
</div>
<p>上記のコードは <tt class="docutils literal"><span class="pre">0</span> <span class="pre">0</span></tt> という行が並んだものを表示します。配列の要素がゼロで初期化されているためです。</p>
<p>正しい型の初期化子を指定することもできます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ii</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-pointers">
<span id="id13"></span><h3>15.18.1.14. ポインタ<a class="headerlink" href="#ctypes-pointers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ポインタのインスタンスは <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> 型に対して <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><tt class="xref py py-func docutils literal"><span class="pre">pointer()</span></tt></a> 関数を呼び出して作成します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ポインタインスタンスはポインタが指すオブジェクト (上の例では <tt class="docutils literal"><span class="pre">i</span></tt> )
を返す <tt class="xref py py-attr docutils literal"><span class="pre">contents</span></tt> 属性を持ちます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は OOR (original object return 、元のオブジェクトを返すこと)
ではないことに注意してください。属性を取り出す度に、新しい同等のオブジェクトを作成しているのです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>別の <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> インスタンスがポインタの contents 属性に代入されると、これが記憶されているメモリ位置を指すポインタに変化します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ポインタインスタンスは整数でインデックス指定することもできます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>整数インデックスへ代入するとポインタが指す値が変更されます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>0 ではないインデックスを使うこともできますが、 C の場合と同じように自分が何をしているかを理解している必要があります。任意のメモリ位置にアクセスもしくは変更できるのです。一般的にこの機能を使うのは、 C 関数からポインタを受け取り、そのポインタが単一の要素ではなく実際に配列を指していると <em>分かっている</em> 場合だけです。</p>
<p>舞台裏では、 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><tt class="xref py py-func docutils literal"><span class="pre">pointer()</span></tt></a> 関数は単にポインタインスタンスを作成するという以上のことを行っています。はじめにポインタ <em>型</em> を作成する必要があります。これは任意の <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> 型を受け取る <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><tt class="xref py py-func docutils literal"><span class="pre">POINTER()</span></tt></a> 関数を使って行われ、新しい型を返します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ポインタ型を引数なしで呼び出すと <tt class="docutils literal"><span class="pre">NULL</span></tt> ポインタを作成します。
<tt class="docutils literal"><span class="pre">NULL</span></tt> ポインタは <tt class="docutils literal"><span class="pre">False</span></tt> ブール値を持っています。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">)</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> はポインタの指す値を取り出すときに <tt class="docutils literal"><span class="pre">NULL</span></tt> かどうかを調べます(しかし、 <tt class="docutils literal"><span class="pre">NULL</span></tt> でない不正なポインタの指す値の取り出す行為は
Python をクラッシュさせるでしょう)。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-type-conversions">
<span id="id14"></span><h3>15.18.1.15. 型変換<a class="headerlink" href="#ctypes-type-conversions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>たいていの場合、 ctypes は厳密な型チェックを行います。これが意味するのは、関数の <tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> リスト内に、もしくは、構造体定義におけるメンバーフィールドの型として <tt class="docutils literal"><span class="pre">POINTER(c_int)</span></tt> がある場合、厳密に同じ型のインスタンスだけを受け取るということです。このルールには ctypes が他のオブジェクトを受け取る場合に例外がいくつかあります。例えば、ポインタ型の代わりに互換性のある配列インスタンスを渡すことができます。このように、 <tt class="docutils literal"><span class="pre">POINTER(c_int)</span></tt> に対して、 ctypes は c_int の配列を受け取ります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>POINTER型フィールドを <tt class="docutils literal"><span class="pre">NULL</span></tt> に設定するために、 <tt class="docutils literal"><span class="pre">None</span></tt> を代入してもかまいません。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="bp">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>時には、非互換な型のインスタンスであることもあります。 C では、ある型を他の型へキャストすることができます。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は同じやり方で使える
<a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><tt class="xref py py-func docutils literal"><span class="pre">cast()</span></tt></a> 関数を提供しています。上で定義した <tt class="docutils literal"><span class="pre">Bar</span></tt> 構造体は
<tt class="docutils literal"><span class="pre">POINTER(c_int)</span></tt> ポインタまたは <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> 配列を <tt class="docutils literal"><span class="pre">values</span></tt> フィールドに対して受け取り、他の型のインスタンスは受け取りません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>このような場合には、 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><tt class="xref py py-func docutils literal"><span class="pre">cast()</span></tt></a> 関数が便利です。</p>
<p><a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><tt class="xref py py-func docutils literal"><span class="pre">cast()</span></tt></a> 関数は ctypes インスタンスを異なる ctypes データ型を指すポインタへキャストするために使えます。 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><tt class="xref py py-func docutils literal"><span class="pre">cast()</span></tt></a> は二つのパラメータ、ある種のポインタかそのポインタへ変換できる ctypes オブジェクトと、 ctypes ポインタ型を取ります。そして、第二引数のインスタンスを返します。このインスタンスは第一引数と同じメモリブロックを参照しています:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>したがって、 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><tt class="xref py py-func docutils literal"><span class="pre">cast()</span></tt></a> を <tt class="docutils literal"><span class="pre">Bar</span></tt> 構造体の <tt class="docutils literal"><span class="pre">values</span></tt> フィールドへ代入するために使うことができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-incomplete-types">
<span id="id15"></span><h3>15.18.1.16. 不完全型<a class="headerlink" href="#ctypes-incomplete-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>不完全型</em> はメンバーがまだ指定されていない構造体、共用体もしくは配列です。 C では、前方宣言により指定され、後で定義されます。:</p>
<div class="highlight-python"><pre>struct cell; /* 前方宣言 */

struct {
    char *name;
    struct cell *next;
} cell;</pre>
</div>
<p>ctypes コードへの直接的な変換ではこうなるでしょう。しかし、動作しません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n-Identifier">cell</span>
<span class="nc">NameError</span>: <span class="n-Identifier">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>なぜなら、新しい <tt class="docutils literal"><span class="pre">class</span> <span class="pre">cell</span></tt> はクラス文自体の中では利用できないからです。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> では、 <tt class="docutils literal"><span class="pre">cell</span></tt> クラスを定義して、 <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a>
属性をクラス文の後で設定することができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>試してみましょう。 <tt class="docutils literal"><span class="pre">cell</span></tt> のインスタンスを二つ作り、互いに参照し合うようにします。最後に、つながったポインタを何度かたどります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-callback-functions">
<span id="id16"></span><h3>15.18.1.17. コールバック関数<a class="headerlink" href="#ctypes-callback-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は C の呼び出し可能な関数ポインタを Python 呼び出し可能オブジェクトから作成できるようにします。これらは <em>コールバック関数</em> と呼ばれることがあります。</p>
<p>最初に、コールバック関数のためのクラスを作る必要があります。そのクラスには呼び出し規約、戻り値の型およびこの関数が受け取る引数の数と型についての情報があります。</p>
<p>CFUNCTYPE ファクトリ関数は通常の cdecl 呼び出し規約を用いてコールバック関数のための型を作成します。
Windows では、 WINFUNCTYPE ファクトリ関数が stdcall 呼び出し規約を用いてコールバック関数の型を作成します。</p>
<p>これらのファクトリ関数はともに最初の引数に戻り値の型、残りの引数としてコールバック関数が想定する引数の型を渡して呼び出されます。</p>
<p>標準 C ライブラリの <tt class="xref py py-func docutils literal"><span class="pre">qsort()</span></tt> 関数を使う例を示します。これはコールバック関数の助けをかりて要素をソートするために使われます。
<tt class="xref py py-func docutils literal"><span class="pre">qsort()</span></tt> は整数の配列をソートするために使われます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="bp">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">qsort()</span></tt> はソートするデータを指すポインタ、データ配列の要素の数、要素の一つの大きさ、およびコールバック関数である比較関数へのポインタを引数に渡して呼び出さなければなりません。そして、コールバック関数は要素を指す二つのポインタを渡されて呼び出され、一番目が二番目より小さいなら負の数を、等しいならゼロを、それ以外なら正の数を返さなければなりません。</p>
<p>コールバック関数は整数へのポインタを受け取り、整数を返す必要があります。まず、コールバック関数のための <tt class="docutils literal"><span class="pre">type</span></tt> を作成します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>コールバック関数のはじめての実装なので、受け取った引数を単純に表示して、
0 を返します (漸進型開発 (incremental development)です ;-):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>C の呼び出し可能なコールバック関数を作成します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>そうすると、準備完了です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ポインタの中身にアクセスする方法がわかっているので、コールバック関数を再定義しましょう。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windowsでの実行結果です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">py_cmp_func 7 1</span>
<span class="go">py_cmp_func 33 1</span>
<span class="go">py_cmp_func 99 1</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 7 5</span>
<span class="go">py_cmp_func 33 5</span>
<span class="go">py_cmp_func 99 5</span>
<span class="go">py_cmp_func 7 99</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>linuxではソート関数がはるかに効率的に動作しており、実施する比較の数が少ないように見えるのが不思議です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span> <span class="c"># doctest: +LINUX</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ええ、ほぼ完成です! 最終段階は、実際に二つの要素を比較して実用的な結果を返すことです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windowsでの最終的な実行結果です。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> <span class="c"># doctest: +WINDOWS</span>
<span class="go">py_cmp_func 33 7</span>
<span class="go">py_cmp_func 99 33</span>
<span class="go">py_cmp_func 5 99</span>
<span class="go">py_cmp_func 1 99</span>
<span class="go">py_cmp_func 33 7</span>
<span class="go">py_cmp_func 1 33</span>
<span class="go">py_cmp_func 5 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Linuxでは:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> <span class="c"># doctest: +LINUX</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows の <tt class="xref py py-func docutils literal"><span class="pre">qsort()</span></tt> 関数は linux バージョンより多く比較する必要があることがわかり、非常におもしろいですね!</p>
<p>簡単に確認できるように、今では配列はソートされています。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><strong>コールバック関数についての重要な注意事項:</strong></p>
<p>C コードから使われる限り、 CFUNCTYPE オブジェクトへの参照を確実に保持してください。
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は保持しません。もしあなたがやらなければ、オブジェクトはゴミ集めされてしまい、コールバックしたときにあなたのプログラムをクラッシュさせるかもしれません。</p>
</div>
<div class="section" id="ctypes-accessing-values-exported-from-dlls">
<span id="id17"></span><h3>15.18.1.18. dllからエクスポートされている値へアクセスする<a class="headerlink" href="#ctypes-accessing-values-exported-from-dlls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>共有ライブラリの一部は関数だけでなく変数もエクスポートしています。
Python ライブラリにある例としては <tt class="docutils literal"><span class="pre">Py_OptimizeFlag</span></tt> 、起動時の
<a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a> または <a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><em class="xref std std-option">-OO</em></a> フラグに依存して、 0 , 1 または 2 が設定される整数があります。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は型の <tt class="xref py py-meth docutils literal"><span class="pre">in_dll()</span></tt> クラスメソッドを使ってこのように値にアクセスできます。 <em>pythonapi</em> はPython C api へアクセスできるようにするための予め定義されたシンボルです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">opt_flag</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>インタープリタが <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a> を指定されて動き始めた場合、サンプルは
<tt class="docutils literal"><span class="pre">c_long(1)</span></tt> を表示するでしょうし、 <a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><em class="xref std std-option">-OO</em></a> が指定されたならば
<tt class="docutils literal"><span class="pre">c_long(2)</span></tt> を表示するでしょう。</p>
<p>ポインタの使い方を説明する拡張例では、 Python がエクスポートする
<tt class="docutils literal"><span class="pre">PyImport_FrozenModules</span></tt> ポインタにアクセスします。</p>
<p>Python ドキュメントから引用すると: <em>このポインタは
&#8220;struct _frozen&#8221; のレコードからなり、
終端の要素のメンバが NULL かゼロになっているような配列を指すよう初期化されます。
フリーズされたモジュールを import するとき、このテーブルを検索します。
サードパーティ製のコードからこのポインタに仕掛けを講じて、
動的に生成されたフリーズ化モジュールの集合を提供するようにできます。</em></p>
<p>これで、このポインタを操作することが役に立つことを証明できるでしょう。例の大きさを制限するために、このテーブルを <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> を使って読む方法だけを示します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>私たちは <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">_frozen</span></tt> データ型を定義済みなので、このテーブルを指すポインタを得ることができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s">&quot;PyImport_FrozenModules&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">table</span></tt> が <tt class="docutils literal"><span class="pre">struct_frozen</span></tt> レコードの配列への <tt class="docutils literal"><span class="pre">pointer</span></tt> なので、その配列に対して反復処理を行えます。しかし、ループが確実に終了するようにする必要があります。なぜなら、ポインタに大きさの情報がないからです。遅かれ早かれ、アクセス違反か何かでクラッシュすることになるでしょう。
NULL エントリに達したときはループを抜ける方が良いです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">break</span>
<span class="gp">...</span>
<span class="go">__hello__ 104</span>
<span class="go">__phello__ -104</span>
<span class="go">__phello__.spam 104</span>
<span class="go">None 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>標準 Python はフローズンモジュールとフローズンパッケージ (負のサイズのメンバーで表されています) を持っているという事実はあまり知られておらず、テストにだけ使われています。例えば、 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">__hello__</span></tt> を試してみてください。</p>
</div>
<div class="section" id="ctypes-surprises">
<span id="id18"></span><h3>15.18.1.19. 予期しないこと<a class="headerlink" href="#ctypes-surprises" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> には別のことを期待しているのに実際に起きることは違うという場合があります。</p>
<p>次に示す例について考えてみてください。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>うーん、最後の文に <tt class="docutils literal"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></tt> と表示されることを期待していたはずです。何が起きたのでしょうか? 上の行の <tt class="docutils literal"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></tt> の各段階はこのようになります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">temp0</span></tt> と <tt class="docutils literal"><span class="pre">temp1</span></tt> は前記の <tt class="docutils literal"><span class="pre">rc</span></tt> オブジェクトの内部バッファでまだ使われているオブジェクトです。したがって、 <tt class="docutils literal"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></tt> を実行すると <tt class="docutils literal"><span class="pre">temp0</span></tt> のバッファ内容が <tt class="docutils literal"><span class="pre">rc</span></tt> のバッファへコピーされます。さらに、これは <tt class="docutils literal"><span class="pre">temp1</span></tt> の内容を変更します。そのため、最後の代入 <tt class="docutils literal"><span class="pre">rc.b</span>
<span class="pre">=</span> <span class="pre">temp1</span></tt> は、期待する結果にはならないのです。</p>
<p>Structure 、 Union および Array のサブオブジェクトを取り出しても、そのサブオブジェクトが <em>コピー</em> されるわけではなく、ルートオブジェクトの内部バッファにアクセスするラッパーオブジェクトを取り出すことを覚えておいてください。</p>
<p>期待とは違う振る舞いをする別の例はこれです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>なぜ <tt class="docutils literal"><span class="pre">False</span></tt> と表示されるのでしょうか? ctypes インスタンスはメモリと、メモリの内容にアクセスするいくつかの <a class="reference internal" href="../glossary.html#term-descriptor"><em class="xref std std-term">descriptor</em></a> (記述子)を含むオブジェクトです。メモリブロックに Python オブジェクトを保存してもオブジェクト自身が保存される訳ではなく、オブジェクトの <tt class="docutils literal"><span class="pre">contents</span></tt> が保存されます。その contents に再アクセスすると新しい Python オブジェクトがその度に作られます。</p>
</div>
<div class="section" id="ctypes-variable-sized-data-types">
<span id="id19"></span><h3>15.18.1.20. 可変サイズのデータ型<a class="headerlink" href="#ctypes-variable-sized-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は可変サイズの配列と構造体をサポートしています。</p>
<p><a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><tt class="xref py py-func docutils literal"><span class="pre">resize()</span></tt></a> 関数は既存の ctypes オブジェクトのメモリバッファのサイズを変更したい場合に使えます。この関数は第一引数にオブジェクト、第二引数に要求されたサイズをバイト単位で指定します。メモリブロックはオブジェクト型で指定される通常のメモリブロックより小さくすることはできません。これをやろうとすると、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>これはこれで上手くいっていますが、この配列の追加した要素へどうやってアクセスするのでしょうか? この型は要素の数が 4 個であるとまだ認識しているので、他の要素にアクセスするとエラーになります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="nc">IndexError</span>: <span class="n-Identifier">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> で可変サイズのデータ型を使うもう一つの方法は、必要なサイズが分かった後に Python の動的性質を使って一つ一つデータ型を(再)定義することです。</p>
</div>
</div>
<div class="section" id="ctypes-ctypes-reference">
<span id="id20"></span><h2>15.18.2. ctypesリファレンス<a class="headerlink" href="#ctypes-ctypes-reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="ctypes-finding-shared-libraries">
<span id="id21"></span><h3>15.18.2.1. 共有ライブラリを見つける<a class="headerlink" href="#ctypes-finding-shared-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンパイルされる言語でプログラミングしている場合、共有ライブラリはプログラムをコンパイル/リンクしているときと、そのプログラムが動作しているときにアクセスされます。</p>
<p>ctypes ライブラリローダーはプログラムが動作しているときのように振る舞い、ランタイムローダーを直接呼び出すのに対し、 <tt class="xref py py-func docutils literal"><span class="pre">find_library()</span></tt> 関数の目的はコンパイラが行うのと似た方法でライブラリを探し出すことです。
(複数のバージョンの共有ライブラリがあるプラットホームでは、一番最近に見つかったものがロードされます)。</p>
<p><tt class="xref py py-mod docutils literal"><span class="pre">ctypes.util</span></tt> モジュールはロードするライブラリを決めるのに役立つ関数を提供します。</p>
<dl class="data">
<dt>
<tt class="descclassname">ctypes.util.</tt><tt class="descname">find_library</tt><big>(</big><em>name</em><big>)</big></dt>
<dd><p>ライブラリを見つけてパス名を返そうと試みます。 <em>name</em> は <tt class="docutils literal"><span class="pre">lib</span></tt> のような接頭辞、 <tt class="docutils literal"><span class="pre">.so</span></tt>, <tt class="docutils literal"><span class="pre">.dylib</span></tt> のような接尾辞、あるいは、バージョン番号が何も付いていないライブラリの名前です (これは posix リンカのオプション <em class="xref std std-option">-l</em> に使われている形式です)。もしライブラリが見つからなければ、 <tt class="docutils literal"><span class="pre">None</span></tt> を返します。</p>
</dd></dl>

<p>厳密な機能はシステムに依存します。</p>
<p>Linux では、 <tt class="xref py py-func docutils literal"><span class="pre">find_library()</span></tt> はライブラリファイルを見つけるために外部プログラム (<tt class="docutils literal"><span class="pre">/sbin/ldconfig</span></tt>, <tt class="docutils literal"><span class="pre">gcc</span></tt> および <tt class="docutils literal"><span class="pre">objdump</span></tt>) を実行しようとします。ライブラリファイルのファイル名を返します。いくつか例があります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>OS X では、 <tt class="xref py py-func docutils literal"><span class="pre">find_library()</span></tt> はライブラリの位置を探すために、予め定義された複数の命名方法とパスを試し、成功すればフルパスを返します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows では、 <tt class="xref py py-func docutils literal"><span class="pre">find_library()</span></tt> はシステムの探索パスに沿って探し、フルパスを返します。しかし、予め定義された命名方法がないため、
<tt class="docutils literal"><span class="pre">find_library(&quot;c&quot;)</span></tt> のような呼び出しは失敗し、 <tt class="docutils literal"><span class="pre">None</span></tt> を返します。</p>
<p>もし <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> を使って共有ライブラリをラップするなら、実行時にライブラリを探すために <tt class="xref py py-func docutils literal"><span class="pre">find_library()</span></tt> を使う代わりに、開発時に共有ライブラリ名を決めて、ラッパーモジュールにハードコードした方が良い <em>かもしれません</em> 。</p>
</div>
<div class="section" id="ctypes-loading-shared-libraries">
<span id="id22"></span><h3>15.18.2.2. 共有ライブラリをロードする<a class="headerlink" href="#ctypes-loading-shared-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>共有ライブラリを Python プロセスへロードする方法はいくつかあります。一つの方法は下記のクラスの一つをインスタンス化することです。:</p>
<dl class="class">
<dt id="ctypes.CDLL">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">CDLL</tt><big>(</big><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><big>)</big><a class="headerlink" href="#ctypes.CDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は標準 C 呼び出し規約を使用し、 <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> を返すと仮定されます。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.OleDLL">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">OleDLL</tt><big>(</big><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><big>)</big><a class="headerlink" href="#ctypes.OleDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は <tt class="docutils literal"><span class="pre">stdcall</span></tt> 呼び出し規約を使用し、 windows 固有の <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><tt class="xref py py-class docutils literal"><span class="pre">HRESULT</span></tt></a> コードを返すと仮定されます。
<a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><tt class="xref py py-class docutils literal"><span class="pre">HRESULT</span></tt></a> 値には関数呼び出しが失敗したのか成功したのかを特定する情報とともに、補足のエラーコードが含まれます。戻り値が失敗を知らせたならば、 <tt class="xref py py-class docutils literal"><span class="pre">WindowsError</span></tt> が自動的に送出されます。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.WinDLL">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">WinDLL</tt><big>(</big><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><big>)</big><a class="headerlink" href="#ctypes.WinDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は <tt class="docutils literal"><span class="pre">stdcall</span></tt> 呼び出し規約を使用し、デフォルトでは <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> を返すと仮定されます。</p>
<p>Windows CE では標準呼び出し規約だけが使われます。便宜上、このプラットホームでは、 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><tt class="xref py py-class docutils literal"><span class="pre">WinDLL</span></tt></a> と <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><tt class="xref py py-class docutils literal"><span class="pre">OleDLL</span></tt></a> が標準呼び出し規約を使用します。</p>
</dd></dl>

<p>これらのライブラリがエクスポートするどの関数でも呼び出す前に Python
GIL (<a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><em class="xref std std-term">global interpreter lock</em></a>) は解放され、後でまた獲得されます。</p>
<dl class="class">
<dt id="ctypes.PyDLL">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">PyDLL</tt><big>(</big><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em><big>)</big><a class="headerlink" href="#ctypes.PyDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python GIL が関数呼び出しの間解放 <em>されず</em> 、関数実行の後に Python
エラーフラグがチェックされるということを除けば、このクラスのインスタンスは <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><tt class="xref py py-class docutils literal"><span class="pre">CDLL</span></tt></a> インスタンスのように振る舞います。エラーフラグがセットされた場合、 Python 例外が送出されます。</p>
<p>要するに、これは Python C api 関数を直接呼び出すのに便利だというだけです。</p>
</dd></dl>

<p>これらすべてのクラスは少なくとも一つの引数、すなわちロードする共有ライブラリのパスを渡して呼び出すことでインスタンス化されます。すでにロード済みの共有ライブラリへのハンドルがあるなら、 <tt class="docutils literal"><span class="pre">handle</span></tt> 名前付き引数として渡すことができます。土台となっているプラットホームの <tt class="docutils literal"><span class="pre">dlopen</span></tt> または <tt class="docutils literal"><span class="pre">LoadLibrary</span></tt> 関数がプロセスへライブラリをロードするために使われ、そのライブラリに対するハンドルを得ます。</p>
<p><em>mode</em> パラメータはライブラリがどうやってロードされたかを特定するために使うことができます。詳細は、 <em class="manpage">dlopen(3)</em> マニュアルページを参考にしてください。 Windows では <em>mode</em> は無視されます。</p>
<p><em>use_errno</em> 変数が True に設定されたとき、システムの <a class="reference internal" href="errno.html#module-errno" title="errno: 標準の errno システムシンボル。"><tt class="xref py py-data docutils literal"><span class="pre">errno</span></tt></a> エラーナンバーに安全にアクセスする ctypes の仕組みが有効化されます。
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> はシステムの <a class="reference internal" href="errno.html#module-errno" title="errno: 標準の errno システムシンボル。"><tt class="xref py py-data docutils literal"><span class="pre">errno</span></tt></a> 変数のスレッド限定のコピーを管理します。もし、 <tt class="docutils literal"><span class="pre">use_errno=True</span></tt> の状態で作られた外部関数を呼び出したなら、関数呼び出し前の <a class="reference internal" href="errno.html#module-errno" title="errno: 標準の errno システムシンボル。"><tt class="xref py py-data docutils literal"><span class="pre">errno</span></tt></a> 変数は ctypes のプライベートコピーと置き換えられ、同じことが関数呼び出しの直後にも発生します。</p>
<p><a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><tt class="xref py py-func docutils literal"><span class="pre">ctypes.get_errno()</span></tt></a> 関数は ctypes のプライベートコピーの値を返します。そして、 <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><tt class="xref py py-func docutils literal"><span class="pre">ctypes.set_errno()</span></tt></a> 関数は ctypes のプライベートコピーを置き換え、以前の値を返します。</p>
<p><em>use_last_error</em> パラメータは、 True に設定されたとき、
<a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><tt class="xref py py-func docutils literal"><span class="pre">GetLastError()</span></tt></a> と <tt class="xref py py-func docutils literal"><span class="pre">SetLastError()</span></tt>  Windows API によって管理される Windows エラーコードに対するのと同じ仕組みが有効化されます。
<a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><tt class="xref py py-func docutils literal"><span class="pre">ctypes.get_last_error()</span></tt></a> と <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><tt class="xref py py-func docutils literal"><span class="pre">ctypes.set_last_error()</span></tt></a> は Windows
エラーコードの ctypes プライベートコピーを変更したり要求したりするのに使われます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加: </span><em>use_last_error</em> と <em>use_errno</em> オプション変数が追加されました。</p>
<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">RTLD_GLOBAL</tt></dt>
<dd><p><em>mode</em> パラメータとして使うフラグ。このフラグが利用できないプラットホームでは、整数のゼロと定義されています。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">RTLD_LOCAL</tt></dt>
<dd><dl class="docutils">
<dt><em>mode</em> パラメータとして使うフラグ。これが利用できないプラットホーム</dt>
<dd>では、 <em>RTLD_GLOBAL</em> と同様です。</dd>
</dl>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">DEFAULT_MODE</tt></dt>
<dd><p>共有ライブラリをロードするために使われるデフォルトモード。 OSX 10.3
では <em>RTLD_GLOBAL</em> であり、そうでなければ <em>RTLD_LOCAL</em> と同じです。</p>
</dd></dl>

<p>これらのクラスのインスタンスには公開メソッドがありません。けれども、
<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></tt></a> と <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> は特別なはたらきをします。その共有ライブラリがエクスポートする関数に添字を使って属性としてアクセスできるのです。 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></tt></a> と <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> のどちらもが結果をキャッシュし、そのため常に同じオブジェクトを返すことに注意してください。</p>
<p>次に述べる公開属性が利用できます。それらの名前はエクスポートされた関数名に衝突しないように下線で始まります。:</p>
<dl class="attribute">
<dt id="ctypes.PyDLL._handle">
<tt class="descclassname">PyDLL.</tt><tt class="descname">_handle</tt><a class="headerlink" href="#ctypes.PyDLL._handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリへのアクセスに用いられるシステムハンドル。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.PyDLL._name">
<tt class="descclassname">PyDLL.</tt><tt class="descname">_name</tt><a class="headerlink" href="#ctypes.PyDLL._name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタに渡されたライブラリの名前。</p>
</dd></dl>

<p>共有ライブラリは ( <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><tt class="xref py py-class docutils literal"><span class="pre">LibraryLoader</span></tt></a> クラスのインスタンスである )
前もって作られたオブジェクトの一つを使うことによってロードすることもできます。それらの <tt class="xref py py-meth docutils literal"><span class="pre">LoadLibrary()</span></tt> メソッドを呼び出すか、ローダーインスタンスの属性としてライブラリを取り出すかのどちらかによりロードします。</p>
<dl class="class">
<dt id="ctypes.LibraryLoader">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">LibraryLoader</tt><big>(</big><em>dlltype</em><big>)</big><a class="headerlink" href="#ctypes.LibraryLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有ライブラリをロードするクラス。 <em>dlltype</em> は <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><tt class="xref py py-class docutils literal"><span class="pre">CDLL</span></tt></a> 、
<a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><tt class="xref py py-class docutils literal"><span class="pre">PyDLL</span></tt></a> 、 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><tt class="xref py py-class docutils literal"><span class="pre">WinDLL</span></tt></a> もしくは <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><tt class="xref py py-class docutils literal"><span class="pre">OleDLL</span></tt></a> 型の一つであるべきです。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></tt></a> は特別なはたらきをします: ライブラリローダーインスタンスの属性として共有ライブラリにアクセスするとそれがロードされるということを可能にします。結果はキャッシュされます。そのため、繰り返し属性アクセスを行うといつも同じライブラリが返されます。</p>
<dl class="method">
<dt id="ctypes.LibraryLoader.LoadLibrary">
<tt class="descname">LoadLibrary</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有ライブラリをプロセスへロードし、それを返します。このメソッドはライブラリの新しいインスタンスを常に返します。</p>
</dd></dl>

</dd></dl>

<p>これらの前もって作られたライブラリローダーを利用することができます。:</p>
<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">cdll</tt></dt>
<dd><p><a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><tt class="xref py py-class docutils literal"><span class="pre">CDLL</span></tt></a> インスタンスを作ります。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">windll</tt></dt>
<dd><p>Windows用: <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><tt class="xref py py-class docutils literal"><span class="pre">WinDLL</span></tt></a> インスタンスを作ります。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">oledll</tt></dt>
<dd><p>Windows用: <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><tt class="xref py py-class docutils literal"><span class="pre">OleDLL</span></tt></a> インスタンスを作ります。</p>
</dd></dl>

<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">pydll</tt></dt>
<dd><p><a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><tt class="xref py py-class docutils literal"><span class="pre">PyDLL</span></tt></a> インスタンスを作ります。</p>
</dd></dl>

<p>C Python api に直接アクセするために、すぐに使用できる Python 共有ライブラリオブジェクトが用意されています。:</p>
<dl class="data">
<dt>
<tt class="descclassname">ctypes.</tt><tt class="descname">pythonapi</tt></dt>
<dd><p>属性として Python C api 関数を公開する <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><tt class="xref py py-class docutils literal"><span class="pre">PyDLL</span></tt></a> のインスタンス。これらすべての関数は C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> を返すと仮定されますが、もちろん常に正しいとは限りません。そのため、これらの関数を使うためには正しい <tt class="xref py py-attr docutils literal"><span class="pre">restype</span></tt> 属性を代入しなければなりません。</p>
</dd></dl>

</div>
<div class="section" id="ctypes-foreign-functions">
<span id="id23"></span><h3>15.18.2.3. 外部関数<a class="headerlink" href="#ctypes-foreign-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前節で説明した通り、外部関数はロードされた共有ライブラリの属性としてアクセスできます。デフォルトではこの方法で作成された関数オブジェクトはどんな数の引数でも受け取り、引数としてどんな ctypes データのインスタンスをも受け取り、そして、ライブラリローダーが指定したデフォルトの結果の値の型を返します。関数オブジェクトはプライベートクラスのインスタンスです。:</p>
<dl class="class">
<dt id="ctypes._FuncPtr">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">_FuncPtr</tt><a class="headerlink" href="#ctypes._FuncPtr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の呼び出し可能外部関数のためのベースクラス。</p>
<p>外部関数のインスタンスも C 互換データ型です。それらは C の関数ポインタを表しています。</p>
<p>この振る舞いは外部関数オブジェクトの特別な属性に代入することによって、カスタマイズすることができます。</p>
<dl class="attribute">
<dt id="ctypes._FuncPtr.restype">
<tt class="descname">restype</tt><a class="headerlink" href="#ctypes._FuncPtr.restype" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>外部関数の結果の型を指定するために ctypes 型を代入する。何も返さない関数を表す <tt class="xref c c-type docutils literal"><span class="pre">void</span></tt> に対しては <tt class="docutils literal"><span class="pre">None</span></tt> を使います。</p>
<p>ctypes 型ではない呼び出し可能な Python オブジェクトを代入することは可能です。このような場合、関数が C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> を返すと仮定され、呼び出し可能オブジェクトはこの整数を引数に呼び出されます。さらに処理を行ったり、エラーチェックをしたりできるようにするためです。これの使用は推奨されません。より柔軟な後処理やエラーチェックのためには restype として ctypes 型を使い、 <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><tt class="xref py py-attr docutils literal"><span class="pre">errcheck</span></tt></a> 属性へ呼び出し可能オブジェクトを代入してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.argtypes">
<tt class="descname">argtypes</tt><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数が受け取る引数の型を指定するために ctypes 型のタプルを代入します。 <tt class="docutils literal"><span class="pre">stdcall</span></tt> 呼び出し規約をつかう関数はこのタプルの長さと同じ数の引数で呼び出されます。その上、 C 呼び出し規約をつかう関数は追加の不特定の引数も取ります。</p>
<p>外部関数が呼ばれたとき、それぞれの実引数は <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt></a> タプルの要素の <tt class="xref py py-meth docutils literal"><span class="pre">from_param()</span></tt> クラスメソッドへ渡されます。このメソッドは実引数を外部関数が受け取るオブジェクトに合わせて変えられるようにします。例えば、 <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt></a> タプルの <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><tt class="xref py py-class docutils literal"><span class="pre">c_char_p</span></tt></a> 要素は、
ctypes 変換規則にしたがって引数として渡されたユニコード文字列をバイト文字列へ変換するでしょう。</p>
<p>新: ctypes 型でない要素を argtypes に入れることができますが、個々の要素は引数として使える値 ( 整数、文字列、 ctypes インスタンス
) を返す <tt class="xref py py-meth docutils literal"><span class="pre">from_param()</span></tt> メソッドを持っていなければなりません。これにより関数パラメータとしてカスタムオブジェクトを適合するように変更できるアダプタが定義可能となります。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.errcheck">
<tt class="descname">errcheck</tt><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python 関数または他の呼び出し可能オブジェクトをこの属性に代入します。呼び出し可能オブジェクトは三つ以上の引数とともに呼び出されます。</p>
<dl class="function">
<dt>
<tt class="descname">callable</tt><big>(</big><em>result</em>, <em>func</em>, <em>arguments</em><big>)</big></dt>
<dd><p><em>result</em> は外部関数が返すもので、 <a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><tt class="xref py py-attr docutils literal"><span class="pre">restype</span></tt></a> 属性で指定されます。</p>
<p><em>func</em> は外部関数オブジェクト自身で、これにより複数の関数の処理結果をチェックまたは後処理するために、同じ呼び出し可能オブジェクトを再利用できるようになります。</p>
<p><em>arguments</em> は関数呼び出しに最初に渡されたパラメータが入ったタプルです。これにより使われた引数に基づた特別な振る舞いをさせることができるようになります。</p>
</dd></dl>

<p>この関数が返すオブジェクトは外部関数呼び出しから返された値でしょう。しかし、戻り値をチェックして、外部関数呼び出しが失敗しているなら例外を送出させることもできます。</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ctypes.ArgumentError">
<em class="property">exception </em><tt class="descclassname">ctypes.</tt><tt class="descname">ArgumentError</tt><a class="headerlink" href="#ctypes.ArgumentError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外は外部関数呼び出しが渡された引数を変換できなかったときに送出されます。</p>
</dd></dl>

</div>
<div class="section" id="ctypes-function-prototypes">
<span id="id24"></span><h3>15.18.2.4. 関数プロトタイプ<a class="headerlink" href="#ctypes-function-prototypes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>外部関数は関数プロトタイプをインスタンス化することによって作成されます。関数プロトタイプは C の関数プロトタイプと似ています。実装を定義せずに、関数 ( 戻り値、引数の型、呼び出し規約 ) を記述します。ファクトリ関数は関数に要求する戻り値の型と引数の型とともに呼び出されます。</p>
<dl class="function">
<dt id="ctypes.CFUNCTYPE">
<tt class="descclassname">ctypes.</tt><tt class="descname">CFUNCTYPE</tt><big>(</big><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><big>)</big><a class="headerlink" href="#ctypes.CFUNCTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返された関数プロトタイプは標準 C 呼び出し規約をつかう関数を作成します。関数は呼び出されている間 GIL を解放します。
<em>use_errno</em> が True に設定されれば、呼び出しの前後で System 変数
<a class="reference internal" href="errno.html#module-errno" title="errno: 標準の errno システムシンボル。"><tt class="xref py py-data docutils literal"><span class="pre">errno</span></tt></a> の ctypesプライベートコピーは本当の <a class="reference internal" href="errno.html#module-errno" title="errno: 標準の errno システムシンボル。"><tt class="xref py py-data docutils literal"><span class="pre">errno</span></tt></a> の値と交換されます。
<em>use_last_error</em> も Windows エラーコードに対するのと同様です。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>オプションの <em>use_errno</em> と <em>use_last_error</em> 変数が追加されました。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WINFUNCTYPE">
<tt class="descclassname">ctypes.</tt><tt class="descname">WINFUNCTYPE</tt><big>(</big><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><big>)</big><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: 返された関数プロトタイプは <tt class="docutils literal"><span class="pre">stdcall</span></tt> 呼び出し規約をつかう関数を作成します。ただし、 <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><tt class="xref py py-func docutils literal"><span class="pre">WINFUNCTYPE()</span></tt></a> が <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><tt class="xref py py-func docutils literal"><span class="pre">CFUNCTYPE()</span></tt></a> と同じである Windows CE を除きます。関数は呼び出されている間 GIL を解放します。
<em>use_errno</em> と <em>use_last_error</em> は前述と同じ意味を持ちます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.PYFUNCTYPE">
<tt class="descclassname">ctypes.</tt><tt class="descname">PYFUNCTYPE</tt><big>(</big><em>restype</em>, <em>*argtypes</em><big>)</big><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返された関数プロトタイプは Python 呼び出し規約をつかう関数を作成します。関数は呼び出されている間 GIL を解放 <em>しません</em> 。</p>
</dd></dl>

<p>ファクトリ関数によって作られた関数プロトタイプは呼び出しのパラメータの型と数に依存した別の方法でインスタンス化することができます。 :</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">prototype</tt><big>(</big><em>address</em><big>)</big></dt>
<dd><p>指定されたアドレス(整数でなくてはなりません)の外部関数を返します。</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">prototype</tt><big>(</big><em>callable</em><big>)</big></dt>
<dd><p>Python の <em>callable</em> から C の呼び出し可能関数(コールバック関数)
を作成します。</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">prototype</tt><big>(</big><em>func_spec</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">]</span><big>)</big></dt>
<dd><p>共有ライブラリがエクスポートしている外部関数を返します。
<em>func_spec</em> は 2 要素タプル <tt class="docutils literal"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></tt> でなければなりません。第一要素はエクスポートされた関数の名前である文字列、またはエクスポートされた関数の序数である小さい整数です。第二要素は共有ライブラリインスタンスです。</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">prototype</tt><big>(</big><em>vtbl_index</em>, <em>name</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">[</span>, <em>iid</em><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd><p>COM メソッドを呼び出す外部関数を返します。 <em>vtbl_index</em> は仮想関数テーブルのインデックスで、非負の小さい整数です。
<em>name</em> は COM メソッドの名前です。 <em>iid</em> はオプションのインターフェイス識別子へのポインタで、拡張されたエラー情報の提供のために使われます。</p>
<p>COM メソッドは特殊な呼び出し規約を用います。このメソッドは
<tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> タプルに指定されたパラメータに加えて、第一引数として COM インターフェイスへのポインタを必要とします。</p>
</dd></dl>

<p>オプションの <em>paramflags</em> パラメータは上述した機能より多機能な外部関数ラッパーを作成します。</p>
<p><em>paramflags</em> は <tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> と同じ長さのタプルでなければなりません。</p>
<p>このタプルの個々の要素はパラメータについてのより詳細な情報を持ち、
1 、 2 もしくは 3 要素を含むタプルでなければなりません。</p>
<p>第一要素はパラメータについてのフラグの組み合わせを含んだ整数です。</p>
<blockquote>
<div><dl class="docutils">
<dt>1</dt>
<dd>入力パラメータを関数に指定します。</dd>
<dt>2</dt>
<dd>出力パラメータ。外部関数が値を書き込みます。</dd>
<dt>4</dt>
<dd>デフォルトで整数ゼロになる入力パラメータ。</dd>
</dl>
</div></blockquote>
<p>オプションの第二要素はパラメータ名の文字列です。これが指定された場合は、外部関数を名前付きパラメータで呼び出すことができます。</p>
<p>オプションの第三要素はこのパラメータのデフォルト値です。</p>
</div></blockquote>
<p>この例では、デフォルトパラメータと名前付き引数をサポートするために
Windows <tt class="docutils literal"><span class="pre">MessageBoxA</span></tt> 関数をラップする方法を示します。
windowsヘッダファイルの C の宣言はこれです。:</p>
<div class="highlight-python"><pre>WINUSERAPI int WINAPI
MessageBoxA(
    HWND hWnd ,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType);</pre>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> を使ってラップします。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCSTR</span><span class="p">,</span> <span class="n">LPCSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;text&quot;</span><span class="p">,</span> <span class="s">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;caption&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s">&quot;MessageBoxA&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>今は MessageBox 外部関数をこのような方法で呼び出すことができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;foo bar&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>二番目の例は出力パラメータについて説明します。 win32 の
<tt class="docutils literal"><span class="pre">GetWindowRect</span></tt> 関数は、指定されたウィンドウの大きさを呼び出し側が与える <tt class="docutils literal"><span class="pre">RECT</span></tt> 構造体へコピーすることで取り出します。 C の宣言はこうです。:</p>
<div class="highlight-python"><pre>WINUSERAPI BOOL WINAPI
GetWindowRect(
     HWND hWnd,
     LPRECT lpRect);</pre>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> を使ってラップします。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>もし単一の値もしくは一つより多い場合には出力パラメータ値が入ったタプルがあるならば、出力パラメータを持つ関数は自動的に出力パラメータ値を返すでしょう。そのため、今は GetWindowRect 関数は呼び出されたときに RECT インスタンスを返します。</p>
<p>さらに出力処理やエラーチェックを行うために、出力パラメータを
<tt class="xref py py-attr docutils literal"><span class="pre">errcheck</span></tt> プロトコルと組み合わせることができます。 win32
<tt class="docutils literal"><span class="pre">GetWindowRect</span></tt> api 関数は成功したか失敗したかを知らせるために
<tt class="docutils literal"><span class="pre">BOOL</span></tt> を返します。そのため、この関数はエラーチェックを行って、
api 呼び出しが失敗した場合に例外を送出させることができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><tt class="xref py py-attr docutils literal"><span class="pre">errcheck</span></tt> 関数が変更なしに受け取った引数タプルを返したならば、
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は出力パラメータに対して通常の処理を続けます。
<tt class="docutils literal"><span class="pre">RECT</span></tt> インスタンスの代わりに window 座標のタプルを返してほしいなら、関数のフィールドを取り出し、代わりにそれらを返すことができます。通常処理はもはや行われないでしょう。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-utility-functions">
<span id="id25"></span><h3>15.18.2.5. ユーティリティ関数<a class="headerlink" href="#ctypes-utility-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ctypes.addressof">
<tt class="descclassname">ctypes.</tt><tt class="descname">addressof</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#ctypes.addressof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリバッファのアドレスを示す整数を返します。 <em>obj</em> は ctypes 型のインスタンスでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.alignment">
<tt class="descclassname">ctypes.</tt><tt class="descname">alignment</tt><big>(</big><em>obj_or_type</em><big>)</big><a class="headerlink" href="#ctypes.alignment" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ctypes 型のアライメントの必要条件を返します。 <em>obj_or_type</em> は
ctypes 型またはインスタンスでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.byref">
<tt class="descclassname">ctypes.</tt><tt class="descname">byref</tt><big>(</big><em>obj</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes.byref" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> (ctypes 型のインスタンスでなければならない) への軽量ポインタを返します。 <em>offset</em> はデフォルトでは 0 で、内部ポインターへ加算される整数です。</p>
<p><tt class="docutils literal"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></tt> は、 C コードとしては、以下のようにみなされます。:</p>
<div class="highlight-python"><pre>(((char *)&amp;obj) + offset)</pre>
</div>
<p>返されるオブジェクトは外部関数呼び出しのパラメータとしてのみ使用できます。 <tt class="docutils literal"><span class="pre">pointer(obj)</span></tt> と似たふるまいをしますが、作成が非常に速く行えます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加: </span><em>offset</em> オプション引数が追加されました。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.cast">
<tt class="descclassname">ctypes.</tt><tt class="descname">cast</tt><big>(</big><em>obj</em>, <em>type</em><big>)</big><a class="headerlink" href="#ctypes.cast" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は C のキャスト演算子に似ています。 <em>obj</em> と同じメモリブロックを指している <em>type</em> の新しいインスタンスを返します。
<em>type</em> はポインタ型でなければならず、 <em>obj</em> はポインタとして解釈できるオブジェクトでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_string_buffer">
<tt class="descclassname">ctypes.</tt><tt class="descname">create_string_buffer</tt><big>(</big><em>init_or_size</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes.create_string_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は変更可能な文字バッファを作成します。返されるオブジェクトは <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><tt class="xref py py-class docutils literal"><span class="pre">c_char</span></tt></a> の ctypes 配列です。</p>
<p><em>init_or_size</em> は配列のサイズを指定する整数もしくは配列要素を初期化するために使われる文字列である必要があります。</p>
<p>第一引数として文字列が指定された場合は、バッファが文字列の長さより一要素分大きく作られます。配列の最後の要素が NUL 終端文字であるためです。文字列の長さを使うべきでない場合は、配列のサイズを指定するために整数を第二引数として渡すことができます。</p>
<p>第一引数がユニコード文字列ならば、 ctypes 変換規則にしたがい 8 ビット文字列へ変換されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_unicode_buffer">
<tt class="descclassname">ctypes.</tt><tt class="descname">create_unicode_buffer</tt><big>(</big><em>init_or_size</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes.create_unicode_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は変更可能なユニコード文字バッファを作成します。返されるオブジェクトは <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><tt class="xref py py-class docutils literal"><span class="pre">c_wchar</span></tt></a> の ctypes 配列です。</p>
<p><em>init_or_size</em> は配列のサイズを指定する整数もしくは配列要素を初期化するために使われるユニコード文字列です。</p>
<p>第一引数としてユニコード文字列が指定された場合は、バッファが文字列の長さより一要素分大きく作られます。配列の最後の要素が NUL 終端文字であるためです。文字列の長さを使うべきでない場合は、配列のサイズを指定するために整数を第二引数として渡すことができます。</p>
<p>第一引数が 8 ビット文字列ならば、 ctypes 変換規則にしたがいユニコード文字列へ変換されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllCanUnloadNow">
<tt class="descclassname">ctypes.</tt><tt class="descname">DllCanUnloadNow</tt><big>(</big><big>)</big><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: この関数は ctypes をつかってインプロセス COM サーバーを実装できるようにするためのフックです。 _ctypes 拡張 dll がエクスポートしている DllCanUnloadNow 関数から呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllGetClassObject">
<tt class="descclassname">ctypes.</tt><tt class="descname">DllGetClassObject</tt><big>(</big><big>)</big><a class="headerlink" href="#ctypes.DllGetClassObject" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: この関数は ctypes をつかってインプロセス COM サーバーを実装できるようにするためのフックです。 <tt class="docutils literal"><span class="pre">_ctypes</span></tt> 拡張 dll がエクスポートしている DllGetClassObject 関数から呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_library">
<tt class="descclassname">ctypes.util.</tt><tt class="descname">find_library</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#ctypes.util.find_library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリを検索し、パス名を返します。
<em>name</em> は <tt class="docutils literal"><span class="pre">lib</span></tt> のような接頭辞、
<tt class="docutils literal"><span class="pre">.so</span></tt> や <tt class="docutils literal"><span class="pre">.dylib</span></tt> のような接尾辞、そして、バージョンナンバーを除くライブラリ名です (これは posix のリンカーオプション
<em class="xref std std-option">-l</em> で使われる書式です) 。もしライブラリが見つからなければ、
<tt class="docutils literal"><span class="pre">None</span></tt> を返します。</p>
<p>実際の機能はシステムに依存します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>Windows限定: <tt class="docutils literal"><span class="pre">find_library(&quot;m&quot;)</span></tt> もしくは <tt class="docutils literal"><span class="pre">find_library(&quot;c&quot;)</span></tt>
は <tt class="docutils literal"><span class="pre">find_msvcrt()</span></tt> の呼び出し結果を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_msvcrt">
<tt class="descclassname">ctypes.util.</tt><tt class="descname">find_msvcrt</tt><big>(</big><big>)</big><a class="headerlink" href="#ctypes.util.find_msvcrt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: Python と拡張モジュールで使われる VC ランタイプライブラリのファイル名を返します。もしライブラリ名が同定できなければ、
<tt class="docutils literal"><span class="pre">None</span></tt> を返します。</p>
<p>もし、例えば拡張モジュールにより割り付けられたメモリを <tt class="docutils literal"><span class="pre">free(void</span>
<span class="pre">*)</span></tt> で解放する必要があるなら、メモリ割り付けを行ったのと同じライブラリの関数を使うことが重要です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="ctypes.FormatError">
<tt class="descclassname">ctypes.</tt><tt class="descname">FormatError</tt><big>(</big><span class="optional">[</span><em>code</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes.FormatError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: エラーコード <em>code</em> の説明文を返します。エラーコードが指定されない場合は、 Windows api 関数 GetLastError を呼び出して、もっとも新しいエラーコードが使われます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.GetLastError">
<tt class="descclassname">ctypes.</tt><tt class="descname">GetLastError</tt><big>(</big><big>)</big><a class="headerlink" href="#ctypes.GetLastError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: 呼び出し側のスレッド内で Windows によって設定された最新のエラーコードを返します。この関数はWindowsの <cite>GetLastError()</cite> 関数を直接実行します。
ctypesのプライベートなエラーコードのコピーを返したりはしません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_errno">
<tt class="descclassname">ctypes.</tt><tt class="descname">get_errno</tt><big>(</big><big>)</big><a class="headerlink" href="#ctypes.get_errno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>システムの <a class="reference internal" href="errno.html#module-errno" title="errno: 標準の errno システムシンボル。"><tt class="xref py py-data docutils literal"><span class="pre">errno</span></tt></a> 変数の、スレッドローカルなプライベートコピーを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_last_error">
<tt class="descclassname">ctypes.</tt><tt class="descname">get_last_error</tt><big>(</big><big>)</big><a class="headerlink" href="#ctypes.get_last_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windowsのみ: システムの <tt class="xref py py-data docutils literal"><span class="pre">LastError</span></tt> 変数の、スレッドローカルなプライベートコピーを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memmove">
<tt class="descclassname">ctypes.</tt><tt class="descname">memmove</tt><big>(</big><em>dst</em>, <em>src</em>, <em>count</em><big>)</big><a class="headerlink" href="#ctypes.memmove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準 C の memmove ライブラリ関数と同じものです。: <em>count</em> バイトを
<em>src</em> から <em>dst</em> へコピーします。 <em>dst</em> と <em>src</em> はポインタへ変換可能な整数または ctypes インスタンスでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memset">
<tt class="descclassname">ctypes.</tt><tt class="descname">memset</tt><big>(</big><em>dst</em>, <em>c</em>, <em>count</em><big>)</big><a class="headerlink" href="#ctypes.memset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準 C の memset ライブラリ関数と同じものです。: アドレス <em>dst</em> のメモリブロックを値 <em>c</em> を <em>count</em> バイト分書き込みます。
<em>dst</em> はアドレスを指定する整数または ctypes インスタンスである必要があります。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.POINTER">
<tt class="descclassname">ctypes.</tt><tt class="descname">POINTER</tt><big>(</big><em>type</em><big>)</big><a class="headerlink" href="#ctypes.POINTER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このファクトリ関数は新しい ctypes ポインタ型を作成して返します。ポインタ型はキャッシュされ、内部で再利用されます。したがって、この関数を繰り返し呼び出してもコストは小さいです。 <em>type</em> は ctypes 型でなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.pointer">
<tt class="descclassname">ctypes.</tt><tt class="descname">pointer</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#ctypes.pointer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <em>obj</em> を指す新しいポインタインスタンスを作成します。戻り値は <tt class="docutils literal"><span class="pre">POINTER(type(obj))</span></tt> 型のオブジェクトです。</p>
<p>注意: 外部関数呼び出しへオブジェクトへのポインタを渡したいだけなら、はるかに高速な <tt class="docutils literal"><span class="pre">byref(obj)</span></tt> を使うべきです。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.resize">
<tt class="descclassname">ctypes.</tt><tt class="descname">resize</tt><big>(</big><em>obj</em>, <em>size</em><big>)</big><a class="headerlink" href="#ctypes.resize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <em>obj</em> の内部メモリバッファのサイズを変更します。 <em>obj</em>
は ctypes 型のインスタンスでなければなりません。バッファを <tt class="docutils literal"><span class="pre">sizeof(type(obj))</span></tt> で与えられるオブジェクト型の本来のサイズより小さくすることはできませんが、バッファを拡大することはできます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_conversion_mode">
<tt class="descclassname">ctypes.</tt><tt class="descname">set_conversion_mode</tt><big>(</big><em>encoding</em>, <em>errors</em><big>)</big><a class="headerlink" href="#ctypes.set_conversion_mode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は 8 ビット文字列とユニコード文字列の間で変換するときに使われる規則を設定します。 <em>encoding</em> は <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> や <tt class="docutils literal"><span class="pre">'mbcs'</span></tt> のようなエンコーディングを指定する文字列でなければなりません。 <em>errors</em> はエンコーディング/デコーディングエラーについてのエラー処理を指定する文字列でなければなりません。指定可能な値の例としては、 <tt class="docutils literal"><span class="pre">&quot;strict&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;replace&quot;</span></tt>,  <tt class="docutils literal"><span class="pre">&quot;ignore&quot;</span></tt> があります。</p>
<p><a class="reference internal" href="#ctypes.set_conversion_mode" title="ctypes.set_conversion_mode"><tt class="xref py py-func docutils literal"><span class="pre">set_conversion_mode()</span></tt></a> は以前の変換規則を含む 2 要素タプルを返します。
windows では初期の変換規則は <tt class="docutils literal"><span class="pre">('mbcs',</span> <span class="pre">'ignore')</span></tt> であり、他のシステムでは <tt class="docutils literal"><span class="pre">('ascii',</span> <span class="pre">'strict')</span></tt> です。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_errno">
<tt class="descclassname">ctypes.</tt><tt class="descname">set_errno</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#ctypes.set_errno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>システム変数 <cite>errno</cite> の、呼び出し元スレッドでの ctypes のプライベートコピーの現在値を <cite>value</cite> に設定し、前の値を返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_last_error">
<tt class="descclassname">ctypes.</tt><tt class="descname">set_last_error</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#ctypes.set_last_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: システム変数 <cite>LastError</cite> の、呼び出し元スレッドでの
ctypes のプライベートコピーの現在値を <cite>value</cite> に設定し、前の値を返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="ctypes.sizeof">
<tt class="descclassname">ctypes.</tt><tt class="descname">sizeof</tt><big>(</big><em>obj_or_type</em><big>)</big><a class="headerlink" href="#ctypes.sizeof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ctypes 型もしくはインスタンスのメモリバッファのサイズをバイト単位で返します。 C の <tt class="docutils literal"><span class="pre">sizeof()</span></tt> 関数と同じ動作です。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.string_at">
<tt class="descclassname">ctypes.</tt><tt class="descname">string_at</tt><big>(</big><em>address</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes.string_at" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数はメモリアドレス address から始まる文字列を返します。 size
が指定された場合はサイズとして使われます。指定されなければ、文字列がゼロ終端されていると仮定します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WinError">
<tt class="descclassname">ctypes.</tt><tt class="descname">WinError</tt><big>(</big><em>code=None</em>, <em>descr=None</em><big>)</big><a class="headerlink" href="#ctypes.WinError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: この関数は ctypes の中でもおそらく最悪な名前がつけられたものです。
WindowsError のインスタンスを作成します。 <em>code</em> が指定されないならば、エラーコードを決めるために <tt class="docutils literal"><span class="pre">GetLastError</span></tt> が呼び出されます。
<em>descr</em> が指定されないならば、 <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><tt class="xref py py-func docutils literal"><span class="pre">FormatError()</span></tt></a> がエラーの説明文を得るために呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.wstring_at">
<tt class="descclassname">ctypes.</tt><tt class="descname">wstring_at</tt><big>(</big><em>address</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes.wstring_at" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数はユニコード文字列としてメモリアドレス <em>address</em> から始まるワイドキャラクタ文字列を返します。 <em>size</em> が指定されたならば、文字列の文字数として使われます。指定されなければ、文字列がゼロ終端されていると仮定します。</p>
</dd></dl>

</div>
<div class="section" id="ctypes-data-types">
<span id="id26"></span><h3>15.18.2.6. データ型<a class="headerlink" href="#ctypes-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes._CData">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">_CData</tt><a class="headerlink" href="#ctypes._CData" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この非公開クラスはすべての ctypes データ型の共通のベースクラスです。他のことはさておき、すべての ctypes 型インスタンスは C 互換データを保持するメモリブロックを内部に持ちます。このメモリブロックのアドレスは <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><tt class="xref py py-func docutils literal"><span class="pre">addressof()</span></tt></a> ヘルパー関数が返します。別のインスタンス変数が <a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><tt class="xref py py-attr docutils literal"><span class="pre">_objects</span></tt></a> として公開されます。これはメモリブロックがポインタを含む場合に存続し続ける必要のある他の Python オブジェクトを含んでいます。</p>
<p>ctypes データ型の共通メソッド、すべてのクラスメソッドが存在します
(正確には、メタクラスのメソッドです):</p>
<dl class="method">
<dt id="ctypes._CData.from_buffer">
<tt class="descname">from_buffer</tt><big>(</big><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes._CData.from_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>source</em> オブジェクトのバッファを共有する ctypes のインスタンスを返します。 <em>source</em> オブジェクトは書き込み可能バッファインターフェースをサポートしている必要があります。オプションの <em>offset</em> 引数では <em>source</em> バッファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし <em>source</em> バッファが十分に大きくなければ、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_buffer_copy">
<tt class="descname">from_buffer_copy</tt><big>(</big><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>source</em> オブジェクトの読み出し可能バッファをコピーすることで、ctypes のインスタンスを生成します。オプションの
<em>offset</em> 引数では <em>source</em> バッファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし <em>source</em> バッファが十分に大きくなければ、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_address">
<tt class="descname">from_address</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#ctypes._CData.from_address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>address</em> で指定されたメモリを使って ctypes 型のインスタンスを返します。 <em>address</em> は整数でなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_param">
<tt class="descname">from_param</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#ctypes._CData.from_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>obj</em> を ctypes 型に適合させます。外部関数の
<tt class="xref py py-attr docutils literal"><span class="pre">argtypes</span></tt> タプルに、その型があるとき、外部関数呼び出しで実際に使われるオブジェクトと共に呼び出されます。</p>
<p>すべての ctypes のデータ型は、それが型のインスタンスであれば、
<em>obj</em> を返すこのクラスメソッドのデフォルトの実装を持ちます。いくつかの型は、別のオブジェクトも受け付けます。</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.in_dll">
<tt class="descname">in_dll</tt><big>(</big><em>library</em>, <em>name</em><big>)</big><a class="headerlink" href="#ctypes._CData.in_dll" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、共有ライブラリによってエクスポートされた ctypes
型のインスタンスを返します。
<em>name</em> はエクスポートされたデータの名前で、 <em>library</em> はロードされた共有ライブラリです。</p>
</dd></dl>

<p>ctypes データ型共通のインスタンス変数:</p>
<dl class="attribute">
<dt id="ctypes._CData._b_base_">
<tt class="descname">_b_base_</tt><a class="headerlink" href="#ctypes._CData._b_base_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ctypes 型データのインスタンスは、それ自身のメモリブロックを持たず、基底オブジェクトのメモリブロックの一部を共有することがあります。
<a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><tt class="xref py py-attr docutils literal"><span class="pre">_b_base_</span></tt></a> 読み出し専用属性は、メモリブロックを保持する
ctypes の基底オブジェクトです。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._b_needsfree_">
<tt class="descname">_b_needsfree_</tt><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この読み出し専用の変数は、 ctypes データインスタンスが、それ自身に割り当てられたメモリブロックを持つとき true になります。それ以外の場合は false になります。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._objects">
<tt class="descname">_objects</tt><a class="headerlink" href="#ctypes._CData._objects" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメンバは <tt class="docutils literal"><span class="pre">None</span></tt> 、または、メモリブロックの内容が正しく保つために、生存させておかなくてはならない Python オブジェクトを持つディクショナリです。このオブジェクトはデバッグでのみ使われます。決してディクショナリの内容を変更しないで下さい。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ctypes-fundamental-data-types-2">
<span id="id27"></span><h3>15.18.2.7. 基本データ型<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes._SimpleCData">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">_SimpleCData</tt><a class="headerlink" href="#ctypes._SimpleCData" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この非公開クラスはすべての基本 ctypes データ型のベースクラスです。ここでこのクラスに触れたのは、基本 ctypes データ型の共通属性を含んでいるからです。
<a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><tt class="xref py py-class docutils literal"><span class="pre">_SimpleCData</span></tt></a> は <a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><tt class="xref py py-class docutils literal"><span class="pre">_CData</span></tt></a> のサブクラスですので、そのメソッドと属性を継承しています。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>ポインタと、ポインタを含まない ctypes データ型が pickle 化できる
ようになりました。</p>
<p>インスタンスは一つだけ属性を持ちます:</p>
<dl class="attribute">
<dt id="ctypes._SimpleCData.value">
<tt class="descname">value</tt><a class="headerlink" href="#ctypes._SimpleCData.value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性は、インスタンスの実際の値を持ちます。整数型とポインタ型に対しては整数型、文字型に対しては一文字の文字列、文字へのポインタに対しては Python の文字列もしくはユニコード文字列となります。</p>
<p><tt class="docutils literal"><span class="pre">value</span></tt> 属性が ctypes インスタンスより参照されたとき、大抵の場合はそれぞれに対し新しいオブジェクトを返します。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> はオリジナルのオブジェクトを返す実装にはなって <em>おらず</em> 新しいオブジェクトを構築します。同じことが他の ctypes オブジェクトインスタンスに対しても言えます。</p>
</dd></dl>

</dd></dl>

<p>基本データ型は、外部関数呼び出しの結果として返されたときや、例えば構造体のフィールドメンバーや配列要素を取り出すときに、ネイティブの Python
型へ透過的に変換されます。言い換えると、外部関数が <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><tt class="xref py py-class docutils literal"><span class="pre">c_char_p</span></tt></a>
の <tt class="xref py py-attr docutils literal"><span class="pre">restype</span></tt> を持つ場合は、 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><tt class="xref py py-class docutils literal"><span class="pre">c_char_p</span></tt></a> インスタンスでは
<em>なく</em> 常に Python 文字列を受け取ることでしょう。</p>
<p>基本データ型のサブクラスはこの振る舞いを継承 <em>しません</em> 。したがって、外部関数の <tt class="xref py py-attr docutils literal"><span class="pre">restype</span></tt> が <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><tt class="xref py py-class docutils literal"><span class="pre">c_void_p</span></tt></a> のサブクラスならば、関数呼び出しからこのサブクラスのインスタンスを受け取ります。もちろん、
<tt class="docutils literal"><span class="pre">value</span></tt> 属性にアクセスしてポインタの値を得ることができます。</p>
<p>これらが基本データ型です:</p>
<dl class="class">
<dt id="ctypes.c_byte">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_byte</tt><a class="headerlink" href="#ctypes.c_byte" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt> データ型を表し、小整数として値を解釈します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_char</tt><a class="headerlink" href="#ctypes.c_char" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">char</span></tt> データ型を表し、単一の文字として値を解釈します。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の長さちょうど一文字である必要があります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char_p">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_char_p</tt><a class="headerlink" href="#ctypes.c_char_p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> データ型を表し、ゼロ終端文字列へのポインタでなければなりません。バイナリデータを指す可能性のある一般的なポインタに対しては <tt class="docutils literal"><span class="pre">POINTER(c_char)</span></tt> を使わなければなりません。コンストラクタは整数のアドレスもしくは文字列を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_double">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_double</tt><a class="headerlink" href="#ctypes.c_double" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">double</span></tt> データ型を表します。コンストラクタはオプションの浮動小数点数初期化子を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longdouble">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_longdouble</tt><a class="headerlink" href="#ctypes.c_longdouble" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">double</span></tt> データ型を表します。コンストラクタはオプションで浮動小数点数初期化子を受け取ります。 <tt class="docutils literal"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span>
<span class="pre">sizeof(double)</span></tt> であるプラットホームでは <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><tt class="xref py py-class docutils literal"><span class="pre">c_double</span></tt></a> の別名です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_float">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_float</tt><a class="headerlink" href="#ctypes.c_float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">float</span></tt> データ型を表します。コンストラクタはオプションの浮動小数点数初期化子を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_int</tt><a class="headerlink" href="#ctypes.c_int" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。
<tt class="docutils literal"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></tt> であるプラットホームでは、
<a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><tt class="xref py py-class docutils literal"><span class="pre">c_long</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int8">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_int8</tt><a class="headerlink" href="#ctypes.c_int8" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 8-bit <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><tt class="xref py py-class docutils literal"><span class="pre">c_byte</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int16">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_int16</tt><a class="headerlink" href="#ctypes.c_int16" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 16-bit <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><tt class="xref py py-class docutils literal"><span class="pre">c_short</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int32">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_int32</tt><a class="headerlink" href="#ctypes.c_int32" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 32-bit <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int64">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_int64</tt><a class="headerlink" href="#ctypes.c_int64" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 64-bit <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><tt class="xref py py-class docutils literal"><span class="pre">c_longlong</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_long">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_long</tt><a class="headerlink" href="#ctypes.c_long" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">long</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longlong">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_longlong</tt><a class="headerlink" href="#ctypes.c_longlong" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_short">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_short</tt><a class="headerlink" href="#ctypes.c_short" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">short</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_size_t">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_size_t</tt><a class="headerlink" href="#ctypes.c_size_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">size_t</span></tt> データ型を表します。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ssize_t">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_ssize_t</tt><a class="headerlink" href="#ctypes.c_ssize_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">ssize_t</span></tt> データ型を表します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ubyte">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_ubyte</tt><a class="headerlink" href="#ctypes.c_ubyte" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt> データ型を表します。その値は小整数として解釈されます。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_uint</tt><a class="headerlink" href="#ctypes.c_uint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。
<tt class="docutils literal"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></tt> であるプラットホームでは、
<a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><tt class="xref py py-class docutils literal"><span class="pre">c_ulong</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint8">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_uint8</tt><a class="headerlink" href="#ctypes.c_uint8" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 8-bit <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><tt class="xref py py-class docutils literal"><span class="pre">c_ubyte</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint16">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_uint16</tt><a class="headerlink" href="#ctypes.c_uint16" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 16-bit <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><tt class="xref py py-class docutils literal"><span class="pre">c_ushort</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint32">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_uint32</tt><a class="headerlink" href="#ctypes.c_uint32" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 32-bit <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><tt class="xref py py-class docutils literal"><span class="pre">c_uint</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint64">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_uint64</tt><a class="headerlink" href="#ctypes.c_uint64" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 64-bit <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> データ型を表します。たいていは、
<a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><tt class="xref py py-class docutils literal"><span class="pre">c_ulonglong</span></tt></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulong">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_ulong</tt><a class="headerlink" href="#ctypes.c_ulong" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulonglong">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_ulonglong</tt><a class="headerlink" href="#ctypes.c_ulonglong" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ushort">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_ushort</tt><a class="headerlink" href="#ctypes.c_ushort" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_void_p">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_void_p</tt><a class="headerlink" href="#ctypes.c_void_p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt> データ型を表します。値は整数として表されます。コンストラクタはオプションの整数初期化子を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_wchar</tt><a class="headerlink" href="#ctypes.c_wchar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span></tt> データ型を表し、値はユニコード文字列の単一の文字として解釈されます。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の長さはちょうど一文字である必要があります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar_p">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_wchar_p</tt><a class="headerlink" href="#ctypes.c_wchar_p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></tt> データ型を表し、ゼロ終端ワイド文字列へのポインタでなければなりません。コンストラクタは整数のアドレスもしくは文字列を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_bool">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">c_bool</tt><a class="headerlink" href="#ctypes.c_bool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <tt class="xref c c-type docutils literal"><span class="pre">bool</span></tt> データ型 (より正確には、C99 の <tt class="xref c c-type docutils literal"><span class="pre">_Bool</span></tt>) を表します。その値は True または False であり、コンストラクタはどんなオブジェクト
( 真値を持ちます ) でも受け取ります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="class">
<dt id="ctypes.HRESULT">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">HRESULT</tt><a class="headerlink" href="#ctypes.HRESULT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: <tt class="xref c c-type docutils literal"><span class="pre">HRESULT</span></tt> 値を表し、関数またはメソッド呼び出しに対する成功またはエラーの情報を含んでいます。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.py_object">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">py_object</tt><a class="headerlink" href="#ctypes.py_object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt></a> データ型を表します。引数なしでこれを呼び出すと
<tt class="docutils literal"><span class="pre">NULL</span></tt> <a class="reference internal" href="../c-api/structures.html#PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt></a> ポインタを作成します。</p>
</dd></dl>

<p><tt class="xref py py-mod docutils literal"><span class="pre">ctypes.wintypes</span></tt> モジュールは他の Windows 固有のデータ型を提供します。例えば、 <tt class="xref c c-type docutils literal"><span class="pre">HWND</span></tt>, <tt class="xref c c-type docutils literal"><span class="pre">WPARAM</span></tt>, <tt class="xref c c-type docutils literal"><span class="pre">DWORD</span></tt> です。
<tt class="xref c c-type docutils literal"><span class="pre">MSG</span></tt> や <tt class="xref c c-type docutils literal"><span class="pre">RECT</span></tt> のような有用な構造体も定義されています。</p>
</div>
<div class="section" id="ctypes-structured-data-types">
<span id="id28"></span><h3>15.18.2.8. 標準データ型<a class="headerlink" href="#ctypes-structured-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes.Union">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">Union</tt><big>(</big><em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#ctypes.Union" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ネイティブのバイトオーダーでの共用体のための抽象ベースクラス。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.BigEndianStructure">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">BigEndianStructure</tt><big>(</big><em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#ctypes.BigEndianStructure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>ビックエンディアン</em> バイトオーダーでの構造体のための抽象ベースクラス。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.LittleEndianStructure">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">LittleEndianStructure</tt><big>(</big><em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#ctypes.LittleEndianStructure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>リトルエンディアン</em> バイトオーダーでの構造体のための抽象ベースクラス。</p>
</dd></dl>

<p>ネイティブではないバイトオーダーを持つ構造体にポインタ型フィールドあるいはポインタ型フィールドを含む他のどんなデータ型をも入れることはできません。</p>
<dl class="class">
<dt id="ctypes.Structure">
<em class="property">class </em><tt class="descclassname">ctypes.</tt><tt class="descname">Structure</tt><big>(</big><em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#ctypes.Structure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>ネイティブ</em> のバイトオーダーでの構造体のための抽象ベースクラス。</p>
</dd></dl>

<p>具象構造体型と具象共用体型はこれらの型の一つをサブクラス化することで作らなければなりません。少なくとも、 <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> クラス変数を定義する必要があります。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は、属性に直接アクセスしてフィールドを読み書きできるようにする記述子 ( <a class="reference internal" href="../glossary.html#term-descriptor"><em class="xref std std-term">descriptor</em></a> ) を作成するでしょう。これらは、</p>
<blockquote>
<div><dl class="attribute">
<dt id="ctypes._fields_">
<tt class="descclassname">ctypes.</tt><tt class="descname">_fields_</tt><a class="headerlink" href="#ctypes._fields_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>構造体のフィールドを定義するシーケンス。要素は2要素タプルか3要素タプルでなければなりません。第一要素はフィールドの名前です。第二要素はフィールドの型を指定します。それはどんな ctypes データ型でも構いません。</p>
<p><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><tt class="xref py py-class docutils literal"><span class="pre">c_int</span></tt></a> のような整数型のために、オプションの第三要素を与えることができます。フィールドのビット幅を定義する正の小整数である必要があります。</p>
<p>一つの構造体と共用体の中で、フィールド名はただ一つである必要があります。これはチェックされません。名前が繰り返しでてきたときにアクセスできるのは一つのフィールドだけです。</p>
<p>Structure サブクラスを定義するクラス文の <em>後で</em> 、
<a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> クラス変数を定義することができます。これにより自身を直接または間接的に参照するデータ型を作成できるようになります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>しかし、 <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> クラス変数はその型が最初に使われる (
インスタンスが作成される、それに対して <tt class="docutils literal"><span class="pre">sizeof()</span></tt> が呼び出されるなど ) より前に定義されていなければなりません。その後
<a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> クラス変数へ代入すると AttributeError が送出されます。</p>
<p>構造体および共用体サブクラスは位置引数と名前付き引数の両方を受け取ります。位置引数は <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> 定義中に現れたのと同じ順番でフィールドを初期化するために使われ、名前付き引数は対応する名前を使ってフィールドを初期化するために使われます。</p>
<p>構造体型のサブクラスを定義することができ、もしあるならサブクラス内で定義された <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> に加えて、ベースクラスのフィールドも継承します。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._pack_">
<tt class="descclassname">ctypes.</tt><tt class="descname">_pack_</tt><a class="headerlink" href="#ctypes._pack_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンスの構造体フィールドのアライメントを上書きできるようにするオブションの小整数。 <a class="reference internal" href="#ctypes._pack_" title="ctypes._pack_"><tt class="xref py py-attr docutils literal"><span class="pre">_pack_</span></tt></a> は <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> が代入されたときすでに定義されていなければなりません。そうでなければ、何ら影響はありません。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._anonymous_">
<tt class="descclassname">ctypes.</tt><tt class="descname">_anonymous_</tt><a class="headerlink" href="#ctypes._anonymous_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>無名 (匿名) フィールドの名前が並べあげられたオプションのシーケンス。 <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> が代入されたとき、 <a class="reference internal" href="#ctypes._anonymous_" title="ctypes._anonymous_"><tt class="xref py py-attr docutils literal"><span class="pre">_anonymous_</span></tt></a> がすでに定義されていなければなりません。そうでなければ、何ら影響はありません。</p>
<p>この変数に並べあげられたフィールドは構造体型もしくは共用体型フィールドである必要があります。構造体フィールドまたは共用体フィールドを作る必要なく、入れ子になったフィールドに直接アクセスできるようにするために、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><tt class="xref py py-mod docutils literal"><span class="pre">ctypes</span></tt></a> は構造体型の中に記述子を作成します。</p>
<p>型の例です(Windows):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">TYPEDESC</span></tt> 構造体はCOMデータ型を表現しており、 <tt class="docutils literal"><span class="pre">vt</span></tt> フィールドは共用体フィールドのどれが有効であるかを指定します。 <tt class="docutils literal"><span class="pre">u</span></tt> フィールドは匿名フィールドとして定義されているため、 TYPEDESC インスタンスから取り除かれてそのメンバーへ直接アクセスできます。
<tt class="docutils literal"><span class="pre">td.lptdesc</span></tt> と <tt class="docutils literal"><span class="pre">td.u.lptdesc</span></tt> は同等ですが、前者がより高速です。なぜなら一時的な共用体インスタンスを作る必要がないためです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>構造体のサブ-サブクラスを定義することができ、ベースクラスのフィールドを継承します。サブクラス定義に別の <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> 変数がある場合は、この中で指定されたフィールドはベースクラスのフィールドへ追加されます。</p>
<p>構造体と共用体のコンストラクタは位置引数とキーワード引数の両方を受け取ります。位置引数は <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> の中に現れたのと同じ順番でメンバーフィールドを初期化するために使われます。コンストラクタのキーワード引数は属性代入として解釈され、そのため、同じ名前をもつ <a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> を初期化するか、
<a class="reference internal" href="#ctypes._fields_" title="ctypes._fields_"><tt class="xref py py-attr docutils literal"><span class="pre">_fields_</span></tt></a> に存在しない名前に対しては新しい属性を作ります。</p>
</div></blockquote>
</div>
<div class="section" id="ctypes-arrays-pointers">
<span id="id29"></span><h3>15.18.2.9. 配列とポインタ<a class="headerlink" href="#ctypes-arrays-pointers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>未作成 - チュートリアルの節 <a class="reference internal" href="#ctypes-pointers"><em>ポインタ</em></a> と
<a class="reference internal" href="#ctypes-arrays"><em>配列</em></a> を参照してください。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="someos.html" title="16. オプションのオペレーティングシステムサービス"
             >次へ</a> |</li>
        <li class="right" >
          <a href="errno.html" title="15.17. errno — 標準の errno システムシンボル"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="allos.html" >15. 汎用オペレーティングシステムサービス</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>