

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>25.3. unittest — ユニットテストフレームワーク &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="25. 開発ツール" href="development.html" />
    <link rel="next" title="25.4. 2to3 - Python 2 から 3 への自動コード変換" href="2to3.html" />
    <link rel="prev" title="25.2. doctest — 対話的な実行例をテストする" href="doctest.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="25.4. 2to3 - Python 2 から 3 への自動コード変換"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="25.2. doctest — 対話的な実行例をテストする"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="development.html" accesskey="U">25. 開発ツール</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">25.3. <tt class="docutils literal"><span class="pre">unittest</span></tt> &#8212; ユニットテストフレームワーク</a><ul>
<li><a class="reference internal" href="#unittest-minimal-example">25.3.1. 基礎的な例</a></li>
<li><a class="reference internal" href="#unittest-command-line-interface">25.3.2. コマンドラインインタフェース</a><ul>
<li><a class="reference internal" href="#id3">25.3.2.1. コマンドラインオプション</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unittest-test-discovery">25.3.3. テストディスカバリ</a></li>
<li><a class="reference internal" href="#organizing-tests">25.3.4. テストの構成</a></li>
<li><a class="reference internal" href="#legacy-unit-tests">25.3.5. 既存テストコードの再利用</a></li>
<li><a class="reference internal" href="#unittest-skipping">25.3.6. テストのスキップと意図的な失敗</a></li>
<li><a class="reference internal" href="#unittest-contents">25.3.7. クラスと関数</a><ul>
<li><a class="reference internal" href="#testcase-objects">25.3.7.1. テストクラス</a><ul>
<li><a class="reference internal" href="#id10">25.3.7.1.1. 廃止予定のエイリアス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testsuite-objects">25.3.7.2. テストのグルーピング</a></li>
<li><a class="reference internal" href="#id12">25.3.7.3. テストのロードと起動</a><ul>
<li><a class="reference internal" href="#load-tests">25.3.7.3.1. load_tests プロトコル</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id13">25.3.8. クラスとモジュールの修正</a><ul>
<li><a class="reference internal" href="#setupclass-teardownclass">25.3.8.1. setUpClass と tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-teardownmodule">25.3.8.2. setUpModule と tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">25.3.9. シグナルハンドリング</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="doctest.html"
                        title="前の章へ">25.2. <tt class="docutils literal docutils literal docutils literal"><span class="pre">doctest</span></tt> &#8212; 対話的な実行例をテストする</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2to3.html"
                        title="次の章へ">25.4. 2to3 - Python 2 から 3 への自動コード変換</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/unittest.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-unittest">
<span id="unittest"></span><h1>25.3. <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> &#8212; ユニットテストフレームワーク<a class="headerlink" href="#module-unittest" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p class="versionadded">
<span class="versionmodified">バージョン 2.1 で追加.</span></p>
<p>(読者の方がすでにテストの基本概念についてなじみがあるようでしたら、この部分をとばして <a class="reference internal" href="#assert-methods"><em>the list of assert methods</em></a> に進むと良いでしょう。)</p>
<p>この Python ユニットテストフレームワークは時に &#8220;PyUnit&#8221; とも呼ばれ、
Kent Beck と Erich Gamma による JUnit の Python 版です。
JUnit はまた Kent の Smalltalk 用テストフレームワークの Java 版で、どちらもそれぞれの言語で業界標準のユニットテストフレームワークとなっています。</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> では、テストの自動化・初期設定と終了処理の共有・テストの分類・テスト実行と結果レポートの分離などの機能を提供しており、
<a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> のクラスを使って簡単にたくさんのテストを開発できるようになっています。</p>
<p>このようなことを実現するために <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> では、テストを以下のような構成で開発します。</p>
<dl class="docutils">
<dt>test fixture (テストフィクスチャー)</dt>
<dd><em class="dfn">test fixture</em> とは、テスト実行のために必要な準備や終了処理を指します。例: テスト用データベースの作成・ディレクトリ・サーバプロセスの起動など。</dd>
<dt>test case (テストケース)</dt>
<dd><em class="dfn">test case</em> はテストの最小単位で、各入力に対する結果をチェックします。テストケースを作成する場合は、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> が提供する
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスを基底クラスとして利用することができます。</dd>
<dt>test suite (テストスイート)</dt>
<dd><em class="dfn">test suite</em> はテストケースとテストスイートの集まりで、同時に実行しなければならないテストをまとめる場合に使用します。</dd>
<dt>test runner (テストランナー)</dt>
<dd><em class="dfn">test runner</em> はテストの実行と結果表示を管理するコンポーネントです。ランナーはグラフィカルインターフェースでもテキストインターフェースでも良いですし、何も表示せずにテスト結果を示す値を返すだけの場合もあります。</dd>
</dl>
<p><a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> では、テストケースとテストフィクスチャーを、
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスと <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> クラスで提供しています。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスは新規にテストを作成する場合に使用し、
<a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> は既存のテストを <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> に組み込む場合に使用します。テストフィクスチャーの設定処理と終了処理は、
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> では <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> メソッドと <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a>
をオーバーライドして記述し、 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> では初期設定・終了処理を行う既存の関数をコンストラクタで指定します。テスト実行時、まずテストフィクスチャーの初期設定が最初に実行されます。初期設定が正常終了した場合、テスト実行後にはテスト結果に関わらず終了処理が実行されます。
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> の各インスタンスが実行するテストは一つだけで、テストフィクスチャーは各テストごとに新しく作成されます。</p>
<p>テストスイートは <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> クラスで実装されており、複数のテストとテストスイートをまとめる事ができます。テストスイートを実行すると、スイートと子スイートに追加されている全てのテストが実行されます。</p>
<p>テストランナーは <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> メソッドを持つオブジェクトです。このメソッドは引数として <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> か <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> オブジェクトを受け取り、テスト結果を <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> オブジェクトで戻します。 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> ではデフォルトでテスト結果を標準エラーに出力する <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><tt class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></tt></a> をサンプルとして実装しています。これ以外のランナー (グラフィックインターフェース用など) を実装する場合でも、特別なクラスから派生させて実装する必要はありません。</p>
<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt>Module <a class="reference internal" href="doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a></dt>
<dd>もうひとつのテストをサポートするモジュールで、本モジュールと趣きが異なっています。</dd>
<dt><a class="reference external" href="http://pypi.python.org/pypi/unittest2">unittest2: ユニットテストの新機能の Python 2.4-2.6 向けバックポート</a></dt>
<dd>Python 2.7 になり多くの機能が unittest に追加されました。特に、テストディスカバリが追加されました。 unittest2 を導入する事で以前のバージョンの Python でもこれらの機能を使えます。</dd>
<dt><a class="reference external" href="http://www.XProgramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt>
<dd>Kent Beck のテスティングフレームワークに関する原論文で、ここに記載されたパターンを
<a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> が使用しています。</dd>
<dt><a class="reference external" href="http://code.google.com/p/python-nose/">Nose</a> と <a class="reference external" href="http://pytest.org">py.test</a></dt>
<dd>サードパーティのユニットテストフレームワークで軽量な文法でテストを書くことができます。例えば、 <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></tt>  のように書きます。</dd>
<dt><a class="reference external" href="http://pycheesecake.org/wiki/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt>
<dd>多くの Python のテストツールが一覧で紹介されています。ファンクショナルテストのフレームワークやモックライブラリも掲載されています。</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python Mailing List</a></dt>
<dd>Python でテストやテストツールについての議論に特化したグループです。</dd>
</dl>
</div>
<div class="section" id="unittest-minimal-example">
<span id="id1"></span><h2>25.3.1. 基礎的な例<a class="headerlink" href="#unittest-minimal-example" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュールには、テストの開発や実行の為の優れたツールが用意されており、この節では、その一部を紹介します。ほとんどのユーザとっては、ここで紹介するツールだけで十分でしょう。</p>
<p>以下は、 <a class="reference internal" href="random.html#module-random" title="random: よく知られている様々な分布をもつ擬似乱数を生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt></a> モジュールの三つの関数をテストするスクリプトです。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestSequenceFunctions</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># make sure the shuffled sequence does not lose any elements</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

        <span class="c"># should raise an exception for an immutable sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">test_choice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>テストケースは、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt></a> のサブクラスとして作成します。メソッド名が <tt class="docutils literal"><span class="pre">test</span></tt> で始まる三つのメソッドがテストです。テストランナーはこの命名規約によってテストを行うメソッドを検索します。</p>
<p>これらのテスト内では、予定の結果が得られていることを確かめるために
<a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> を、条件のチェックに <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><tt class="xref py py-meth docutils literal"><span class="pre">assertTrue()</span></tt></a> を、例外が発生する事を確認するために <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> をそれぞれ呼び出しています。 <a class="reference internal" href="../reference/simple_stmts.html#assert"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> 文の代わりにこれらのメソッドを使用すると、テストランナーでテスト結果を集計してレポートを作成する事ができます。</p>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> メソッドが定義されている場合、テストランナーは各テストを実行する前に <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> メソッドを呼び出します。同様に、
<a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> メソッドが定義されている場合は各テストの実行後に呼び出します。上のサンプルでは、それぞれのテスト用に新しいシーケンスを作成するために <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> を使用しています。</p>
<p>サンプルの末尾が、簡単なテストの実行方法です。 <a class="reference internal" href="#unittest.main" title="unittest.main"><tt class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></tt></a>
は、テストスクリプトのコマンドライン用インターフェースです。コマンドラインから起動された場合、上記のスクリプトから以下のような結果が出力されます:</p>
<div class="highlight-python"><pre>...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK</pre>
</div>
<p>簡略化した結果を出力したり、コマンドライン以外からも起動する等のより細かい制御が必要であれば、 <a class="reference internal" href="#unittest.main" title="unittest.main"><tt class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></tt></a> を使用せずに別の方法でテストを実行します。例えば、上記サンプルの最後の2行は以下のように書くことができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">TestSequenceFunctions</span><span class="p">)</span>
<span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>
</pre></div>
</div>
<p>変更後のスクリプトをインタープリタや別のスクリプトから実行すると、以下の出力が得られます:</p>
<div class="highlight-python"><pre>test_choice (__main__.TestSequenceFunctions) ... ok
test_sample (__main__.TestSequenceFunctions) ... ok
test_shuffle (__main__.TestSequenceFunctions) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.110s

OK</pre>
</div>
<p>以上が <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュールでよく使われる機能で、ほとんどのテストではこれだけでも十分です。基礎となる概念や全ての機能については以降の章を参照してください。</p>
</div>
<div class="section" id="unittest-command-line-interface">
<span id="id2"></span><h2>25.3.2. コマンドラインインタフェース<a class="headerlink" href="#unittest-command-line-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユニットテストモジュールはコマンドラインから使うこともできます。モジュール、クラス、もしくは、特定のテストメソッドで定義されたテストを実行します。:</p>
<div class="highlight-python"><pre>python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method</pre>
</div>
<p>引数として渡す事ができるのは、テストが定義されたモジュール名、もしくはクラス、メソッドのフルパス名です。</p>
<p>テスト実行時に（冗長な）詳細を表示するには -f フラグを渡します。:</p>
<div class="highlight-python"><pre>python -m unittest -v test_module</pre>
</div>
<p>コマンドラインプションの一覧を表示するには以下のコマンドを実行します。:</p>
<div class="highlight-python"><pre>python -m unittest -h</pre>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>以前のバージョンでは、特定のメソッドでしか実行できず、
モジュールやクラスは指定できませんでした。</p>
<div class="section" id="id3">
<h3>25.3.2.1. コマンドラインオプション<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong class="program">unittest</strong> には以下のコマンドラインオプションがあります:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-b">
<tt class="descname">-b</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--buffer</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-b" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準出力と標準エラーのストリームをテスト実行の間バッファリングします。テストが成功している間は結果の出力は破棄されます。テストが失敗、もしくはエラーが発生した場合には、結果にエラーメッセージが追加されたうえで通常通り出力されます。</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-c">
<tt class="descname">-c</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--catch</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-c" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>control-C を実行中のテストが終了するまで遅延させ、そこまでの結果を出力します。二回目の control-C は、通常通り <a class="reference internal" href="exceptions.html#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><tt class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></tt></a>
の例外を発生させます。</p>
<p>この機能の仕組みについては、 <a href="#id15"><span class="problematic" id="id16">`Signal Handling`_</span></a> を参照してください。</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-f">
<tt class="descname">-f</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--failfast</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-f" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>初回のエラーもしくは失敗の時にテストを停止します。</p>
</dd></dl>

<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加: </span>コマンドラインオプションの <tt class="docutils literal"><span class="pre">-b</span></tt>, <tt class="docutils literal"><span class="pre">-c</span></tt> および <tt class="docutils literal"><span class="pre">-f</span></tt> が追加されました。</p>
<p>このコマンドラインは、プロジェクト内の全テストを実行したり、サブセットのみを実行したりといった、テストディスカバリを使用することもできます。</p>
</div>
</div>
<div class="section" id="unittest-test-discovery">
<span id="id4"></span><h2>25.3.3. テストディスカバリ<a class="headerlink" href="#unittest-test-discovery" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
<p>unittest はシンプルなテストディスカバリをサポートします。このテストディスカバリに対応するために、テストが定義された全ファイルは
<a class="reference internal" href="../tutorial/modules.html#tut-modules"><em>modules</em></a> もしくは <a class="reference internal" href="../tutorial/modules.html#tut-packages"><em>packages</em></a> としてプロジェクトの最上位のディスカバリでインポート可能である必要があります。（つまり、これらのファイルは <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><em>identifiers</em></a> として有効である必要があるということです。）</p>
<p>テストディスカバリは <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><tt class="xref py py-meth docutils literal"><span class="pre">TestLoader.discover()</span></tt></a> で実装されています。しかし、コマンドラインからも使う事ができます。コマンドラインからは以下のように使用します。:</p>
<div class="highlight-python"><pre>cd project_directory
python -m unittest discover</pre>
</div>
<p><tt class="docutils literal"><span class="pre">discover</span></tt> サブコマンドには以下のオプションがあります。</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-v">
<tt class="descname">-v</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">--verbose</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-unittest-discover-v" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>詳細な出よr区</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-s">
<tt class="descname">-s</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-unittest-discover-s" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ディスカバリを開始するディレクトリ （デフォルトは &#8216;.&#8217;）</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-p">
<tt class="descname">-p</tt><tt class="descclassname"> pattern</tt><a class="headerlink" href="#cmdoption-unittest-discover-p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストファイル名を識別するパターン （デフォルトは &#8216;test*.py&#8217;）</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-t">
<tt class="descname">-t</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-unittest-discover-t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロジェクトの最上位のディスカバリのディレクトリ （デフォルトは開始のディレクトリ）</p>
</dd></dl>

<p>The <a class="reference internal" href="#cmdoption-unittest-discover-s"><em class="xref std std-option">-s</em></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><em class="xref std std-option">-p</em></a>, and <a class="reference internal" href="#cmdoption-unittest-discover-t"><em class="xref std std-option">-t</em></a> options can be passed in
as positional arguments in that order. The following two command lines
are equivalent:</p>
<div class="highlight-python"><pre>:option:`-s` 、 :option:`-p` 、および :option:`-t` の各オプションは、</pre>
</div>
<p>この順番で指定すれば位置固定の引数として指定する事ができます。以下の二つのコマンドは同じ結果になります。:</p>
<div class="highlight-python"><pre>python -m unittest discover -s project_directory -p '*_test.py'
python -m unittest discover project_directory '*_test.py'</pre>
</div>
<p>パスを渡すのはもちろんのこと、例えば <tt class="docutils literal"><span class="pre">myproject.subpackage.test</span></tt> のように、パッケージ名をスタートディレクトリとして渡すことができます。指定したパッケージがインポートされ、そのパッケージのファイルシステム上のパスがスタートディレクトリになります。</p>
<div class="admonition caution">
<p class="first admonition-title">ご用心</p>
<p>テストディスカバリはテストをインポートすることで読み込みます。テストディスカバリは一度、指定した開始ディレクトリから全テストファイルを探索し、そのファイルのパスをパッケージ名に変換してインポートします。例えば、 <cite>foo/bar/baz.py</cite> は <tt class="docutils literal"><span class="pre">foo.bar.baz</span></tt> としてインポートされます。</p>
<p>もしパッケージをグローバルにインストールしていて、インストールしたのとは異なるパッケージのコピーをディスカバリしようとすると、間違った場所からインポートして <em>しまうかもしれません</em> 。このような状態になるとテストディスカバリは警告を出し、停止します。</p>
<p class="last">スタートディレクトリとしてディレクトリのパスではなくパッケージ名を指定した場合は、いずれかの場所からインポートされます。この場合は警告が表示されません。</p>
</div>
<p>テストモジュールとテストパッケージは、テストのロードとディスカバリをカスタマイズすることができます。そのために <a href="#id17"><span class="problematic" id="id18">`load_tests protocol`_</span></a> を使用します。</p>
</div>
<div class="section" id="organizing-tests">
<span id="id5"></span><h2>25.3.4. テストの構成<a class="headerlink" href="#organizing-tests" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユニットテストの基礎となる構築要素は、 <em class="dfn">test case</em> &#8212; セットアップと正しさのチェックを行う、独立したシナリオ &#8212; です。 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> では、テストケースは <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュールの <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスのインスタンスで示します。テストケースを作成するには
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスを記述するか、または
<a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> を使用します。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> から派生したクラスのインスタンスは、このオブジェクトだけで一件のテストと初期設定・終了処理を行います。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> インスタンスは外部から完全に独立し、単独で実行する事も、他の任意のテストと一緒に実行する事もできなければなりません。</p>
<p>以下のように、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスは <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> をオーバライドし、必要なテスト処理を記述するだけで簡単に書くことができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="s">&#39;incorrect default size&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>何らかのテストを行う場合、ベースクラス <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> の
<tt class="xref py py-meth docutils literal"><span class="pre">assert*()</span></tt> メソッドを使用してください。テストが失敗すると例外が送出され、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> はテスト結果を
<em class="dfn">failure</em> とします。その他の例外は <em class="dfn">error</em> となります。これによりどこに問題があるかが判ります。 <em class="dfn">failure</em> は間違った結果
(6 になるはずが 5 だった) で発生します。 <em class="dfn">error</em> は間違ったコード
(たとえば間違った関数呼び出しによる <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a>) で発生します。</p>
<p>テストの実行方法については後述とし、まずはテストケースインスタンスの作成方法を示します。テストケースインスタンスは、以下のように引数なしでコンストラクタを呼び出して作成します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">testCase</span> <span class="o">=</span> <span class="n">DefaultWidgetSizeTestCase</span><span class="p">()</span>
</pre></div>
</div>
<p>似たようなテストを数多く行う場合、同じ環境設定処理を何度も必要となります。例えば上記のような Widget のテストが 100 種類も必要な場合、それぞれのサブクラスで <tt class="xref py py-class docutils literal"><span class="pre">Widget</span></tt> オブジェクトを生成する処理を記述するのは好ましくありません。</p>
<p>このような場合、初期化処理は <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> メソッドに切り出し、テスト実行時にテストフレームワークが自動的に実行するようにすることができます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">SimpleWidgetTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                        <span class="s">&#39;incorrect default size&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WidgetResizeTestCase</span><span class="p">(</span><span class="n">SimpleWidgetTestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                        <span class="s">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>テスト中に <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> メソッドで例外が発生した場合、テストフレームワークはテストを実行することができないとみなし、 <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> を実行しません。</p>
<p>同様に、終了処理を <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> メソッドに記述すると、
<tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> メソッド終了後に実行されます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">SimpleWidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> が正常終了した場合、 <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> が成功したかどうかに従って <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> が実行されます。</p>
<p>このような、テストを実行する環境を <em class="dfn">fixture</em> と呼びます。</p>
<p>JUnit では、多数の小さなテストケースを同じテスト環境で実行する場合、全てのテストについて <tt class="xref py py-class docutils literal"><span class="pre">DefaultWidgetSizeTestCase</span></tt> のような
<tt class="xref py py-class docutils literal"><span class="pre">SimpleWidgetTestCase</span></tt> のサブクラスを作成する必要があります。これは時間のかかる、うんざりする作業ですので、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> ではより簡単なメカニズムを用意しています:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">test_default_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>この例では <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> がありませんが、二つのテストメソッドを定義しています。このクラスのインスタンスは <tt class="xref py py-meth docutils literal"><span class="pre">test_*()</span></tt> メソッドのどちらか一方の実行と、 <tt class="docutils literal"><span class="pre">self.widget</span></tt> の生成・解放を行います。この場合、テストケースインスタンス生成時に、コンストラクタの引数として実行するメソッド名を指定します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">defaultSizeTestCase</span> <span class="o">=</span> <span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">)</span>
<span class="n">resizeTestCase</span> <span class="o">=</span> <span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> では <tt class="xref py py-class docutils literal"><span class="pre">test</span> <span class="pre">suite</span></tt> によってテストケースインスタンスをテスト対象の機能によってグループ化することができます。
<em class="dfn">test suite</em> は、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> の <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> クラスで作成します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">widgetTestSuite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
<span class="n">widgetTestSuite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">))</span>
<span class="n">widgetTestSuite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>各テストモジュールで、テストケースを組み込んだテストスイートオブジェクトを作成する呼び出し可能オブジェクトを用意しておくと、テストの実行や参照が容易になります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>または:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;test_default_size&#39;</span><span class="p">,</span> <span class="s">&#39;test_resize&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">,</span> <span class="n">tests</span><span class="p">))</span>
</pre></div>
</div>
<p>一般的には、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスには良く似た名前のテスト関数が複数定義されますので、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> ではテストスイートを作成して個々のテストで満たすプロセスを自動化するのに使う <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a>
を用意しています。たとえば、:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestLoader</span><span class="p">()</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">)</span>
</pre></div>
</div>
<p>は <tt class="docutils literal"><span class="pre">WidgetTestCase.test_default_size()</span></tt> と
<tt class="docutils literal"><span class="pre">WidgetTestCase.test_resize</span></tt> を走らせるテストスイートを作成します。
<a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> は自動的にテストメソッドを識別するのに <tt class="docutils literal"><span class="pre">'test'</span></tt>
というメソッド名の接頭辞を使います。</p>
<p>いろいろなテストケースが実行される順序は、テスト関数名を組み込みの文字列の順番に従って決まります。</p>
<p>システム全体のテストを行う場合など、テストスイートをさらにグループ化したい場合がありますが、このような場合、 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> インスタンスには <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> と同じように <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> を追加する事ができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">suite1</span> <span class="o">=</span> <span class="n">module1</span><span class="o">.</span><span class="n">TheTestSuite</span><span class="p">()</span>
<span class="n">suite2</span> <span class="o">=</span> <span class="n">module2</span><span class="o">.</span><span class="n">TheTestSuite</span><span class="p">()</span>
<span class="n">alltests</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">([</span><span class="n">suite1</span><span class="p">,</span> <span class="n">suite2</span><span class="p">])</span>
</pre></div>
</div>
<p>テストケースやテストスイートは (<tt class="file docutils literal"><span class="pre">widget.py</span></tt> のような) テスト対象のモジュール内にも記述できますが、テストは (<tt class="file docutils literal"><span class="pre">test_widget.py</span></tt> のような) 独立したモジュールに置いた方が以下のような点で有利です:</p>
<ul class="simple">
<li>テストモジュールだけをコマンドラインから実行することができる。</li>
<li>テストコードと出荷するコードを分離する事ができる。</li>
<li>テストコードを、テスト対象のコードに合わせて修正する誘惑に駆られにくい。</li>
<li>テストコードは、テスト対象コードほど頻繁に更新されない。</li>
<li>テストコードをより簡単にリファクタリングすることができる。</li>
<li>Cで書いたモジュールのテストは、どっちにしろ独立したモジュールとなる。</li>
<li>テスト戦略を変更した場合でも、ソースコードを変更する必要がない。</li>
</ul>
</div>
<div class="section" id="legacy-unit-tests">
<span id="id6"></span><h2>25.3.5. 既存テストコードの再利用<a class="headerlink" href="#legacy-unit-tests" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>既存のテストコードが有るとき、このテストを <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> で実行しようとするために古いテスト関数をいちいち <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスのサブクラスに変換するのは大変です。</p>
<p>このような場合は、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> では <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスである <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> クラスを使い、既存のテスト関数をラップします。初期設定と終了処理も行なえます。</p>
<p>以下のテストコードがあった場合:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="c"># ...</span>
</pre></div>
</div>
<p>テストケースインスタンスは次のように作成します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">)</span>
</pre></div>
</div>
<p>初期設定、終了処理が必要な場合は、次のように指定します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<p>既存のテストスイートからの移行を容易にするため、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> は
<a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a> の送出でテストの失敗を示すような書き方もサポートしています。しかしながら、 <tt class="xref py py-meth docutils literal"><span class="pre">TestCase.fail*()</span></tt> および
<tt class="xref py py-meth docutils literal"><span class="pre">TestCase.assert*()</span></tt> メソッドを使って明確に書くことが推奨されています。 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> の将来のバージョンでは、 <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a>
は別の目的に使用される可能性が有ります。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><tt class="xref py py-class docutils literal"><span class="pre">FunctionTestCase</span></tt></a> を使って既存のテストを <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> ベースのテスト体系に変換することができますが、この方法は推奨されません。時間を掛けて <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスに書き直した方が将来的なテストのリファクタリングが限りなく易しくなります。</p>
</div>
<p>既存のテストが <a class="reference internal" href="doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a> を使って書かれている場合もあるでしょう。その場合、 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a> は <tt class="xref py py-class docutils literal"><span class="pre">DocTestSuite</span></tt> クラスを提供します。このクラスは、既存の <a class="reference internal" href="doctest.html#module-doctest" title="doctest: docstring の中のテストコード."><tt class="xref py py-mod docutils literal"><span class="pre">doctest</span></tt></a>ベースのテストから、自動的に <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">unittest.TestSuite</span></tt></a> のインスタンスを作成します。</p>
</div>
<div class="section" id="unittest-skipping">
<span id="id7"></span><h2>25.3.6. テストのスキップと意図的な失敗<a class="headerlink" href="#unittest-skipping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
<p>unittest は特定のテストメソッドやテストクラス全体をスキップする仕組みを備えています。さらに、この機能はテスト結果を「意図的な失敗」とすることができ、テストが失敗しても <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> の失敗数にはカウントされなくなります。</p>
<p>テストをスキップするには、 単に <a class="reference internal" href="#unittest.skip" title="unittest.skip"><tt class="xref py py-func docutils literal"><span class="pre">skip()</span></tt></a> デコレータ(<a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a>) を使用するか、条件を表現するための <a class="reference internal" href="#unittest.skip" title="unittest.skip"><tt class="xref py py-func docutils literal"><span class="pre">skip()</span></tt></a> に類するデコレータを使用します。</p>
<p>スキップは以下のようになります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest.skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest.skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;win&quot;</span><span class="p">),</span> <span class="s">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># windows specific testing code</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>このサンプルを詳細モードで実行すると以下のように出力されます。</p>
<div class="highlight-python"><pre>test_format (__main__.MyTestCase) ... skipped 'not supported in this library version'
test_nothing (__main__.MyTestCase) ... skipped 'demonstrating skipping'
test_windows_support (__main__.MyTestCase) ... skipped 'requires Windows'

----------------------------------------------------------------------
Ran 3 tests in 0.005s

OK (skipped=3)</pre>
</div>
<p>テストクラスは以下のようにメソッドをスキップすることができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@skip</span><span class="p">(</span><span class="s">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">TestCase.setUp()</span></tt></a> もスキップすることができます。この機能はセットアップの対象のリソースが使用不可能な状態の時に便利です。</p>
<p>意図的な失敗の機能を使用するには、 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><tt class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></tt></a> デコレータを使います。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest.expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>独自のスキップ用のデコレータも簡単に作成することができます。そのためには、独自のデコレータのスキップしたい時点で <a class="reference internal" href="#unittest.skip" title="unittest.skip"><tt class="xref py py-func docutils literal"><span class="pre">skip()</span></tt></a> を呼び出します。以下のデコレータはオブジェクトに指定した属性が無い場合にテストをスキップします。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s">&quot;{0!r} doesn&#39;t have {1!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>以下のデコレータはテストのスキップと意図的な失敗を実装しています。</p>
<dl class="function">
<dt id="unittest.skip">
<tt class="descclassname">unittest.</tt><tt class="descname">skip</tt><big>(</big><em>reason</em><big>)</big><a class="headerlink" href="#unittest.skip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デコレートしたテストを無条件でスキップします。
<em>reason</em> にはテストをスキップした理由を記載します。</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipIf">
<tt class="descclassname">unittest.</tt><tt class="descname">skipIf</tt><big>(</big><em>condition</em>, <em>reason</em><big>)</big><a class="headerlink" href="#unittest.skipIf" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>condition</em> が真の場合に、デコレートしたテストをスキップします。</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipUnless">
<tt class="descclassname">unittest.</tt><tt class="descname">skipUnless</tt><big>(</big><em>condition</em>, <em>reason</em><big>)</big><a class="headerlink" href="#unittest.skipUnless" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>condition</em> が偽の場合に、デコレートしたテストをスキップします。</p>
</dd></dl>

<dl class="function">
<dt id="unittest.expectedFailure">
<tt class="descclassname">unittest.</tt><tt class="descname">expectedFailure</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.expectedFailure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストの失敗が意図的であることを表します。該当のテストが失敗しても、そのテストは失敗にカウントされません。</p>
</dd></dl>

<p>スキップしたテストの前後では、 <tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt> および <tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt> は実行されません。同様に、スキップしたテストクラスの前後では、 <tt class="xref py py-meth docutils literal"><span class="pre">setUpClass()</span></tt> および</p>
<blockquote>
<div><tt class="xref py py-meth docutils literal"><span class="pre">tearDownClass()</span></tt> は実行されません。</div></blockquote>
</div>
<div class="section" id="unittest-contents">
<span id="id8"></span><h2>25.3.7. クラスと関数<a class="headerlink" href="#unittest-contents" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節では、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュールのAPIの詳細について説明します。</p>
<div class="section" id="testcase-objects">
<span id="id9"></span><h3>25.3.7.1. テストクラス<a class="headerlink" href="#testcase-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="unittest.TestCase">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestCase</tt><big>(</big><span class="optional">[</span><em>methodName</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#unittest.TestCase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスのインスタンスは、 <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> の世界におけるテストの最小実行単位を示します。このクラスをベースクラスとして使用し、必要なテストを具象サブクラスに実装します。
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスでは、テストランナーがテストを実行するためのインターフェースと、各種のチェックやテスト失敗をレポートするためのメソッドを実装しています。</p>
<p>それぞれの <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスのインスタンスはただ一つのテストメソッド、 <em>methodName</em> という名のメソッドを実行します。既に次のような例を扱ったことを憶えているでしょうか。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_default_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s">&#39;test_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>ここでは、それぞれが一つずつのテストを実行するような
<tt class="xref py py-class docutils literal"><span class="pre">WidgetTestCase</span></tt> の二つのインスタンスを作成しています。</p>
<p><em>methodName</em> のデフォルトは <tt class="xref py py-meth docutils literal"><span class="pre">runTest()</span></tt> です。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のインスタンスのメソッドは3種類のグループに分けられます。
1つ目のグループのメソッドはテストの実行で使用します。2つ目のグループのメソッドは条件の確認および失敗のレポートといったテストの実装で使用されます。3つ目のグループである問い合わせ用のメソッドはテスト自身の情報を収集するために使用します。</p>
<p>はじめのグループ（テスト実行）に含まれるメソッドは以下の通りです。</p>
<dl class="method">
<dt id="unittest.TestCase.setUp">
<tt class="descname">setUp</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.setUp" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストフィクスチャの準備のために呼び出されるメソッドです。テストメソッドの直前に呼び出されます。このメソッドを実行中に例外が発生した場合、テストの失敗ではなくエラーとされます。デフォルトの実装では何も行いません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDown">
<tt class="descname">tearDown</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.tearDown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストメソッドが実行され、結果が記録された直後に呼び出されるメソッドです。このメソッドはテストメソッドで例外が投げられても呼び出されます。そのため、サブクラスでこのメソッドを実装する場合は、内部状態を確認することが必要になるでしょう。メソッドを実行中に例外が発生した場合、テストの失敗ではなくエラーとみなされます。このメソッドは、テストの結果に関わらず
<a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> が成功した場合にのみ呼ばれます。デフォルトの実装では何も行いません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.setUpClass">
<tt class="descname">setUpClass</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.setUpClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス内に定義されたテストが実行される前に呼び出されるクラスメソッドです。
<tt class="docutils literal"><span class="pre">setUpClass</span></tt> はクラスを唯一の引数として取り、 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a> でデコレートされている必要があります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>詳しくは <a href="#id19"><span class="problematic" id="id20">`Class and Module Fixtures`_</span></a> を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDownClass">
<tt class="descname">tearDownClass</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス内に定義されたテストが実行された後に呼び出されるクラスメソッドです。
<tt class="docutils literal"><span class="pre">tearDownClass</span></tt> はクラスを唯一の引数として取り、 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a> でデコレートされている必要があります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>詳しくは <a href="#id21"><span class="problematic" id="id22">`Class and Module Fixtures`_</span></a> を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.run">
<tt class="descname">run</tt><big>(</big><em>result=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストを実行し、テスト結果を <em>result</em> に指定されたテスト結果オブジェクトに渡します。 <em>result</em> 省略されるか <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> か渡された場合、一時的な結果オブジェクトを（ <tt class="xref py py-meth docutils literal"><span class="pre">defaultTestCase()</span></tt> メソッドを呼んで）生成して使用しますが <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> の呼び出し元には渡されません。</p>
<p>このメソッドは、単に <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> インスタンスの呼び出した場合と同様に振る舞います。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.skipTest">
<tt class="descname">skipTest</tt><big>(</big><em>reason</em><big>)</big><a class="headerlink" href="#unittest.TestCase.skipTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のテストでテストクラスもしくは <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> をスキップする場合に呼ばれます。詳細については、 <a class="reference internal" href="#unittest-skipping"><em>テストのスキップと意図的な失敗</em></a> を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.debug">
<tt class="descname">debug</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.debug" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テスト結果を収集せずにテストを実行します。例外が呼び出し元に通知されます。また、テストをデバッガで実行することができます。</p>
</dd></dl>

<p id="assert-methods"><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスには、条件の確認と失敗のレポートのために以下のメソッドが定義されています。</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="34%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">メソッド</th>
<th class="head">確認事項</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><tt class="xref py py-meth docutils literal"><span class="pre">assertTrue(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><tt class="xref py py-meth docutils literal"><span class="pre">assertFalse(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><tt class="xref py py-meth docutils literal"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsNone(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsNotNone(x)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><tt class="xref py py-meth docutils literal"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><tt class="xref py py-meth docutils literal"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></tt></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<p>（ <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> と <a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaisesRegexp()</span></tt></a> を除く）すべてのアサートメソッドには <em>msg</em> 引数を指定することができ、テストの失敗時のエラーメッセージで使用されます。（ <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><tt class="xref py py-data docutils literal"><span class="pre">longMessage</span></tt></a> も参照してください。）</p>
<dl class="method">
<dt id="unittest.TestCase.assertEqual">
<tt class="descname">assertEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が等しいことをテストします。両者が比較出来ない場合は、テストが失敗します。</p>
<p>さらに、 <em>first</em> と <em>second</em> が厳密に同じ型であり、その型が、list, tuple, dict, set, frozenset もしくは unicode のいずれか、または <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><tt class="xref py py-meth docutils literal"><span class="pre">addTypeEqualityFunc()</span></tt></a> で比較関数が登録されている型の場合には、デフォルトのエラーメッセージを生成するために、その型特有の比較関数が呼ばれます。（ <a class="reference internal" href="#type-specific-methods"><em>list of type-specific methods</em></a> も参照してください。）</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>型特有の比較関数の自動呼び出しを追加。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotEqual">
<tt class="descname">assertNotEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が等しくないことをテストします。両者が比較出来ない場合は、テストが失敗します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertTrue">
<tt class="descname">assertTrue</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertTrue" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertFalse">
<tt class="descname">assertFalse</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertFalse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>expr</em> が真（偽）であることをテストします。</p>
<p>このメソッドは、 <tt class="docutils literal"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></tt> と等価であり、 <tt class="docutils literal"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></tt> と等価ではないことに注意が必要です（後者のためには、 <tt class="docutils literal"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></tt>
が用意されています）。また、専用のメソッドが使用できる場合には、そちらを使用してください（例えば <tt class="docutils literal"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></tt> の代わりに
<tt class="docutils literal"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></tt> を使用してください）。そうすることにより、テスト失敗時のエラーメッセージを詳細に表示することができます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIs">
<tt class="descname">assertIs</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIs" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertIsNot">
<tt class="descname">assertIsNot</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が同じオブジェクトであること（そうでないこと）をテストします。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsNone">
<tt class="descname">assertIsNone</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertIsNotNone">
<tt class="descname">assertIsNotNone</tt><big>(</big><em>expr</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>expr</em> が None であること（そうでないこと）をテストします。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIn">
<tt class="descname">assertIn</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIn" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertNotIn">
<tt class="descname">assertNotIn</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> が <em>second</em> に含まれること（そうでないこと）をテストします。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsInstance">
<tt class="descname">assertIsInstance</tt><big>(</big><em>obj</em>, <em>cls</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertNotIsInstance">
<tt class="descname">assertNotIsInstance</tt><big>(</big><em>obj</em>, <em>cls</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> が <em>cls</em> のインスタンスであること（そうでないこと）をテストします。（この <em>cls</em> は、 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a> が扱うことのできる、クラスもしくはクラスのタプルである必要があります。）</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<p>例外と例外発生時の警告を確認するために以下のメソッドを使用することができます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="36%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">メソッド</th>
<th class="head">確認事項</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></tt> raises <cite>exc</cite></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaisesRegexp(exc,</span> <span class="pre">re,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></tt> raises <cite>exc</cite>
and the message matches <cite>re</cite></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertRaises">
<tt class="descname">assertRaises</tt><big>(</big><em>exception</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertRaises" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">assertRaises</tt><big>(</big><em>exception</em><big>)</big></dt>
<dd><p><em>callable</em> を呼び出した時に例外が発生することをテストします。
<a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> で指定した位置パラメータとキーワードパラメータを該当メソッドに渡します。 <em>exception</em> が投げられた場合にテストが成功します。また、他の例外が投げられた場合はエラー、例外が投げられなかった場合は失敗になります。複数の例外をキャッチする場合には、例外クラスのタプルを <em>exception</em> に指定してください。</p>
<p><em>exception</em> 引数のみが渡された場合には、コンテキストマネージャが返されます。これにより関数名を渡す形式ではなく、インラインでテスト対象のコードを書くことができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>このコンテキストマネージャは <tt class="xref py py-attr docutils literal"><span class="pre">exception</span></tt> で指定されたオブジェクトを格納します。これにより、例外発生時の詳細な確認をおこなうことができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>コンテキストマネージャとして <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> を使用する機能を追加。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRaisesRegexp">
<tt class="descname">assertRaisesRegexp</tt><big>(</big><em>exception</em>, <em>regexp</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertRaisesRegexp" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">assertRaisesRegexp</tt><big>(</big><em>exception</em>, <em>regexp</em><big>)</big></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a> と同等ですが、例外の文字列表現が正規表現オブジェクトにマッチすることもテストします。 <em>regexp</em> は正規表現オブジェクトか、 <a class="reference internal" href="re.html#re.search" title="re.search"><tt class="xref py py-func docutils literal"><span class="pre">re.search()</span></tt></a> が扱える正規表現が書かれた文字列である必要があります。例えば以下のようになります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegexp</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;invalid literal for.*XYZ$&#39;</span><span class="p">,</span>
                        <span class="nb">int</span><span class="p">,</span> <span class="s">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>もしくは</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegexp</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<p>さらに特有の確認を行うために以下のメソッドが用意されています。</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="38%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">メソッド</th>
<th class="head">確認項目</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><tt class="xref py py-meth docutils literal"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><tt class="xref py py-meth docutils literal"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertRegexpMatches" title="unittest.TestCase.assertRegexpMatches"><tt class="xref py py-meth docutils literal"><span class="pre">assertRegexpMatches(s,</span> <span class="pre">re)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">regex.search(s)</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotRegexpMatches" title="unittest.TestCase.assertNotRegexpMatches"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotRegexpMatches(s,</span> <span class="pre">re)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">not</span> <span class="pre">regex.search(s)</span></tt></td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertItemsEqual" title="unittest.TestCase.assertItemsEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertItemsEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>sorted(a) == sorted(b) and
works with unhashable objs</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertDictContainsSubset" title="unittest.TestCase.assertDictContainsSubset"><tt class="xref py py-meth docutils literal"><span class="pre">assertDictContainsSubset(a,</span> <span class="pre">b)</span></tt></a></td>
<td>all the key/value pairs
in <cite>a</cite> exist in <cite>b</cite></td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertAlmostEqual">
<tt class="descname">assertAlmostEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertNotAlmostEqual">
<tt class="descname">assertNotAlmostEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> と <em>second</em> が近似的に等しい（等しくない）ことをテストします。この比較は、*places* （デフォルト7）で指定した小数位で丸めた差分をゼロと比べることでおこないます。これらのメソッドは、（ <a class="reference internal" href="functions.html#round" title="round"><tt class="xref py py-func docutils literal"><span class="pre">round()</span></tt></a> と同様に）</p>
<blockquote>
<div><em>小数位</em> を指定するのであって、*有効桁数* を指定するのではないことに注意してください。</div></blockquote>
<p><em>places</em> の代わりに <em>delta</em> が渡された場合には、
<em>first</em> と <em>second</em> の差分が <em>delta</em> より大きい（小さい）ことをテストします。</p>
<p><em>delta</em> と <em>places</em> の両方が指定された場合は <tt class="docutils literal"><span class="pre">TypeError</span></tt> が投げられます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual()</span></tt></a> は、オブジェクトが等しい場合には自動で
近似的に等しいとみなすようになりました。
<a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual()</span></tt></a> は、オブジェクトが等しい場合には自動的に
失敗するようになりました。
<em>delta</em> 引数が追加されました。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertGreater">
<tt class="descname">assertGreater</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertGreater" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertGreaterEqual">
<tt class="descname">assertGreaterEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertLess">
<tt class="descname">assertLess</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertLess" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertLessEqual">
<tt class="descname">assertLessEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>first</em> が <em>second</em> と比べて、メソッド名に対応して &gt;, &gt;=, &lt; もしくは &lt;=
であることをテストします。そうでない場合はテストが失敗します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRegexpMatches">
<tt class="descname">assertRegexpMatches</tt><big>(</big><em>text</em>, <em>regexp</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertRegexpMatches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>regexp</em> の検索が <em>text</em> とマッチすることをテストします。テスト失敗時には、エラーメッセージにパターンと <em>text</em> が表示されます（もしくは、パターンと意図しないかたちでマッチした <em>text</em> の一部が表示されます）。
<em>regexp</em> は正規表現オブジェクトか、 <a class="reference internal" href="re.html#re.search" title="re.search"><tt class="xref py py-func docutils literal"><span class="pre">re.search()</span></tt></a> が扱える正規表現が書かれた文字列である必要があります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotRegexpMatches">
<tt class="descname">assertNotRegexpMatches</tt><big>(</big><em>text</em>, <em>regexp</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertNotRegexpMatches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>regexp</em> の検索が <em>text</em> とマッチしないことをテストします。テスト失敗時には、エラーメッセージにマッチしたパターンと <em>text</em> が表示されます。
<em>regexp</em> は正規表現オブジェクトか、 <a class="reference internal" href="re.html#re.search" title="re.search"><tt class="xref py py-func docutils literal"><span class="pre">re.search()</span></tt></a> が扱える正規表現が書かれた文字列である必要があります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertItemsEqual">
<tt class="descname">assertItemsEqual</tt><big>(</big><em>actual</em>, <em>expected</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertItemsEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンス <em>expected</em> が <em>actual</em> と同じ要素を含んでいることをテストします。要素の順序はテスト結果に影響しません。要素が含まれていない場合には、シーケンスの差分がエラーメッセージとして表示されます。</p>
<p><em>actual</em> と <em>expected</em> の比較では、重複した要素は無視 <em>されません</em> 。両者に同じ数の要素が含まれていることを検証します。このメソッドは
<tt class="docutils literal"><span class="pre">assertEqual(sorted(expected),</span> <span class="pre">sorted(actual))</span></tt> と同等に振る舞うことに加えて、ハッシュ化できないオブジェクトのシーケンスでも動作します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictContainsSubset">
<tt class="descname">assertDictContainsSubset</tt><big>(</big><em>expected</em>, <em>actual</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertDictContainsSubset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書 <em>actual</em> のキー/バリューペアが <em>expected</em> のスーパーセットになっているかどうかをテストします。そうなっていない場合には、足りないキーとバリューの一覧がエラーメッセージに表示されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
<p class="deprecated">
<span class="versionmodified">バージョン 3.2 で撤廃.</span></p>
</dd></dl>

<p id="type-specific-methods"><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> メソッドは、同じ型のオブジェクトの等価性確認のために、型ごとに特有のメソッドにディスパッチします。これらのメソッドは、ほとんどの組み込み型用のメソッドは既に実装されています。さらに、 <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><tt class="xref py py-meth docutils literal"><span class="pre">addTypeEqualityFunc()</span></tt></a> を使う事で新たなメソッドを登録することができます。</p>
<dl class="method">
<dt id="unittest.TestCase.addTypeEqualityFunc">
<tt class="descname">addTypeEqualityFunc</tt><big>(</big><em>typeobj</em>, <em>function</em><big>)</big><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> で呼び出される型特有のメソッドを登録します。登録するメソッドは、 比較する2つのオブジェクトの型がが厳密に <em>typeobj</em> と同じ（サブクラスでもいけません）の場合に等価性を確認します。 <em>function</em>  は
<a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> と同様に、2つの位置固定引数と、3番目に msg=None のキーワード引数を取れる必要があります。このメソッドは、始めの2つに指定したパラメータ間の差分を検出した時に <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><tt class="xref py py-data docutils literal"><span class="pre">self.failureException(msg)</span></tt></a> の例外を投げる必要があります。この例外を投げる際は、出来る限り、エラーの内容が分かる有用な情報と差分の詳細をエラーメッセージに含めてください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> が自動的に呼び出す型特有のメソッドの概要を以下の表示に記載しています。これらのメソッドは通常は直接呼び出す必要がないことに注意が必要です。</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="35%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">メソッド</th>
<th class="head">比較の対象</th>
<th class="head">初出</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>strings</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>sequences</td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>lists</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>tuples</td>
<td>2.7</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>sets or frozensets</td>
<td>2.7</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></tt></a></td>
<td>dicts</td>
<td>2.7</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertMultiLineEqual">
<tt class="descname">assertMultiLineEqual</tt><big>(</big><em>first</em>, <em>second</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>複数行の文字列 <em>first</em> が文字列 <em>second</em> と等しいことをテストします。等しくない場合には、両者の差分がハイライトされてエラーメッセージに表示されます。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> が string を比較するときに自動的に使用します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSequenceEqual">
<tt class="descname">assertSequenceEqual</tt><big>(</big><em>seq1</em>, <em>seq2</em>, <em>msg=None</em>, <em>seq_type=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのシーケンスが等しいことをテストします。 <em>seq_type</em> が指定された場合、
<em>seq1</em> と <em>seq2</em> が <em>seq_type</em> のインスタンスで無い場合にはテストが失敗します。シーケンスどうしが異なる場合には、両者の差分がエラーメッセージに表示されます。</p>
<p>このメソッドは直接 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> からは呼ばれませんが、
<a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertListEqual()</span></tt></a> と <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertTupleEqual()</span></tt></a> の実装で使われています。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertListEqual">
<tt class="descname">assertListEqual</tt><big>(</big><em>list1</em>, <em>list2</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="この定義へのパーマリンク">¶</a></dt>
<dt id="unittest.TestCase.assertTupleEqual">
<tt class="descname">assertTupleEqual</tt><big>(</big><em>tuple1</em>, <em>tuple2</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのリストまたはタプルが等しいかどうかをテストします。等しくない場合には、両者の差分を表示します。2つのパラメータの型が異なる場合にはテストがエラーになります。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> が
list または tuple を比較するときに自動的に使用します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSetEqual">
<tt class="descname">assertSetEqual</tt><big>(</big><em>set1</em>, <em>set2</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのセットが等しいかどうかをテストします。等しくない場合には、両者の差分を表示します。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> が
set もしくは frozenset を比較するときに自動的に使用します。</p>
<p><em>set1</em> or <em>set2</em> のいずれかに <a class="reference internal" href="stdtypes.html#set.difference" title="set.difference"><tt class="xref py py-meth docutils literal"><span class="pre">set.difference()</span></tt></a> が無い場合にはテストは失敗します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictEqual">
<tt class="descname">assertDictEqual</tt><big>(</big><em>expected</em>, <em>actual</em>, <em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つの辞書が等しいかどうかをテストします。等しくない場合には、両者の差分を表示します。このメソッドは、デフォルトで、 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a> が
dict を比較するときに自動的に使用します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<p id="other-methods-and-attrs">最後に、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> の残りのメソッドと属性を紹介します。</p>
<dl class="method">
<dt id="unittest.TestCase.fail">
<tt class="descname">fail</tt><big>(</big><em>msg=None</em><big>)</big><a class="headerlink" href="#unittest.TestCase.fail" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>無条件にテストを失敗させます。エラーメッセージの表示に、 <em>msg</em> または <tt class="docutils literal"><span class="pre">None</span></tt> が使われます。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.failureException">
<tt class="descname">failureException</tt><a class="headerlink" href="#unittest.TestCase.failureException" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="test.html#module-test" title="test"><tt class="xref py py-meth docutils literal"><span class="pre">test()</span></tt></a> メソッドが送出する例外を指定するクラス属性です。例えばテストフレームワークで追加情報を付した特殊な例外が必要になる場合、この例外のサブクラスとして作成します。この属性の初期値は <a class="reference internal" href="exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a>
です。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.longMessage">
<tt class="descname">longMessage</tt><a class="headerlink" href="#unittest.TestCase.longMessage" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性に <tt class="docutils literal"><span class="pre">True</span></tt> が設定された場合、 <a class="reference internal" href="#assert-methods"><em>assert methods</em></a>
で指定したすべての明示的な失敗メッセージが、通常の失敗メッセージに追加されます。通常の失敗メッセージには、オブジェクトに関する有用な情報が含まれています。例えば、 assertEqual は異なるオブジェクトの repr を表示します。この属性を <tt class="docutils literal"><span class="pre">True</span></tt> にすることで、カスタマイズしたエラーメッセージを通常のメッセージに追加することができます。</p>
<p>この属性はデフォルトで <tt class="docutils literal"><span class="pre">False</span></tt> になっていて、カスタムメッセージが渡されても表示しないようになっています。</p>
<p>アサートメソッドを呼び出す前に、インスタンス属性として <tt class="docutils literal"><span class="pre">True</span></tt> または <tt class="docutils literal"><span class="pre">False</span></tt> を指定することで、この設定をオーバーライドすることができます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.maxDiff">
<tt class="descname">maxDiff</tt><a class="headerlink" href="#unittest.TestCase.maxDiff" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性は、アサーションメソッドが失敗をレポートする時に表示する差分の長さをコントロールします。デフォルトは 80*8 文字です。この属性が影響するメソッドは、
<a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertSequenceEqual()</span></tt></a> （およびこのメソッドに委譲するシーケンス比較メソッド）、
<a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertDictEqual()</span></tt></a> と <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertMultiLineEqual()</span></tt></a> です。</p>
<p><tt class="docutils literal"><span class="pre">maxDiff</span></tt> に <tt class="docutils literal"><span class="pre">None</span></tt> を指定すると差分表示の上限がなくなります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<p>テストフレームワークは、テスト情報を収集するために以下のメソッドを使用します。</p>
<dl class="method">
<dt id="unittest.TestCase.countTestCases">
<tt class="descname">countTestCases</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.countTestCases" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストオブジェクトに含まれるテストの数を返します。
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> インスタンスは常に <tt class="docutils literal"><span class="pre">1</span></tt> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.defaultTestResult">
<tt class="descname">defaultTestResult</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このテストケースクラスで使われるテスト結果クラスのインスタンスを (
もし <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> メソッドに他の結果インスタンスが提供されないならば
) 返します。</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> インスタンスに対しては、いつも
<a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> のインスタンスですので、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスでは必要に応じてこのメソッドをオーバライドしてください。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.id">
<tt class="descname">id</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.id" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストケースを特定する文字列を返します。通常、 <em>id</em> はモジュール名・クラス名を含む、テストメソッドのフルネームを指定します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.shortDescription">
<tt class="descname">shortDescription</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.shortDescription" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストの説明を一行分、または説明がない場合には <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> を返します。デフォルトでは、テストメソッドの docstring の先頭の一行、または <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.addCleanup">
<tt class="descname">addCleanup</tt><big>(</big><em>function</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#unittest.TestCase.addCleanup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> の後に呼び出される関数を追加します。この関数はリソースのクリーンアップのために使用します。追加された関数は、追加された順と逆の順番で呼び出されます（LIFO）。
<a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><tt class="xref py py-meth docutils literal"><span class="pre">addCleanup()</span></tt></a> に渡された引数とキーワード引数が追加された関数にも渡されます。</p>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> が失敗した場合、つまり <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> が呼ばれなかった場合でも、追加されたクリーンアップ関数は呼び出されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.doCleanups">
<tt class="descname">doCleanups</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestCase.doCleanups" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> の後、もしくは、
<a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> が例外を投げた場合は <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> の後に、無条件で呼ばれます。</p>
<p>このメソッドは、 <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><tt class="xref py py-meth docutils literal"><span class="pre">addCleanup()</span></tt></a> で追加された関数を呼び出す責務を担います。もし、クリーンアップ関数を <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> より前に呼び出す必要がある場合には、
<a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><tt class="xref py py-meth docutils literal"><span class="pre">doCleanups()</span></tt></a> を明示的に呼び出してください。</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><tt class="xref py py-meth docutils literal"><span class="pre">doCleanups()</span></tt></a> は、どこで呼び出されても、クリーンアップ関数をスタックから削除して実行します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.FunctionTestCase">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">FunctionTestCase</tt><big>(</big><em>testFunc</em>, <em>setUp=None</em>, <em>tearDown=None</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#unittest.FunctionTestCase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスでは <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> インターフェースの内、テストランナーがテストを実行するためのインターフェースだけを実装しており、テスト結果のチェックやレポートに関するメソッドは実装していません。既存のテストコードを <a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> によるテストフレームワークに組み込むために使用します。</p>
</dd></dl>

<div class="section" id="id10">
<h4>25.3.7.1.1. 廃止予定のエイリアス<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>歴史的な経緯で、 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のいくつかのエイリアスは廃止予定となりました。以下の表に、廃止予定のエイリアスをまとめます。</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">メソッド名</th>
<th class="head">廃止予定のエリアス</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertEqual()</span></tt></a></td>
<td>failUnlessEqual, assertEquals</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotEqual()</span></tt></a></td>
<td>failIfEqual</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><tt class="xref py py-meth docutils literal"><span class="pre">assertTrue()</span></tt></a></td>
<td>failUnless, assert_</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><tt class="xref py py-meth docutils literal"><span class="pre">assertFalse()</span></tt></a></td>
<td>failIf</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><tt class="xref py py-meth docutils literal"><span class="pre">assertRaises()</span></tt></a></td>
<td>failUnlessRaises</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertAlmostEqual()</span></tt></a></td>
<td>failUnlessAlmostEqual</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><tt class="xref py py-meth docutils literal"><span class="pre">assertNotAlmostEqual()</span></tt></a></td>
<td>failIfAlmostEqual</td>
</tr>
</tbody>
</table>
<p class="deprecated">
<span class="versionmodified">バージョン 2.7 で撤廃: </span>表の第2列のエイリアスを廃止予定</p>
</div></blockquote>
</div>
</div>
<div class="section" id="testsuite-objects">
<span id="id11"></span><h3>25.3.7.2. テストのグルーピング<a class="headerlink" href="#testsuite-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="unittest.TestSuite">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestSuite</tt><big>(</big><em>tests=()</em><big>)</big><a class="headerlink" href="#unittest.TestSuite" title="この定義へのパーマリンク">¶</a></dt>
<dd><blockquote>
<div><p>このクラスは、個々のテストケースやテストスイートの集約を示します。通常のテストケースと同じようにテストランナーで実行するためのインタフェースを備えています。 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> インスタンスを実行することはスイートの繰り返しを使って個々のテストを実行することと同じです。</p>
<p>引数 <em>tests</em> が指定された場合、それはテストケースに亘る繰り返し可能オブジェクトまたは内部でスイートを組み立てるための他のテストスイートでなければなりません。後からテストケースやスイートをコレクションに付け加えるためのメソッドも提供されています。</p>
<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> は <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> オブジェクトのように振る舞います。違いは、スイートにはテストを実装しない点にあります。代わりに、テストをまとめてグループ化して、同時に実行します。 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> のインスタンスにテスト追加するためのメソッドが用意されています。</p>
<dl class="method">
<dt id="unittest.TestSuite.addTest">
<tt class="descname">addTest</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestSuite.addTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> 又は <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> のインスタンスをスイートに追加します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.addTests">
<tt class="descname">addTests</tt><big>(</big><em>tests</em><big>)</big><a class="headerlink" href="#unittest.TestSuite.addTests" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテラブル <em>tests</em> に含まれる全ての <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> 又は
<a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> のインスタンスをスイートに追加します。</p>
<p>このメソッドは <em>test</em> 上のイテレーションをしながらそれぞれの要素に
<a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><tt class="xref py py-meth docutils literal"><span class="pre">addTest()</span></tt></a> を呼び出すのと等価です。</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> クラスは <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> と以下のメソッドを共有します。</p>
<dl class="method">
<dt id="unittest.TestSuite.run">
<tt class="descname">run</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#unittest.TestSuite.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スイート内のテストを実行し、結果を <em>result</em> で指定した結果オブジェクトに収集します。 <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><tt class="xref py py-meth docutils literal"><span class="pre">TestCase.run()</span></tt></a> と異なり、
<a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><tt class="xref py py-meth docutils literal"><span class="pre">TestSuite.run()</span></tt></a> では必ず結果オブジェクトを指定する必要があります。</p>
</dd></dl>

</div></blockquote>
<dl class="method">
<dt id="unittest.TestSuite.debug">
<tt class="descname">debug</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestSuite.debug" title="この定義へのパーマリンク">¶</a></dt>
<dd><blockquote>
<div>このスイートに関連づけられたテストを結果を収集せずに実行します。これによりテストで送出された例外は呼び出し元に伝わるようになり、デバッガの下でのテスト実行をサポートできるようになります。</div></blockquote>
<dl class="method">
<dt id="unittest.TestSuite.countTestCases">
<tt class="descname">countTestCases</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このテストオブジェクトによって表現されるテストの数を返します。これには個別のテストと下位のスイートも含まれます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestSuite.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> でグループ化されたテストはイテレータでアクセスできます。サブクラスは <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> をオーバーライドすることで、テストへのアクセスを定義します。1つのメソッド内でこのメソッドは何度も呼ばれる可能性があることに注意してください（例えば、テスト数のカウントと等価性の比較）。そのため、イテレーションを繰り返しても同じテストを返すように実装してください。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>以前のバージョンでは <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> はイテレータではなく、直接テストに
アクセスしていました。そのため、 <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> をオーバーラードしても
テストにアクセスできませんでした。</p>
</dd></dl>

<p>通常、 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> の <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> メソッドは
<tt class="xref py py-class docutils literal"><span class="pre">TestRunner</span></tt> が起動するため、ユーザが直接実行する必要はありません。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id12">
<h3>25.3.7.3. テストのロードと起動<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<blockquote>
<div><dl class="class">
<dt id="unittest.TestLoader">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestLoader</tt><a class="headerlink" href="#unittest.TestLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> クラスはクラスとモジュールからテストスイートを生成します。通常、このクラスのインスタンスを明示的に生成する必要はありません。
<a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> モジュールの <tt class="docutils literal"><span class="pre">unittest.defaultTestLoader</span></tt> を共用インスタンスとして使用することができます。しかし、このクラスのサブクラスやインスタンスで、属性をカスタマイズすることができます。</p>
<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> のオブジェクトには以下のメソッドがあります。</p>
<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromTestCase">
<tt class="descname">loadTestsFromTestCase</tt><big>(</big><em>testCaseClass</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> の派生クラス <tt class="xref py py-class docutils literal"><span class="pre">testCaseClass</span></tt> に含まれる全テストケースのスイートを返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromModule">
<tt class="descname">loadTestsFromModule</tt><big>(</big><em>module</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定したモジュールに含まれる全テストケースのスイートを返します。このメソッドは <em>module</em> 内の <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> 派生クラスを検索し、見つかったクラスのテストメソッドごとにクラスのインスタンスを作成します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスを基底クラスとしてクラス階層を構築すると
fixture や補助的な関数をうまく共用することができますが、基底クラスに直接インスタンス化できないテストメソッドがあると、この
<a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFromModule()</span></tt></a> を使うことができません。この場合でも、
fixture が全て別々で定義がサブクラスにある場合は使用することができます。</p>
</div>
<p>モジュールが <tt class="docutils literal"><span class="pre">load_tests</span></tt> 関数を用意している場合、この関数がテストのロードに使われます。これによりテストのロードをカスタマイズできます。これが <a href="#id23"><span class="problematic" id="id24">`load_tests protocol`_</span></a> です。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span><tt class="docutils literal"><span class="pre">load_tests</span></tt> をサポートしました。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromName">
<tt class="descname">loadTestsFromName</tt><big>(</big><em>name</em>, <em>module=None</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列で指定される全テストケースを含むスイートを返します。</p>
<p><em>name</em> には &#8220;ドット修飾名&#8221; でモジュールかテストケースクラス、テストケースクラス内のメソッド、 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> インスタンスまたは
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> か <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> のインスタンスを返す呼び出し可能オブジェクトを指定します。このチェックはここで挙げた順番に行なわれます。すなわち、候補テストケースクラス内のメソッドは「呼び出し可能オブジェクト」としてではなく「テストケースクラス内のメソッド」として拾い出されます。</p>
<p>例えば <tt class="xref py py-mod docutils literal"><span class="pre">SampleTests</span></tt> モジュールに <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> から派生した <tt class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></tt> クラスがあり、 <tt class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></tt>
にはテストメソッド <tt class="xref py py-meth docutils literal"><span class="pre">test_one()</span></tt> ・ <tt class="xref py py-meth docutils literal"><span class="pre">test_two()</span></tt> ・
<tt class="xref py py-meth docutils literal"><span class="pre">test_three()</span></tt> があるとします。この場合、 <em>name</em> に
<tt class="docutils literal"><span class="pre">'SampleTests.SampleTestCase'</span></tt> と指定すると、
<tt class="xref py py-class docutils literal"><span class="pre">SampleTestCase</span></tt> の三つのテストメソッドを実行するテストスイートが作成されます。 <tt class="docutils literal"><span class="pre">'SampleTests.SampleTestCase.test_two'</span></tt> と指定すれば、 <tt class="xref py py-meth docutils literal"><span class="pre">test_two()</span></tt> だけを実行するテストスイートが作成されます。インポートされていないモジュールやパッケージ名を含んだ名前を指定した場合は自動的にインポートされます。</p>
<p>また、 <em>module</em> を指定した場合、 <em>module</em> 内の <em>name</em> を取得します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromNames">
<tt class="descname">loadTestsFromNames</tt><big>(</big><em>names</em>, <em>module=None</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFromName()</span></tt></a> と同じですが、名前を一つだけ指定するのではなく、複数の名前のシーケンスを指定する事ができます。戻り値は
<em>names</em> 中の名前で指定されるテスト全てを含むテストスイートです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.getTestCaseNames">
<tt class="descname">getTestCaseNames</tt><big>(</big><em>testCaseClass</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>testCaseClass</em> 中の全てのメソッド名を含むソート済みシーケンスを返します。 <em>testCaseClass</em> は <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のサブクラスでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.discover">
<tt class="descname">discover</tt><big>(</big><em>start_dir</em>, <em>pattern='test*.py'</em>, <em>top_level_dir=None</em><big>)</big><a class="headerlink" href="#unittest.TestLoader.discover" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>すべてのテストモジュールを指定された開始ディレクトリから検索して返します。再帰的にサブディレクトリも検索します。 <em>pattern</em> にマッチしたテストファイルだけがロードの対象になります。（シェルスタイルのパターンマッチングが使われます。）その中で、インポート可能なもジュール（つまりPythonの識別子として有効であるということです）がロードされます。</p>
<p>すべてのテストモジュールはプロジェクトのトップレベルからインポート可能である必要があります。開始ディレクトリがトップレベルディレクトリでない場合は、トップレベルディレクトリが分離できなくてはいけません。</p>
<p>例えば、シンタックスエラーなどで、モジュールのインポートに失敗した場合、エラーが記録され、ディスカバリ自体は続けられます。</p>
<p>テストパッケージ名（ <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> の置かれたディレクトリ名） がパターンにマッチした場合、 <tt class="docutils literal"><span class="pre">load_tests</span></tt> 関数がチェックされます。この関数が存在している場合、この関数に <em>loader</em>, <em>tests</em>, <em>pattern</em> が渡され呼び出されます。</p>
<p>load_tests が存在して、ディスカバリがパッケージ内を再帰的な検索を続けている途中で <em>ない</em> 場合、 <tt class="docutils literal"><span class="pre">load_tests</span></tt> はそのパッケージ内の全てのテストをロードする責務を担います。</p>
<p>意図的にパターンはローダの属性として保持されないようになっています。それにより、パッケージが自分自身のディスカバリを続ける事ができます。
<em>top_level_dir</em> は保持されるため、 <tt class="docutils literal"><span class="pre">loader.discover()</span></tt> に引数として渡す必要はありません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<p>以下の属性は、サブクラス化またはインスタンスの属性値を変更して
<a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> をカスタマイズする場合に使用します。</p>
<dl class="attribute">
<dt id="unittest.TestLoader.testMethodPrefix">
<tt class="descname">testMethodPrefix</tt><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストメソッドの名前と判断されるメソッド名の接頭語を示す文字列。デフォルト値は <tt class="docutils literal"><span class="pre">'test'</span></tt> です。</p>
<p>この値は <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><tt class="xref py py-meth docutils literal"><span class="pre">getTestCaseNames()</span></tt></a> と全ての <tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></tt>
メソッドに影響を与えます。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.sortTestMethodsUsing">
<tt class="descname">sortTestMethodsUsing</tt><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><tt class="xref py py-meth docutils literal"><span class="pre">getTestCaseNames()</span></tt></a> および全ての <tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></tt> メソッドでメソッド名をソートする際に使用する比較関数。デフォルト値は組み込み関数 <a class="reference internal" href="functions.html#cmp" title="cmp"><tt class="xref py py-func docutils literal"><span class="pre">cmp()</span></tt></a> です。ソートを行なわないようにこの属性に
<a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> を指定することもできます。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.suiteClass">
<tt class="descname">suiteClass</tt><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストのリストからテストスイートを構築する呼び出し可能オブジェクト。メソッドを持つ必要はありません。デフォルト値は <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a>
です。</p>
<p>この値は全ての <tt class="xref py py-meth docutils literal"><span class="pre">loadTestsFrom*()</span></tt> メソッドに影響を与えます。</p>
</dd></dl>

</dd></dl>

</div></blockquote>
<dl class="class">
<dt id="unittest.TestResult">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TestResult</tt><a class="headerlink" href="#unittest.TestResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはどのテストが成功しどのテストが失敗したかという情報を収集するのに使います。</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> は、複数のテスト結果を記録します。
<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスと <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> クラスのテスト結果を正しく記録しますので、テスト開発者が独自にテスト結果を管理する処理を開発する必要はありません。</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: ユニットテストフレームワーク"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> を利用したテストフレームワークでは、
<tt class="xref py py-meth docutils literal"><span class="pre">TestRunner.run()</span></tt> が返す <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> インスタンスを参照し、テスト結果をレポートします。</p>
<p>以下の属性は、テストの実行結果を検査する際に使用することができます。</p>
<dl class="attribute">
<dt id="unittest.TestResult.errors">
<tt class="descname">errors</tt><a class="headerlink" href="#unittest.TestResult.errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> と例外のトレースバック情報をフォーマットした文字列の 2 要素タプルからなるリスト。それぞれのタプルは予想外の例外を送出したテストに対応します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2 で変更: </span><a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> の結果ではなく、フォーマットしたトレースバッ
クを保存します。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failures">
<tt class="descname">failures</tt><a class="headerlink" href="#unittest.TestResult.failures" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> と例外のトレースバック情報をフォーマットした文字列の
2 要素タプルからなるリスト。それぞれのタプルは
<tt class="xref py py-meth docutils literal"><span class="pre">TestCase.fail*()</span></tt> や <tt class="xref py py-meth docutils literal"><span class="pre">TestCase.assert*()</span></tt> メソッドを使って見つけ出した失敗に対応します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2 で変更: </span><a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> の結果ではなく、フォーマットしたトレースバック
を保存します。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.skipped">
<tt class="descname">skipped</tt><a class="headerlink" href="#unittest.TestResult.skipped" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> インスタンスと理由の文字列の2要素タプルからなるリストを保持します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.expectedFailures">
<tt class="descname">expectedFailures</tt><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> と例外のトレースバック情報をフォーマットした文字列の
2 要素タプルからなるリスト。それぞれのタプルは意図した失敗に対応します。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.unexpectedSuccesses">
<tt class="descname">unexpectedSuccesses</tt><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>意図した失敗のマークが付いていながら成功してしまった <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> のインスタンスのリスト。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.shouldStop">
<tt class="descname">shouldStop</tt><a class="headerlink" href="#unittest.TestResult.shouldStop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> が設定されると <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> によりテストの実行が停止します。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.testsRun">
<tt class="descname">testsRun</tt><a class="headerlink" href="#unittest.TestResult.testsRun" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これまでに実行したテストの総数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.buffer">
<tt class="descname">buffer</tt><a class="headerlink" href="#unittest.TestResult.buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> が設定されると、 <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> と <tt class="docutils literal"><span class="pre">sys.stderr</span></tt> は、
<a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><tt class="xref py py-meth docutils literal"><span class="pre">startTest()</span></tt></a> から <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><tt class="xref py py-meth docutils literal"><span class="pre">stopTest()</span></tt></a> が呼ばれるまでの間バッファリングされます。実際に、結果が <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> と <tt class="docutils literal"><span class="pre">sys.stderr</span></tt> に出力されるのは、テストが失敗するかエラーが発生した時になります。表示の際には、全ての失敗 / エラーメッセージが表示されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failfast">
<tt class="descname">failfast</tt><a class="headerlink" href="#unittest.TestResult.failfast" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> が設定されると、 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> が始めの失敗もしくはエラーの時に呼び出され、テストの実行が終了します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.wasSuccessful">
<tt class="descname">wasSuccessful</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これまでに実行したテストが全て成功していれば <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> を、それ以外なら <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TestResult.stop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドを呼び出して <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> の <tt class="docutils literal"><span class="pre">shouldStop</span></tt> 属性に <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> をセットすることで、実行中のテストは中断しなければならないというシグナルを送ることができます。 <tt class="xref py py-class docutils literal"><span class="pre">TestRunner</span></tt> オブジェクトはこのフラグを尊重してそれ以上のテストを実行することなく復帰しなければなりません。</p>
<p>たとえばこの機能は、ユーザのキーボード割り込みを受け取って
<a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><tt class="xref py py-class docutils literal"><span class="pre">TextTestRunner</span></tt></a> クラスがテストフレームワークを停止させるのに使えます。 <tt class="xref py py-class docutils literal"><span class="pre">TestRunner</span></tt> の実装を提供する対話的なツールでも同じように使用することができます。</p>
</dd></dl>

<p>以下のメソッドは内部データ管理用のメソッドですが、対話的にテスト結果をレポートするテストツールを開発する場合などにはサブクラスで拡張することができます。</p>
<dl class="method">
<dt id="unittest.TestResult.startTest">
<tt class="descname">startTest</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.startTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>test</em> を実行する直前に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTest">
<tt class="descname">stopTest</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.stopTest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>test</em> の実行直後に、テスト結果に関わらず呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.startTestRun">
<tt class="descname">startTestRun</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.startTestRun" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全てのテストが実行される前に一度だけ実行されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTestRun">
<tt class="descname">stopTestRun</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全てのテストが実行された後に一度だけ実行されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addError">
<tt class="descname">addError</tt><big>(</big><em>test</em>, <em>err</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テスト <em>test</em> 実行中に、想定外の例外が発生した場合に呼び出されます。
<em>err</em> は <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> が返すタプル <tt class="docutils literal"><span class="pre">(type,</span> <span class="pre">value,</span>
<span class="pre">traceback)</span></tt> です。</p>
<p>デフォルトの実装では、タプル、 <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></tt> をインスタンスの <tt class="docutils literal"><span class="pre">errors</span></tt> 属性に追加します。ここで、 <em>formatted_err</em> は、
<em>err</em> から導出される、整形されたトレースバックです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addFailure">
<tt class="descname">addFailure</tt><big>(</big><em>test</em>, <em>err</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addFailure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストが失敗した場合に呼び出されます。 <em>err</em> は
<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><tt class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></tt></a> が返すタプル <tt class="docutils literal"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></tt> です。</p>
<p>デフォルトの実装では、タプル、 <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></tt> をインスタンスの <tt class="docutils literal"><span class="pre">errors</span></tt> 属性に追加します。ここで、 <em>formatted_err</em> は、
<em>err</em> から導出される、整形されたトレースバックです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSuccess">
<tt class="descname">addSuccess</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addSuccess" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テストケース <em>test</em> が成功した場合に呼び出されます。</p>
<p>デフォルトの実装では何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSkip">
<tt class="descname">addSkip</tt><big>(</big><em>test</em>, <em>reason</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addSkip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>test</em> がスキップされた時に呼び出されます。
<em>reason</em> はスキップの際に渡された理由の文字列です。</p>
<p>デフォルトの実装では、 <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">reason)</span></tt> のタプルをインスタンスの <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><tt class="xref py py-attr docutils literal"><span class="pre">skipped</span></tt></a> 属性に追加します。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addExpectedFailure">
<tt class="descname">addExpectedFailure</tt><big>(</big><em>test</em>, <em>err</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><tt class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></tt></a> のデコレータでマークされた <em>test</em> が失敗した時に呼び出されます。</p>
<p>デフォルトの実装では <tt class="docutils literal"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></tt> のタプルをインスタンスの <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><tt class="xref py py-attr docutils literal"><span class="pre">expectedFailures</span></tt></a> に追加します。ここで <em>formatted_err</em> は <em>err</em> から派生した整形されたトレースバックです。</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addUnexpectedSuccess">
<tt class="descname">addUnexpectedSuccess</tt><big>(</big><em>test</em><big>)</big><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><tt class="xref py py-func docutils literal"><span class="pre">expectedFailure()</span></tt></a> のデコレータでマークされた <em>test</em> が成功した時に呼び出されます。</p>
<p>デフォルトの実装ではテストをインスタンスの <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><tt class="xref py py-attr docutils literal"><span class="pre">unexpectedSuccesses</span></tt></a> 属性に追加します。</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="unittest.defaultTestLoader">
<tt class="descclassname">unittest.</tt><tt class="descname">defaultTestLoader</tt><a class="headerlink" href="#unittest.defaultTestLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> のインスタンスで、共用することが目的です。
<a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> をカスタマイズする必要がなければ、新しい
<a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> オブジェクトを作らずにこのインスタンスを使用します。</p>
</dd></dl>

<dl class="class">
<dt id="unittest.TextTestRunner">
<em class="property">class </em><tt class="descclassname">unittest.</tt><tt class="descname">TextTestRunner</tt><big>(</big><em>stream=sys.stderr</em>, <em>descriptions=True</em>, <em>verbosity=1</em><big>)</big><a class="headerlink" href="#unittest.TextTestRunner" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行結果を標準エラーに出力する、単純なテストランナー。いくつかの設定項目がありますが、非常に単純です。グラフィカルなテスト実行アプリケーションでは、独自のテストランナーを作成してください。</p>
<dl class="method">
<dt id="unittest.TextTestRunner._makeResult">
<tt class="descname">_makeResult</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> で使われる <tt class="docutils literal"><span class="pre">TestResult</span></tt> のインスタンスを返します。このメソッドは明示的に呼び出す必要はありませんが、サブクラスで <tt class="docutils literal"><span class="pre">TestResult</span></tt> をカスタマイズすることができます。</p>
<p><tt class="docutils literal"><span class="pre">_makeResult()</span></tt> は、 <tt class="docutils literal"><span class="pre">TextTestRunner</span></tt> のコンストラクタで
<tt class="docutils literal"><span class="pre">resultclass</span></tt> 引数として渡されたクラスもしくはコーラブルオブジェクトをインスタンス化します。 <tt class="docutils literal"><span class="pre">resultclass</span></tt> が指定されていない場合には、デフォルトで <tt class="xref py py-class docutils literal"><span class="pre">TextTestResult</span></tt> が使用されます。結果のクラスは以下の引数が渡されインスタンス化されます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="unittest.main">
<tt class="descclassname">unittest.</tt><tt class="descname">main</tt><big>(</big><span class="optional">[</span><em>module</em><span class="optional">[</span>, <em>defaultTest</em><span class="optional">[</span>, <em>argv</em><span class="optional">[</span>, <em>testRunner</em><span class="optional">[</span>, <em>testLoader</em><span class="optional">[</span>, <em>exit</em><span class="optional">[</span>, <em>verbosity</em><span class="optional">[</span>, <em>failfast</em><span class="optional">[</span>, <em>catchbreak</em><span class="optional">[</span>, <em>buffer</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#unittest.main" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">unittest.</tt><tt class="descname">main</tt><big>(</big><span class="optional">[</span><em>module</em><span class="optional">[</span>, <em>defaultTest</em><span class="optional">[</span>, <em>argv</em><span class="optional">[</span>, <em>testRunner</em><span class="optional">[</span>, <em>testLoader</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd><p>テストを実行するためのコマンドラインプログラム。この関数を使えば、簡単に実行可能なテストモジュールを作成する事ができます。一番簡単なこの関数の使い方は、以下の行をテストスクリプトの最後に置くことです。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>You can run tests with more detailed information by passing in the verbosity
argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>引数、 <em>testRunner</em> は、test runner class、あるいは、そのインスタンスのどちらでも構いません。でフォルトでは <tt class="docutils literal"><span class="pre">main</span></tt> はテストが成功したか失敗したかに対応した終了コードと共に <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><tt class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></tt></a> を呼び出します。</p>
<p><tt class="docutils literal"><span class="pre">main</span></tt> は、 <tt class="docutils literal"><span class="pre">exit=False</span></tt> を指定する事で対話的なインタプリタから使用することもできます。この引数を指定すると、 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><tt class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></tt></a> を呼ばずに、結果のみを出力します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s">&#39;test_module&#39;</span><span class="p">,</span> <span class="nb">exit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">failfast</span></tt>, <tt class="docutils literal"><span class="pre">catchbreak</span></tt> と <tt class="docutils literal"><span class="pre">buffer</span></tt> は、 <a href="#id25"><span class="problematic" id="id26">`command-line options`_</span></a> にある同名のオプションと同じ効果のあるパラメータです。</p>
<p><tt class="docutils literal"><span class="pre">main</span></tt> を呼び出すと、 <tt class="docutils literal"><span class="pre">TestProgram</span></tt> のインスタンスが返されます。このインスタンスは、 <tt class="docutils literal"><span class="pre">result</span></tt> 属性にテスト結果を保持します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span><tt class="docutils literal"><span class="pre">exit</span></tt>, <tt class="docutils literal"><span class="pre">verbosity</span></tt>, <tt class="docutils literal"><span class="pre">failfast</span></tt>, <tt class="docutils literal"><span class="pre">catchbreak</span></tt> と <tt class="docutils literal"><span class="pre">buffer</span></tt>
パラメータが追加されました。</p>
</dd></dl>

<div class="section" id="load-tests">
<h4>25.3.7.3.1. load_tests プロトコル<a class="headerlink" href="#load-tests" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
<p>モジュールやパッケージには、 <tt class="docutils literal"><span class="pre">load_tests</span></tt> と呼ばれる関数を実装できます。これにより、通常のテスト実行時やテストディスカバリ時のテストのロードされ方をカスタマイズできます。</p>
<p>テストモジュールが <tt class="docutils literal"><span class="pre">load_tests</span></tt> を定義していると、それが <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><tt class="xref py py-meth docutils literal"><span class="pre">TestLoader.loadTestsFromModule()</span></tt></a> から呼ばれます。引数は以下です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> を返すべきです。</p>
<p><em>loader</em> はローディングを行う <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><tt class="xref py py-class docutils literal"><span class="pre">TestLoader</span></tt></a> のインスタンスです。
<em>standard_tests</em> は、そのモジュールからデフォルトでロードされるテストです。これは、テストの標準セットのテストの追加や削除のみを行いたいテストモジュールに一般に使われます。第三引数は、パッケージをテストディスカバリの一部としてロードするときに使われます。</p>
<p>特定の <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> クラスのセットからテストをロードする典型的な <tt class="docutils literal"><span class="pre">load_tests</span></tt> 関数は、このようになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>ディスカバリが開始されると、パッケージ名にマッチするパターンを、コマンドラインまたは:meth:<cite>TestLoader.discover</cite> に与えることで、
<tt class="file docutils literal"><span class="pre">__init__.py</span></tt> に <tt class="docutils literal"><span class="pre">load_tests</span></tt> があるか調べられます。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p>デフォルトのパターンは &#8216;test*.py&#8217; です。これは、 &#8216;test&#8217; で始まる全ての Python ファイルにマッチしますが、テストディレクトリには絶対にマッチ <em>しません</em> 。</p>
<p class="last">&#8216;test*&#8217; のようなパターンは、モジュールだけでなくテストパッケージにもマッチします。</p>
</div>
<p>パッケージ <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> が <tt class="docutils literal"><span class="pre">load_tests</span></tt> を定義していると、それが呼び出され、ディスカバリはそれ以上パッケージ内で続けられません。
<tt class="docutils literal"><span class="pre">load_tests</span></tt> が以下の引数で呼び出されます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>これはパッケージ内のすべてのテストを表す <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> を返すべきです。
(<tt class="docutils literal"><span class="pre">standard_tests</span></tt> には、 <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> から収集されたテストのみが含まれます。)</p>
<p>パターンは <tt class="docutils literal"><span class="pre">load_tests</span></tt> に渡されるので、パッケージは自由にテストディスカバリを継続 (必要なら変更) できます。テストパッケージに
&#8216;何もしない&#8217; <tt class="docutils literal"><span class="pre">load_tests</span></tt> 関数は次のようになります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>25.3.8. クラスとモジュールの修正<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>クラスレベルとモジュールレベルの修正が <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><tt class="xref py py-class docutils literal"><span class="pre">TestSuite</span></tt></a> に実装されました。テストスイートが新しいクラスのテストに出会うと、以前のクラス (があれば) から
<tt class="xref py py-meth docutils literal"><span class="pre">tearDownClass()</span></tt> が呼び出され、その後に新しいクラスから
<tt class="xref py py-meth docutils literal"><span class="pre">setUpClass()</span></tt> が呼び出されます。</p>
<p>同様に、テストが以前のテストとは異なるモジュールからのテストであるとき、まず以前のモジュールから <tt class="docutils literal"><span class="pre">tearDownModule</span></tt> が実行され、その後に新しいモジュールから <tt class="docutils literal"><span class="pre">setUpModule</span></tt> が実行されます。</p>
<p>すべてのテストが実行された後、最後の <tt class="docutils literal"><span class="pre">tearDownClass</span></tt> と <tt class="docutils literal"><span class="pre">tearDownModule</span></tt>
が実行されます。</p>
<p>なお、共通の修正は、テストの並列化などの [潜在的な] 機能と同時にはうまくいかず、テストの分離を中断します。気をつけて使うべきです。</p>
<p>unittest テストローダによるテスト作成のデフォルトの順序では、同じモジュールやクラスからのテストはすべて同じグループにまとめられます。これにより、 <tt class="docutils literal"><span class="pre">setUpClass</span></tt> / <tt class="docutils literal"><span class="pre">setUpModule</span></tt> (など) は、一つのクラスやモジュールにつき一度だけ呼ばれます。この順序をバラバラにし、異なるモジュールやクラスのテストが並ぶようにすると、共通の修正関数は、一度のテストで複数回呼ばれるようにもなります。</p>
<p>共通の修正は、普通でない順序に合わせることを意図していません。共通の修正を望まないフレームワークのために、 <tt class="docutils literal"><span class="pre">BaseTestSuite</span></tt> がまだ存在しています。</p>
<p>共通の修正関数のいずれかの中で送出された例外があれば、そのテストはエラーとして報告されます。対応するテストインスタンスが無いので、(<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> と同じインタフェースの) <tt class="docutils literal"><span class="pre">_ErrorHolder</span></tt> オブジェクトが生成され、エラーを表します。貴方が標準 unittest テストランナーであればこの詳細は問題になりませんが、貴方はそれが関係するフレームワーク作者かもしれません。</p>
<div class="section" id="setupclass-teardownclass">
<h3>25.3.8.1. setUpClass と tearDownClass<a class="headerlink" href="#setupclass-teardownclass" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらは、クラスメソッドとして実装されなければなりません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>基底クラスの <tt class="docutils literal"><span class="pre">setUpClass</span></tt> および <tt class="docutils literal"><span class="pre">tearDownClass</span></tt> を使いたいなら、それらを自分で呼び出さなければなりません。 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><tt class="xref py py-class docutils literal"><span class="pre">TestCase</span></tt></a> の実装は空です。</p>
<p><tt class="docutils literal"><span class="pre">setUpClass</span></tt> の中で例外が送出されたら、クラス内のテストは実行されず、
<tt class="docutils literal"><span class="pre">tearDownClass</span></tt> も実行されません。スキップされたクラスは <tt class="docutils literal"><span class="pre">setUpClass</span></tt> も
<tt class="docutils literal"><span class="pre">tearDownClass</span></tt> も実行されません。例外が <tt class="docutils literal"><span class="pre">SkipTest</span></tt> 例外であると、そのクラスはエラーとしてではなくスキップされたものとして報告されます。</p>
</div>
<div class="section" id="setupmodule-teardownmodule">
<h3>25.3.8.2. setUpModule と tearDownModule<a class="headerlink" href="#setupmodule-teardownmodule" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらは、関数として実装されなければなりません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">setUpModule</span></tt> の中で例外が送出されたら、モジュール内のテストは実行されず、
<tt class="docutils literal"><span class="pre">tearDownModule</span></tt> も実行されません。例外が <tt class="docutils literal"><span class="pre">SkipTest</span></tt> 例外であると、そのモジュールはエラーとしてではなくスキップされたものとして報告されます。</p>
</div>
</div>
<div class="section" id="id14">
<h2>25.3.9. シグナルハンドリング<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>unittest の <a class="reference internal" href="#cmdoption-unittest-c"><em class="xref std std-option">-c/--catch</em></a> コマンドラインオプションや、
<a class="reference internal" href="#unittest.main" title="unittest.main"><tt class="xref py py-func docutils literal"><span class="pre">unittest.main()</span></tt></a> の <tt class="docutils literal"><span class="pre">catchbreak</span></tt> パラメタは、テスト実行中の
control-C の処理をよりフレンドリーにします。中断捕捉動作を有効である場合、
control-C が押されると、現在実行されているテストまで完了され、そのテストランが終わると今までの結果が報告されます。control-C がもう一度押されると、通常通り <a class="reference internal" href="exceptions.html#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><tt class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></tt></a> が送出されます。</p>
<p>シグナルハンドラを処理する control-c は、独自の <tt class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></tt>
ハンドラをインストールするコードやテストの互換性を保とうとします。
<tt class="docutils literal"><span class="pre">unittest</span></tt> ハンドラが呼ばれ、それがインストールされた
<tt class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></tt> ハンドラで <em>なければ</em> 、すなわちテスト中のシステムに置き換えられて移譲されたなら、それはデフォルトのハンドラを呼び出します。インストールされたハンドラを置き換えて委譲するようなコードは、通常その動作を期待するからです。 <tt class="docutils literal"><span class="pre">unittest</span></tt> の control-c 処理を無効にしたいような個別のテストには、 <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><tt class="xref py py-func docutils literal"><span class="pre">removeHandler()</span></tt></a> デコレータが使えます。</p>
<p>フレームワークの作者がテストフレームワーク内で control-c 処理を有効にするための、いくつかのユーティリティ関数があります。</p>
<dl class="function">
<dt id="unittest.installHandler">
<tt class="descclassname">unittest.</tt><tt class="descname">installHandler</tt><big>(</big><big>)</big><a class="headerlink" href="#unittest.installHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>control-c ハンドラをインストールします。(主にユーザが control-c を押したことにより) <tt class="xref py py-const docutils literal"><span class="pre">signal.SIGINT</span></tt> が受け取られると、登録した結果すべてに <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> が呼び出されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="unittest.registerResult">
<tt class="descclassname">unittest.</tt><tt class="descname">registerResult</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#unittest.registerResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>control-c 処理のために <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> を登録します。結果を登録するとそれに対する弱参照が格納されるので、結果がガベージコレクトされるのを妨げません。</p>
<p>control-c 処理が有効でなければ、 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><tt class="xref py py-class docutils literal"><span class="pre">TestResult</span></tt></a> オブジェクトの登録には副作用がありません。ですからテストフレームワークは、処理が有効か無効かにかかわらず、作成する全ての結果を無条件に登録できます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="unittest.removeResult">
<tt class="descclassname">unittest.</tt><tt class="descname">removeResult</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#unittest.removeResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>登録された結果を削除します。一旦結果が削除されると、control-c が押された際にその結果オブジェクトに対して <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> が呼び出されなくなります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="unittest.removeHandler">
<tt class="descclassname">unittest.</tt><tt class="descname">removeHandler</tt><big>(</big><em>function=None</em><big>)</big><a class="headerlink" href="#unittest.removeHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数なしで呼び出されたとき、control-c ハンドラがインストールされていると、この関数はそれを取り除きます。この関数は、テストが実行されている間だけ一時的にハンドラを取り除くテストデコレータとしても使えます。</p>
<blockquote>
<div><p>&#64;unittest.removeHandler
def test_signal_handling(self):</p>
<blockquote>
<div>...</div></blockquote>
</div></blockquote>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="25.4. 2to3 - Python 2 から 3 への自動コード変換"
             >次へ</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="25.2. doctest — 対話的な実行例をテストする"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="development.html" >25. 開発ツール</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>