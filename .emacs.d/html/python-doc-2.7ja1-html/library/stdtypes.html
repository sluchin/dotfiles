

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. 組み込み型 &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python 標準ライブラリ" href="index.html" />
    <link rel="next" title="6. 組み込み例外" href="exceptions.html" />
    <link rel="prev" title="4. 組み込み定数" href="constants.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="6. 組み込み例外"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="constants.html" title="4. 組み込み定数"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python 標準ライブラリ</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. 組み込み型</a><ul>
<li><a class="reference internal" href="#truth">5.1. 真理値テスト</a></li>
<li><a class="reference internal" href="#and-or-not">5.2. ブール演算 &#8212; <tt class="docutils literal"><span class="pre">and</span></tt>, <tt class="docutils literal"><span class="pre">or</span></tt>, <tt class="docutils literal"><span class="pre">not</span></tt></a></li>
<li><a class="reference internal" href="#stdcomparisons">5.3. 比較</a></li>
<li><a class="reference internal" href="#int-float-long-complex">5.4. 数値型 <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">complex</span></tt></a><ul>
<li><a class="reference internal" href="#bitstring-ops">5.4.1. 整数型におけるビット列演算</a></li>
<li><a class="reference internal" href="#id7">5.4.2. 整数型に対する追加のメソッド</a></li>
<li><a class="reference internal" href="#id8">5.4.3. 浮動小数点数に対する追加のメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#typeiter">5.5. イテレータ型</a><ul>
<li><a class="reference internal" href="#generator-types">5.5.1. ジェネレータ型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#str-unicode-list-tuple-bytearray-buffer-xrange">5.6. シーケンス型 &#8212; <tt class="docutils literal"><span class="pre">str</span></tt>, <tt class="docutils literal"><span class="pre">unicode</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">bytearray</span></tt>, <tt class="docutils literal"><span class="pre">buffer</span></tt>, <tt class="docutils literal"><span class="pre">xrange</span></tt></a><ul>
<li><a class="reference internal" href="#string-methods">5.6.1. 文字列メソッド</a></li>
<li><a class="reference internal" href="#string-formatting">5.6.2. 文字列フォーマット操作</a></li>
<li><a class="reference internal" href="#xrange">5.6.3. XRange 型</a></li>
<li><a class="reference internal" href="#typesseq-mutable">5.6.4. 変更可能なシーケンス型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-set-frozenset">5.7. set（集合）型 &#8212; <tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt></a></li>
<li><a class="reference internal" href="#typesmapping">5.8. マップ型</a><ul>
<li><a class="reference internal" href="#dict-views">5.8.1. 辞書ビューオブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bltin-file-objects">5.9. ファイルオブジェクト</a></li>
<li><a class="reference internal" href="#typememoryview">5.10. メモリビュー型</a></li>
<li><a class="reference internal" href="#typecontextmanager">5.11. コンテキストマネージャ型</a></li>
<li><a class="reference internal" href="#typesother">5.12. 他の組み込み型</a><ul>
<li><a class="reference internal" href="#typesmodules">5.12.1. モジュール</a></li>
<li><a class="reference internal" href="#typesobjects">5.12.2. クラスおよびクラスインスタンス</a></li>
<li><a class="reference internal" href="#typesfunctions">5.12.3. 関数</a></li>
<li><a class="reference internal" href="#typesmethods">5.12.4. メソッド</a></li>
<li><a class="reference internal" href="#bltin-code-objects">5.12.5. コードオブジェクト</a></li>
<li><a class="reference internal" href="#bltin-type-objects">5.12.6. 型オブジェクト</a></li>
<li><a class="reference internal" href="#bltin-null-object">5.12.7. ヌルオブジェクト</a></li>
<li><a class="reference internal" href="#bltin-ellipsis-object">5.12.8. 省略表記オブジェクト</a></li>
<li><a class="reference internal" href="#id31">5.12.9. ブール値</a></li>
<li><a class="reference internal" href="#typesinternal">5.12.10. 内部オブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specialattrs">5.13. 特殊な属性</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="constants.html"
                        title="前の章へ">4. 組み込み定数</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="exceptions.html"
                        title="次の章へ">6. 組み込み例外</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/stdtypes.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bltin-types">
<span id="id1"></span><h1>5. 組み込み型<a class="headerlink" href="#bltin-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>以下のセクションでは、インタプリタに組み込まれている標準の型について記述します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">これまでの (リリース 2.2 までの) Python の歴史では、組み込み型はオブジェクト指向における継承を行う際に雛型にできないという点で、ユーザ定義型とは異なっていました。いまではこのような制限はなくなっています。</p>
</div>
<p id="index-0">主要な組み込み型は数値型、シーケンス型、マッピング型、ファイル、クラス、インスタンス型、および例外です。</p>
<p id="index-1">演算によっては、複数の型でサポートされているものがあります; 特に、ほぼ全てのオブジェクトについて、比較、真理値テスト、 (<a class="reference internal" href="repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a> 関数や、わずかに異なる <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> 関数による) 文字列への変換を行うことができます。オブジェクトが <a class="reference internal" href="functions.html#print" title="print"><tt class="xref py py-func docutils literal"><span class="pre">print()</span></tt></a> 関数によって書かれていると、後の方の文字列への変換が暗黙に行われます。</p>
<div class="section" id="truth">
<span id="id2"></span><h2>5.1. 真理値テスト<a class="headerlink" href="#truth" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-2">どのオブジェクトも <a class="reference internal" href="../reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> または <a class="reference internal" href="../reference/compound_stmts.html#while"><tt class="xref std std-keyword docutils literal"><span class="pre">while</span></tt></a> 条件文の中や、以下のブール演算における被演算子として真理値テストを行うことができます。以下の値は偽であると見なされます:</p>
<blockquote>
<div></div></blockquote>
<ul id="index-3">
<li><p class="first"><tt class="docutils literal"><span class="pre">None</span></tt></p>
</li>
<li id="index-4"><p class="first"><tt class="docutils literal"><span class="pre">False</span></tt></p>
</li>
<li><p class="first">数値型におけるゼロ。例えば <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">0L</span></tt>, <tt class="docutils literal"><span class="pre">0.0</span></tt>, <tt class="docutils literal"><span class="pre">0j</span></tt> 。</p>
</li>
<li><p class="first">空のシーケンス型。例えば <tt class="docutils literal"><span class="pre">''</span></tt>, <tt class="docutils literal"><span class="pre">()</span></tt>, <tt class="docutils literal"><span class="pre">[]</span></tt> 。</p>
</li>
<li><p class="first">空のマッピング型。例えば <tt class="docutils literal"><span class="pre">{}</span></tt> 。</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/datamodel.html#object.__nonzero__" title="object.__nonzero__"><tt class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></tt></a> または <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><tt class="xref py py-meth docutils literal"><span class="pre">__len__()</span></tt></a> メソッドが定義されているようなユーザ定義クラスのインスタンスで、それらのメソッドが整数値ゼロまたは <a class="reference internal" href="functions.html#bool" title="bool"><tt class="xref py py-class docutils literal"><span class="pre">bool</span></tt></a> 値の <tt class="docutils literal"><span class="pre">False</span></tt> を返すとき。
<a class="footnote-reference" href="#id34" id="id3">[1]</a></p>
</li>
</ul>
<p id="index-5">それ以外の値は全て真であると見なされます &#8212; 従って、ほとんどの型のオブジェクトは常に真です。</p>
<p id="index-6">ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に偽値として <tt class="docutils literal"><span class="pre">0</span></tt> または <tt class="docutils literal"><span class="pre">False</span></tt> を返し、真値として <tt class="docutils literal"><span class="pre">1</span></tt>  または
<tt class="docutils literal"><span class="pre">True</span></tt> を返します (重要な例外: ブール演算 <tt class="docutils literal"><span class="pre">or</span></tt> および <tt class="docutils literal"><span class="pre">and</span></tt> は常に被演算子の中の一つを返します)。</p>
</div>
<div class="section" id="and-or-not">
<span id="boolean"></span><h2>5.2. ブール演算 &#8212; <a class="reference internal" href="../reference/expressions.html#and"><tt class="xref std std-keyword docutils literal"><span class="pre">and</span></tt></a>, <a class="reference internal" href="../reference/expressions.html#or"><tt class="xref std std-keyword docutils literal"><span class="pre">or</span></tt></a>, <a class="reference internal" href="../reference/expressions.html#not"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span></tt></a><a class="headerlink" href="#and-or-not" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-7">以下にブール演算子を示します。優先度の低いものから順に並んでいます。:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="68%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></tt></td>
<td><em>x</em> が偽なら <em>y</em>, そうでなければ <em>x</em></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></tt></td>
<td><em>x</em> が偽なら <em>x</em>, そうでなければ <em>y</em></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></tt></td>
<td><em>x</em> が偽なら <tt class="docutils literal"><span class="pre">True</span></tt>, そうでなければ
<tt class="docutils literal"><span class="pre">False</span></tt></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p id="index-8">注釈:</p>
<ol class="arabic simple">
<li>これは、短絡的な演算子であり、一つめの引数が <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> のときにのみ、二つめの引数を評価します。</li>
<li>これは、短絡的な演算子であり、一つめの引数が <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> のときにのみ、二つめの引数を評価します。</li>
<li><tt class="docutils literal"><span class="pre">not</span></tt> は非ブール演算子よりも低い演算優先度なので、 <tt class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt>
は <tt class="docutils literal"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></tt> と評価され、 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></tt> は構文エラーとなります。</li>
</ol>
</div>
<div class="section" id="stdcomparisons">
<span id="id4"></span><h2>5.3. 比較<a class="headerlink" href="#stdcomparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-9">比較演算は全てのオブジェクトでサポートされています。比較演算子は全て同じ演算優先度を持っています (ブール演算より高い演算優先度です)。比較は任意の形で連鎖させることができます; 例えば、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></tt> は
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></tt> と等価で、違うのは <em>y</em> が一度だけしか評価されないということです (どちらの場合でも、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt> が偽となった場合には
<em>z</em> は評価されません)。</p>
<p>以下のテーブルに比較演算をまとめます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&lt;</span></tt></td>
<td>より小さい</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&lt;=</span></tt></td>
<td>以下</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&gt;</span></tt></td>
<td>より大きい</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&gt;=</span></tt></td>
<td>以上</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">==</span></tt></td>
<td>等しい</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">!=</span></tt></td>
<td>等しくない</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">is</span></tt></td>
<td>同一のオブジェクトである</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></tt></td>
<td>同一のオブジェクトでない</td>
</tr>
</tbody>
</table>
<p id="index-10">数値型間の比較か文字列間の比較でないかぎり、異なる型のオブジェクトを比較しても等価になることはありません; これらのオブジェクトの順番付けは一貫してはいますが任意のものです (従って要素の型が一様でないシーケンスをソートした結果は一貫したものになります)。さらに、 (例えばファイルオブジェクトのように) 型によっては、その型の
2 つのオブジェクトの不等性だけの、縮退した比較の概念しかサポートしないものもあります。繰り返しますが、そのようなオブジェクトも任意の順番付けをされていますが、それは一貫したものです。被演算子が複素数の場合、演算子 <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt> および <tt class="docutils literal"><span class="pre">&gt;=</span></tt> は例外 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> を送出します。</p>
<p id="index-11">あるクラスのインスタンス間の比較は、そのクラスで <a class="reference internal" href="../reference/datamodel.html#object.__cmp__" title="object.__cmp__"><tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt></a> メソッドが定義されていない限り等しくなりません。このメソッドを使ってオブジェクトの比較方法に影響を及ぼすための情報については <a class="reference internal" href="../reference/datamodel.html#customization"><em>基本的なカスタマイズ</em></a> を参照してください。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 数値型を除き、異なる型のオブジェクトは型の名前で順番付けされます; 適当な比較をサポートしていないある型のオブジェクトはアドレスによって順番付けされます。</p>
</div>
<p id="index-12">同じ優先度を持つ演算子としてさらに 2 つ、シーケンス型でのみ <tt class="docutils literal"><span class="pre">in</span></tt> および <tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> がサポートされています (以下を参照)。</p>
</div>
<div class="section" id="int-float-long-complex">
<span id="typesnumeric"></span><h2>5.4. 数値型 <a class="reference internal" href="functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>, <a class="reference internal" href="functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a>, <a class="reference internal" href="functions.html#long" title="long"><tt class="xref py py-class docutils literal"><span class="pre">long</span></tt></a>, <a class="reference internal" href="functions.html#complex" title="complex"><tt class="xref py py-class docutils literal"><span class="pre">complex</span></tt></a><a class="headerlink" href="#int-float-long-complex" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-13">4 つの異なる数値型があります: <em class="dfn">通常の整数型</em>, <em class="dfn">長整数型</em>,
<em class="dfn">浮動小数点型</em>, <em class="dfn">複素数型</em> です。さらに、真偽値(Boolean)型も通常の整数型のサブタイプです。通常の整数 (単に
<em class="dfn">整数型</em> とも呼ばれます) は C言語の <tt class="xref c c-type docutils literal"><span class="pre">long</span></tt> 型を使って実装されており、少なくとも 32 ビットの精度があります (<tt class="docutils literal"><span class="pre">sys.maxint</span></tt> は常に通常の整数の各プラットフォームにおける最大値にセットされており、最小値は
<tt class="docutils literal"><span class="pre">-sys.maxint</span> <span class="pre">-</span> <span class="pre">1</span></tt> になります)。長整数型には精度の制限がありません。浮動小数点型はたいていは C の <tt class="xref c c-type docutils literal"><span class="pre">double</span></tt> を使って実装されています;
あなたのプログラムが動作するマシンでの浮動小数点型の精度と内部表現は、
<a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><tt class="xref py py-data docutils literal"><span class="pre">sys.float_info</span></tt></a> から利用できます。複素数型は実部と虚部を持ち、それぞれ浮動小数点数です。複素数 <em>z</em> から実部および虚部を取り出すには、
<tt class="docutils literal"><span class="pre">z.real</span></tt> および <tt class="docutils literal"><span class="pre">z.imag</span></tt> を使ってください。
(標準ライブラリには、追加の数値型、分数を保持する <a class="reference internal" href="fractions.html#module-fractions" title="fractions: 有理数"><tt class="xref py py-mod docutils literal"><span class="pre">fractions</span></tt></a> や、ユーザ定義の精度の浮動小数点数を保持する <a class="reference internal" href="decimal.html#module-decimal" title="decimal: 汎用10進数演算仕様 (General Decimal Arithmetic Specification) の実装。"><tt class="xref py py-mod docutils literal"><span class="pre">decimal</span></tt></a> があります。)</p>
<p id="index-14">数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。修飾のない整数リテラル ( 2 進表現や、 16 進表現や 8 進表現の値も含みます) は、通常の整数値を表します。値が通常の整数で表すには大きすぎる場合、
<tt class="docutils literal"><span class="pre">'L'</span></tt> または <tt class="docutils literal"><span class="pre">'l'</span></tt> が末尾につく整数リテラルは長整数型を表します
(<tt class="docutils literal"><span class="pre">'L'</span></tt> が望ましいです。というのは <tt class="docutils literal"><span class="pre">1l</span></tt> は 11 と非常に紛らわしいからです!) 小数点または指数表記のある数値リテラルは浮動小数点数を表します。数値リテラルに <tt class="docutils literal"><span class="pre">'j'</span></tt> または <tt class="docutils literal"><span class="pre">'J'</span></tt> をつけると実数部がゼロの複素数を表します。複素数の数値リテラルは実数部と虚数部を足したものです。</p>
<p id="index-15">Python は型混合の演算を完全にサポートします: ある 2 項演算子が互いに異なる数値型の被演算子を持つ場合、より &#8220;制限された&#8221; 型の被演算子は他方の型に合わせて広げられます。ここで通常の整数は長整数より制限されており、長整数は浮動小数点数より制限されており、浮動小数点は複素数より制限されています。型混合の数値間での比較も同じ規則に従います。 <a class="footnote-reference" href="#id35" id="id5">[2]</a> コンストラクタ <a class="reference internal" href="functions.html#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a>, <a class="reference internal" href="functions.html#long" title="long"><tt class="xref py py-func docutils literal"><span class="pre">long()</span></tt></a>, <a class="reference internal" href="functions.html#float" title="float"><tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt></a>, および
<a class="reference internal" href="functions.html#complex" title="complex"><tt class="xref py py-func docutils literal"><span class="pre">complex()</span></tt></a> を使って、特定の型の数を生成することができます。</p>
<p>全ての組み込み数値型は以下の演算をサポートします。演算子の優先度については、 <a class="reference internal" href="../reference/expressions.html#power"><em>べき乗演算 (power operator)</em></a>,および、あとのセクションを参照下さい。</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="61%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt></td>
<td><em>x</em> と <em>y</em> の和</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></tt></td>
<td><em>x</em> と <em>y</em> の差</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></tt></td>
<td><em>x</em> と <em>y</em> の積</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></tt></td>
<td><em>x</em> と <em>y</em> の商</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></tt></td>
<td><em>x</em> と <em>y</em> の商(を切り下げたもの)</td>
<td>(4)(5)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></tt> の剰余</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">-x</span></tt></td>
<td><em>x</em> の符号反転</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">+x</span></tt></td>
<td><em>x</em> の符号不変</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">abs(x)</span></tt></td>
<td><em>x</em> の絶対値または大きさ</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">int(x)</span></tt></td>
<td><em>x</em> の通常整数への変換</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">long(x)</span></tt></td>
<td><em>x</em> の長整数への変換</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">float(x)</span></tt></td>
<td><em>x</em> の浮動小数点数への変換</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">complex(re,im)</span></tt></td>
<td>実数部 <em>re</em>, 虚数部 <em>im</em> の複素数。 <em>im</em>
のデフォルト値はゼロ。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">c.conjugate()</span></tt></td>
<td>複素数 <em>c</em> の共役複素数(実数部に依存する)</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></tt> からなるペア</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></tt></td>
<td><em>x</em> の <em>y</em> 乗</td>
<td>(3)(7)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></tt></td>
<td><em>x</em> の <em>y</em> 乗</td>
<td>(7)</td>
</tr>
</tbody>
</table>
<p id="index-16">注釈:</p>
<ol class="arabic">
<li><p id="index-17">(通常および長) 整数の割り算では、結果は整数になります。この場合値は常にマイナス無限大の方向に丸められます: つまり、1/2 は 0、 (-1)/2
は -1、1/(-1) は -1、そして (-1)/(-2) は 0 になります。被演算子の両方が長整数の場合、計算値に関わらず結果は長整数で返されるので注意してください。</p>
</li>
<li><p id="index-18">浮動小数点数から <a class="reference internal" href="functions.html#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a>,または、 <a class="reference internal" href="functions.html#long" title="long"><tt class="xref py py-func docutils literal"><span class="pre">long()</span></tt></a> を使った変換では、関連する関数、 <a class="reference internal" href="math.html#math.trunc" title="math.trunc"><tt class="xref py py-func docutils literal"><span class="pre">math.trunc()</span></tt></a> のようにゼロ方向へ丸められます。下方向への丸めには <a class="reference internal" href="math.html#math.floor" title="math.floor"><tt class="xref py py-func docutils literal"><span class="pre">math.floor()</span></tt></a> を使い、上方向への丸めには <a class="reference internal" href="math.html#math.ceil" title="math.ceil"><tt class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></tt></a> を使って下さい。</p>
</li>
<li><p class="first">完全な記述については、 <a class="reference internal" href="functions.html#built-in-funcs"><em>組み込み関数</em></a>,を参照してください。</p>
</li>
<li><p class="first">複素数の切り詰め除算演算子、モジュロ演算子、および <a class="reference internal" href="functions.html#divmod" title="divmod"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a> 。</p>
<p class="deprecated">
<span class="versionmodified">バージョン 2.3 で撤廃: </span>複素数の切り詰め除算演算子、モジュロ演算子、および <a class="reference internal" href="functions.html#divmod" title="divmod"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a>
関数は、複素数には定義されなくなりました。
複素数型には使えません。適切なら代わりに <a class="reference internal" href="functions.html#abs" title="abs"><tt class="xref py py-func docutils literal"><span class="pre">abs()</span></tt></a> で浮動小数点型に
変換してください。</p>
</li>
<li><p class="first">整数の除算とも呼ばれます。結果の値は整数ですが、整数型(int)とは限りません。</p>
</li>
<li><p class="first">浮動小数点数は、文字列、オプションの接頭辞 &#8220;+&#8221; または &#8220;-&#8221; と共に
&#8220;nan&#8221; と &#8220;inf&#8221; を、非数 (Not a Number (NaN)) や正、負の無限大として受け付けます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</li>
<li><p class="first">Python はプログラム言語一般でそうであるように、 <tt class="docutils literal"><span class="pre">pow(0,</span> <span class="pre">0)</span></tt>,および、 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></tt> を <tt class="docutils literal"><span class="pre">1</span></tt> と定義します。</p>
</li>
</ol>
<p>全ての <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><tt class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></tt></a> 型 (<a class="reference internal" href="functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>, <a class="reference internal" href="functions.html#long" title="long"><tt class="xref py py-class docutils literal"><span class="pre">long</span></tt></a>,および、 <a class="reference internal" href="functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a>) は以下の演算を含みます。 :</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="63%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">備考</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">math.trunc(x)</span></tt></td>
<td><em>x</em> を整数に切り捨てます。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">round(x[,</span> <span class="pre">n])</span></tt></td>
<td><em>x</em> を n 桁に丸めます。丸め方は偶数丸めです。
n が省略されれば 0 がデフォルトとなります。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">math.floor(x)</span></tt></td>
<td><em>x</em> 以下の最大の整数を浮動少数点数で返します。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">math.ceil(x)</span></tt></td>
<td><em>x</em> 以上の最小の整数を浮動小数点数で返します。</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<div class="section" id="bitstring-ops">
<span id="id6"></span><h3>5.4.1. 整数型におけるビット列演算<a class="headerlink" href="#bitstring-ops" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-19">通常および長整数型ではさらに、ビット列に対してのみ意味のある演算をサポートしています。負の数はその値の 2 の補数の値として扱われます (長整数の場合、演算操作中にオーバフローが起こらないように十分なビット数があるものと仮定します) 。</p>
<p>2 進のビット単位演算は全て、数値演算よりも低く、比較演算子よりも高い優先度です; 単項演算 <tt class="docutils literal"><span class="pre">~</span></tt> は他の単項数値演算 (<tt class="docutils literal"><span class="pre">+</span></tt> および <tt class="docutils literal"><span class="pre">-</span></tt>) と同じ優先度です。</p>
<p>以下のテーブルでは、ビット列演算を優先度の低いものから順に並べています。 :</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="66%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></tt></td>
<td>ビット単位の <em>x</em> と <em>y</em> の <em class="dfn">論理和</em></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></tt></td>
<td>ビット単位の <em>x</em> と <em>y</em> の
<em class="dfn">排他的論理和</em></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></tt></td>
<td>ビット単位の <em>x</em> と <em>y</em> の <em class="dfn">論理積</em></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></tt></td>
<td><em>x</em> の <em>n</em> ビット左シフト</td>
<td>(1)(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></tt></td>
<td><em>x</em> の <em>n</em> ビット右シフト</td>
<td>(1)(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">~x</span></tt></td>
<td><em>x</em> のビット反転</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic simple">
<li>負値のシフト数は不正であり、 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。</li>
<li><em>n</em> ビットの左シフトは、 <tt class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></tt> による乗算と等価です。結果が通常の整数の範囲を越えるときには、長整数が返されます。</li>
<li><em>n</em> ビットの右シフトは、 <tt class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></tt> による除算と等価です。</li>
</ol>
</div>
<div class="section" id="id7">
<h3>5.4.2. 整数型に対する追加のメソッド<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数型は <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><tt class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></tt></a>  <a class="reference internal" href="../glossary.html#term-abstract-base-class"><em class="xref std std-term">abstract base class</em></a> を実装します。さらに、追加のメソッドを一つ提供します。</p>
<dl class="method">
<dt id="int.bit_length">
<tt class="descclassname">int.</tt><tt class="descname">bit_length</tt><big>(</big><big>)</big><a class="headerlink" href="#int.bit_length" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="long.bit_length">
<tt class="descclassname">long.</tt><tt class="descname">bit_length</tt><big>(</big><big>)</big><a class="headerlink" href="#long.bit_length" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を、符号と先頭の 0 は除いて二進法で表すために必要なビットの数を返します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>正確には、 <tt class="docutils literal"><span class="pre">x</span></tt> が非 0 なら、 <tt class="docutils literal"><span class="pre">x.bit_length()</span></tt> は
<tt class="docutils literal"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></tt> を満たす唯一の正の整数 <tt class="docutils literal"><span class="pre">k</span></tt> です。同様に、 <tt class="docutils literal"><span class="pre">abs(x)</span></tt> が十分小さくて対数を適切に丸められるとき、
<tt class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></tt> です。
<tt class="docutils literal"><span class="pre">x</span></tt> が 0 なら、 <tt class="docutils literal"><span class="pre">x.bit_length()</span></tt> は <tt class="docutils literal"><span class="pre">0</span></tt> を返します。</p>
<p>以下と等価です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s">&#39;-0b&#39;</span><span class="p">)</span> <span class="c"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

</div>
<div class="section" id="id8">
<h3>5.4.3. 浮動小数点数に対する追加のメソッド<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>浮動小数点数型は、 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><tt class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></tt></a> 抽象基底クラス
(<a class="reference internal" href="../glossary.html#term-abstract-base-class"><em class="xref std std-term">abstract base class</em></a>)
を実装しています。浮動小数点型はまた、以下の追加のメソッドを持ちます。</p>
<dl class="method">
<dt id="float.as_integer_ratio">
<tt class="descclassname">float.</tt><tt class="descname">as_integer_ratio</tt><big>(</big><big>)</big><a class="headerlink" href="#float.as_integer_ratio" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>比が元の浮動小数点数とちょうど同じで分母が正である、一対の整数を返します。無限大に対しては、 <a class="reference internal" href="exceptions.html#exceptions.OverflowError" title="exceptions.OverflowError"><tt class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></tt></a> を、非数 (NaN) に対しては <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を送出します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="float.is_integer">
<tt class="descclassname">float.</tt><tt class="descname">is_integer</tt><big>(</big><big>)</big><a class="headerlink" href="#float.is_integer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数インスタンスが有限の整数値なら <tt class="docutils literal"><span class="pre">True</span></tt> を、そうでなければ <tt class="docutils literal"><span class="pre">False</span></tt> を返します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<p>16 進表記の文字列へ、または、 16 進表記からの変換をサポートするメソッドは二つあります。 Python の浮動小数点数は内部的には2進数で保持され、若干の丸め誤差を持って <em>10進数</em> へ、または、 <em>10進数</em> から変換されます。それに対し、 16 進表記では浮動小数点数を、正確に表現することができます。これはデバッグのときや、数学的な用途に便利でしょう。</p>
<dl class="method">
<dt id="float.hex">
<tt class="descclassname">float.</tt><tt class="descname">hex</tt><big>(</big><big>)</big><a class="headerlink" href="#float.hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数の 16 進文字列表現を返します。有限の浮動小数点数に対し、この表現は常に <tt class="docutils literal"><span class="pre">0x</span></tt> で始まり <tt class="docutils literal"><span class="pre">p</span></tt> と指数が続きます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="float.fromhex">
<tt class="descclassname">float.</tt><tt class="descname">fromhex</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#float.fromhex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>16 進文字列表現 <em>s</em> で表される、浮動小数点数を返すクラスメソッドです。文字列 <em>s</em> は、前や後にホワイトスペースを含んでいても構いません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<p><a class="reference internal" href="#float.fromhex" title="float.fromhex"><tt class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></tt></a> はクラスメソッドですが、 <a class="reference internal" href="#float.hex" title="float.hex"><tt class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></tt></a> はインスタンスメソッドであることに注意して下さい。</p>
<p>16 進文字列表現は以下の書式となります:</p>
<div class="highlight-python"><pre>[符号] ['0x'] 整数部 ['.' 小数部] ['p' 指数部]</pre>
</div>
<p><tt class="docutils literal"><span class="pre">符号</span></tt> はオプションで、 <tt class="docutils literal"><span class="pre">+</span></tt> と <tt class="docutils literal"><span class="pre">-</span></tt> のどちらでも構いません。
<tt class="docutils literal"><span class="pre">整数部</span></tt> と <tt class="docutils literal"><span class="pre">小数部</span></tt> は 16 進数の文字列で、 <tt class="docutils literal"><span class="pre">指数部</span></tt> はオプションで符号がつけられる 10 進数です。大文字・小文字は区別されず、最低でも 1 つの 16 進数文字を整数部もしくは小数部に含む必要があります。この制限は C99 規格のセクション 6.4.4.2 で規定されます。また、 Java 1.5
以降で使われます。特に、 <a class="reference internal" href="#float.hex" title="float.hex"><tt class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></tt></a> は C や Java コード中で、浮動小数点数の 16 進表記として役に立つでしょう。また、 C の <tt class="docutils literal"><span class="pre">%a</span></tt> 書式や、 Java の <tt class="docutils literal"><span class="pre">Double.toHexString</span></tt> で書きだされた文字列は
<a class="reference internal" href="#float.fromhex" title="float.fromhex"><tt class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></tt></a> で受け取ることができます。</p>
<p>指数部が 16 進数ではなく、 10 進数で書かれ、 2 の累乗となることに注意して下さい。例えば、 16 進文字列表現 <tt class="docutils literal"><span class="pre">0x3.a7p10</span></tt> は浮動小数点数
<tt class="docutils literal"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></tt> もしくは <tt class="docutils literal"><span class="pre">3740.0</span></tt> を表します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p>逆変換を <tt class="docutils literal"><span class="pre">3740.0</span></tt> に適用すると、元とは異なる 16 進文字列表現を返します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="typeiter">
<span id="id9"></span><h2>5.5. イテレータ型<a class="headerlink" href="#typeiter" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p id="index-20">Python はコンテナの内容にわたって反復処理を行う概念をサポートしています。この概念は 2 つの別々のメソッドを使って実装されています;
これらのメソッドはユーザ定義のクラスで反復を行えるようにするために使われます。後に詳しく述べるシーケンス型はすべて反復処理メソッドをサポートしています。</p>
<p>以下はコンテナオブジェクトに反復処理をサポートさせるために定義しなければならないメソッドです:</p>
<dl class="method">
<dt id="container.__iter__">
<tt class="descclassname">container.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#container.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータオブジェクトを返します。イテレータオブジェクトは以下で述べるイテレータプロトコルをサポートする必要があります。あるコンテナが異なる形式の反復処理をサポートする場合、それらの反復処理形式のイテレータを特定的に要求するようなメソッドを追加することができます
(複数の形式での反復処理をサポートするようなオブジェクトとして木構造の例があります。木構造は幅優先走査と深さ優先走査の両方をサポートします)。このメソッドは Python/C API において Python オブジェクトを表す型構造体の <tt class="xref py py-attr docutils literal"><span class="pre">tp_iter</span></tt> スロットに対応します。</p>
</dd></dl>

<p>イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要があります。これらのメソッドは 2 つ合わせて <em class="dfn">イテレータプロトコル</em> を成します:</p>
<dl class="method">
<dt id="iterator.__iter__">
<tt class="descclassname">iterator.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#iterator.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータオブジェクト自体を返します。このメソッドはコンテナとイテレータの両方を <a class="reference internal" href="../reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> および <a class="reference internal" href="../reference/expressions.html#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> 文で使えるようにするために必要です。このメソッドは Python/C API において Python オブジェクトを表す型構造体の <tt class="xref py py-attr docutils literal"><span class="pre">tp_iter</span></tt> スロットに対応します。</p>
</dd></dl>

<dl class="method">
<dt id="iterator.next">
<tt class="descclassname">iterator.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#iterator.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテナ内の次の要素を返します。もう要素が残っていない場合、例外
<a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> を送出します。このメソッドは Python/C API において Python オブジェクトを表す型構造体の <tt class="xref py py-attr docutils literal"><span class="pre">tp_iternext</span></tt> スロットに対応します。</p>
</dd></dl>

<p>Python では、いくつかのイテレータオブジェクトを定義しています。これらは一般的および特殊化されたシーケンス型、辞書型、そして他のさらに特殊化された形式をサポートします。特殊型であることはイテレータプロトコルの実装が特殊になること以外は重要なことではありません。</p>
<p>このプロトコルの趣旨は、一度イテレータの <a class="reference internal" href="functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドが
<a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> 例外を送出した場合、以降の呼び出しでもずっと例外を送出しつづけるところにあります。この特性に従わないような実装は変則であるとみなされます (この制限は Python 2.3 で追加されました; Python 2.2
では、この規則に従うと多くのイテレータが変則となります)。</p>
<div class="section" id="generator-types">
<span id="id10"></span><h3>5.5.1. ジェネレータ型<a class="headerlink" href="#generator-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python における <a class="reference internal" href="../glossary.html#term-generator"><em class="xref std std-term">generator</em></a> (ジェネレータ) は、イテレータプロトコルを実装する簡便な方法を提供します。コンテナオブジェクトの
<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> メソッドがジェネレータとして実装されていれば、メソッドは <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> および <a class="reference internal" href="functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドを提供するイテレータオブジェクト (技術的にはジェネレータオブジェクト) を自動的に返します。
<a class="reference internal" href="../reference/expressions.html#yieldexpr"><em>yield 式についてのドキュメント</em></a> により多くの情報があります。</p>
</div>
</div>
<div class="section" id="str-unicode-list-tuple-bytearray-buffer-xrange">
<span id="typesseq"></span><h2>5.6. シーケンス型 &#8212; <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="functions.html#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a>, <a class="reference internal" href="functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, <a class="reference internal" href="functions.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a>, <a class="reference internal" href="functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>, <a class="reference internal" href="functions.html#buffer" title="buffer"><tt class="xref py py-class docutils literal"><span class="pre">buffer</span></tt></a>, <a class="reference internal" href="functions.html#xrange" title="xrange"><tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></a><a class="headerlink" href="#str-unicode-list-tuple-bytearray-buffer-xrange" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>シーケンス型には 7 つあります: 文字列、Unicode 文字列、リスト、タプル、、バイト配列 (bytearray)、バッファ、そして xrange オブジェクトです。</p>
<p>他のコンテナ型については、組み込みクラスの <a class="reference internal" href="#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> および
<a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> を参照下さい。</p>
<p id="index-21">文字列リテラルは <tt class="docutils literal"><span class="pre">'xyzzy'</span></tt> , <tt class="docutils literal"><span class="pre">&quot;frobozz&quot;</span></tt> といったように、単引用符または二重引用符の中に書かれます。文字列リテラルについての詳細は、 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><em>文字列リテラル</em></a> を参照下さい。
Unicode 文字列はほとんど文字列と同じですが、 <tt class="docutils literal"><span class="pre">u'abc'</span></tt> , <tt class="docutils literal"><span class="pre">u&quot;def&quot;</span></tt>
といったように先頭に文字 <tt class="docutils literal"><span class="pre">'u'</span></tt> を付けて指定します。リストは <tt class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span>
<span class="pre">c]</span></tt> のように要素をコンマで区切り角括弧で囲って生成します。タプルは <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></tt> のようにコンマ演算子で区切って生成します (角括弧の中には入れません)。丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは  <tt class="docutils literal"><span class="pre">()</span></tt> のように丸括弧で囲わなければなりません。要素が一つのタプルでは、例えば <tt class="docutils literal"><span class="pre">(d,)</span></tt> のように、要素の後ろにコンマをつけなければなりません。</p>
<p>バイト配列は、組み込み関数 <a class="reference internal" href="functions.html#bytearray" title="bytearray"><tt class="xref py py-func docutils literal"><span class="pre">bytearray()</span></tt></a> で構成されます。</p>
<p>バッファオブジェクトは Python の構文上では直接サポートされていませんが、組み込み関数 <a class="reference internal" href="functions.html#buffer" title="buffer"><tt class="xref py py-func docutils literal"><span class="pre">buffer()</span></tt></a> で生成することができます。バッファオブジェクトは結合や反復をサポートしていません。</p>
<p>xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない点でバッファに似ていて、関数 <a class="reference internal" href="functions.html#xrange" title="xrange"><tt class="xref py py-func docutils literal"><span class="pre">xrange()</span></tt></a> で生成します。
xrange オブジェクトはスライス、結合、反復をサポートせず、 <tt class="docutils literal"><span class="pre">in</span></tt> ,
<tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> , <a class="reference internal" href="functions.html#min" title="min"><tt class="xref py py-func docutils literal"><span class="pre">min()</span></tt></a> または <a class="reference internal" href="functions.html#max" title="max"><tt class="xref py py-func docutils literal"><span class="pre">max()</span></tt></a> は効率的ではありません。</p>
<p>ほとんどのシーケンス型は以下の演算操作をサポートします。 <tt class="docutils literal"><span class="pre">in</span></tt> および
<tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> は比較演算とおなじ優先度を持っています。 <tt class="docutils literal"><span class="pre">+</span></tt> および <tt class="docutils literal"><span class="pre">*</span></tt>
は対応する数値演算とおなじ優先度です。
<a class="footnote-reference" href="#id36" id="id11">[3]</a> <a class="reference internal" href="#typesseq-mutable"><em>変更可能なシーケンス型</em></a> で追加のメソッドが提供されています。</p>
<p>以下のテーブルはシーケンス型の演算を優先度の低いものから順に挙げたものです (同じボックス内の演算は同じ優先度です)。テーブル内の <em>s</em> および
<em>t</em> は同じ型のシーケンスです; <em>n</em> , <em>i</em> および <em>j</em> は整数です:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="62%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></tt></td>
<td><em>s</em> のある要素 <em>x</em> と等しい場合 <tt class="docutils literal"><span class="pre">True</span></tt>
, そうでない場合 <tt class="docutils literal"><span class="pre">False</span></tt></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></tt></td>
<td><em>s</em> のある要素が <em>x</em> と等しい場合
<tt class="docutils literal"><span class="pre">False</span></tt>,  そうでない場合 <tt class="docutils literal"><span class="pre">True</span></tt></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></tt></td>
<td><em>s</em> および <em>t</em> の結合</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n,</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></tt></td>
<td><em>s</em> の浅いコピー <em>n</em> 個からなる結合</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s[i]</span></tt></td>
<td><em>s</em> の 0 から数えて <em>i</em> 番目の要素</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s[i:j]</span></tt></td>
<td><em>s</em> の <em>i</em> 番目から <em>j</em> 番目までのスライス</td>
<td>(3)(4)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s[i:j:k]</span></tt></td>
<td><em>s</em> の <em>i</em> 番目から <em>j</em>  番目まで、 <em>k</em>
毎のスライス</td>
<td>(3)(5)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">len(s)</span></tt></td>
<td><em>s</em> の長さ</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">min(s)</span></tt></td>
<td><em>s</em> の最小の要素</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">max(s)</span></tt></td>
<td><em>s</em> の最大の要素</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s.index(i)</span></tt></td>
<td><em>s</em> 中で最初に <em>i</em> が現れる場所のインデクス</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s.count(i)</span></tt></td>
<td><em>s</em> 中に <em>i</em> が現れる数</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>シーケンス型は比較演算子もサポートします。特にタプルとリストは相当する要素による辞書編集方式的に比較されます。つまり、等しいということは、ふたつのシーケンスの長さ、型が同じであり、全ての要素が等しいということです (詳細は言語リファレンスの <a class="reference internal" href="../reference/expressions.html#comparisons"><em>比較 (comparison)</em></a> を参照下さい) 。</p>
<p id="index-22">注釈:</p>
<ol class="arabic">
<li><p class="first"><em>s</em> が文字列または Unicode 文字列の場合、演算操作 <tt class="docutils literal"><span class="pre">in</span></tt> および
<tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> は部分文字列の一致テストと同じように動作します。バージョン 2.3 以前の Python では、 <em>x</em> は長さ 1 の文字列でした。 Python
2.3 以降では、 <em>x</em> はどの長さでもかまいません。</p>
</li>
<li><p class="first"><em>n</em> が <tt class="docutils literal"><span class="pre">0</span></tt> 以下の値の場合、 <tt class="docutils literal"><span class="pre">0</span></tt> として扱われます (これは <em>s</em> と同じ型の空のシーケンスを表します)。コピーは浅いコピーなので注意してください; 入れ子になったデータ構造はコピーされません。これは Python
に慣れていないプログラマをよく悩ませます。例えば以下のコードを考えます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>上のコードでは、 <tt class="docutils literal"><span class="pre">lists</span></tt> はリスト <tt class="docutils literal"><span class="pre">[[]]</span></tt> (空のリストを唯一の要素として含んでいるリスト) の3つのコピーを要素とするリストです。しかし、リスト内の要素に含まれているリストは各コピー間で共有されています。以下のようにすると、異なるリストを要素とするリストを生成できます:
上のコードで、 <tt class="docutils literal"><span class="pre">[[]]</span></tt> は空のリストを要素として含んでいるリストですから、 <tt class="docutils literal"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></tt> の3つの要素の全てが、空のリスト（への参照）になります。 <tt class="docutils literal"><span class="pre">lists</span></tt> のいずれかの要素を修正することでこの単一のリストが変更されます。以下のようにすると、異なる個別のリストを生成できます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>i</em> または <em>j</em> が負の数の場合、インデクスは文字列の末端からの相対インデクスになります: <tt class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></tt>  または <tt class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></tt> が代入されます。しかし <tt class="docutils literal"><span class="pre">-0</span></tt> は <tt class="docutils literal"><span class="pre">0</span></tt> のままなので注意してください。</p>
</li>
<li><p class="first"><em>s</em> の <em>i</em> から <em>j</em> へのスライスは <tt class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></tt> となるようなインデクス <em>k</em> を持つ要素からなるシーケンスとして定義されます。 <em>i</em> または <em>j</em> が <tt class="docutils literal"><span class="pre">len(s)</span></tt> よりも大きい場合、 <tt class="docutils literal"><span class="pre">len(s)</span></tt> を使います。
<em>i</em> が省略されるか <tt class="docutils literal"><span class="pre">None</span></tt> だった場合、 <tt class="docutils literal"><span class="pre">0</span></tt> を使います。 <em>j</em> が省略されるか <tt class="docutils literal"><span class="pre">None</span></tt> だった場合、 <tt class="docutils literal"><span class="pre">len(s)</span></tt> を使います。
<em>i</em> が <em>j</em> 以上の場合、スライスは空のシーケンスになります。</p>
</li>
<li><p class="first"><em>s</em> の <em>i</em> 番目から <em>j</em> 番目まで  <em>k</em> 毎のスライスは、 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span>
<span class="pre">(j-i)/k</span></tt> となるような、インデクス <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></tt> を持つ要素からなるシーケンスとして定義されます。言い換えるとインデクスは <tt class="docutils literal"><span class="pre">i</span></tt>,
<tt class="docutils literal"><span class="pre">i+k</span></tt>, <tt class="docutils literal"><span class="pre">i+2*k</span></tt>, <tt class="docutils literal"><span class="pre">i+3*k</span></tt> などであり、 <em>j</em> に達したところ
(しかし <em>j</em> は含みません)でストップします。 <em>i</em> または <em>j</em> が
<tt class="docutils literal"><span class="pre">len(s)</span></tt> より大きい場合、 <tt class="docutils literal"><span class="pre">len(s)</span></tt> を使います。 <em>i</em> または <em>j</em>
を省略するか <tt class="docutils literal"><span class="pre">None</span></tt> だった場合、&#8221;最後&#8221; (<em>k</em> の符号に依存) を示す値を使います。 <em>k</em> はゼロにできないので注意してください。 <em>k</em> が
<tt class="docutils literal"><span class="pre">None</span></tt> だった場合、 <tt class="docutils literal"><span class="pre">1</span></tt> として扱われます。</p>
</li>
<li><div class="impl-detail first compound">
<p><strong>CPython implementation detail:</strong> <em>s</em> と <em>t</em> の両者が文字列であるとき、
CPython のような実装では、 <tt class="docutils literal"><span class="pre">s=s+t</span></tt> や <tt class="docutils literal"><span class="pre">s+=t</span></tt> という書式で代入をするのに in-place optimization が働きます。このような時、最適化は二乗の実行時間の低減をもたらします。この最適化はバージョンや実装に依存します。実行効率が必要なコードでは、バージョンと実装が変わっても、直線的な連結の実行効率を保証する <a class="reference internal" href="#str.join" title="str.join"><tt class="xref py py-meth docutils literal"><span class="pre">str.join()</span></tt></a> を使うのがより望ましいでしょう。</p>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>以前、文字列の連結はin-placeで再帰されませんでした.</p>
</li>
</ol>
<div class="section" id="string-methods">
<span id="id12"></span><h3>5.6.1. 文字列メソッド<a class="headerlink" href="#string-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-23">Below ar8-bit 文字列と Unicode オブジェクトは、どちらも以下に挙げるメソッドに対応しています。この中には、 <a class="reference internal" href="functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> オブジェクトで使えるものもあります。</p>
<p>さらに、 Python の文字列は <a class="reference internal" href="#typesseq"><em>シーケンス型 &#8212; str, unicode, list, tuple, bytearray, buffer, xrange</em></a> に記載されるシーケンス型のメソッドもサポートします。書式指定して文字列を出力するためには、テンプレート文字列を使うか、
<a class="reference internal" href="#string-formatting"><em>文字列フォーマット操作</em></a> に記載される <tt class="docutils literal"><span class="pre">%</span></tt> 演算子を使います。正規表現に基づく文字列操作関数については、 <a class="reference internal" href="re.html#module-re" title="re: 正規表現操作"><tt class="xref py py-mod docutils literal"><span class="pre">re</span></tt></a> モジュールを参照下さい。</p>
<dl class="method">
<dt id="str.capitalize">
<tt class="descclassname">str.</tt><tt class="descname">capitalize</tt><big>(</big><big>)</big><a class="headerlink" href="#str.capitalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の文字のみを大文字にした文字列のコピーを返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.center">
<tt class="descclassname">str.</tt><tt class="descname">center</tt><big>(</big><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.center" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ中央寄せされた文字列を返します。パディングには
<em>fillchar</em> で指定された値 (デフォルトではスペース) が使われます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>引数 <em>fillchar</em> に対応.</p>
</dd></dl>

<dl class="method">
<dt id="str.count">
<tt class="descclassname">str.</tt><tt class="descname">count</tt><big>(</big><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>[<em>start</em>, <em>end</em>] の範囲に、部分文字列 <em>sub</em> が出現する回数を返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同じように解釈されます。</p>
</dd></dl>

<dl class="method">
<dt id="str.decode">
<tt class="descclassname">str.</tt><tt class="descname">decode</tt><big>(</big><span class="optional">[</span><em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>codec に登録された文字コード系 <em>encoding</em> を使って文字列をデコードします。 <em>encoding</em> は標準でデフォルトの文字列エンコーディングになります。標準とは異なるエラー処理を行うために <em>errors</em> を与えることができます。標準のエラー処理は <tt class="docutils literal"><span class="pre">'strict'</span></tt> で、エンコードに関するエラーは <a class="reference internal" href="exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><tt class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></tt></a> を送出します。他に利用できる値は
<tt class="docutils literal"><span class="pre">'ignore'</span></tt>, <tt class="docutils literal"><span class="pre">'replace'</span></tt> および関数
<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><tt class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></tt></a> によって登録された名前です。これについてはセクション <a class="reference internal" href="codecs.html#codec-base-classes"><em>Codec 基底クラス</em></a> 節を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>その他のエラーハンドリングスキーマがサポートされました.</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>キーワード引数のサポートが追加されました。</p>
</dd></dl>

<dl class="method">
<dt id="str.encode">
<tt class="descclassname">str.</tt><tt class="descname">encode</tt><big>(</big><span class="optional">[</span><em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.encode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列のエンコードされたバージョンを返します。標準のエンコーディングは現在のデフォルト文字列エンコーディングです。標準とは異なるエラー処理を行うために <em>errors</em> を与えることができます。標準のエラー処理は <tt class="docutils literal"><span class="pre">'strict'</span></tt> で、エンコードに関するエラーは <a class="reference internal" href="exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><tt class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></tt></a>
を送出します。他に利用できる値は <tt class="docutils literal"><span class="pre">'ignore'</span></tt>, <tt class="docutils literal"><span class="pre">'replace'</span></tt>,
<tt class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></tt>, <tt class="docutils literal"><span class="pre">'backslashreplace'</span></tt> および関数
<a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><tt class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></tt></a> によって登録された名前です。これについてはセクション <a class="reference internal" href="codecs.html#codec-base-classes"><em>Codec 基底クラス</em></a> を参照してください。利用可能なエンコーディングの一覧は、セクション
<a class="reference internal" href="codecs.html#standard-encodings"><em>標準エンコーディング</em></a> を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.0 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span><tt class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></tt>, <tt class="docutils literal"><span class="pre">'backslashreplace'</span></tt>
およびその他のエラーハンドリングスキーマがサポートされました.</p>
</dd></dl>

<dl class="method">
<dt id="str.endswith">
<tt class="descclassname">str.</tt><tt class="descname">endswith</tt><big>(</big><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.endswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の一部が <em>suffix</em> で終わるときに <tt class="docutils literal"><span class="pre">True</span></tt> を返します。そうでない場合 <tt class="docutils literal"><span class="pre">False</span></tt> を返します。 <em>suffix</em> は見つけたい複数の接尾語のタプルでも構いません。オプション引数 <em>start</em> がある場合、文字列の
<em>start</em> から比較を始めます。 <em>end</em> がある場合、文字列の <em>end</em> で比較を終えます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span><em>suffix</em> でタプルを受け付けるようになりました.</p>
</dd></dl>

<dl class="method">
<dt id="str.expandtabs">
<tt class="descclassname">str.</tt><tt class="descname">expandtabs</tt><big>(</big><span class="optional">[</span><em>tabsize</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.expandtabs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>カラム数と与えられるタブサイズに依存し、全てのタブ文字をひとつ以上の空白で置換して文字列のコピーを返します。カラム数は文字列中に改行文字が現れる度に 0 にリセットされます。他の非表示文字や制御文字は解釈しません。</p>
</dd></dl>

<dl class="method">
<dt id="str.find">
<tt class="descclassname">str.</tt><tt class="descname">find</tt><big>(</big><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.find" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列のスライス <tt class="docutils literal"><span class="pre">s[start,</span> <span class="pre">end]</span></tt> に <em>sub</em> が含まれる場合、その最小のインデクスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合 <tt class="docutils literal"><span class="pre">-1</span></tt>
を返します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p><a class="reference internal" href="#str.find" title="str.find"><tt class="xref py py-meth docutils literal"><span class="pre">find()</span></tt></a> メソッドは、 <em>sub</em> の位置を知りたいときにのみ使うべきです。 <em>sub</em> が部分文字列であるかどうかのみを調べるには、
<a class="reference internal" href="../reference/expressions.html#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> 演算子を使ってください:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format">
<tt class="descclassname">str.</tt><tt class="descname">format</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#str.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の書式操作を行います。このメソッドを呼び出す文字列は通常の文字、または、 <tt class="docutils literal"><span class="pre">{}</span></tt> で区切られた置換フィールドを含みます。それぞれの置換フィールドは位置引数のインデックスナンバー、または、キーワード引数の名前を含みます。返り値は、引数に応じて置換されたあとの文字列のコピーです。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;The sum of 1 + 2 is {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>書式指定のオプションについては、書式指定文字列を規定する
<a class="reference internal" href="string.html#formatstrings"><em>書式指定文字列の文法</em></a> を参照下さい。</p>
<p>この文字列書式指定のメソッドは Python 3.0 での新しい標準であり、新しいコードでは、 <a class="reference internal" href="#string-formatting"><em>文字列フォーマット操作</em></a> で規定される <tt class="docutils literal"><span class="pre">%</span></tt> を使った書式指定より好ましい書き方です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="str.index">
<tt class="descclassname">str.</tt><tt class="descname">index</tt><big>(</big><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.index" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.find" title="str.find"><tt class="xref py py-meth docutils literal"><span class="pre">find()</span></tt></a> と同様ですが、 <em>sub</em> が見つからなかった場合
<a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalnum">
<tt class="descclassname">str.</tt><tt class="descname">isalnum</tt><big>(</big><big>)</big><a class="headerlink" href="#str.isalnum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が英数文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalpha">
<tt class="descclassname">str.</tt><tt class="descname">isalpha</tt><big>(</big><big>)</big><a class="headerlink" href="#str.isalpha" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が英文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isdigit">
<tt class="descclassname">str.</tt><tt class="descname">isdigit</tt><big>(</big><big>)</big><a class="headerlink" href="#str.isdigit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.islower">
<tt class="descclassname">str.</tt><tt class="descname">islower</tt><big>(</big><big>)</big><a class="headerlink" href="#str.islower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の大小文字の区別のある文字全てが小文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isspace">
<tt class="descclassname">str.</tt><tt class="descname">isspace</tt><big>(</big><big>)</big><a class="headerlink" href="#str.isspace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.istitle">
<tt class="descclassname">str.</tt><tt class="descname">istitle</tt><big>(</big><big>)</big><a class="headerlink" href="#str.istitle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、例えば大文字は大小文字の区別のない文字の後にのみ続き、小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。そうでない場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.isupper">
<tt class="descclassname">str.</tt><tt class="descname">isupper</tt><big>(</big><big>)</big><a class="headerlink" href="#str.isupper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の大小文字の区別のある文字全てが大文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.join">
<tt class="descclassname">str.</tt><tt class="descname">join</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#str.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterable"><em class="xref std std-term">iterable</em></a> <em>iterable</em> 中の文字列を結合した文字列を返します。文字列を結合するときの区切り文字は、このメソッドを適用する対象の文字列になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.ljust">
<tt class="descclassname">str.</tt><tt class="descname">ljust</tt><big>(</big><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.ljust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ左寄せした文字列を返します。パディングには
<em>fillchar</em> で指定された文字(デフォルトではスペース)が使われます。
<em>width</em> が <tt class="docutils literal"><span class="pre">len(s)</span></tt> よりも小さい場合、元の文字列が返されます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>引数 <em>fillchar</em> が追加されました.</p>
</dd></dl>

<dl class="method">
<dt id="str.lower">
<tt class="descclassname">str.</tt><tt class="descname">lower</tt><big>(</big><big>)</big><a class="headerlink" href="#str.lower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、小文字に変換して返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.lstrip">
<tt class="descclassname">str.</tt><tt class="descname">lstrip</tt><big>(</big><span class="optional">[</span><em>chars</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.lstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の先頭部分を除去したコピーを返します。引数 <em>chars</em> は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか <tt class="docutils literal"><span class="pre">None</span></tt> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接頭語ではなく、そこに含まれる文字の組み合わせ全てがはぎ取られます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2.2 で変更: </span>引数 <em>chars</em> をサポートしました.</p>
</dd></dl>

<dl class="method">
<dt id="str.partition">
<tt class="descclassname">str.</tt><tt class="descname">partition</tt><big>(</big><em>sep</em><big>)</big><a class="headerlink" href="#str.partition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> の最初の出現位置で区切り、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字列が入ります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="str.replace">
<tt class="descclassname">str.</tt><tt class="descname">replace</tt><big>(</big><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.replace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、部分文字列 <em>old</em> のある部分全てを <em>new</em> に置換して返します。オプション引数 <em>count</em> が与えられている場合、先頭から
<em>count</em> 個の <em>old</em> だけを置換します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rfind">
<tt class="descclassname">str.</tt><tt class="descname">rfind</tt><big>(</big><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.rfind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の領域 <tt class="docutils literal"><span class="pre">s[start,</span> <span class="pre">end]</span></tt> に <em>sub</em> が含まれる場合、その最大のインデクスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。
<em>sub</em> が見つからなかった場合 <tt class="docutils literal"><span class="pre">-1</span></tt>  を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rindex">
<tt class="descclassname">str.</tt><tt class="descname">rindex</tt><big>(</big><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.rindex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.rfind" title="str.rfind"><tt class="xref py py-meth docutils literal"><span class="pre">rfind()</span></tt></a> と同様ですが、 <em>sub</em> が見つからなかった場合
<a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rjust">
<tt class="descclassname">str.</tt><tt class="descname">rjust</tt><big>(</big><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.rjust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ右寄せした文字列を返します。パディングには
<em>fillchar</em> で指定された文字(デフォルトではスペース)が使われます。
<em>width</em> が <tt class="docutils literal"><span class="pre">len(s)</span></tt> よりも小さい場合、元の文字列が返されます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>引数 <em>fillchar</em> が追加されました.</p>
</dd></dl>

<dl class="method">
<dt id="str.rpartition">
<tt class="descclassname">str.</tt><tt class="descname">rpartition</tt><big>(</big><em>sep</em><big>)</big><a class="headerlink" href="#str.rpartition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> の最後の出現位置で区切り、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのものが入ります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="str.rsplit">
<tt class="descclassname">str.</tt><tt class="descname">rsplit</tt><big>(</big><span class="optional">[</span><em>sep</em><span class="optional">[</span>, <em>maxsplit</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.rsplit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sep</em> を区切り文字とした、文字列中の単語のリストを返します。
<em>maxsplit</em> が与えられた場合、最大で <em>maxsplit</em> 個になるように分割が行なわれます、 <em>最も右側</em> (の単語)は 1 つになります。 <em>sep</em> が指定されていない、あるいは <tt class="docutils literal"><span class="pre">None</span></tt> のとき、全ての空白文字が区切り文字となります。右から分割していくことを除けば、 <a class="reference internal" href="#str.rsplit" title="str.rsplit"><tt class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></tt></a> は後ほど詳しく述べる <a class="reference internal" href="#str.split" title="str.split"><tt class="xref py py-meth docutils literal"><span class="pre">split()</span></tt></a> と同様に振る舞います。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="str.rstrip">
<tt class="descclassname">str.</tt><tt class="descname">rstrip</tt><big>(</big><span class="optional">[</span><em>chars</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.rstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の末尾部分を除去したコピーを返します。引数 <em>chars</em> は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか <tt class="docutils literal"><span class="pre">None</span></tt> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接尾語ではなく、そこに含まれる文字の組み合わせ全てがはぎ取られます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2.2 で変更: </span>引数 <em>chars</em> をサポートしました.</p>
</dd></dl>

<dl class="method">
<dt id="str.split">
<tt class="descclassname">str.</tt><tt class="descname">split</tt><big>(</big><span class="optional">[</span><em>sep</em><span class="optional">[</span>, <em>maxsplit</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.split" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sep</em> を単語の境界として文字列を単語に分割し、分割された単語からなるリストを返します。 <em>maxsplit</em> が与えられた場合、最大で <em>maxsplit</em>
回の分割が行われます (したがって返されるリストは <tt class="docutils literal"><span class="pre">maxsplit+1</span></tt> の要素を持ちます) 。
<em>maxsplit</em> が指定されない場合、無制限に分割が行なわれます(全ての可能な分割が行なわれる)。</p>
<p><em>sep</em> が与えられた場合、連続した区切り文字はグループ化されず、空の文字列を区切っていると判断されます(例えば <tt class="docutils literal"><span class="pre">'1,,2'.split(',')</span></tt> は
<tt class="docutils literal"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></tt> を返します)。引数 <em>sep</em> は複数の文字にもできます
(例えば <tt class="docutils literal"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></tt> は <tt class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></tt> を返します)。区切り文字を指定して空の文字列を分割すると、 <tt class="docutils literal"><span class="pre">['']</span></tt> を返します。</p>
<p><em>sep</em> が指定されていないか <tt class="docutils literal"><span class="pre">None</span></tt> が指定されている場合、異なる分割アルゴリズムが適用されます。:
連続する空白文字はひとつの分割子とみなされます。そして、分割対象の文字列の先頭、または、末尾に空白文字があっても、分割結果の最初、または、最後に空文字列を含みません。空文字列や、空白文字だけからなる文字列を <tt class="docutils literal"><span class="pre">None</span></tt> 分割子で分割すると <tt class="docutils literal"><span class="pre">[]</span></tt> が返されます。</p>
<p>例えば、 <tt class="docutils literal"><span class="pre">'</span> <span class="pre">1</span>&nbsp; <span class="pre">2</span>&nbsp;&nbsp; <span class="pre">3</span>&nbsp; <span class="pre">'.split()</span></tt> は <tt class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></tt> を返し、
<tt class="docutils literal"><span class="pre">'</span>&nbsp; <span class="pre">1</span>&nbsp; <span class="pre">2</span>&nbsp;&nbsp; <span class="pre">3</span>&nbsp; <span class="pre">'.split(None,</span> <span class="pre">1)</span></tt> は <tt class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2</span>&nbsp;&nbsp; <span class="pre">3</span>&nbsp; <span class="pre">']</span></tt> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.splitlines">
<tt class="descclassname">str.</tt><tt class="descname">splitlines</tt><big>(</big><span class="optional">[</span><em>keepends</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.splitlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を改行部分で分解し、各行からなるリストを返します。 <em>keepends</em>
が与えられていて、かつその値が真でない限り、返されるリストには改行文字は含まれません。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.startswith">
<tt class="descclassname">str.</tt><tt class="descname">startswith</tt><big>(</big><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.startswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の一部が <em>prefix</em> で始まるときに <tt class="docutils literal"><span class="pre">True</span></tt> を返します。そうでない場合 <tt class="docutils literal"><span class="pre">False</span></tt> を返します。 <em>prefix</em> は複数の接頭語のタプルにしても構いません。オプション引数 <em>start</em> がある場合、文字列の <em>start</em>
から比較を始めます。 <em>end</em> がある場合、文字列の <em>end</em> で比較を終えます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span><em>prefix</em> でタプルを受け付けるようになりました.</p>
</dd></dl>

<dl class="method">
<dt id="str.strip">
<tt class="descclassname">str.</tt><tt class="descname">strip</tt><big>(</big><span class="optional">[</span><em>chars</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.strip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の先頭および末尾部分を除去したコピーを返します。引数 <em>chars</em>
は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか
<tt class="docutils literal"><span class="pre">None</span></tt> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接頭語でも接尾語でもなく、そこに含まれる文字の組み合わせ全てがはぎ取られます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2.2 で変更: </span>引数 <em>chars</em> をサポートしました.</p>
</dd></dl>

<dl class="method">
<dt id="str.swapcase">
<tt class="descclassname">str.</tt><tt class="descname">swapcase</tt><big>(</big><big>)</big><a class="headerlink" href="#str.swapcase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。</p>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.title">
<tt class="descclassname">str.</tt><tt class="descname">title</tt><big>(</big><big>)</big><a class="headerlink" href="#str.title" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を、単語ごとに大文字から始まり、残りの文字のうち大小文字の区別があるものは全て小文字にする、タイトルケースにして返します。</p>
<p>このアルゴリズムは単語の定義として連続した文字列の集まりという単純な言語によってはうまくいかない定義を使います。この定義は多くの状況ではうまく機能しますが、短縮形や所有格のアポストロフィは単語の境界を形成してしまうため、望みの結果を得られない場合があります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>正規表現を使うことでアポストロフィに対応することができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="go">        return re.sub(r&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;,</span>
<span class="go">                      lambda mo: mo.group(0)[0].upper() +</span>
<span class="go">                                 mo.group(0)[1:].lower(),</span>
<span class="go">                      s)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<p>8 ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.translate">
<tt class="descclassname">str.</tt><tt class="descname">translate</tt><big>(</big><em>table</em><span class="optional">[</span>, <em>deletechars</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str.translate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、オプション引数の文字列 <em>deletechars</em> の中に含まれる文字を全て除去します。その後、残った文字を変換テーブル <em>table</em> に従ってマップして返します。変換テーブルは長さ 256 の文字列でなければなりません。</p>
<p>トランスレーションテーブル作成のために、 <a class="reference internal" href="string.html#module-string" title="string: 一般的な文字列操作"><tt class="xref py py-mod docutils literal"><span class="pre">string</span></tt></a> モジュールの
<a class="reference internal" href="string.html#string.maketrans" title="string.maketrans"><tt class="xref py py-func docutils literal"><span class="pre">maketrans()</span></tt></a> 補助関数を使うこともできます。文字列型オブジェクトに対しては、 <em>table</em> 引数に <tt class="docutils literal"><span class="pre">None</span></tt> を与えることで、文字の削除だけを実施します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加: </span><tt class="docutils literal"><span class="pre">None</span></tt> の <em>table</em> 引数をサポートしました。</p>
<p>Unicode オブジェクトの場合、 <a class="reference internal" href="#str.translate" title="str.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> メソッドはオプションの <em>deletechars</em> 引数を受理しません。その代わり、メソッドはすべての文字が与えられた変換テーブルで対応付けされている <em>s</em> のコピーを返します。この変換テーブルは Unicode 順 (ordinal) から Unicode 順、
Unicode 文字列、または <tt class="docutils literal"><span class="pre">None</span></tt> への対応付けでなくてはなりません。対応付けされていない文字は何もせず放置されます。 <tt class="docutils literal"><span class="pre">None</span></tt> に対応付けられた文字は削除されます。ちなみに、より柔軟性のあるアプローチは、自作の文字対応付けを行う codec を <a class="reference internal" href="codecs.html#module-codecs" title="codecs: データやストリームのエンコード・デコード。"><tt class="xref py py-mod docutils literal"><span class="pre">codecs</span></tt></a> モジュールを使って作成することです  (例えば <tt class="xref py py-mod docutils literal"><span class="pre">encodings.cp1251</span></tt> を参照してください。)</p>
</dd></dl>

<dl class="method">
<dt id="str.upper">
<tt class="descclassname">str.</tt><tt class="descname">upper</tt><big>(</big><big>)</big><a class="headerlink" href="#str.upper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、大文字に変換して返します。</p>
<p>8ビット文字列では、メソッドはロケール依存になります。</p>
</dd></dl>

<dl class="method">
<dt id="str.zfill">
<tt class="descclassname">str.</tt><tt class="descname">zfill</tt><big>(</big><em>width</em><big>)</big><a class="headerlink" href="#str.zfill" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値文字列の左側をゼロ詰めし、幅 <em>width</em> にして返します。符号接頭辞も正しく扱われます。 <em>width</em> が <tt class="docutils literal"><span class="pre">len(s)</span></tt> よりも短い場合もとの文字列自体が返されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<p>以下のメソッドは、 Unicode オブジェクトにのみ実装されます:</p>
<dl class="method">
<dt id="unicode.isnumeric">
<tt class="descclassname">unicode.</tt><tt class="descname">isnumeric</tt><big>(</big><big>)</big><a class="headerlink" href="#unicode.isnumeric" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数字を表す文字のみで構成される場合、 <tt class="docutils literal"><span class="pre">True</span></tt> を返します。それ以外の場合は <tt class="docutils literal"><span class="pre">False</span></tt> を返します。数字を表す文字には、 0 から 9 までの数字と、 Unicode の数字プロパティを持つ全ての文字が含まれます。 (e.g. U+2155, VULGAR FRACTION ONE
FIFTH)</p>
</dd></dl>

<dl class="method">
<dt id="unicode.isdecimal">
<tt class="descclassname">unicode.</tt><tt class="descname">isdecimal</tt><big>(</big><big>)</big><a class="headerlink" href="#unicode.isdecimal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>10 進数文字のみで構成される場合、 <tt class="docutils literal"><span class="pre">True</span></tt> を返します。それ以外の場合は、 <tt class="docutils literal"><span class="pre">False</span></tt> を返します。 10 進数文字には 0 から 9 までの数字と、
10 進基数表記に使われる全ての文字が含まれます。 (e.g. U+0660,
ARABIC-INDIC DIGIT ZERO)</p>
</dd></dl>

</div>
<div class="section" id="string-formatting">
<span id="id13"></span><h3>5.6.2. 文字列フォーマット操作<a class="headerlink" href="#string-formatting" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-24">文字列および Unicode オブジェクトには固有の操作: <tt class="docutils literal"><span class="pre">%</span></tt> 演算子 (モジュロ) があります。この演算子は文字列 <em>フォーマット化</em> または <em>補間</em> 演算としても知られています。 <tt class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></tt> (<em>format</em> は文字列または
Unicode オブジェクト) とすると、 <em>format</em> 中の <tt class="docutils literal"><span class="pre">%</span></tt> 変換指定は
<em>values</em> 中のゼロ個またはそれ以上の要素で置換されます。この動作は C
言語における <tt class="xref c c-func docutils literal"><span class="pre">sprintf()</span></tt> に似ています。 <em>format</em> が Unicode オブジェクトであるか、または <tt class="docutils literal"><span class="pre">%s</span></tt>  変換を使って Unicode オブジェクトが変換される場合、その結果も Unicode オブジェクトになります。</p>
<p><em>format</em> が単一の引数しか要求しない場合、 <em>values</em> はタプルでない単一のオブジェクトでもかまいません。 <a class="footnote-reference" href="#id37" id="id14">[4]</a>
それ以外の場合、 <em>values</em> はフォーマット文字列中で指定された項目と正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければなりません。</p>
<p>一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりますが、示した順に出現しなければなりません:</p>
<ol class="arabic simple">
<li>変換指定子が開始することを示す文字 <tt class="docutils literal"><span class="pre">'%'</span></tt> 。</li>
<li>マップキー (オプション)。丸括弧で囲った文字列からなります (例えば
<tt class="docutils literal"><span class="pre">(someone)</span></tt>) 。</li>
<li>変換フラグ (オプション)。一部の変換型の結果に影響します。</li>
<li>最小のフィールド幅 (オプション)。 <tt class="docutils literal"><span class="pre">'*'</span></tt> (アスタリスク) を指定した場合、実際の文字列幅が <em>values</em> タプルの次の要素から読み出されます。タプルには最小フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにします。</li>
<li>精度 (オプション)。 <tt class="docutils literal"><span class="pre">'.'</span></tt> (ドット) とその後に続く精度で与えられます。 <tt class="docutils literal"><span class="pre">'*'</span></tt> (アスタリスク) を指定した場合、精度の桁数はタプルの次の要素から読み出されます。タプルには精度指定の後に変換したい値がくるようにします。</li>
<li>精度長変換子 (オプション)。</li>
<li>変換型。</li>
</ol>
<p><tt class="docutils literal"><span class="pre">%</span></tt> 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合),
文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字 <tt class="docutils literal"><span class="pre">'%'</span></tt> の直後にくるようにしたものが含まれていなければ <em>なりません</em>
。マップキーはフォーマット化したい値をマップから選び出します。例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;</span><span class="si">%(language)s</span><span class="s"> has </span><span class="si">%(number)03d</span><span class="s"> quote types.&#39;</span> <span class="o">%</span> \
<span class="gp">... </span>      <span class="p">{</span><span class="s">&quot;language&quot;</span><span class="p">:</span> <span class="s">&quot;Python&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>この場合、 <tt class="docutils literal"><span class="pre">*</span></tt> 指定子をフォーマットに含めてはいけません (<tt class="docutils literal"><span class="pre">*</span></tt> 指定子は順番付けされたパラメタのリストが必要だからです。)</p>
<p>変換フラグ文字を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">フラグ</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'#'</span></tt></td>
<td>値の変換に (下で定義されている) &#8220;別の形式&#8221; を使います。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'0'</span></tt></td>
<td>数値型に対してゼロによるパディングを行います。</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'-'</span></tt></td>
<td>変換された値を左寄せにします (<tt class="docutils literal"><span class="pre">'0'</span></tt> と同時に与えた場合、 <tt class="docutils literal"><span class="pre">'0'</span></tt>
を上書きします) 。</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></tt></td>
<td>(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます
(そうでない場合は空文字になります)  。</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'+'</span></tt></td>
<td>変換の先頭に符号文字 (<tt class="docutils literal"><span class="pre">'+'</span></tt> または <tt class="docutils literal"><span class="pre">'-'</span></tt>) を付けます(&#8220;スペース&#8221;
フラグを上書きします) 。</td>
</tr>
</tbody>
</table>
<p>精度長変換子(<tt class="docutils literal"><span class="pre">h</span></tt>, <tt class="docutils literal"><span class="pre">l</span></tt>,または <tt class="docutils literal"><span class="pre">L</span></tt>) を使うことができますが、
Python では必要ないため無視されます。 &#8211; つまり、例えば <tt class="docutils literal"><span class="pre">%ld</span></tt> は
<tt class="docutils literal"><span class="pre">%d</span></tt> と等価です。</p>
<p>変換型を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="80%" />
<col width="8%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">変換</th>
<th class="head">意味</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'d'</span></tt></td>
<td>符号付き 10 進整数。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'i'</span></tt></td>
<td>符号付き 10 進整数。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'o'</span></tt></td>
<td>符号なし 8 進数。</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'u'</span></tt></td>
<td>符号なし 10 進数。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'x'</span></tt></td>
<td>符号なし 16 進数 (小文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'X'</span></tt></td>
<td>符号なし 16 進数 (大文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'e'</span></tt></td>
<td>指数表記の浮動小数点数 (小文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'E'</span></tt></td>
<td>指数表記の浮動小数点数 (大文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'f'</span></tt></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'F'</span></tt></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'g'</span></tt></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'G'</span></tt></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'c'</span></tt></td>
<td>文字一文字 (整数または一文字からなる文字列を受理します)。</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'r'</span></tt></td>
<td>文字列 (Python オブジェクトを
<a class="reference internal" href="repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a> で変換します)。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'s'</span></tt></td>
<td>文字列 (Python オブジェクトを <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a>
で変換します)。</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'%'</span></tt></td>
<td>引数を変換せず、返される文字列中では文字 <tt class="docutils literal"><span class="pre">'%'</span></tt>
になります。</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first">この形式の出力にした場合、変換結果の先頭の数字がゼロ (<tt class="docutils literal"><span class="pre">'0'</span></tt>)  でないときには、数字の先頭と左側のパディングとの間にゼロを挿入します。</p>
</li>
<li><p class="first">この形式にした場合、変換結果の先頭の数字がゼロでないときには、数字の先頭と左側のパディングとの間に <tt class="docutils literal"><span class="pre">'0x'</span></tt> または <tt class="docutils literal"><span class="pre">'0X'</span></tt>
(フォーマット文字が <tt class="docutils literal"><span class="pre">'x'</span></tt> か <tt class="docutils literal"><span class="pre">'X'</span></tt> かに依存します) が挿入されます。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ、それはその後ろに数字が続かない場合にも適用されます。</p>
<p>指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ他の形式とは違って末尾の 0 は取り除かれません。</p>
<p>指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">%r</span></tt> 変換は Python 2.0 で追加されました。</p>
<p>指定精度は最大文字数を決定します。</p>
</li>
<li><p class="first">オブジェクトや与えられた書式が <a class="reference internal" href="functions.html#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a> 文字列の場合、変換後の文字列も <a class="reference internal" href="functions.html#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a> になります。</p>
<p>指定精度は最大文字数を決定します。</p>
</li>
<li><p class="first"><span class="target" id="index-25"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> を参照してください。</p>
<p>Python 文字列には明示的な長さ情報があるので、 <tt class="docutils literal"><span class="pre">%s</span></tt> 変換において
<tt class="docutils literal"><span class="pre">'\0'</span></tt> を文字列の末端と仮定したりはしません。</p>
</li>
</ol>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>絶対値が 1e50 を超える数の <tt class="docutils literal"><span class="pre">%f</span></tt> 変換は、 <tt class="docutils literal"><span class="pre">%g</span></tt> による変換に
置き換えられなくなりました。</p>
<p id="index-26">その他の文字列操作は標準モジュール <a class="reference internal" href="string.html#module-string" title="string: 一般的な文字列操作"><tt class="xref py py-mod docutils literal"><span class="pre">string</span></tt></a>  および <a class="reference internal" href="re.html#module-re" title="re: 正規表現操作"><tt class="xref py py-mod docutils literal"><span class="pre">re</span></tt></a> で定義されています。</p>
</div>
<div class="section" id="xrange">
<span id="typesseq-xrange"></span><h3>5.6.3. XRange 型<a class="headerlink" href="#xrange" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-27"><a class="reference internal" href="functions.html#xrange" title="xrange"><tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></a> 型は値の変更不能なシーケンスで、広範なループ処理に使われています。 <a class="reference internal" href="functions.html#xrange" title="xrange"><tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></a> 型の利点は、 <a class="reference internal" href="functions.html#xrange" title="xrange"><tt class="xref py py-class docutils literal"><span class="pre">xrange</span></tt></a> オブジェクトは表現する値域の大きさにかかわらず常に同じ量のメモリしか占めないということです。はっきりしたパフォーマンス上の利点はありません。</p>
<p>XRange オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反復、 <a class="reference internal" href="functions.html#len" title="len"><tt class="xref py py-func docutils literal"><span class="pre">len()</span></tt></a> 関数のみをサポートしています。</p>
</div>
<div class="section" id="typesseq-mutable">
<span id="id15"></span><h3>5.6.4. 変更可能なシーケンス型<a class="headerlink" href="#typesseq-mutable" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-28">リストとバイト配列 (<a class="reference internal" href="functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>) オブジェクトは、オブジェクトをインプレースに変更できるようにする追加の操作をサポートします。他のミュータブルなシーケンス型
(を言語に追加するとき) も、それらの操作をサポートするべきです。文字列およびタプルはイミュータブルなシーケンス型です:
これらのオブジェクトは一度生成されたら変更できません。ミュータブルなシーケンス型では以下の操作が定義されています
(ここで <em>x</em> は任意のオブジェクトとします)。</p>
<table border="1" class="docutils" id="index-29">
<colgroup>
<col width="32%" />
<col width="46%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">操作</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></tt></td>
<td><em>s</em> の要素 <em>s</em> を <em>x</em> と入れ替えます</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></tt></td>
<td><em>s</em> の <em>i</em> から <em>j</em> 番目までのスライスをイテラブル <em>t</em> の内容に入れ替えます</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></tt> と同じです</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></tt></td>
<td><tt class="docutils literal"><span class="pre">s[i:j:k]</span></tt> の要素を <em>t</em> と入れ替えます</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></tt></td>
<td>リストから <tt class="docutils literal"><span class="pre">s[i:j:k]</span></tt> の要素を削除します</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s.append(x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></tt>
と同じです</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s.extend(x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">x</span></tt> と同じです</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s.count(x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">s[i]</span> <span class="pre">==</span> <span class="pre">x</span></tt> となる <em>i</em> の個数を返します</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></tt></td>
<td><tt class="docutils literal"><span class="pre">s[k]</span> <span class="pre">==</span> <span class="pre">x</span></tt> かつ <tt class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></tt>
となる最小の <em>k</em> を返します。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt> の場合の <tt class="docutils literal"><span class="pre">s[i:i]</span> <span class="pre">=</span>
<span class="pre">[x]</span></tt> と同じです</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s.pop([i])</span></tt></td>
<td><tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">s[i];</span> <span class="pre">del</span> <span class="pre">s[i];</span> <span class="pre">return</span>
<span class="pre">x</span></tt> と同じです</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s.remove(x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">del</span> <span class="pre">s[s.index(x)]</span></tt> と同じです</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">s.reverse()</span></tt></td>
<td><em>s</em> の値の並びを反転します</td>
<td>(7)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s.sort([cmp[,</span> <span class="pre">key[,</span>
<span class="pre">reverse]]])</span></tt></td>
<td><em>s</em> の要素を並べ替えます</td>
<td>(7), (8), (9), (10)</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic">
<li><p class="first"><em>t</em> は入れ替えるスライスと同じ長さでなければいけません。</p>
</li>
<li><p class="first">かつての Python の C 実装では、複数パラメタを受理し、非明示的にそれらをタプルに結合していました。この間違った機能は Python 1.4 で廃用され、 Python 2.0 の導入とともにエラーにするようになりました。</p>
</li>
<li><p class="first"><em>x</em> は任意のイテラブル (繰り返し可能オブジェクト) にできます。</p>
</li>
<li><p class="first"><em>x</em> が <em>s</em> 中に見つからなかった場合 <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を送出します。負のインデクスが二番目または三番目のパラメタとして <tt class="xref py py-meth docutils literal"><span class="pre">index()</span></tt> メソッドに渡されると、これらの値にはスライスのインデクスと同様にリストの長さが加算されます。加算後もまだ負の場合、その値はスライスのインデクスと同様にゼロに切り詰められます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>以前は、 <tt class="xref py py-meth docutils literal"><span class="pre">index()</span></tt> は開始位置や終了位置を指定するのに負の数
を使うことができませんでした。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">insert()</span></tt>
の最初のパラメタとして負のインデクスが渡された場合、スライスのインデクスと同じく、リストの長さが加算されます。それでも負の値を取る場合、スライスのインデクスと同じく、 0 に丸められます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>以前は、すべての負値は 0 に丸められていました。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt> メソッドはリストおよびアレイ型のみでサポートされています。オプションの引数 <em>i</em> は標準で <tt class="docutils literal"><span class="pre">-1</span></tt> なので、標準では最後の要素をリストから除去して返します。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">sort()</span></tt> および <tt class="xref py py-meth docutils literal"><span class="pre">reverse()</span></tt> メソッドは大きなリストを並べ替えたり反転したりする際、容量の節約のためにリストを直接変更します。副作用があることをユーザに思い出させるために、これらの操作は並べ替えまたは反転されたリストを返しません。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">sort()</span></tt> メソッドは、比較を制御するためにオプションの引数をとります。</p>
<p><em>cmp</em> は2つの引数 (list items) からなるカスタムの比較関数を指定します。これは始めの引数が 2 つ目の引数に比べて小さい、等しい、大きいかに応じて負数、ゼロ、正数を返します。 <tt class="docutils literal"><span class="pre">cmp=lambda</span> <span class="pre">x,y:</span>
<span class="pre">cmp(x.lower(),</span> <span class="pre">y.lower())</span></tt> 。デフォルト値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p><em>key</em> は1つの引数からなる関数を指定します。これは個々のリストの要素から比較のキーを取り出すのに使われます。 <tt class="docutils literal"><span class="pre">key=str.lower</span></tt> 。デフォルト値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p><em>reverse</em> は真偽値です。 <tt class="docutils literal"><span class="pre">True</span></tt> がセットされた場合、リストの要素は個々の比較が反転したものとして並び替えられます。</p>
<p>一般的に、 <em>key</em> および <em>reverse</em> の変換プロセスは同等の <em>cmp</em> 関数を指定するより早く動作します。これは <em>key</em> および <em>reverse</em> がそれぞれの要素に一度だけ触れる間に、 <em>cmp</em> はリストのそれぞれの要素に対して複数回呼ばれることによるものです。旧式の <em>cmp</em> 関数を <em>key</em> 関数に変換するには <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><tt class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></tt></a>
を使用してください。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span><tt class="docutils literal"><span class="pre">None</span></tt> を渡すのと、 <em>cmp</em> を省略した場合とで、同等に扱うサポートを追加.</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span><em>key</em> および <em>reverse</em> のサポートを追加.</p>
</li>
<li><p class="first">Python2.3 以降、 <tt class="xref py py-meth docutils literal"><span class="pre">sort()</span></tt> メソッドは安定していることが保証されています。ソートは等しいとされた要素の相対オーダーが変更されないことが保証されれば、安定しています &#8212; これは複合的なパス（例えば部署ごとにソートして、それを給与の等級）でソートを行なうのに役立ちます。</p>
</li>
<li><div class="impl-detail first compound">
<p><strong>CPython implementation detail:</strong> リストが並べ替えられている間は、リストの変更はもとより、その値の閲覧すらその結果は未定義です。 Python 2.3 以降の C 実装では、この間リストは空に見えるようになり、並べ替え中にリストが変更されたことが検出されると <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。</p>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="set-set-frozenset">
<span id="types-set"></span><h2>5.7. set（集合）型 &#8212; <a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a>, <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a><a class="headerlink" href="#set-set-frozenset" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-30"><em class="dfn">set</em> オブジェクトは順序付けされていない <a class="reference internal" href="../glossary.html#term-hashable"><em class="xref std std-term">hashable</em></a> (ハッシュ可能な) オブジェクトのコレクションです。よくある使い方には、メンバーシップのテスト、数列から重複を削除する、そして論理積、論理和、差集合、対称差など数学的演算の計算が含まれます。
(他のコンテナ型については、組み込みクラスの <a class="reference internal" href="#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>,
<a class="reference internal" href="functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, <a class="reference internal" href="functions.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a>,および、モジュール <a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a>
を参照下さい)</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
<p>他のコレクションと同様、 sets は <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">len(set)</span></tt> および
<tt class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></tt> をサポートします。順序を持たないコレクションとして、
sets は要素の位置と (要素の) 挿入位置を保持しません。したがって、 sets
はインデックス、スライス、その他のシーケンス的な振る舞いをサポートしません。</p>
<p><a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> および <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> という、2つの組み込みset型があります。 <a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> は変更可能な &#8212; <tt class="xref py py-meth docutils literal"><span class="pre">add()</span></tt> や <tt class="xref py py-meth docutils literal"><span class="pre">remove()</span></tt>
のようなメソッドを使って内容を変更できます。変更可能なため、ハッシュ値を持たず、また辞書のキーや他のsetの要素として用いることができません。
<a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> 型はイミュータブルで、ハッシュ化可能
(<a class="reference internal" href="../glossary.html#term-hashable"><em class="xref std std-term">hashable</em></a>) です &#8212; 作成後に内容を改変できません。そのため、辞書のキーや他の集合の要素として使えます。</p>
<p>Python 2.7 では、空でない set (frozenset ではない) は、 <a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a>
コンストラクタに加え、要素を波カッコ中にカンマで区切って列挙することでも生成できます。例: <tt class="docutils literal"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></tt>.</p>
<p>両方のクラスのコンストラクタの働きは同じです:</p>
<dl class="class">
<dt id="set">
<em class="property">class </em><tt class="descname">set</tt><big>(</big><span class="optional">[</span><em>iterable</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#set" title="この定義へのパーマリンク">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><tt class="descname">frozenset</tt><big>(</big><span class="optional">[</span><em>iterable</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#frozenset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> から要素と取り込んだ、新しい set もしくは frozenset オブジェクトを返します。 set の要素はハッシュ可能なものでなくてはなりません。
set の set, つまり内部 set は <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> オブジェクトでなくてはなりません。もし、 <em>iterable</em> が指定されないならば、新しい空の set
が返されます。</p>
<p><a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> および <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> のインスタンスは以下の操作を提供します:</p>
<dl class="describe">
<dt>
<tt class="descname">len(s)</tt></dt>
<dd><p>set <em>s</em> の要素数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x in s</tt></dt>
<dd><p><em>x</em> が <em>s</em> のメンバーに含まれるか確認します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x not in s</tt></dt>
<dd><p><em>x</em> が <em>s</em> のメンバーに含まれていないことを確認します。</p>
</dd></dl>

<dl class="method">
<dt id="set.isdisjoint">
<tt class="descname">isdisjoint</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#set.isdisjoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>set が <em>other</em> と共通の要素を持たないとき、 True を返します。
set はそれらの積集合が空集合となるときのみ、互いに素となります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="set.issubset">
<tt class="descname">issubset</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#set.issubset" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set &lt;= other</tt></dt>
<dd><p>set の全ての要素が、 <em>other</em> に含まれるか確認します。</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">set &lt; other</tt></dt>
<dd><p>set が <em>other</em> の真部分集合であるかを確認します。つまり、
<tt class="docutils literal"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></tt> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="set.issuperset">
<tt class="descname">issuperset</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#set.issuperset" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set &gt;= other</tt></dt>
<dd><p><em>other</em> の全ての要素が、 set に含まれるか確認します。</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">set &gt; other</tt></dt>
<dd><p>set が <em>other</em> の真上位集合であるかを確認します。つまり、 <tt class="docutils literal"><span class="pre">set</span>
<span class="pre">&gt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></tt> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="set.union">
<tt class="descname">union</tt><big>(</big><em>other</em>, <em>...</em><big>)</big><a class="headerlink" href="#set.union" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set | other | ...</tt></dt>
<dd><p>set と全ての other の要素からなる新しい set を返します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="set.intersection">
<tt class="descname">intersection</tt><big>(</big><em>other</em>, <em>...</em><big>)</big><a class="headerlink" href="#set.intersection" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set &amp; other &amp; ...</tt></dt>
<dd><p>set と全ての other に共通する要素を持つ、新しい set を返します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="set.difference">
<tt class="descname">difference</tt><big>(</big><em>other</em>, <em>...</em><big>)</big><a class="headerlink" href="#set.difference" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set - other - ...</tt></dt>
<dd><p>set に含まれて、かつ、全ての other に含まれない要素を持つ、新しい set を返します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>複数のイテラブルからの入力を受け入れるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="set.symmetric_difference">
<tt class="descname">symmetric_difference</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#set.symmetric_difference" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set ^ other</tt></dt>
<dd><p>set もしくは <em>other</em> のいずれか一方だけに含まれる要素を持つ新しい set を返します。</p>
</dd></dl>

<dl class="method">
<dt id="set.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#set.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>s</em> の浅いコピーを新しい set として返します。</p>
</dd></dl>

<p>演算子でないバージョンの <a class="reference internal" href="#set.union" title="set.union"><tt class="xref py py-meth docutils literal"><span class="pre">union()</span></tt></a>, <a class="reference internal" href="#set.intersection" title="set.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">intersection()</span></tt></a>,
<a class="reference internal" href="#set.difference" title="set.difference"><tt class="xref py py-meth docutils literal"><span class="pre">difference()</span></tt></a>, <a class="reference internal" href="#set.symmetric_difference" title="set.symmetric_difference"><tt class="xref py py-meth docutils literal"><span class="pre">symmetric_difference()</span></tt></a>, <a class="reference internal" href="#set.issubset" title="set.issubset"><tt class="xref py py-meth docutils literal"><span class="pre">issubset()</span></tt></a>,
<a class="reference internal" href="#set.issuperset" title="set.issuperset"><tt class="xref py py-meth docutils literal"><span class="pre">issuperset()</span></tt></a> メソッドはいかなるイテラブルをも引数としてとることに注意して下さい。それとは対照的に、それらの演算子版では set であることを要求します。これは、より読みやすい
<tt class="docutils literal"><span class="pre">set('abc').intersection('cbs')</span></tt> のような書き方を支持し、
<tt class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></tt> のような、間違った構文を予防します。</p>
<p><a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> と <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> の両方とも、 set と set の比較をサポートします。二つの set は、それぞれの set の要素が互いに等しい場合にのみ等しくなります (互いに、他方の部分集合になっている場合です) 。一つめの set が二つめの set の真部分集合になっているときのみ、一つめ set は二つめの set より小さくなります (つまり、部分集合であり、かつ、等しくない場合です) 。</p>
<p><a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> のインスタンスは、 <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> のインスタンスとの比較は、それぞれの要素に基づいて行われます。例えば、
<tt class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></tt> や <tt class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">in</span>
<span class="pre">set([frozenset('abc')])</span></tt> は <tt class="docutils literal"><span class="pre">True</span></tt> を返します。</p>
<p>部分集合と等価性の比較は順序関数には拡張されません。例えば、互いに素 (等しくなく、互いに部分集合でもない) である集合は、以下の全てに、
<tt class="docutils literal"><span class="pre">False</span></tt> を返します : <tt class="docutils literal"><span class="pre">a&lt;b</span></tt>, <tt class="docutils literal"><span class="pre">a==b</span></tt>, および <tt class="docutils literal"><span class="pre">a&gt;b</span></tt> 。そのため、
set は <a class="reference internal" href="../reference/datamodel.html#object.__cmp__" title="object.__cmp__"><tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt></a> メソッドを実装しません。</p>
<p>set は不完全な順序の定義(部分集合の関係)しか持たないため、
<tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> メソッドの出力は set のリストに対して定義されません。</p>
<p>set の要素は、辞書のキーのように、 <a class="reference internal" href="../glossary.html#term-hashable"><em class="xref std std-term">hashable</em></a> (ハッシュ可能)
でなければなりません。</p>
<p><a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> インスタンスと <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> インスタンスを取り混ぜてのバイナリ演算は、ひとつめの演算対象の型のインスタンスを返します。例えば : <tt class="docutils literal"><span class="pre">frozenset('ab')</span> <span class="pre">|</span> <span class="pre">set('bc')</span></tt> は <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a>
インスタンスを返します。</p>
<p>以下の内容を更新する操作は <a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> に適用されますが、変更不可である <a class="reference internal" href="#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> のインスタンスには適用されません :</p>
<dl class="method">
<dt id="set.update">
<tt class="descname">update</tt><big>(</big><em>other</em>, <em>...</em><big>)</big><a class="headerlink" href="#set.update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set |= other | ...</tt></dt>
<dd><p>全ての other の要素を追加し、 set を更新します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>複数の入力イテラブルを受け付けるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="set.intersection_update">
<tt class="descname">intersection_update</tt><big>(</big><em>other</em>, <em>...</em><big>)</big><a class="headerlink" href="#set.intersection_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set &amp;= other &amp; ...</tt></dt>
<dd><p>元の set と 全ての other に共通する要素だけを残して set を更新します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>複数の入力イテラブルを受け付けるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="set.difference_update">
<tt class="descname">difference_update</tt><big>(</big><em>other</em>, <em>...</em><big>)</big><a class="headerlink" href="#set.difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set -= other | ...</tt></dt>
<dd><p><em>other</em> に含まれる要素を取り除き、 set を更新します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>複数の入力イテラブルを受け付けるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="set.symmetric_difference_update">
<tt class="descname">symmetric_difference_update</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#set.symmetric_difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<tt class="descname">set ^= other</tt></dt>
<dd><p>どちらかにのみ含まれて、共通には持たない要素のみで set を更新します。</p>
</dd></dl>

<dl class="method">
<dt id="set.add">
<tt class="descname">add</tt><big>(</big><em>elem</em><big>)</big><a class="headerlink" href="#set.add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> を set に追加します。</p>
</dd></dl>

<dl class="method">
<dt id="set.remove">
<tt class="descname">remove</tt><big>(</big><em>elem</em><big>)</big><a class="headerlink" href="#set.remove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> を set から取り除きます。もし <em>elem</em> が set に含まれなければ  <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="set.discard">
<tt class="descname">discard</tt><big>(</big><em>elem</em><big>)</big><a class="headerlink" href="#set.discard" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> が set に含まれていれば、取り除きます。</p>
</dd></dl>

<dl class="method">
<dt id="set.pop">
<tt class="descname">pop</tt><big>(</big><big>)</big><a class="headerlink" href="#set.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意に要素を set から返し、それを set から取り除きます。 set が空であれば、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="set.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#set.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>set の全ての要素を取り除きます。</p>
</dd></dl>

<p>非演算子版の <a class="reference internal" href="#set.update" title="set.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a>, <a class="reference internal" href="#set.intersection_update" title="set.intersection_update"><tt class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></tt></a>,
<a class="reference internal" href="#set.difference_update" title="set.difference_update"><tt class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></tt></a>, および
<a class="reference internal" href="#set.symmetric_difference_update" title="set.symmetric_difference_update"><tt class="xref py py-meth docutils literal"><span class="pre">symmetric_difference_update()</span></tt></a> メソッドはどんなイテラブルでも引数として受け付けることに注意して下さい。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><tt class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></tt></a>, <a class="reference internal" href="#set.remove" title="set.remove"><tt class="xref py py-meth docutils literal"><span class="pre">remove()</span></tt></a>, および <a class="reference internal" href="#set.discard" title="set.discard"><tt class="xref py py-meth docutils literal"><span class="pre">discard()</span></tt></a> メソッドの引数 <em>elem</em> は set であっても構いません。等価な frozenset の検索をサポートするために、 <em>elem</em> set は一時的に検索の間は変化させられ、その後、復元されます。検索の間は意味のある値を持たなくなるため、
<em>elem</em> set を読み出したり、変更してはいけません。</p>
</dd></dl>

<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="sets.html#comparison-to-builtin-set"><em>組み込み set 型との比較</em></a></dt>
<dd><a class="reference internal" href="sets.html#module-sets" title="sets: ユニークな要素の集合の実装 (撤廃)"><tt class="xref py py-mod docutils literal"><span class="pre">sets</span></tt></a> モジュールと組み込み set 型の違い</dd>
</dl>
</div>
</div>
<div class="section" id="typesmapping">
<span id="id16"></span><h2>5.8. マップ型<a class="headerlink" href="#typesmapping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-31">マップ型 (<em class="dfn">mapping</em>) オブジェクトは <a class="reference internal" href="../glossary.html#term-hashable"><em class="xref std std-term">hashable</em></a> (ハッシュ可能) な値を任意のオブジェクトに割り付けます。マップ型は変更可能なオブジェクトです。現時点では、ひとつだけの標準マップ型として辞書型 (<em class="dfn">dictionary</em>) があります (他のコンテナ型については組み込みクラスの <a class="reference internal" href="functions.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, <a class="reference internal" href="#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a>, および
<a class="reference internal" href="functions.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> と、 <a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> モジュールを参照下さい) 。</p>
<p>辞書型のキーは <em>ほぼ</em> 任意の値です。ハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><em class="xref std std-term">hashable</em></a>)でない、つまり、リストや辞書型を含む、変更可能な型 (値ではなく、オブジェクトの同一性で比較されます) はキーとして使用できません。数値型は通常の数値比較のルールに従ってキーとして使われます　: もしふたつの数値を比較し、等しければ (例えば <tt class="docutils literal"><span class="pre">1</span></tt> と <tt class="docutils literal"><span class="pre">1.0</span></tt> のように) 同じ辞書型に対しインデックスとして同じものとして使用できます (しかしながら、コンピュータ上では近似値を浮動小数点数として保管されることに注意して下さい。これは大抵の場合、辞書型のキーとして使用するのに良い方法ではありません) 。</p>
<p>辞書型は <tt class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></tt> の形式の対の値をカンマ区切りのリストを波括弧でくくることで作成できます。例えば : <tt class="docutils literal"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></tt>
あるいは <tt class="docutils literal"><span class="pre">{4098:</span> <span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></tt> 。あるいは、 <a class="reference internal" href="#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>
のコンストラクタでも作成できます。</p>
<dl class="class">
<dt id="dict">
<em class="property">class </em><tt class="descname">dict</tt><big>(</big><span class="optional">[</span><em>arg</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションのポジション引数、もしくは、一連のキーワード引数で初期化された新しい辞書型を返します。引数が無い場合は、空の辞書型を返します。もし、ポジション引数 <em>arg</em> がマップ型オブジェクトであれば、もとのマップ型オブジェクトと同じ値に同じキーを割り当てた辞書型を返します。そうでない場合は、ポジション引数はイテレーションをサポートするシーケンスか、イテレータオブジェクトでなければなりません。引数の要素もまた、それと同様でなくてはならず、かつ、それぞれがちょうどふたつのオブジェクトを持っている必要があります。最初のものが新しい辞書型において、キーとして使われます。ふたつめのものがキーの値として使われます。もし、与えられたキーが二度以上現れた場合は、最後に現れた値が新しい辞書型において採用されます。</p>
<p>キーワード引数が与えられた場合、キーワード自身がその値として辞書型に加えられます。もしキーがポジション引数において、キーワード引数を規定した場合、キーワードに値が割り当てられ辞書に追加されます。例えば以下は全て <tt class="docutils literal"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2}</span></tt> と等しい辞書型インスタンスを返します :</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">dict(one=1,</span> <span class="pre">two=2)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">dict({'one':</span> <span class="pre">1,</span> <span class="pre">'two':</span> <span class="pre">2})</span></tt></li>
<li><tt class="docutils literal"><span class="pre">dict(zip(('one',</span> <span class="pre">'two'),</span> <span class="pre">(1,</span> <span class="pre">2)))</span></tt></li>
<li><tt class="docutils literal"><span class="pre">dict([['two',</span> <span class="pre">2],</span> <span class="pre">['one',</span> <span class="pre">1]])</span></tt></li>
</ul>
<p>最初の例では、 Python の識別子として有効なキーに対してのみ機能します ; 他の例はキーとして有効なものであればいかなるキーに対しても機能します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>キーワード引数からの辞書型の作成のサポートが追加されました。</p>
<p>以下は辞書型がサポートする操作です (それゆえ、カスタムのマップ型もこれらの操作をサポートするべきです):</p>
<dl class="describe">
<dt>
<tt class="descname">len(d)</tt></dt>
<dd><p>辞書 <em>d</em> に含まれる項目数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">d[key]</tt></dt>
<dd><p><em>d</em> のキー <em>key</em> の項目を返します。もし <em>key</em> が存在しなければ、
<a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">d[key] = value</tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">d[key]</span></tt> に <em>value</em> を設定します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">del d[key]</tt></dt>
<dd><p><em>d</em> から <tt class="docutils literal"><span class="pre">d[key]</span></tt> を削除します。もし <em>key</em> が存在しなければ、
<a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">key in d</tt></dt>
<dd><p><em>d</em> がキー <em>key</em> を持っていれば、 <tt class="docutils literal"><span class="pre">True</span></tt> を返します。そうでなければ、 <tt class="docutils literal"><span class="pre">False</span></tt> を返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">key not in d</tt></dt>
<dd><p><tt class="docutils literal"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></tt> と等価です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">iter(d)</tt></dt>
<dd><p>辞書 <em>d</em> の全てのキーに渡って、イテレータを返します。これは
<a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><tt class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></tt></a> メソッドへのショートカットです。</p>
</dd></dl>

<dl class="method">
<dt id="dict.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の全ての項目を消去します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の浅いコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.fromkeys">
<tt class="descname">fromkeys</tt><big>(</big><em>seq</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dict.fromkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>seq</em> をキーとし、 <em>value</em> を値に設定した、新しい辞書を作成します。</p>
<p><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><tt class="xref py py-func docutils literal"><span class="pre">fromkeys()</span></tt></a> は新しい辞書を返すクラスメソッドです。 <em>value</em>
のデフォルト値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.get">
<tt class="descname">get</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dict.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もし <em>key</em> が辞書にあれば、 <em>key</em> に対する値を返します。そうでなければ、 <em>default</em> を返します。 <em>default</em> が与えられなかった場合、デフォルトでは <tt class="docutils literal"><span class="pre">None</span></tt> となります。そのため、このメソッドは
<a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出することはありません。</p>
</dd></dl>

<dl class="method">
<dt id="dict.has_key">
<tt class="descname">has_key</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#dict.has_key" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書に <em>key</em> が存在するかを確認します。 <a class="reference internal" href="#dict.has_key" title="dict.has_key"><tt class="xref py py-meth docutils literal"><span class="pre">has_key()</span></tt></a> は <tt class="docutils literal"><span class="pre">key</span>
<span class="pre">in</span> <span class="pre">d</span></tt> と同じことです。</p>
</dd></dl>

<dl class="method">
<dt id="dict.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のコピーを <tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> の対のリストとして返します。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> キーと値のリストは任意の順序で返されますが、ランダムではなく、
Python の実装と、辞書への挿入、および、削除操作の来歴によって決まります。</p>
</div>
<p>もし、 <a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">items()</span></tt></a>, <a class="reference internal" href="#dict.keys" title="dict.keys"><tt class="xref py py-meth docutils literal"><span class="pre">keys()</span></tt></a>, <a class="reference internal" href="#dict.values" title="dict.values"><tt class="xref py py-meth docutils literal"><span class="pre">values()</span></tt></a>,
<a class="reference internal" href="#dict.iteritems" title="dict.iteritems"><tt class="xref py py-meth docutils literal"><span class="pre">iteritems()</span></tt></a>, <a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><tt class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></tt></a> および <a class="reference internal" href="#dict.itervalues" title="dict.itervalues"><tt class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></tt></a> が辞書を変更することなく呼び出されたら、リストは一致するでしょう。これにより、 <tt class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></tt> の対を <a class="reference internal" href="functions.html#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a>
または <tt class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></tt> を使って生成するとができます。同じ関係が、 <a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><tt class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></tt></a> および <a class="reference internal" href="#dict.itervalues" title="dict.itervalues"><tt class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></tt></a> メソッドにもあてはまります :
<tt class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.itervalues(),</span> <span class="pre">d.iterkeys())</span></tt> は <tt class="docutils literal"><span class="pre">pairs</span></tt> と同じ値を返します。
<tt class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.iteritems()]</span></tt> も同様です。</p>
</dd></dl>

<dl class="method">
<dt id="dict.iteritems">
<tt class="descname">iteritems</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.iteritems" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の <tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> の対をイテレータで返します。
<a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></tt></a> の Note も参照下さい。</p>
<p><a class="reference internal" href="#dict.iteritems" title="dict.iteritems"><tt class="xref py py-meth docutils literal"><span class="pre">iteritems()</span></tt></a> を辞書の項目の追加や削除と同時に行うと、
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> を送出されるか全ての項目に対する反復に失敗することになります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.iterkeys">
<tt class="descname">iterkeys</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.iterkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーをイテレータで返します。 <a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></tt></a> の Note も参照下さい。</p>
<p><a class="reference internal" href="#dict.iterkeys" title="dict.iterkeys"><tt class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></tt></a> を辞書の項目の追加や削除と同時に行うと、
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> を送出されるか全ての項目に対する反復に失敗することになります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.itervalues">
<tt class="descname">itervalues</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.itervalues" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値をイテレータで返します。 <a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></tt></a> の Note も参照下さい。</p>
<p><a class="reference internal" href="#dict.itervalues" title="dict.itervalues"><tt class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></tt></a> を辞書の項目の追加や削除と同時に行うと、
<a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> を送出されるか全ての項目に対する反復に失敗することになります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーのリストのコピーを返します。 <a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></tt></a> の
Note も参照下さい。</p>
</dd></dl>

<dl class="method">
<dt id="dict.pop">
<tt class="descname">pop</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dict.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もし <em>key</em> が辞書に存在すれば、その値を辞書から除去して返します。そうでなければ、 <em>default</em> を返します。 <em>default</em> が与えらず、かつ、 <em>key</em> が辞書に存在しなければ <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.popitem">
<tt class="descname">popitem</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.popitem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意の <tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> の対を辞書から除去して返します。</p>
<p>set のアルゴリズムで使われるのと同じように <a class="reference internal" href="#dict.popitem" title="dict.popitem"><tt class="xref py py-func docutils literal"><span class="pre">popitem()</span></tt></a> は辞書に繰り返し適用して消去するのに便利です。もし辞書が空であれば、
<a class="reference internal" href="#dict.popitem" title="dict.popitem"><tt class="xref py py-func docutils literal"><span class="pre">popitem()</span></tt></a> の呼び出しは <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.setdefault">
<tt class="descname">setdefault</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dict.setdefault" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もし、 <em>key</em> が辞書に存在すれば、その値を返します。そうでなければ、値を <em>default</em> として <em>key</em> を挿入し、 <em>default</em> を返します。
<em>default</em> のデフォルト値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
</dd></dl>

<dl class="method">
<dt id="dict.update">
<tt class="descname">update</tt><big>(</big><span class="optional">[</span><em>other</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dict.update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の内容を <em>other</em> のキーと値で更新します。既存のキーは上書きされます。返り値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p><a class="reference internal" href="#dict.update" title="dict.update"><tt class="xref py py-func docutils literal"><span class="pre">update()</span></tt></a> は、他の辞書オブジェクトでもキーと値の対のイテラブル (タプル、もしくは、長さが2のイテラブル) でも、どちらでも受け付けます。キーワード引数が指定されれば、そのキーと値で辞書を更新します。 : <tt class="docutils literal"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></tt></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>キーと値の対のイテラブル、および、キーワード引数を引数として
与えることができるようになりました。</p>
</dd></dl>

<dl class="method">
<dt id="dict.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値のリストのコピーを返します。 <a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></tt></a> の Note
も参照下さい。</p>
</dd></dl>

<dl class="method">
<dt id="dict.viewitems">
<tt class="descname">viewitems</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.viewitems" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の要素 (<tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> の対) の新しいビューを返します。ビューオブジェクトのドキュメントは下を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.viewkeys">
<tt class="descname">viewkeys</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.viewkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーの新しいビューを返します。ビューオブジェクトのドキュメントは下を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="dict.viewvalues">
<tt class="descname">viewvalues</tt><big>(</big><big>)</big><a class="headerlink" href="#dict.viewvalues" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値の新しいビューを返します。ビューオブジェクトのドキュメントは下を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

</dd></dl>

<div class="section" id="dict-views">
<span id="id17"></span><h3>5.8.1. 辞書ビューオブジェクト<a class="headerlink" href="#dict-views" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#dict.keys" title="dict.keys"><tt class="xref py py-meth docutils literal"><span class="pre">dict.keys()</span></tt></a> 、 <a class="reference internal" href="#dict.values" title="dict.values"><tt class="xref py py-meth docutils literal"><span class="pre">dict.values()</span></tt></a> 、 <a class="reference internal" href="#dict.items" title="dict.items"><tt class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></tt></a> によって返されるオブジェクトは、 <em>ビューオブジェクト</em> です。これらは、辞書の項目の動的なビューを提供し、辞書が変更された時、ビューはその変更を反映します。</p>
<p>辞書ビューを通して反復することで、対応するデータを産出できます。また、帰属検査をサポートしています。</p>
<dl class="describe">
<dt>
<tt class="descname">len(dictview)</tt></dt>
<dd><p>辞書の項目数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">iter(dictview)</tt></dt>
<dd><p>辞書のキー、値、または (<tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> のタプルとして表される) 要素に渡るイテレータを返します。</p>
<p>キーと値のリストは任意の順序で反復されますが、ランダムではなく、
Python の実装によって変わり、辞書への挿入や削除の履歴に依存します。キー、値、要素のビューを通して、辞書の変更を挟まずにイテレートされたら、その要素の順序は完全に一致します。これにより、 <tt class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></tt> の対を
<a class="reference internal" href="functions.html#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a> で作成できます: <tt class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></tt> 。同じリストを作成する他の方法は、
<tt class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></tt> です。</p>
<p>辞書の項目の追加や削除中にビューをイテレートすると、 <a class="reference internal" href="exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a>
を送出したり、すべての項目に渡ってイテレートできなかったりします。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x in dictview</tt></dt>
<dd><p><em>x</em> が下にある辞書のキー、値、または要素 (要素の場合、 <em>x</em> は
<tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> タプルであるべきです) にあるとき <tt class="docutils literal"><span class="pre">True</span></tt> を返します。</p>
</dd></dl>

<p>キーのビューは、項目が一意的でハッシュ可能であるという点で、集合に似ています。すべての値がハッシュ可能なら、 <tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> の対も一意的でハッシュ可能であり、要素のビューも集合に似ています。(値のビューは、要素が一般に一意的でないことから、集合に似ているとは考えられません。)
ですから、これらの集合演算が利用できます。
(&#8220;other&#8221; は別のビューか集合です):</p>
<dl class="describe">
<dt>
<tt class="descname">dictview &amp; other</tt></dt>
<dd><p>辞書ビューと別のオブジェクトの共通部分を新しい集合として返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">dictview | other</tt></dt>
<dd><p>辞書ビューと別のオブジェクトの合併集合を新しい集合として返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">dictview - other</tt></dt>
<dd><p>辞書ビューと別のオブジェクトの差集合 (<em>dictview</em> に属して <em>other</em> に属さないすべての要素) を新しい集合として返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">dictview ^ other</tt></dt>
<dd><p>辞書ビューと別のオブジェクトの対称差 (<em>dictview</em> と <em>other</em> のどちらかに属すが両方には属さないすべての要素) を新しい集合として返します。</p>
</dd></dl>

<p>辞書ビューの使用法の例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">viewvalues</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c"># keys and values are iterated over in the same order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;bacon&#39;, &#39;sausage&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;spam&#39;, &#39;bacon&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s">&#39;eggs&#39;</span><span class="p">,</span> <span class="s">&#39;bacon&#39;</span><span class="p">,</span> <span class="s">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bltin-file-objects">
<span id="id18"></span><h2>5.9. ファイルオブジェクト<a class="headerlink" href="#bltin-file-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-32">ファイルオブジェクト  は C の <tt class="docutils literal"><span class="pre">stdio</span></tt> パッケージを使って実装されており、組み込み関数の <a class="reference internal" href="functions.html#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> で生成することができます。ファイルオブジェクトはまた、 <a class="reference internal" href="os.html#os.popen" title="os.popen"><tt class="xref py py-func docutils literal"><span class="pre">os.popen()</span></tt></a> や <a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><tt class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></tt></a>,
ソケットオブジェクトの <tt class="xref py py-meth docutils literal"><span class="pre">makefile()</span></tt> メソッドのような、他の組み込み関数およびメソッドによっても返されます。一時ファイルは <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: 一時的なファイルやディレクトリを生成。"><tt class="xref py py-mod docutils literal"><span class="pre">tempfile</span></tt></a>
モジュールを使って生成でき、ファイルやディレクトリのコピー、移動、消去などの高次の操作は <a class="reference internal" href="shutil.html#module-shutil" title="shutil: コピーを含む高レベルなファイル操作。"><tt class="xref py py-mod docutils literal"><span class="pre">shutil</span></tt></a> モジュールで行います。</p>
<p>ファイル操作が I/O 関連の理由で失敗した場合例外 <a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> が送出されます。この理由には例えば <tt class="xref py py-meth docutils literal"><span class="pre">seek()</span></tt> を端末デバイスに行ったり、読み出し専用で開いたファイルに書き込みを行うといった、何らかの理由によってそのファイルで定義されていない操作を行ったような場合も含まれます。</p>
<p>ファイルは以下のメソッドを持ちます:</p>
<dl class="method">
<dt id="file.close">
<tt class="descclassname">file.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#file.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルを閉じます。閉じられたファイルはそれ以後読み書きすることはできません。ファイルが開かれていることが必要な操作は、ファイルが閉じられた後はすべて <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を送出します。 <a class="reference internal" href="#file.close" title="file.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a>
を一度以上呼び出してもかまいません。</p>
<p>Python 2.5 から <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文を使えばこのメソッドを直接呼び出す必要はなくなりました。たとえば、以下のコードは <em>f</em> を
<a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> ブロックを抜ける際に自動的に閉じます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span> <span class="c"># これは Python 2.6 では不要です</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;hello.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">line</span>
</pre></div>
</div>
<p>古いバージョンの Python では同じ効果を得るために次のようにしなければいけませんでした。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">line</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">全ての Python の &#8220;ファイル的&#8221; 型が <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文用のコンテキスト・マネージャとして使えるわけではありません。もし、全てのファイル的オブジェクトで動くようにコードを書きたいのならば、オブジェクトを直接使うのではなく <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: with-構文コンテキストのためのユーティリティ。"><tt class="xref py py-mod docutils literal"><span class="pre">contextlib</span></tt></a> にある
<a class="reference internal" href="contextlib.html#contextlib.closing" title="contextlib.closing"><tt class="xref py py-func docutils literal"><span class="pre">contextlib.closing()</span></tt></a> 関数を使うと良いでしょう。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.flush">
<tt class="descclassname">file.</tt><tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#file.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">stdio</span></tt> の <tt class="xref c c-func docutils literal"><span class="pre">fflush()</span></tt> のように、内部バッファをフラッシュします。ファイル類似のオブジェクトによっては、この操作は何も行いません。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><a class="reference internal" href="#file.flush" title="file.flush"><tt class="xref py py-meth docutils literal"><span class="pre">flush()</span></tt></a> は必ずしもファイルのデータをディスクに書き込むとは限りません。そのような挙動を保証するには <a class="reference internal" href="#file.flush" title="file.flush"><tt class="xref py py-meth docutils literal"><span class="pre">flush()</span></tt></a> の後に <a class="reference internal" href="os.html#os.fsync" title="os.fsync"><tt class="xref py py-func docutils literal"><span class="pre">os.fsync()</span></tt></a> を使って下さい。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.fileno">
<tt class="descclassname">file.</tt><tt class="descname">fileno</tt><big>(</big><big>)</big><a class="headerlink" href="#file.fileno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-33">背後にある実装系がオペレーティングシステムに I/O 操作を要求するために用いる、整数の &#8220;ファイル記述子&#8221; を返します。この値は他の用途として、 <a class="reference internal" href="fcntl.html#module-fcntl" title="fcntl: fcntl() および ioctl() システムコール。 (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">fcntl</span></tt></a> モジュールや <a class="reference internal" href="os.html#os.read" title="os.read"><tt class="xref py py-func docutils literal"><span class="pre">os.read()</span></tt></a> やその仲間のような、ファイル記述子を必要とする低レベルのインタフェースで役に立ちます。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">ファイル類似のオブジェクトが実際のファイルに関連付けられていない場合、このメソッドを提供すべきでは <em>ありません</em> 。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.isatty">
<tt class="descclassname">file.</tt><tt class="descname">isatty</tt><big>(</big><big>)</big><a class="headerlink" href="#file.isatty" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルが tty (または類似の) デバイスに接続されている場合 <tt class="docutils literal"><span class="pre">True</span></tt>
を返し、そうでない場合 <tt class="docutils literal"><span class="pre">False</span></tt> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">ファイル類似のオブジェクトが実際のファイルに関連付けられていない場合、このメソッドを実装すべきでは <em>ありません</em> 。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.next">
<tt class="descclassname">file.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#file.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルオブジェクトはそれ自身がイテレータです。すなわち、
<tt class="docutils literal"><span class="pre">iter(f)</span></tt> は (<em>f</em> が閉じられていない限り) <em>f</em> を返します。
<a class="reference internal" href="../reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループ (例えば <tt class="docutils literal"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">f:</span> <span class="pre">print</span> <span class="pre">line</span></tt>) のようにファイルがイテレータとして使われた場合、 <a class="reference internal" href="functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドが繰り返し呼び出されます。ファイルが読み出しモードで開かれている場合、このメソッドは次の入力行を返すか、または、 EOF に到達したときに
<a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> を送出します (ファイルが書き込みモードで開かれている場合、動作は未定義です) 。ファイル内の各行に対する <a class="reference internal" href="../reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループ (非常によくある操作です) を効率的な方法で行うために、 <a class="reference internal" href="functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドは隠蔽された先読みバッファを使います。先読みバッファを使った結果として、
(<a class="reference internal" href="readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> のような) 他のファイルメソッドと <a class="reference internal" href="functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> を組み合わせて使うとうまく動作しません。しかし、 <a class="reference internal" href="#file.seek" title="file.seek"><tt class="xref py py-meth docutils literal"><span class="pre">seek()</span></tt></a> を使ってファイル位置を絶対指定しなおすと、先読みバッファは消去されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="file.read">
<tt class="descclassname">file.</tt><tt class="descname">read</tt><big>(</big><span class="optional">[</span><em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#file.read" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最大で <em>size</em> バイトをファイルから読み込みます (<em>size</em> バイトを取得する前に EOF に到達した場合、それ以下の長さになります) 。 <em>size</em> 引数が負であるか省略された場合、 EOF に到達するまでの全てのデータを読み込みます。読み出されたバイト列は文字列オブジェクトとして返されます。直後に EOF に到達した場合、空の文字列が返されます。 (端末のようなある種のファイルでは、 EOF に到達した後でファイルを読みつづけることにも意味があります) 。このメソッドは、 <em>size</em> バイトに可能な限り近くデータを取得するために、背後の C 関数 <tt class="xref c c-func docutils literal"><span class="pre">fread()</span></tt> を 1 度以上呼び出すかもしれないので注意してください。また、非ブロック・モードでは、 <em>size</em> パラメータが与えられなくても、要求されたよりも少ないデータが返される場合があることに注意してください。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">この関数は単純に、背後の C 関数、 <tt class="xref c c-func docutils literal"><span class="pre">fread()</span></tt> のラッパーです。そのため、 EOF が見つからない場合など、特殊な状況では同様に振る舞います。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.readline">
<tt class="descclassname">file.</tt><tt class="descname">readline</tt><big>(</big><span class="optional">[</span><em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#file.readline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルから一行全部を読み込みます。終末の改行文字は文字列に残ります
(しかし、ファイルが不完全な行で終わっていたら、存在しないかもしれません)。 <a class="footnote-reference" href="#id38" id="id19">[5]</a>
<em>size</em> 引数が与えられ、負でなければ、それが (終末の改行文字を含む)
最大バイト数となり、不完全な行でも返されます。 <em>size</em> が 0 でなければ、空の文字列が返されるのは、即座に EOF に到達したとき <em>だけ</em> です。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><tt class="docutils literal"><span class="pre">stdio</span></tt> の <tt class="xref c c-func docutils literal"><span class="pre">fgets()</span></tt> と違い、入力中にヌル文字 (<tt class="docutils literal"><span class="pre">'\0'</span></tt>)
が含まれていれば、ヌル文字を含んだ文字列が返されます。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.readlines">
<tt class="descclassname">file.</tt><tt class="descname">readlines</tt><big>(</big><span class="optional">[</span><em>sizehint</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#file.readlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> を使ってに到達するまで読み出し、 EOF 読み出された行を含むリストを返します。オプションの <em>sizehint</em> 引数が存在すれば、
EOF まで読み出す代わりに完全な行を全体で大体 <em>sizehint</em> バイトになるように (おそらく内部バッファサイズを切り詰めて) 読み出します。ファイル類似のインタフェースを実装しているオブジェクトは、 <em>sizehint</em>
を実装できないか効率的に実装できない場合には無視してもかまいません。</p>
</dd></dl>

<dl class="method">
<dt id="file.xreadlines">
<tt class="descclassname">file.</tt><tt class="descname">xreadlines</tt><big>(</big><big>)</big><a class="headerlink" href="#file.xreadlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <tt class="docutils literal"><span class="pre">iter(f)</span></tt> と同じ結果を返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.1 で追加.</span></p>
<p class="deprecated">
<span class="versionmodified">バージョン 2.3 で撤廃: </span>代わりに <tt class="docutils literal"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file</span></tt> を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="file.seek">
<tt class="descclassname">file.</tt><tt class="descname">seek</tt><big>(</big><em>offset</em><span class="optional">[</span>, <em>whence</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#file.seek" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">stdio</span></tt> の <tt class="xref c c-func docutils literal"><span class="pre">fseek()</span></tt> と同様に、ファイルの現在位置を設定します。
<em>whence</em> 引数はオプションで、標準の値は <tt class="docutils literal"><span class="pre">os.SEEK_SET</span></tt> もしくは
<tt class="docutils literal"><span class="pre">0</span></tt> (絶対位置指定) です; 他に取り得る値は <tt class="docutils literal"><span class="pre">os.SEEK_CUR</span></tt> もしくは <tt class="docutils literal"><span class="pre">1</span></tt> (現在のファイル位置から相対的に seek する) および
<tt class="docutils literal"><span class="pre">os.SEEK_END</span></tt> もしくは <tt class="docutils literal"><span class="pre">2</span></tt> (ファイルの末端から相対的に seek する) です。戻り値はありません。</p>
<p>例えば、 <tt class="docutils literal"><span class="pre">f.seek(2,</span> <span class="pre">os.SEEK_CUR)</span></tt> 位置を2つ進めます。
<tt class="docutils literal"><span class="pre">f.seek(-3,</span> <span class="pre">os.SEEK_END)</span></tt> では終端の3つ手前に設定します。</p>
<p>ファイルを追記モード (モード <tt class="docutils literal"><span class="pre">'a'</span></tt> または <tt class="docutils literal"><span class="pre">'a+'</span></tt>) で開いた場合、書き込みを行うまでに行った <a class="reference internal" href="#file.seek" title="file.seek"><tt class="xref py py-meth docutils literal"><span class="pre">seek()</span></tt></a> 操作はすべて元に戻されるので注意してください。ファイルが追記のみの書き込みモード (<tt class="docutils literal"><span class="pre">'a'</span></tt>) で開かれた場合、このメソッドは実質何も行いませんが、読み込みが可能な追記モード (<tt class="docutils literal"><span class="pre">'a+'</span></tt>) で開かれたファイルでは役に立ちます。ファイルをテキストモードで (<tt class="docutils literal"><span class="pre">'b'</span></tt> なしで) 開いた場合、 <a class="reference internal" href="#file.tell" title="file.tell"><tt class="xref py py-meth docutils literal"><span class="pre">tell()</span></tt></a> が返すオフセットのみが正しい値になります。他のオフセット値を使った場合、その振る舞いは未定義です。</p>
<p>全てのファイルオブジェクトが seek できるとは限らないので注意してください。</p>
</dd></dl>

<dl class="method">
<dt id="file.tell">
<tt class="descclassname">file.</tt><tt class="descname">tell</tt><big>(</big><big>)</big><a class="headerlink" href="#file.tell" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">stdio</span></tt> の <tt class="xref c c-func docutils literal"><span class="pre">ftell()</span></tt> と同様、ファイルの現在位置を返します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">Windows では、(<tt class="xref c c-func docutils literal"><span class="pre">fgets()</span></tt> の後で) Unix-スタイルの改行のファイルを読むときに <a class="reference internal" href="#file.tell" title="file.tell"><tt class="xref py py-meth docutils literal"><span class="pre">tell()</span></tt></a> が不正な値を返すことがあります。この問題に遭遇しないためにはバイナリーモード (<tt class="docutils literal"><span class="pre">'rb'</span></tt>) を使うようにしてください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="file.truncate">
<tt class="descclassname">file.</tt><tt class="descname">truncate</tt><big>(</big><span class="optional">[</span><em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#file.truncate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルのサイズを切り詰めます。オプションの <em>size</em> が存在すれば、ファイルは (最大で) 指定されたサイズに切り詰められます。標準設定のサイズの値は、現在のファイル位置までのファイルサイズです。現在のファイル位置は変更されません。指定されたサイズがファイルの現在のサイズを越える場合、その結果はプラットフォーム依存なので注意してください:
可能性としては、ファイルは変更されないか、指定されたサイズまでゼロで埋められるか、指定されたサイズまで未定義の新たな内容で埋められるか、があります。利用可能な環境:  Windows, 多くの Unix 系。</p>
</dd></dl>

<dl class="method">
<dt id="file.write">
<tt class="descclassname">file.</tt><tt class="descname">write</tt><big>(</big><em>str</em><big>)</big><a class="headerlink" href="#file.write" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をファイルに書き込みます。戻り値はありません。バッファリングによって、 <a class="reference internal" href="#file.flush" title="file.flush"><tt class="xref py py-meth docutils literal"><span class="pre">flush()</span></tt></a> または <a class="reference internal" href="#file.close" title="file.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> が呼び出されるまで実際にファイル中に文字列が書き込まれないこともあります。</p>
</dd></dl>

<dl class="method">
<dt id="file.writelines">
<tt class="descclassname">file.</tt><tt class="descname">writelines</tt><big>(</big><em>sequence</em><big>)</big><a class="headerlink" href="#file.writelines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列からなるシーケンスをファイルに書き込みます。シーケンスは文字列を生成する反復可能なオブジェクトなら何でもかまいません。よくあるのは文字列からなるリストです。戻り値はありません。 (関数の名前は
<a class="reference internal" href="#file.readlines" title="file.readlines"><tt class="xref py py-meth docutils literal"><span class="pre">readlines()</span></tt></a> と対応づけてつけられました; <a class="reference internal" href="#file.writelines" title="file.writelines"><tt class="xref py py-meth docutils literal"><span class="pre">writelines()</span></tt></a> は行間の区切りを追加しません)</p>
</dd></dl>

<p>ファイルはイテレータプロトコルをサポートします。各反復操作では
<tt class="docutils literal"><span class="pre">file.readline()</span></tt> と同じ結果を返し、反復は <a class="reference internal" href="readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> メソッドが空文字列を返した際に終了します。</p>
<p>ファイルオブジェクトはまた、多くの興味深い属性を提供します。これらはファイル類似オブジェクトでは必要ではありませんが、特定のオブジェクトにとって意味を持たせたいなら実装しなければなりません。</p>
<dl class="attribute">
<dt id="file.closed">
<tt class="descclassname">file.</tt><tt class="descname">closed</tt><a class="headerlink" href="#file.closed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のファイルオブジェクトの状態を示すブール値です。この値は読み出し専用の属性です; <a class="reference internal" href="#file.close" title="file.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> メソッドがこの値を変更します。全てのファイル類似オブジェクトで利用可能とは限りません。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.encoding">
<tt class="descclassname">file.</tt><tt class="descname">encoding</tt><a class="headerlink" href="#file.encoding" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このファイルが使っているエンコーディングです。 Unicode 文字列がファイルに書き込まれる際、 Unicode 文字列はこのエンコーディングを使ってバイト文字列に変換されます。さらに、ファイルが端末に接続されている場合、この属性は端末が使っているとおぼしきエンコーディング (この情報は端末がうまく設定されていない場合には不正確なこともあります) を与えます。この属性は読み出し専用で、すべてのファイル類似オブジェクトにあるとは限りません。またこの値は <tt class="docutils literal"><span class="pre">None</span></tt> のこともあり、この場合、ファイルは Unicode 文字列の変換のためにシステムのデフォルトエンコーディングを使います。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="file.errors">
<tt class="descclassname">file.</tt><tt class="descname">errors</tt><a class="headerlink" href="#file.errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エンコーディングに用いられる、 Unicode エラーハンドラです。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="file.mode">
<tt class="descclassname">file.</tt><tt class="descname">mode</tt><a class="headerlink" href="#file.mode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルの I/O モードです。ファイルが組み込み関数 <a class="reference internal" href="functions.html#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> で作成された場合、この値は引数 <em>mode</em> の値になります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに存在するとは限りません。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.name">
<tt class="descclassname">file.</tt><tt class="descname">name</tt><a class="headerlink" href="#file.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルオブジェクトが <a class="reference internal" href="functions.html#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> を使って生成された時のファイルの名前です。そうでなければ、ファイルオブジェクト生成の起源を示す何らかの文字列になり、 <tt class="docutils literal"><span class="pre">&lt;...&gt;</span></tt> の形式をとります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに存在するとは限りません。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.newlines">
<tt class="descclassname">file.</tt><tt class="descname">newlines</tt><a class="headerlink" href="#file.newlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python がユニバーサル改行モードを (デフォルトどおり) 有効にしてビルドされているなら、この読み込み専用属性が存在し、ファイルがユニバーサル改行モードで開かれたファイルで、ファイルの読み込み中にあった改行の種類を記録します。取り得る値は <tt class="docutils literal"><span class="pre">'\r'</span></tt>, <tt class="docutils literal"><span class="pre">'\n'</span></tt>, <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>,
<tt class="docutils literal"><span class="pre">None</span></tt> (不明であるか、まだ改行を読み込んでいない)、または、複数の改行方式の種類が存在したことを表す、見つかったすべての改行の種類を含むタプルです。ユニバーサル改行モードで開かれたのでないファイルに対しては、この属性の値は <tt class="docutils literal"><span class="pre">None</span></tt> になります。</p>
</dd></dl>

<dl class="attribute">
<dt id="file.softspace">
<tt class="descclassname">file.</tt><tt class="descname">softspace</tt><a class="headerlink" href="#file.softspace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> 文を使った場合、他の値を出力する前にスペース文字を出力する必要があるかどうかを示すブール値です。ファイルオブジェクトをシミュレート仕様とするクラスは書き込み可能な <a class="reference internal" href="#file.softspace" title="file.softspace"><tt class="xref py py-attr docutils literal"><span class="pre">softspace</span></tt></a> 属性を持たなければならず、この値はゼロに初期化されなければなりません。この値は Python で実装されているほとんどのクラスで自動的に初期化されます (属性へのアクセス手段を上書きするようなオブジェクトでは注意が必要です); C で実装された型では、書き込み可能な <a class="reference internal" href="#file.softspace" title="file.softspace"><tt class="xref py py-attr docutils literal"><span class="pre">softspace</span></tt></a>
属性を提供しなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">この属性は <a class="reference internal" href="../reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> 文を制御するために用いられますが、
<a class="reference internal" href="../reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> の内部状態を乱さないために、その実装を行うことはできません。</p>
</div>
</dd></dl>

</div>
<div class="section" id="typememoryview">
<span id="id20"></span><h2>5.10. メモリビュー型<a class="headerlink" href="#typememoryview" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#memoryview" title="memoryview"><tt class="xref py py-class docutils literal"><span class="pre">memoryview</span></tt></a> オブジェクトは、Python コードがバッファプロトコルをコピーすることなく対応しているオブジェクトの内部データにアクセス出来るようにします。メモリは通常、単純なバイト列として解釈されます。</p>
<dl class="class">
<dt id="memoryview">
<em class="property">class </em><tt class="descname">memoryview</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#memoryview" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> を参照する <a class="reference internal" href="#memoryview" title="memoryview"><tt class="xref py py-class docutils literal"><span class="pre">memoryview</span></tt></a> を作成します。 <em>obj</em> はバッファプロトコルをサポートしていなければなりません。バッファプロトコルをサポートする組み込みオブジェクトには、
<a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> 、 <a class="reference internal" href="functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> などがあります
(ただし、 <a class="reference internal" href="functions.html#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a> は違います)。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><tt class="xref py py-class docutils literal"><span class="pre">memoryview</span></tt></a> には <em>要素</em> の概念があり、それが起源のオブジェクト
<em>obj</em> によって扱われる原子的なメモリの単位になります。多くの単純なオブジェクト、例えば <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> や <a class="reference internal" href="functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> では、要素は単バイトになりますが、他のサードパーティの型では、要素はより大きくなりえます。</p>
<p><tt class="docutils literal"><span class="pre">len(view)</span></tt> は、メモリビュー <em>view</em> の要素の総数を返します。
<a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><tt class="xref py py-class docutils literal"><span class="pre">itemsize</span></tt></a> 属性は、一つの要素内のバイト数を与えます。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><tt class="xref py py-class docutils literal"><span class="pre">memoryview</span></tt></a> はスライスしてデータを晒すことに対応しています。一つのインデクスを取ると、一つの要素を <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> オブジェクトとして返します。完全なスライシングは部分ビューになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="s">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;g&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x77ab28&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">&#39;bce&#39;</span>
</pre></div>
</div>
<p>メモリビューが基にしているオブジェクトがデータの変更に対応していれば、メモリビューはスライス代入に対応します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="s">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">cannot modify size of memoryview object</span>
</pre></div>
</div>
<p>この通り、メモリビューオブジェクトの長さは変えられません。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><tt class="xref py py-class docutils literal"><span class="pre">memoryview</span></tt></a> には 2 つのメソッドがあります。</p>
<dl class="method">
<dt id="memoryview.tobytes">
<tt class="descname">tobytes</tt><big>(</big><big>)</big><a class="headerlink" href="#memoryview.tobytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中のデータをバイト文字列 (クラス <a class="reference internal" href="functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> のオブジェクト)
として返します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">&#39;abc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tolist">
<tt class="descname">tolist</tt><big>(</big><big>)</big><a class="headerlink" href="#memoryview.tolist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中のデータを整数のリストとして返します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">memoryview</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
</pre></div>
</div>
</dd></dl>

<p>読み込み専用の属性もいくつか使えます:</p>
<dl class="attribute">
<dt id="memoryview.format">
<tt class="descname">format</tt><a class="headerlink" href="#memoryview.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ビューのそれぞれの要素に対する、(<a class="reference internal" href="struct.html#module-struct" title="struct: 文字列データをパックされたバイナリデータとして解釈する."><tt class="xref py py-mod docutils literal"><span class="pre">struct</span></tt></a> モジュールのスタイルでの)
フォーマットを含む文字列です。デフォルトは <tt class="docutils literal"><span class="pre">'B'</span></tt> で、単純なバイト文字列です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.itemsize">
<tt class="descname">itemsize</tt><a class="headerlink" href="#memoryview.itemsize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリビューのそれぞれの要素のバイト数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#memoryview.shape" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリの形状を N 次元配列として与える、長さ <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><tt class="xref py py-attr docutils literal"><span class="pre">ndim</span></tt></a> の整数のタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.ndim">
<tt class="descname">ndim</tt><a class="headerlink" href="#memoryview.ndim" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが表す多次元配列が何次元かを示す整数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.strides">
<tt class="descname">strides</tt><a class="headerlink" href="#memoryview.strides" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列のそれぞれの次元に対して、それぞれの要素にアクセスするのに必要なバイト数を表す、長さ <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><tt class="xref py py-attr docutils literal"><span class="pre">ndim</span></tt></a> の整数のタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.readonly">
<tt class="descname">readonly</tt><a class="headerlink" href="#memoryview.readonly" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが読み込み専用かを表すブールです。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="typecontextmanager">
<span id="id21"></span><h2>5.11. コンテキストマネージャ型<a class="headerlink" href="#typecontextmanager" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
<p id="index-34">Python の <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文はコンテキストマネージャによって定義される実行時コンテキストの概念をサポートします。これは、ユーザ定義クラスが文の本体が実行される前に進入し文の終わりで脱出する実行時コンテキストを定義することを許す二つの別々のメソッドを使って実装されます。</p>
<p><em class="dfn">コンテキスト管理プロトコル</em> (<em class="dfn">context management protocol</em>) は実行時コンテキストを定義するコンテキストマネージャオブジェクトが提供すべき一対のメソッドから成ります。</p>
<dl class="method">
<dt id="contextmanager.__enter__">
<tt class="descclassname">contextmanager.</tt><tt class="descname">__enter__</tt><big>(</big><big>)</big><a class="headerlink" href="#contextmanager.__enter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連したオブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャを使う <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文の <a class="reference internal" href="../reference/compound_stmts.html#as"><tt class="xref std std-keyword docutils literal"><span class="pre">as</span></tt></a> 節の識別子に束縛されます。</p>
<p>自分自身を返すコンテキストマネージャの例としてファイルオブジェクトがあります。ファイルオブジェクトは <a class="reference internal" href="#contextmanager.__enter__" title="contextmanager.__enter__"><tt class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></tt></a> から自分自身を返して <a class="reference internal" href="functions.html#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> が <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文のコンテキスト式として使われるようにします。</p>
<p>関連オブジェクトを返すコンテキストマネージャの例としては
<a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><tt class="xref py py-func docutils literal"><span class="pre">decimal.localcontext()</span></tt></a> が返すものがあります。このマネージャはアクティブな10進数コンテキストをオリジナルのコンテキストのコピーにセットしてそのコピーを返します。こうすることで, <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文の本体の内部で、外側のコードに影響を与えずに、
10進数コンテキストを変更できます。</p>
</dd></dl>

<dl class="method">
<dt id="contextmanager.__exit__">
<tt class="descclassname">contextmanager.</tt><tt class="descname">__exit__</tt><big>(</big><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><big>)</big><a class="headerlink" href="#contextmanager.__exit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時コンテキストから抜け、例外 (がもし起こっていたとしても) を抑制することを示すブール値フラグを返します。 <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文の本体を実行中に例外が起こったならば、引数にはその例外の型と値とトレースバック情報を渡します。そうでなければ、引数は全て <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p>このメソッドから真となる値が返されると <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文は例外の発生を抑え、 <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文の直後の文に実行を続けます。そうでなければ、このメソッドの実行を終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は <a class="reference internal" href="../reference/compound_stmts.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> 文の本体の実行中に起こった例外を置き換えてしまいます。</p>
<p>渡された例外を直接的に再送出すべきではありません。その代わりに、このメソッドが偽の値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝えるべきです。このようにすれば
(<tt class="docutils literal"><span class="pre">contextlib.nested</span></tt> のような) コンテキストマネージャは
<a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><tt class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></tt></a> メソッド自体が失敗したのかどうかを簡単に見分けることができます。</p>
</dd></dl>

<p>Python は幾つかのコンテキストマネージャを、易しいスレッド同期・ファイルなどのオブジェクトの即時クローズ・単純化されたアクティブな10進算術コンテキストのサポートのために用意しています。各型はコンテキスト管理プロトコルを実装しているという以上の特別の取り扱いを受けるわけではありません。例については <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: with-構文コンテキストのためのユーティリティ。"><tt class="xref py py-mod docutils literal"><span class="pre">contextlib</span></tt></a> モジュールを参照下さい。</p>
<p>Python のジェネレータ (<a class="reference internal" href="../glossary.html#term-generator"><em class="xref std std-term">generator</em></a>) と
<tt class="docutils literal"><span class="pre">contextlib.contextmanager</span></tt> デコレータ (<a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a>) はこのプロトコルの簡便な実装方法を提供します。ジェネレータ関数を
<tt class="docutils literal"><span class="pre">contextlib.contextmanager</span></tt> でデコレートすると、デコレートしなければ返されるイテレータを返す代わりに、必要な <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><tt class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></tt></a> および
<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><tt class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></tt></a> メソッドを実装したコンテキストマネージャを返すようになります。</p>
<p>これらのメソッドのために Python/C API の中の Python オブジェクトの型構造体に特別なスロットが作られたわけではないことに注意してください。これらのメソッドを定義したい拡張型については通常の Python からアクセスできるメソッドとして提供しなければなりません。実行時コンテキストを準備することに比べたら、一つのクラスの辞書引きは無視できるオーバーヘッドです。</p>
</div>
<div class="section" id="typesother">
<span id="id22"></span><h2>5.12. 他の組み込み型<a class="headerlink" href="#typesother" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>インタプリタはその他の種類のオブジェクトをいくつかサポートします。これらのほとんどは 1 または 2 つの演算だけをサポートします。</p>
<div class="section" id="typesmodules">
<span id="id23"></span><h3>5.12.1. モジュール<a class="headerlink" href="#typesmodules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールに対する唯一の特殊な演算は属性へのアクセス: <tt class="docutils literal"><span class="pre">m.name</span></tt> です。ここで <em>m</em> はモジュールで、 <em>name</em> は <em>m</em> のシンボルテーブル上に定義された名前にアクセスします。モジュール属性も代入することができます。
(<a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文は、厳密にいえば、モジュールオブジェクトに対する演算です; <tt class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></tt> は <em>foo</em> と名づけられたモジュールオブジェクトが存在することを必要とはせず、むしろ <em>foo</em> と名づけられた (外部の) モジュールの <em>定義</em> を必要とします。)</p>
<p>各モジュールの特殊なメンバは <tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> です。これはモジュールのシンボルテーブルを含む辞書です。この辞書を修正すると、実際にはモジュールのシンボルテーブルを変更しますが、 <tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> 属性を直接代入することはできません (<tt class="docutils literal"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></tt> と書いて <tt class="docutils literal"><span class="pre">m.a</span></tt> を <tt class="docutils literal"><span class="pre">1</span></tt>
に定義することはできますが、 <tt class="docutils literal"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></tt> と書くことはできません) 。 <tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> を直接編集するのは推奨されません。</p>
<p>インタプリタ内に組み込まれたモジュールは、 <tt class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'sys'</span>
<span class="pre">(built-in)&gt;</span></tt> のように書かれます。ファイルから読み出された場合、
<tt class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span> <span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></tt> と書かれます。</p>
</div>
<div class="section" id="typesobjects">
<span id="id24"></span><h3>5.12.2. クラスおよびクラスインスタンス<a class="headerlink" href="#typesobjects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらについては <a class="reference internal" href="../reference/datamodel.html#objects"><em>オブジェクト、値、および型</em></a> および <a class="reference internal" href="../reference/compound_stmts.html#class"><em>クラス定義</em></a> を参照下さい。</p>
</div>
<div class="section" id="typesfunctions">
<span id="id25"></span><h3>5.12.3. 関数<a class="headerlink" href="#typesfunctions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数オブジェクトは関数定義によって生成されます。関数オブジェクトに対する唯一の操作は、それを呼び出すことです: <tt class="docutils literal"><span class="pre">func(argument-list)</span></tt></p>
<p>関数オブジェクトには実際には 2 つの種: 組み込み関数とユーザ定義関数があります。両方とも同じ操作 (関数の呼び出し) をサポートしますが、実装は異なるので、オブジェクトの型も異なります。</p>
<p>詳細は、 <a class="reference internal" href="../reference/compound_stmts.html#function"><em>関数定義</em></a> を参照下さい。</p>
</div>
<div class="section" id="typesmethods">
<span id="id26"></span><h3>5.12.4. メソッド<a class="headerlink" href="#typesmethods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-35">メソッドは属性表記を使って呼び出される関数です。メソッドには二つの種類があります: (リストへの <tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt> のような) 組み込みメソッドと、クラスインスタンスのメソッドです。組み込みメソッドはそれをサポートする型と一緒に記述されています。</p>
<p>実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性を追加しています: <tt class="docutils literal"><span class="pre">m.im_self</span></tt> はメソッドが操作するオブジェクトで、
<tt class="docutils literal"><span class="pre">m.im_func</span></tt> はメソッドを実装している関数です。 <tt class="docutils literal"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span>
<span class="pre">arg-n)</span></tt> の呼び出しは、 <tt class="docutils literal"><span class="pre">m.im_func(m.im_self,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span>
<span class="pre">arg-n)</span></tt> の呼び出しと完全に等価です。</p>
<p>クラスインスタンスメソッドには、メソッドがインスタンスからアクセスされるかクラスからアクセスされるかによって、それぞれ <em>バインド</em> または <em>非
バインド</em> があります。メソッドが非バインドメソッドの場合、 <tt class="docutils literal"><span class="pre">im_self</span></tt>
属性は <tt class="docutils literal"><span class="pre">None</span></tt> になるため、呼び出す際には <tt class="docutils literal"><span class="pre">self</span></tt> オブジェクトを明示的に第一引数として指定しなければなりません。この場合、 <tt class="docutils literal"><span class="pre">self</span></tt> は非バインドメソッドのクラス (サブクラス) のインスタンスでなければならず、そうでなければ <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。</p>
<p>関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得できます。しかし、メソッド属性は実際には背後の関数オブジェクト
(<tt class="docutils literal"><span class="pre">meth.im_func</span></tt>) に記憶されているので、バインド、非バインド、メソッドへのメソッド属性の設定は許されていません。メソッド属性の設定を試みると <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。メソッド属性を設定するためには、その背後の関数オブジェクトで明示的に:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">im_func</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s">&#39;my name is c&#39;</span>
</pre></div>
</div>
<p>詳細は、 <a class="reference internal" href="../reference/datamodel.html#types"><em>標準型の階層</em></a> を参照下さい。</p>
</div>
<div class="section" id="bltin-code-objects">
<span id="id27"></span><h3>5.12.5. コードオブジェクト<a class="headerlink" href="#bltin-code-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-36"></span><p id="index-37">コードオブジェクトは、関数本体のような &#8220;擬似コンパイルされた&#8221; Python
の実行可能コードを表すために実装系によって使われます。コードオブジェクトはグローバルな実行環境への参照を持たない点で関数オブジェクトとは異なります。コードオブジェクトは組み込み関数
<a class="reference internal" href="functions.html#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a> によって返され、関数オブジェクトの <tt class="xref py py-attr docutils literal"><span class="pre">func_code</span></tt>
属性として取り出すことができます。 <a class="reference internal" href="code.html#module-code" title="code: read-eval-print ループを実装するのを助ける"><tt class="xref py py-mod docutils literal"><span class="pre">code</span></tt></a> も参照下さい。</p>
<p id="index-38">コードオブジェクトは <a class="reference internal" href="../reference/simple_stmts.html#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文や組み込み関数 <a class="reference internal" href="functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> に
(ソースコード文字列の代わりに) 渡すことで、実行したり値評価したりすることができます。</p>
<p>詳細は、 <a class="reference internal" href="../reference/datamodel.html#types"><em>標準型の階層</em></a> を参照下さい。</p>
</div>
<div class="section" id="bltin-type-objects">
<span id="id28"></span><h3>5.12.6. 型オブジェクト<a class="headerlink" href="#bltin-type-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-39">型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は組み込み関数 <a class="reference internal" href="functions.html#type" title="type"><tt class="xref py py-func docutils literal"><span class="pre">type()</span></tt></a> でアクセスされます。型オブジェクトには特有の操作はありません。標準モジュール <a class="reference internal" href="types.html#module-types" title="types: 組み込み型の名前"><tt class="xref py py-mod docutils literal"><span class="pre">types</span></tt></a> には全ての組み込み型名が定義されています。</p>
<p>型は <tt class="docutils literal"><span class="pre">&lt;type</span> <span class="pre">'int'&gt;</span></tt> のように書き表されます。</p>
</div>
<div class="section" id="bltin-null-object">
<span id="id29"></span><h3>5.12.7. ヌルオブジェクト<a class="headerlink" href="#bltin-null-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは明示的に値を返さない関数によって返されます。このオブジェクトには特有の操作はありません。ヌルオブジェクトは一つだけで、
<tt class="docutils literal"><span class="pre">None</span></tt> (組み込み名) と名づけられています。</p>
<p><tt class="docutils literal"><span class="pre">None</span></tt> と書き表されます。</p>
</div>
<div class="section" id="bltin-ellipsis-object">
<span id="id30"></span><h3>5.12.8. 省略表記オブジェクト<a class="headerlink" href="#bltin-ellipsis-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは拡張スライス表記によって使われます (<a class="reference internal" href="../reference/expressions.html#slicings"><em>スライス表記 (slicing)</em></a>
を参照下さい)。特殊な操作は何もサポートしていません。省略表記オブジェクトは一つだけで、その名前は <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><tt class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></tt></a> (組み込み名) です。</p>
<p><tt class="docutils literal"><span class="pre">Ellipsis</span></tt> と書き表されます。</p>
</div>
<div class="section" id="id31">
<h3>5.12.9. ブール値<a class="headerlink" href="#id31" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ブール値とは二つの定数オブジェクト <tt class="docutils literal"><span class="pre">False</span></tt> および <tt class="docutils literal"><span class="pre">True</span></tt> です。これらは真偽値を表すために使われます (他の値も偽または真とみなされます)
数値処理のコンテキスト (例えば算術演算子の引数として使われた場合) では、これらはそれぞれ 0 および 1 と同様に振舞います。任意の値に対して真偽値を変換できる場合、組み込み関数 <a class="reference internal" href="functions.html#bool" title="bool"><tt class="xref py py-func docutils literal"><span class="pre">bool()</span></tt></a> は値をブール値にキャストするのに使われます (真理値テストの節を参照してください) 。</p>
<p id="index-40">これらはそれぞれ <tt class="docutils literal"><span class="pre">False</span></tt> および <tt class="docutils literal"><span class="pre">True</span></tt> と書き表されます。</p>
</div>
<div class="section" id="typesinternal">
<span id="id32"></span><h3>5.12.10. 内部オブジェクト<a class="headerlink" href="#typesinternal" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スタックフレームオブジェクト、トレースバックオブジェクト、スライスオブジェクト関しては、 <a class="reference internal" href="../reference/datamodel.html#types"><em>標準型の階層</em></a> を参照下さい。</p>
</div>
</div>
<div class="section" id="specialattrs">
<span id="id33"></span><h2>5.13. 特殊な属性<a class="headerlink" href="#specialattrs" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>実装では、いくつかのオブジェクト型に対して、数個の読み出し専用の特殊な属性を追加しています。それぞれ:</p>
<dl class="attribute">
<dt id="object.__dict__">
<tt class="descclassname">object.</tt><tt class="descname">__dict__</tt><a class="headerlink" href="#object.__dict__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書または他のマップ型オブジェクトです。</p>
</dd></dl>

<dl class="attribute">
<dt id="object.__methods__">
<tt class="descclassname">object.</tt><tt class="descname">__methods__</tt><a class="headerlink" href="#object.__methods__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p class="deprecated">
<span class="versionmodified">バージョン 2.2 で撤廃: </span>オブジェクトの属性からなるリストを取得するには、組み込み関数
<a class="reference internal" href="functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> を使ってください。この属性はもう利用できません。</p>
</dd></dl>

<dl class="attribute">
<dt id="object.__members__">
<tt class="descclassname">object.</tt><tt class="descname">__members__</tt><a class="headerlink" href="#object.__members__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p class="deprecated">
<span class="versionmodified">バージョン 2.2 で撤廃: </span>オブジェクトの属性からなるリストを取得するには、組み込み関数
<a class="reference internal" href="functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> を使ってください。この属性はもう利用できません。</p>
</dd></dl>

<dl class="attribute">
<dt id="instance.__class__">
<tt class="descclassname">instance.</tt><tt class="descname">__class__</tt><a class="headerlink" href="#instance.__class__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスインスタンスが属しているクラスです。</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__bases__">
<tt class="descclassname">class.</tt><tt class="descname">__bases__</tt><a class="headerlink" href="#class.__bases__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスオブジェクトの基底クラスからなるタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__name__">
<tt class="descclassname">class.</tt><tt class="descname">__name__</tt><a class="headerlink" href="#class.__name__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスまたは型の名前です。</p>
</dd></dl>

<p>以下の属性は、新しいクラス (<a class="reference internal" href="../glossary.html#term-new-style-class"><em class="xref std std-term">new-style class</em></a>) でのみサポートされます。</p>
<dl class="attribute">
<dt id="class.__mro__">
<tt class="descclassname">class.</tt><tt class="descname">__mro__</tt><a class="headerlink" href="#class.__mro__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性はメソッドの解決に探索される基底クラスのタプルです。</p>
</dd></dl>

<dl class="method">
<dt id="class.mro">
<tt class="descclassname">class.</tt><tt class="descname">mro</tt><big>(</big><big>)</big><a class="headerlink" href="#class.mro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、メタクラスによって、そのインスタンスのメソッド解決の順序をカスタマイズするために、上書きされるかも知れません。これは、クラスインスタンスの作成と呼び、その結果は <a class="reference internal" href="#class.__mro__" title="class.__mro__"><tt class="xref py py-attr docutils literal"><span class="pre">__mro__</span></tt></a>
に格納されます。</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasses__">
<tt class="descclassname">class.</tt><tt class="descname">__subclasses__</tt><big>(</big><big>)</big><a class="headerlink" href="#class.__subclasses__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれの新しいクラスは、それ自身の直接のサブクラスへの弱参照を保持します。このメソッドはそれらの参照のうち、生存しているもののリストを返します。例</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;type &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>これらの特殊なメソッドのさらなる情報は、 Python リファレンスマニュアル (<a class="reference internal" href="../reference/datamodel.html#customization"><em>基本的なカスタマイズ</em></a>) を参照下さい。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>この結果として、リスト <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></tt> は <tt class="docutils literal"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></tt> と等しいと見なされます。タプルの場合も同様です。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[3]</a></td><td>パーザが被演算子の型を識別できるようにするために、このような優先度でなければならないのです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[4]</a></td><td>従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを <em>values</em> に与えなくてはなりません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[5]</a></td><td>改行を残す利点は、空の文字列が返ると EOF を示し、紛らわしくなくなるからです。また、ファイルの最後の行が改行で終わっているかそうでない (ありえることです!) か (例えば、ファイルを行単位で読みながらその完全なコピーを作成した場合には問題になります) を調べることができます。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="6. 組み込み例外"
             >次へ</a> |</li>
        <li class="right" >
          <a href="constants.html" title="4. 組み込み定数"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>