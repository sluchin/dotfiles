

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9.7. itertools — 効率的なループ実行のためのイテレータ生成関数 &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="9. 数値と数学モジュール" href="numeric.html" />
    <link rel="next" title="9.8. functools — 高階関数と呼び出し可能オブジェクトの操作" href="functools.html" />
    <link rel="prev" title="9.6. random — 擬似乱数を生成する" href="random.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="functools.html" title="9.8. functools — 高階関数と呼び出し可能オブジェクトの操作"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="random.html" title="9.6. random — 擬似乱数を生成する"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="numeric.html" accesskey="U">9. 数値と数学モジュール</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.7. <tt class="docutils literal"><span class="pre">itertools</span></tt> &#8212; 効率的なループ実行のためのイテレータ生成関数</a><ul>
<li><a class="reference internal" href="#itertool">9.7.1. Itertool関数</a></li>
<li><a class="reference internal" href="#itertools-recipes">9.7.2. レシピ</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="random.html"
                        title="前の章へ">9.6. <tt class="docutils literal docutils literal"><span class="pre">random</span></tt> &#8212; 擬似乱数を生成する</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="functools.html"
                        title="次の章へ">9.8. <tt class="docutils literal docutils literal"><span class="pre">functools</span></tt> &#8212; 高階関数と呼び出し可能オブジェクトの操作</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/itertools.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-itertools">
<span id="itertools"></span><h1>9.7. <a class="reference internal" href="#module-itertools" title="itertools: 効率的なループ実行のためのイテレータ生成関数。"><tt class="xref py py-mod docutils literal"><span class="pre">itertools</span></tt></a> &#8212; 効率的なループ実行のためのイテレータ生成関数<a class="headerlink" href="#module-itertools" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
<p>このモジュールではイテレータ(<a class="reference internal" href="../glossary.html#term-iterator"><em class="xref std std-term">iterator</em></a>)を構築する部品を実装しています。プログラム言語 APL, Haskell, SML からアイデアを得ていますが、
Python に適した形に修正されています。</p>
<p>このモジュールは、高速でメモリ効率に優れ、単独でも組合せても使用することのできるツールを標準化したものです。同時に、このツール群は &#8220;イテレータの代数&#8221; を構成していて、 pure Python
で簡潔かつ効率的なツールを作れるようにしています。</p>
<p>例えば、SML の作表ツール <tt class="docutils literal"><span class="pre">tabulate(f)</span></tt> は <tt class="docutils literal"><span class="pre">f(0),</span> <span class="pre">f(1),</span> <span class="pre">...</span></tt>
のシーケンスを作成します。同じことを Python では <a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> と <a class="reference internal" href="#itertools.count" title="itertools.count"><tt class="xref py py-func docutils literal"><span class="pre">count()</span></tt></a> を組合せて
<tt class="docutils literal"><span class="pre">imap(f,</span> <span class="pre">count())</span></tt> という形で実現できます。</p>
<p>これらのツールと、対をなすビルトインの組合せは、 <a class="reference internal" href="operator.html#module-operator" title="operator: 標準演算子に対応する関数"><tt class="xref py py-mod docutils literal"><span class="pre">operator</span></tt></a> モジュールにある高速な関数を使うことでうまく実現できます。例えば、乗算演算子を二つのベクタにmapすることで効率的なドット積ができます:
<tt class="docutils literal"><span class="pre">sum(imap(operator.mul,</span> <span class="pre">vector1,</span> <span class="pre">vector2))</span></tt></p>
<p><strong>無限イテレータ:</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="39%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">イテレータ</th>
<th class="head">引数</th>
<th class="head">結果</th>
<th class="head">例</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#itertools.count" title="itertools.count"><tt class="xref py py-func docutils literal"><span class="pre">count()</span></tt></a></td>
<td>start, [step]</td>
<td>start, start+step, start+2*step, ...</td>
<td><tt class="docutils literal"><span class="pre">count(10)</span> <span class="pre">--&gt;</span> <span class="pre">10</span> <span class="pre">11</span> <span class="pre">12</span> <span class="pre">13</span> <span class="pre">14</span> <span class="pre">...</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.cycle" title="itertools.cycle"><tt class="xref py py-func docutils literal"><span class="pre">cycle()</span></tt></a></td>
<td>p</td>
<td>p0, p1, ... plast, p0, p1, ...</td>
<td><tt class="docutils literal"><span class="pre">cycle('ABCD')</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">...</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.repeat" title="itertools.repeat"><tt class="xref py py-func docutils literal"><span class="pre">repeat()</span></tt></a></td>
<td>elem [,n]</td>
<td>elem, elem, elem, ... 無限もしくは n 回</td>
<td><tt class="docutils literal"><span class="pre">repeat(10,</span> <span class="pre">3)</span> <span class="pre">--&gt;</span> <span class="pre">10</span> <span class="pre">10</span> <span class="pre">10</span></tt></td>
</tr>
</tbody>
</table>
<p><strong>一番短い入力シーケンスで止まるイテレータ:</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="18%" />
<col width="32%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">イテレータ</th>
<th class="head">引数</th>
<th class="head">結果</th>
<th class="head">例</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#itertools.chain" title="itertools.chain"><tt class="xref py py-func docutils literal"><span class="pre">chain()</span></tt></a></td>
<td>p, q, ...</td>
<td>p0, p1, ... plast, q0, q1, ...</td>
<td><tt class="docutils literal"><span class="pre">chain('ABC',</span> <span class="pre">'DEF')</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">E</span> <span class="pre">F</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.compress" title="itertools.compress"><tt class="xref py py-func docutils literal"><span class="pre">compress()</span></tt></a></td>
<td>data, selectors</td>
<td>(d[0] if s[0]), (d[1] if s[1]), ...</td>
<td><tt class="docutils literal"><span class="pre">compress('ABCDEF',</span> <span class="pre">[1,0,1,0,1,1])</span> <span class="pre">--&gt;</span> <span class="pre">A</span> <span class="pre">C</span> <span class="pre">E</span> <span class="pre">F</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.dropwhile" title="itertools.dropwhile"><tt class="xref py py-func docutils literal"><span class="pre">dropwhile()</span></tt></a></td>
<td>pred, seq</td>
<td>seq[n], seq[n+1], pred が偽の場所から始まる</td>
<td><tt class="docutils literal"><span class="pre">dropwhile(lambda</span> <span class="pre">x:</span> <span class="pre">x&lt;5,</span> <span class="pre">[1,4,6,4,1])</span> <span class="pre">--&gt;</span> <span class="pre">6</span> <span class="pre">4</span> <span class="pre">1</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><tt class="xref py py-func docutils literal"><span class="pre">groupby()</span></tt></a></td>
<td>iterable[, keyfunc]</td>
<td>keyfunc(v) の値でグループ化したサブイテレータ</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.ifilter" title="itertools.ifilter"><tt class="xref py py-func docutils literal"><span class="pre">ifilter()</span></tt></a></td>
<td>pred, seq</td>
<td>pred(elem) が真になるseqの要素</td>
<td><tt class="docutils literal"><span class="pre">ifilter(lambda</span> <span class="pre">x:</span> <span class="pre">x%2,</span> <span class="pre">range(10))</span> <span class="pre">--&gt;</span> <span class="pre">1</span> <span class="pre">3</span> <span class="pre">5</span> <span class="pre">7</span> <span class="pre">9</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.ifilterfalse" title="itertools.ifilterfalse"><tt class="xref py py-func docutils literal"><span class="pre">ifilterfalse()</span></tt></a></td>
<td>pred, seq</td>
<td>pred(elem) が偽になるseqの要素</td>
<td><tt class="docutils literal"><span class="pre">ifilterfalse(lambda</span> <span class="pre">x:</span> <span class="pre">x%2,</span> <span class="pre">range(10))</span> <span class="pre">--&gt;</span> <span class="pre">0</span> <span class="pre">2</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">8</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.islice" title="itertools.islice"><tt class="xref py py-func docutils literal"><span class="pre">islice()</span></tt></a></td>
<td>seq, [start,] stop [, step]</td>
<td>seq[start:stop:step]</td>
<td><tt class="docutils literal"><span class="pre">islice('ABCDEFG',</span> <span class="pre">2,</span> <span class="pre">None)</span> <span class="pre">--&gt;</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">E</span> <span class="pre">F</span> <span class="pre">G</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a></td>
<td>func, p, q, ...</td>
<td>func(p0, q0), func(p1, q1), ...</td>
<td><tt class="docutils literal"><span class="pre">imap(pow,</span> <span class="pre">(2,3,10),</span> <span class="pre">(5,2,3))</span> <span class="pre">--&gt;</span> <span class="pre">32</span> <span class="pre">9</span> <span class="pre">1000</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><tt class="xref py py-func docutils literal"><span class="pre">starmap()</span></tt></a></td>
<td>func, seq</td>
<td>func(*seq[0]), func(*seq[1]), ...</td>
<td><tt class="docutils literal"><span class="pre">starmap(pow,</span> <span class="pre">[(2,5),</span> <span class="pre">(3,2),</span> <span class="pre">(10,3)])</span> <span class="pre">--&gt;</span> <span class="pre">32</span> <span class="pre">9</span> <span class="pre">1000</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.tee" title="itertools.tee"><tt class="xref py py-func docutils literal"><span class="pre">tee()</span></tt></a></td>
<td>it, n</td>
<td>it1, it2 , ... itn  一つのイテレータを n 個に分ける</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><tt class="xref py py-func docutils literal"><span class="pre">takewhile()</span></tt></a></td>
<td>pred, seq</td>
<td>seq[0], seq[1], pred が偽になるまで</td>
<td><tt class="docutils literal"><span class="pre">takewhile(lambda</span> <span class="pre">x:</span> <span class="pre">x&lt;5,</span> <span class="pre">[1,4,6,4,1])</span> <span class="pre">--&gt;</span> <span class="pre">1</span> <span class="pre">4</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.izip" title="itertools.izip"><tt class="xref py py-func docutils literal"><span class="pre">izip()</span></tt></a></td>
<td>p, q, ...</td>
<td>(p[0], q[0]), (p[1], q[1]), ...</td>
<td><tt class="docutils literal"><span class="pre">izip('ABCD',</span> <span class="pre">'xy')</span> <span class="pre">--&gt;</span> <span class="pre">Ax</span> <span class="pre">By</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.izip_longest" title="itertools.izip_longest"><tt class="xref py py-func docutils literal"><span class="pre">izip_longest()</span></tt></a></td>
<td>p, q, ...</td>
<td>(p[0], q[0]), (p[1], q[1]), ...</td>
<td><tt class="docutils literal"><span class="pre">izip_longest('ABCD',</span> <span class="pre">'xy',</span> <span class="pre">fillvalue='-')</span> <span class="pre">--&gt;</span> <span class="pre">Ax</span> <span class="pre">By</span> <span class="pre">C-</span> <span class="pre">D-</span></tt></td>
</tr>
</tbody>
</table>
<p><strong>組合せジェネレータ:</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="16%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">イテレータ</th>
<th class="head">引数</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#itertools.product" title="itertools.product"><tt class="xref py py-func docutils literal"><span class="pre">product()</span></tt></a></td>
<td>p, q, ... [repeat=1]</td>
<td>デカルト積、ネストしたforループと等価</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><tt class="xref py py-func docutils literal"><span class="pre">permutations()</span></tt></a></td>
<td>p[, r]</td>
<td>長さrのタプル列, 繰り返しを許さない順列</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#itertools.combinations" title="itertools.combinations"><tt class="xref py py-func docutils literal"><span class="pre">combinations()</span></tt></a></td>
<td>p, r</td>
<td>長さrのタプル列, 繰り返しを許さない組合せ</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><tt class="xref py py-func docutils literal"><span class="pre">combinations_with_replacement()</span></tt></a></td>
<td>p, r</td>
<td>長さrのタプル列, 繰り返しを許した組合せ</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">product('ABCD',</span> <span class="pre">repeat=2)</span></tt></td>
<td>&nbsp;</td>
<td><tt class="docutils literal"><span class="pre">AA</span> <span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BA</span> <span class="pre">BB</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CA</span> <span class="pre">CB</span> <span class="pre">CC</span> <span class="pre">CD</span> <span class="pre">DA</span> <span class="pre">DB</span> <span class="pre">DC</span> <span class="pre">DD</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">permutations('ABCD',</span> <span class="pre">2)</span></tt></td>
<td>&nbsp;</td>
<td><tt class="docutils literal"><span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BA</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CA</span> <span class="pre">CB</span> <span class="pre">CD</span> <span class="pre">DA</span> <span class="pre">DB</span> <span class="pre">DC</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">combinations('ABCD',</span> <span class="pre">2)</span></tt></td>
<td>&nbsp;</td>
<td><tt class="docutils literal"><span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CD</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">combinations_with_replacement('ABCD',</span> <span class="pre">2)</span></tt></td>
<td>&nbsp;</td>
<td><tt class="docutils literal"><span class="pre">AA</span> <span class="pre">AB</span> <span class="pre">AC</span> <span class="pre">AD</span> <span class="pre">BB</span> <span class="pre">BC</span> <span class="pre">BD</span> <span class="pre">CC</span> <span class="pre">CD</span> <span class="pre">DD</span></tt></td>
</tr>
</tbody>
</table>
<div class="section" id="itertool">
<span id="itertools-functions"></span><h2>9.7.1. Itertool関数<a class="headerlink" href="#itertool" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数は全て、イテレータを作成して返します。無限長のストリームのイテレータを返す関数もあり、この場合にはストリームを中断するような関数かループ処理から使用しなければなりません。</p>
<dl class="function">
<dt id="itertools.chain">
<tt class="descclassname">itertools.</tt><tt class="descname">chain</tt><big>(</big><em>*iterables</em><big>)</big><a class="headerlink" href="#itertools.chain" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>先頭の iterable の全要素を返し、次に2番目の iterable の全要素…と全 iterable の要素を返すイテレータを作成します。連続したシーケンスを、一つのシーケンスとして扱う場合に使用します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c"># chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="itertools.chain.from_iterable">
<em class="property">classmethod </em><tt class="descclassname">chain.</tt><tt class="descname">from_iterable</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#itertools.chain.from_iterable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もう一つの <a class="reference internal" href="#itertools.chain" title="itertools.chain"><tt class="xref py py-func docutils literal"><span class="pre">chain()</span></tt></a> のためのコンストラクタです。遅延評価される唯一のイテラブル引数から連鎖した入力を受け取ります。この関数は以下のコードと等価です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_iterable</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c"># chain.from_iterable([&#39;ABC&#39;, &#39;DEF&#39;]) --&gt; A B C D E F</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.combinations">
<tt class="descclassname">itertools.</tt><tt class="descname">combinations</tt><big>(</big><em>iterable</em>, <em>r</em><big>)</big><a class="headerlink" href="#itertools.combinations" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>入力 <em>iterable</em> の要素からなる長さ <em>r</em> の部分列を返します。</p>
<p>組合せ(combination)は辞書式順序で出力されます。したがって、入力 <em>iterable</em> がソートされていれば、組合せのタプルは整列された形で生成されます。</p>
<p>各要素は場所に基づいて一意に取り扱われ、値には依りません。入力された要素がバラバラならば、各組合せの中に重複した値は現れません。</p>
<p>この関数は以下のコードと等価です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c"># combinations(&#39;ABCD&#39;, 2) --&gt; AB AC AD BC BD CD</span>
    <span class="c"># combinations(range(4), 3) --&gt; 012 013 023 123</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">combination()</span></tt> のコードは <a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><tt class="xref py py-func docutils literal"><span class="pre">permutations()</span></tt></a> のシーケンスから
(入力プールでの位置に応じた順序で)
要素がソートされていないものをフィルターしたようにも表現できます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p>返される要素の数は、 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt> の場合は、 <tt class="docutils literal"><span class="pre">n!</span> <span class="pre">/</span> <span class="pre">r!</span> <span class="pre">/</span> <span class="pre">(n-r)!</span></tt>
で、 <tt class="docutils literal"><span class="pre">r</span> <span class="pre">&gt;</span> <span class="pre">n</span></tt> の場合は 0 です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.combinations_with_replacement">
<tt class="descclassname">itertools.</tt><tt class="descname">combinations_with_replacement</tt><big>(</big><em>iterable</em>, <em>r</em><big>)</big><a class="headerlink" href="#itertools.combinations_with_replacement" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>入力 <em>iterable</em> から、それぞれの要素が複数回現れることを許して、長さ <em>r</em> の要素の部分列を返します。</p>
<p>組合せは、辞書的に並べられた順序で出力されます。ですから、入力 <em>iterable</em> がソートされていれば、組合せのタプルはソートされた順に生成されます。</p>
<p>要素は、値ではなく位置に基づいて一意に扱われます。ですから、入力の要素が一意であれば、生成された組合せも一意になります。</p>
<p>以下と等価です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">combinations_with_replacement</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c"># combinations_with_replacement(&#39;ABC&#39;, 2) --&gt; AA AB AC BB BC CC</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><tt class="xref py py-func docutils literal"><span class="pre">combinations_with_replacement()</span></tt></a> のコードは、 <a class="reference internal" href="#itertools.product" title="itertools.product"><tt class="xref py py-func docutils literal"><span class="pre">product()</span></tt></a> の部分列から、要素が (入力プールの位置に従って) ソートされた順になっていない項目をフィルタリングしたものとしても表せます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">combinations_with_replacement</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p>返される要素の数は、 <tt class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt> のとき <tt class="docutils literal"><span class="pre">(n+r-1)!</span> <span class="pre">/</span> <span class="pre">r!</span> <span class="pre">/</span> <span class="pre">(n-1)!</span></tt> です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.compress">
<tt class="descclassname">itertools.</tt><tt class="descname">compress</tt><big>(</big><em>data</em>, <em>selectors</em><big>)</big><a class="headerlink" href="#itertools.compress" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>data</em> の要素から、 <em>selectors</em> の対応する要素が <tt class="docutils literal"><span class="pre">True</span></tt> と評価されるものだけを返す、フィルタリングしたイテレータを作ります。
<em>data</em> と <em>selectors</em> のどちらかが尽きたときに止まります。以下と等価です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">selectors</span><span class="p">):</span>
    <span class="c"># compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">selectors</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.7 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.count">
<tt class="descclassname">itertools.</tt><tt class="descname">count</tt><big>(</big><em>start=0</em>, <em>step=1</em><big>)</big><a class="headerlink" href="#itertools.count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>n</em> で始まる、等間隔の値を返すイテレータを作成します。
<a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> で連続したデータの生成によく使われます。また、 <a class="reference internal" href="#itertools.izip" title="itertools.izip"><tt class="xref py py-func docutils literal"><span class="pre">izip()</span></tt></a> にシーケンス番号を追加するのにも使われます。この関数は以下のスクリプトと同等です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">step</span>
</pre></div>
</div>
<p>浮動小数点数で数えるときは、 <tt class="docutils literal"><span class="pre">(start</span> <span class="pre">+</span> <span class="pre">step</span> <span class="pre">*</span> <span class="pre">i</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">count())</span></tt>
のように、掛け算を使ったコードに置き換えたほうが正確にできることがあります。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span><em>step</em> 引数を追加し、非整数の引数を取れるようになりました。</p>
</dd></dl>

<dl class="function">
<dt id="itertools.cycle">
<tt class="descclassname">itertools.</tt><tt class="descname">cycle</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#itertools.cycle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>iterable から要素を取得し、同時にそのコピーを保存するイテレータを作成します。
iterable の全要素を返すと、セーブされたコピーから要素を返し、これを無限に繰り返します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="c"># cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D A B C D ...</span>
    <span class="n">saved</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">element</span>
        <span class="n">saved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">saved</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">saved</span><span class="p">:</span>
              <span class="k">yield</span> <span class="n">element</span>
</pre></div>
</div>
<p><a class="reference internal" href="#itertools.cycle" title="itertools.cycle"><tt class="xref py py-func docutils literal"><span class="pre">cycle()</span></tt></a> は大きなメモリ領域を使用します。使用するメモリ量は iterable の大きさに依存します。</p>
</dd></dl>

<dl class="function">
<dt id="itertools.dropwhile">
<tt class="descclassname">itertools.</tt><tt class="descname">dropwhile</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.dropwhile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>predicate が真である限りは要素を無視し、その後は全ての要素を返すイテレータを作成します。このイテレータは、predicate が最初に偽になるまで <em>全く</em> 要素を返さないため、要素を返し始めるまでに長い時間がかかる場合があります。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dropwhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</span>
    <span class="n">iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
            <span class="k">break</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="itertools.groupby">
<tt class="descclassname">itertools.</tt><tt class="descname">groupby</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.groupby" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>同じキーをもつような要素からなる <em>iterable</em> 中のグループに対して、キーとグループを返すようなイテレータを作成します。 <em>key</em>
は各要素に対するキー値を計算する関数です。キーを指定しない場合や <tt class="docutils literal"><span class="pre">None</span></tt> にした場合、
<em>key</em> 関数のデフォルトは恒等関数になり要素をそのまま返します。通常、 <em>iterable</em> は同じキー関数で並べ替え済みである必要があります。</p>
<p><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><tt class="xref py py-func docutils literal"><span class="pre">groupby()</span></tt></a> の操作は Unix の <tt class="docutils literal"><span class="pre">uniq</span></tt> フィルターと似ています。
key 関数の値が変わるたびに休止または新しいグループを生成します
(このために通常同じ key 関数でソートしておく必要があるのです)。この動作は SQL の入力順に関係なく共通の要素を集約する GROUP BY とは違ます。</p>
<p>返されるグループはそれ自体がイテレータで、 <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><tt class="xref py py-func docutils literal"><span class="pre">groupby()</span></tt></a> と
<em>iterable</em> を共有しています。もととなる <em>iterable</em> を共有しているため、
<a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><tt class="xref py py-func docutils literal"><span class="pre">groupby()</span></tt></a> オブジェクトの要素取り出しを先に進めると、それ以前の要素であるグループは見えなくなってしまいます。従って、データが後で必要な場合にはリストの形で保存しておく必要があります：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">uniquekeys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">keyfunc</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keyfunc</span><span class="p">):</span>
    <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>      <span class="c"># Store group iterator as a list</span>
    <span class="n">uniquekeys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><tt class="xref py py-func docutils literal"><span class="pre">groupby()</span></tt></a> は以下のコードと等価です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">groupby</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># [k for k, g in groupby(&#39;AAAABBBCCDAABBB&#39;)] --&gt; A B C D A B</span>
    <span class="c"># [list(g) for k, g in groupby(&#39;AAAABBBCCD&#39;)] --&gt; AAAA BBB CC D</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">it</span><span class="p">)</span>    <span class="c"># Exit on StopIteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currkey</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grouper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tgtkey</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">_grouper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tgtkey</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">==</span> <span class="n">tgtkey</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">it</span><span class="p">)</span>    <span class="c"># Exit on StopIteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currvalue</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.ifilter">
<tt class="descclassname">itertools.</tt><tt class="descname">ifilter</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.ifilter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>predicate が <tt class="docutils literal"><span class="pre">True</span></tt> となる要素だけを返すイテレータを作成します。
<em>predicate</em> が <tt class="docutils literal"><span class="pre">None</span></tt> の場合、値が真であるアイテムだけを返します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">ifilter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># ifilter(lambda x: x%2, range(10)) --&gt; 1 3 5 7 9</span>
    <span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">predicate</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="itertools.ifilterfalse">
<tt class="descclassname">itertools.</tt><tt class="descname">ifilterfalse</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.ifilterfalse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>predicateが <tt class="docutils literal"><span class="pre">False</span></tt> となる要素だけを返すイテレータを作成します。
<em>predicate</em> が <tt class="docutils literal"><span class="pre">None</span></tt> の場合、値が偽であるアイテムだけを返します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">ifilterfalse</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># ifilterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</span>
    <span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">predicate</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="itertools.imap">
<tt class="descclassname">itertools.</tt><tt class="descname">imap</tt><big>(</big><em>function</em>, <em>*iterables</em><big>)</big><a class="headerlink" href="#itertools.imap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>iterables の要素を引数として funtion を呼び出すイテレータを作成します。
<em>function</em> が <tt class="docutils literal"><span class="pre">None</span></tt> の場合、引数のタプルを返します。
<a class="reference internal" href="functions.html#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a> と似ていますが、最短の iterable の末尾まで到達した後は
<tt class="docutils literal"><span class="pre">None</span></tt> を補って処理を続行するのではなく、終了します。これは、
<a class="reference internal" href="functions.html#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a> に無限長のイテレータを指定するのは多くの場合誤りですが
(全出力が評価されてしまうため)、
<a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> の場合には一般的で役に立つ方法であるためです。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">imap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c"># imap(pow, (2,3,10), (5,2,3)) --&gt; 32 9 1000</span>
    <span class="n">iterables</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="n">iterables</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="itertools.islice">
<tt class="descclassname">itertools.</tt><tt class="descname">islice</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.islice" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>iterable から要素を選択して返すイテレータを作成します。
<em>start</em> が0以外であれば、iterable の先頭要素は start に達するまでスキップします。以降、 <em>step</em> が1以下なら連続した要素を返し、
1以上なら指定された値分の要素をスキップします。
<em>stop</em> が <tt class="docutils literal"><span class="pre">None</span></tt> であれば、無限に、もしくは iterable の全要素を返すまで値を返します。
<tt class="docutils literal"><span class="pre">None</span></tt> 以外ならイテレータは指定された要素位置で停止します。通常のスライスと異なり、 <em>start</em> 、
<em>stop</em> 、 <em>step</em> に負の値を指定する事はできません。シーケンス化されたデータから関連するデータを取得する場合（複数行からなるレポートで、三行ごとに名前が指定されている場合など）に使用します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 2) --&gt; A B</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 2, 4) --&gt; C D</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 2, None) --&gt; C D E F G</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 0, None, 2) --&gt; A C E G</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">nexti</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nexti</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
            <span class="n">nexti</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</pre></div>
</div>
<p><em>start</em> が <tt class="docutils literal"><span class="pre">None</span></tt> ならば、繰返しは0から始まります。
<em>step</em> が <tt class="docutils literal"><span class="pre">None</span></tt> ならば、ステップは1となります。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span><em>start</em> と <em>step</em> はデフォルト値として <tt class="docutils literal"><span class="pre">None</span></tt> を受け付けます。</p>
</dd></dl>

<dl class="function">
<dt id="itertools.izip">
<tt class="descclassname">itertools.</tt><tt class="descname">izip</tt><big>(</big><em>*iterables</em><big>)</big><a class="headerlink" href="#itertools.izip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>各 iterable の要素をまとめるイテレータを作成します。
<a class="reference internal" href="functions.html#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a> に似ていますが、リストではなくイテレータを返します。複数のイテレート可能オブジェクトに対して、同じ繰り返し処理を同時に行う場合に使用します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">izip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c"># izip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By</span>
    <span class="n">iterables</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="n">iterables</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">iterables</span><span class="p">))</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>イテレート可能オブジェクトを指定しない場合、
<a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外を送出する代わりに長さゼロのイテレータを返します。</p>
<p>イテレート可能オブジェクトの左から右への評価順序は保証されます。このことによって、データ列を長さnのグループにまとめる常套句
<tt class="docutils literal"><span class="pre">izip(*[iter(s)]*n)</span></tt> が実現可能になります。</p>
<p><a class="reference internal" href="#itertools.izip" title="itertools.izip"><tt class="xref py py-func docutils literal"><span class="pre">izip()</span></tt></a> を長さが不揃いな入力に使うのは、残され使われなかった長い方のイテレート可能オブジェクトの値を気にしない時だけにするべきです。こういった値が重要ならば <a class="reference internal" href="#itertools.izip_longest" title="itertools.izip_longest"><tt class="xref py py-func docutils literal"><span class="pre">izip_longest()</span></tt></a> を代わりに使ってください。</p>
</dd></dl>

<dl class="function">
<dt id="itertools.izip_longest">
<tt class="descclassname">itertools.</tt><tt class="descname">izip_longest</tt><big>(</big><em>*iterables</em><span class="optional">[</span>, <em>fillvalue</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.izip_longest" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>各 iterable の要素をまとめるイテレータを作成します。イテレート可能オブジェクトの長さが不揃いならば、足りない値は <em>fillvalue</em>
で埋められます。最も長いイテレート可能オブジェクトが尽きるまで繰り返されます。この関数は以下のコードと等価です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">izip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="c"># izip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&gt; Ax By C- D-</span>
    <span class="n">fillvalue</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;fillvalue&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sentinel</span><span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="p">([</span><span class="n">fillvalue</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">pop</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">counter</span><span class="p">()</span>         <span class="c"># yields the fillvalue, or raises IndexError</span>
    <span class="n">fillers</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">)</span>
    <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">chain</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">(),</span> <span class="n">fillers</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="o">*</span><span class="n">iters</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">tup</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>もしイテラブルの内一つでも潜在的に無限列であれば、
<a class="reference internal" href="#itertools.izip_longest" title="itertools.izip_longest"><tt class="xref py py-func docutils literal"><span class="pre">izip_longest()</span></tt></a> 関数の呼出しを呼び出し回数を制限する何か
(たとえば <a class="reference internal" href="#itertools.islice" title="itertools.islice"><tt class="xref py py-func docutils literal"><span class="pre">islice()</span></tt></a> や <a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><tt class="xref py py-func docutils literal"><span class="pre">takewhile()</span></tt></a>)
で包むべきです。
<em>fillvalue</em> が指定されない場合のデフォルトは <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.permutations">
<tt class="descclassname">itertools.</tt><tt class="descname">permutations</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>r</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.permutations" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素からなる長さ <em>r</em> の置換(permutation)を次々と返します。</p>
<p><em>r</em> が指定されないかまたは <tt class="docutils literal"><span class="pre">None</span></tt> であるならば、
<em>r</em> のデフォルトは <em>iterable</em> の長さとなり全ての可能な最長の置換が生成されます。</p>
<p>置換は辞書式にソートされた順序で吐き出されます。したがって入力の <em>iterable</em> がソートされていたならば、置換のタプルはソートされた状態で出力されます。</p>
<p>要素は位置に基づいて一意的に扱われ、値に基づいてではありません。したがって入力された要素が全て異なっているならば、それぞれの置換に重複した要素が現れないことになります。</p>
<p>以下と等価です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># permutations(&#39;ABCD&#39;, 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span>
    <span class="c"># permutations(range(3)) --&gt; 012 021 102 120 201 210</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">cycles</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
</pre></div>
</div>
<p><a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><tt class="xref py py-func docutils literal"><span class="pre">permutations()</span></tt></a> のコードは <a class="reference internal" href="#itertools.product" title="itertools.product"><tt class="xref py py-func docutils literal"><span class="pre">product()</span></tt></a> の列から重複のあるもの
(それらは入力プールの同じ位置から取られたものです)
を除外するようにフィルタを掛けたものとしても表現できます：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p>返される要素の数は、 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt> の場合 <tt class="docutils literal"><span class="pre">n!</span> <span class="pre">/</span> <span class="pre">(n-r)!</span></tt>
で、 <tt class="docutils literal"><span class="pre">r</span> <span class="pre">&gt;</span> <span class="pre">n</span></tt> の場合は 0 です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.product">
<tt class="descclassname">itertools.</tt><tt class="descname">product</tt><big>(</big><em>*iterables</em><span class="optional">[</span>, <em>repeat</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.product" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>入力イテラブルの直積(Cartesian product)です。</p>
<p>ジェネレータ式の入れ子 for ループと等価になります。たとえば <tt class="docutils literal"><span class="pre">product(A,</span> <span class="pre">B)</span></tt> は <tt class="docutils literal"><span class="pre">((x,y)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">B)</span></tt>
と同じものを返します。</p>
<p>入れ子ループは走行距離計と同じように右端の要素がイテレーションごとに更新されていきます。このパターンは辞書式順序を作り出し、入力のイテレート可能オブジェクトたちがソートされていれば、直積タプルもソートされた順に吐き出されます。</p>
<p>イテラブル自身との直積を計算するためには、オプションの <em>repeat</em> キーワード引数に繰り返し回数を指定します。たとえば <tt class="docutils literal"><span class="pre">product(A,</span> <span class="pre">repeat=4)</span></tt> は  <tt class="docutils literal"><span class="pre">product(A,</span> <span class="pre">A,</span> <span class="pre">A,</span> <span class="pre">A)</span></tt>
と同じ意味です。</p>
<p>この関数は以下のコードと等価ですが、実際の実装ではメモリ中に中間結果を作りません：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="c"># product(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax Ay Bx By Cx Cy Dx Dy</span>
    <span class="c"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span>
    <span class="n">pools</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;repeat&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="itertools.repeat">
<tt class="descclassname">itertools.</tt><tt class="descname">repeat</tt><big>(</big><em>object</em><span class="optional">[</span>, <em>times</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.repeat" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>繰り返し <em>object</em> を返すイテレータを作成します。
<em>times</em> を指定しない場合、無限に値を返し続けます。
<a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> で常に同じオブジェクトを関数の引数として指定する場合に使用します。また、 <a class="reference internal" href="#itertools.izip" title="itertools.izip"><tt class="xref py py-func docutils literal"><span class="pre">izip()</span></tt></a>
で作成するタプルの定数部分を指定する場合にも使用することもできます。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># repeat(10, 3) --&gt; 10 10 10</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">object</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">object</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="itertools.starmap">
<tt class="descclassname">itertools.</tt><tt class="descname">starmap</tt><big>(</big><em>function</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.starmap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>iterables の要素を引数として funtion を呼び出すイテレータを作成します。
function の引数が単一の iterable にタプルとして格納されている場合(&#8220;zip済み&#8221;)、
<a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> の代わりに使用します。 <a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> と
<a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><tt class="xref py py-func docutils literal"><span class="pre">starmap()</span></tt></a> ではfunctionの呼び出し方法が異なり、
<a class="reference internal" href="#itertools.imap" title="itertools.imap"><tt class="xref py py-func docutils literal"><span class="pre">imap()</span></tt></a> は <tt class="docutils literal"><span class="pre">function(a,b)</span></tt> 、 <a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><tt class="xref py py-func docutils literal"><span class="pre">starmap()</span></tt></a> では
<tt class="docutils literal"><span class="pre">function(*c)</span></tt> のように呼び出します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">starmap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</span>
    <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>以前のバージョンでは、
<a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><tt class="xref py py-func docutils literal"><span class="pre">starmap()</span></tt></a> は関数の引数がタプルであることが必要でした。
このバージョンからどんなイテレート可能オブジェクトでも良くなりました。</p>
</dd></dl>

<dl class="function">
<dt id="itertools.takewhile">
<tt class="descclassname">itertools.</tt><tt class="descname">takewhile</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.takewhile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>predicate が真である限り iterable から要素を返すイテレータを作成します。この関数は以下のスクリプトと同等です：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">takewhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">iterable</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="itertools.tee">
<tt class="descclassname">itertools.</tt><tt class="descname">tee</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>n=2</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.tee" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一つの <em>iterable</em> から <em>n</em> 個の独立したイテレータを生成して返します。以下のコードと等価になります：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">deques</span> <span class="o">=</span> <span class="p">[</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">mydeque</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mydeque</span><span class="p">:</span>             <span class="c"># when the local deque is empty</span>
                <span class="n">newval</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>       <span class="c"># fetch a new value and</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deques</span><span class="p">:</span>        <span class="c"># load it to all the deques</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newval</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">mydeque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deques</span><span class="p">)</span>
</pre></div>
</div>
<p>一度 <a class="reference internal" href="#itertools.tee" title="itertools.tee"><tt class="xref py py-func docutils literal"><span class="pre">tee()</span></tt></a> でイテレータを分割すると、もとの <em>iterable</em> を他で使ってはいけません。さもなければ、 <a class="reference internal" href="#itertools.tee" title="itertools.tee"><tt class="xref py py-func docutils literal"><span class="pre">tee()</span></tt></a> オブジェクトの知らない間に
<em>iterable</em> が先の要素に進んでしまうことになります。</p>
<p><a class="reference internal" href="#itertools.tee" title="itertools.tee"><tt class="xref py py-func docutils literal"><span class="pre">tee()</span></tt></a> はかなり大きなメモリ領域を使用するかもしれません
(使用するメモリ量はiterableの大きさに依存します)。一般には、一つのイテレータが他のイテレータよりも先にほとんどまたは全ての要素を消費するような場合には、
<a class="reference internal" href="#itertools.tee" title="itertools.tee"><tt class="xref py py-func docutils literal"><span class="pre">tee()</span></tt></a> よりも <a class="reference internal" href="functions.html#list" title="list"><tt class="xref py py-func docutils literal"><span class="pre">list()</span></tt></a>
を使った方が高速です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

</div>
<div class="section" id="itertools-recipes">
<span id="id1"></span><h2>9.7.2. レシピ<a class="headerlink" href="#itertools-recipes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節では、既存の itertools を素材としてツールセットを拡張するためのレシピを示します。</p>
<p>iterable 全体を一度にメモリ上に置くよりも、要素を一つづつ処理する方がメモリ効率上の有利さを保てます。関数形式のままツールをリンクしてゆくと、コードのサイズを減らし、一時変数を減らす助けになります。インタプリタのオーバヘッドをもたらす for ループやジェネレータ(<a class="reference internal" href="../glossary.html#term-generator"><em class="xref std std-term">generator</em></a>)
を使わずに、 &#8220;ベクトル化された&#8221; ビルディングブロックを使うと、高速な処理を実現できます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="s">&quot;Return first n items of the iterable as a list&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tabulate</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s">&quot;Return function(0), function(1), ...&quot;</span>
    <span class="k">return</span> <span class="n">imap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="s">&quot;Advance the iterator n-steps ahead. If n is none, consume entirely.&quot;</span>
    <span class="c"># Use functions that consume iterators at C speed.</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># feed the entire iterator into a zero-length deque</span>
        <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># advance to the empty slice starting at position n</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nth</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">&quot;Returns the nth item or a default value&quot;</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="n">default</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quantify</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">pred</span><span class="o">=</span><span class="nb">bool</span><span class="p">):</span>
    <span class="s">&quot;Count how many times the predicate is true&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">imap</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">padnone</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the sequence elements and then returns None indefinitely.</span>

<span class="sd">    Useful for emulating the behavior of the built-in map() function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">chain</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">ncycles</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="s">&quot;Returns the sequence elements n times&quot;</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">imap</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">listOfLists</span><span class="p">):</span>
    <span class="s">&quot;Flatten one level of nesting&quot;</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">listOfLists</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">repeatfunc</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repeat calls to func with specified arguments.</span>

<span class="sd">    Example:  repeatfunc(random.random)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">starmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">starmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">times</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="s">&quot;s -&gt; (s0,s1), (s1,s2), (s2, s3), ...&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">izip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">grouper</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">&quot;grouper(3, &#39;ABCDEFG&#39;, &#39;x&#39;) --&gt; ABC DEF Gxx&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">izip_longest</span><span class="p">(</span><span class="n">fillvalue</span><span class="o">=</span><span class="n">fillvalue</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">roundrobin</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="s">&quot;roundrobin(&#39;ABC&#39;, &#39;D&#39;, &#39;EF&#39;) --&gt; A D E B F C&quot;</span>
    <span class="c"># Recipe credited to George Sakkis</span>
    <span class="n">pending</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterables</span><span class="p">)</span>
    <span class="n">nexts</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">.</span><span class="n">next</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">pending</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">nexts</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">next</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">pending</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">nexts</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">nexts</span><span class="p">,</span> <span class="n">pending</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="s">&quot;powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">unique_everseen</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">&quot;List unique elements, preserving order. Remember all elements ever seen.&quot;</span>
    <span class="c"># unique_everseen(&#39;AAAABBBCCDAABBB&#39;) --&gt; A B C D</span>
    <span class="c"># unique_everseen(&#39;ABBCcAD&#39;, str.lower) --&gt; A B C D</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">seen_add</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">ifilterfalse</span><span class="p">(</span><span class="n">seen</span><span class="o">.</span><span class="n">__contains__</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
            <span class="n">seen_add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">element</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen_add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">element</span>

<span class="k">def</span> <span class="nf">unique_justseen</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">&quot;List unique elements, preserving order. Remember only the element just seen.&quot;</span>
    <span class="c"># unique_justseen(&#39;AAAABBBCCDAABBB&#39;) --&gt; A B C D A B</span>
    <span class="c"># unique_justseen(&#39;ABBCcAD&#39;, str.lower) --&gt; A B C A D</span>
    <span class="k">return</span> <span class="n">imap</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">imap</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">groupby</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">iter_except</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Call a function repeatedly until an exception is raised.</span>

<span class="sd">    Converts a call-until-exception interface to an iterator interface.</span>
<span class="sd">    Like __builtin__.iter(func, sentinel) but uses an exception instead</span>
<span class="sd">    of a sentinel to end the loop.</span>

<span class="sd">    Examples:</span>
<span class="sd">        bsddbiter = iter_except(db.next, bsddb.error, db.first)</span>
<span class="sd">        heapiter = iter_except(functools.partial(heappop, h), IndexError)</span>
<span class="sd">        dictiter = iter_except(d.popitem, KeyError)</span>
<span class="sd">        dequeiter = iter_except(d.popleft, IndexError)</span>
<span class="sd">        queueiter = iter_except(q.get_nowait, Queue.Empty)</span>
<span class="sd">        setiter = iter_except(s.pop, KeyError)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">first</span><span class="p">()</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">exception</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">def</span> <span class="nf">random_product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="s">&quot;Random selection from itertools.product(*args, **kwds)&quot;</span>
    <span class="n">pools</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;repeat&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_permutation</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">&quot;Random selection from itertools.permutations(iterable, r)&quot;</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">random_combination</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="s">&quot;Random selection from itertools.combinations(iterable, r)&quot;</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">r</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_combination_with_replacement</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="s">&quot;Random selection from itertools.combinations_with_replacement(iterable, r)&quot;</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p>上記のレシピはデフォルト値を指定してグローバルな名前検索をローカル変数の検索に変えることで、より効率を上げることができます。例えば、 <em>dotproduct</em> のレシピを書き換えるとすればこんな具合です:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">imap</span><span class="o">=</span><span class="n">imap</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">imap</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="functools.html" title="9.8. functools — 高階関数と呼び出し可能オブジェクトの操作"
             >次へ</a> |</li>
        <li class="right" >
          <a href="random.html" title="9.6. random — 擬似乱数を生成する"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="numeric.html" >9. 数値と数学モジュール</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>