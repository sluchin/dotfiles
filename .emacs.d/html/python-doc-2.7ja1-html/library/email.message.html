

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>18.1.1. email: 電子メールメッセージの表現 &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="18.1. email — 電子メールと MIME 処理のためのパッケージ" href="email.html" />
    <link rel="next" title="18.1.2. email: 電子メールメッセージを解析(パース)する" href="email.parser.html" />
    <link rel="prev" title="18.1. email — 電子メールと MIME 処理のためのパッケージ" href="email.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="18.1.2. email: 電子メールメッセージを解析(パース)する"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="email.html" title="18.1. email — 電子メールと MIME 処理のためのパッケージ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="netdata.html" >18. インターネット上のデータの操作</a> &raquo;</li>
          <li><a href="email.html" accesskey="U">18.1. <tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">email</span></tt> &#8212; 電子メールと MIME 処理のためのパッケージ</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>前のトピックへ</h4>
  <p class="topless"><a href="email.html"
                        title="前の章へ">18.1. <tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">email</span></tt> &#8212; 電子メールと MIME 処理のためのパッケージ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="email.parser.html"
                        title="次の章へ">18.1.2. <tt class="docutils literal docutils literal"><span class="pre">email</span></tt>: 電子メールメッセージを解析(パース)する</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/email.message.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-email.message">
<span id="email"></span><h1>18.1.1. <a class="reference internal" href="email.html#module-email" title="email: 電子メールのメッセージを解析、操作および生成を支援するパッケージ。 これには MIME 文書もふくまれる。"><tt class="xref py py-mod docutils literal"><span class="pre">email</span></tt></a>: 電子メールメッセージの表現<a class="headerlink" href="#module-email.message" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> クラスは、 <a class="reference internal" href="email.html#module-email" title="email: 電子メールのメッセージを解析、操作および生成を支援するパッケージ。 これには MIME 文書もふくまれる。"><tt class="xref py py-mod docutils literal"><span class="pre">email</span></tt></a> パッケージの中心となるクラスです。これは <a class="reference internal" href="email.html#module-email" title="email: 電子メールのメッセージを解析、操作および生成を支援するパッケージ。 これには MIME 文書もふくまれる。"><tt class="xref py py-mod docutils literal"><span class="pre">email</span></tt></a> オブジェクトモデルの基底クラスになっています。
<a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> はヘッダフィールドを検索したりメッセージ本体にアクセスするための核となる機能を提供します。</p>
<p>概念的には、(<a class="reference internal" href="#module-email.message" title="email.message: 電子メールのメッセージを表現する基底クラス"><tt class="xref py py-mod docutils literal"><span class="pre">email.message</span></tt></a> モジュールからインポートされる)
<a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクトには <em>ヘッダ</em> と <em>ペイロード</em> が格納されています。ヘッダは、 <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a> 形式のフィールド名およびフィールド値がコロンで区切られたものです。コロンはフィールド名またはフィールド値のどちらにも含まれません。</p>
<p>ヘッダは大文字小文字を区別した形式で保存されますが、ヘッダ名が一致するかどうかの検査は大文字小文字を区別せずにおこなうことができます。
<em>Unix-From</em> ヘッダまたは <tt class="docutils literal"><span class="pre">From_</span></tt> ヘッダとして知られるエンベロープヘッダがひとつ存在することもあります。ペイロードは、単純なメッセージオブジェクトの場合は単なる文字列ですが、
MIME コンテナ文書 (<em class="mimetype">multipart/*</em> または
<em class="mimetype">message/rfc822</em> など) の場合は <a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクトのリストになっています。</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクトは、メッセージヘッダにアクセスするためのマップ (辞書) 形式のインタフェイスと、ヘッダおよびペイロードの両方にアクセスするための明示的なインタフェイスを提供します。これにはメッセージオブジェクトツリーからフラットなテキスト文書を生成したり、一般的に使われるヘッダのパラメータにアクセスしたり、またオブジェクトツリーを再帰的にたどったりするための便利なメソッドを含みます。</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> クラスのメソッドは以下のとおりです:</p>
<dl class="class">
<dt id="email.message.Message">
<em class="property">class </em><tt class="descclassname">email.message.</tt><tt class="descname">Message</tt><a class="headerlink" href="#email.message.Message" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタは引数をとりません。</p>
<dl class="method">
<dt id="email.message.Message.as_string">
<tt class="descname">as_string</tt><big>(</big><span class="optional">[</span><em>unixfrom</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.as_string" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ全体をフラットな文字列として返します。オプション <em>unixfrom</em> が
<tt class="docutils literal"><span class="pre">True</span></tt> の場合、返される文字列にはエンベロープヘッダも含まれます。
<em>unixfrom</em> のデフォルトは <tt class="docutils literal"><span class="pre">False</span></tt> です。もし、文字列への変換を完全に行うためにデフォルト値を埋める必要がある場合、メッセージのフラット化は <a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> の変更を引き起こす可能性があります
(例えば、MIME の境界が生成される、変更される等)。</p>
<p>このメソッドは手軽に利用する事ができますが、必ずしも期待通りにメッセージをフォーマットするとは限りません。たとえば、これはデフォルトでは <tt class="docutils literal"><span class="pre">From</span></tt> で始まる行を変更してしまいます。以下の例のように <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><tt class="xref py py-class docutils literal"><span class="pre">Generator</span></tt></a>
のインスタンスを生成して <tt class="xref py py-meth docutils literal"><span class="pre">flatten()</span></tt> メソッドを直接呼び出せばより柔軟な処理を行う事ができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">Generator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.__str__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="xref py py-meth docutils literal"><span class="pre">as_string(unixfrom=True)()</span></tt> と同じです。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.is_multipart">
<tt class="descname">is_multipart</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.is_multipart" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージのペイロードが子 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクトからなるリストであれば <tt class="docutils literal"><span class="pre">True</span></tt> を返し、そうでなければ <tt class="docutils literal"><span class="pre">False</span></tt>
を返します。 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><tt class="xref py py-meth docutils literal"><span class="pre">is_multipart()</span></tt></a> が False を返した場合は、ペイロードは文字列オブジェクトである必要があります。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_unixfrom">
<tt class="descname">set_unixfrom</tt><big>(</big><em>unixfrom</em><big>)</big><a class="headerlink" href="#email.message.Message.set_unixfrom" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージのエンベロープヘッダを <em>unixfrom</em> に設定します。これは文字列である必要があります。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_unixfrom">
<tt class="descname">get_unixfrom</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.get_unixfrom" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージのエンベロープヘッダを返します。エンベロープヘッダが設定されていない場合は <tt class="docutils literal"><span class="pre">None</span></tt> が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.attach">
<tt class="descname">attach</tt><big>(</big><em>payload</em><big>)</big><a class="headerlink" href="#email.message.Message.attach" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>payload</em> を現在のペイロードに追加します。この時点でのペイロードは <tt class="docutils literal"><span class="pre">None</span></tt> か、あるいは <a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a>
オブジェクトのリストである必要があります。このメソッドの実行後、ペイロードは必ず <a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a>
オブジェクトのリストになります。ペイロードにスカラーオブジェクト (文字列など) を格納したい場合は、かわりに <a class="reference internal" href="#email.message.Message.set_payload" title="email.message.Message.set_payload"><tt class="xref py py-meth docutils literal"><span class="pre">set_payload()</span></tt></a>
を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_payload">
<tt class="descname">get_payload</tt><big>(</big><span class="optional">[</span><em>i</em><span class="optional">[</span>, <em>decode</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_payload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のペイロードへの参照を返します。これは <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><tt class="xref py py-meth docutils literal"><span class="pre">is_multipart()</span></tt></a> が
<tt class="docutils literal"><span class="pre">True</span></tt> の場合 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクトのリストになり、
<a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><tt class="xref py py-meth docutils literal"><span class="pre">is_multipart()</span></tt></a> が <tt class="docutils literal"><span class="pre">False</span></tt> の場合は文字列になります。ペイロードがリストの場合、リストを変更することはそのメッセージのペイロードを変更することになります。</p>
<p>オプション引数の <em>i</em> がある場合、
<a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><tt class="xref py py-meth docutils literal"><span class="pre">is_multipart()</span></tt></a> が <tt class="docutils literal"><span class="pre">True</span></tt> ならば <a class="reference internal" href="#email.message.Message.get_payload" title="email.message.Message.get_payload"><tt class="xref py py-meth docutils literal"><span class="pre">get_payload()</span></tt></a> はペイロード中で 0 から数えて <em>i</em> 番目の要素を返します。
<em>i</em> が 0 より小さい場合、あるいはペイロードの個数以上の場合は
<a class="reference internal" href="exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><tt class="xref py py-exc docutils literal"><span class="pre">IndexError</span></tt></a> が発生します。ペイロードが文字列 (つまり <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><tt class="xref py py-meth docutils literal"><span class="pre">is_multipart()</span></tt></a> が <tt class="docutils literal"><span class="pre">False</span></tt>)
にもかかわらず <em>i</em> が与えられたときは <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が発生します。</p>
<p>オプションの <em>decode</em> はそのペイロードが
<em class="mailheader">Content-Transfer-Encoding</em> ヘッダに従ってデコードされるべきかどうかを指示するフラグです。この値が <tt class="docutils literal"><span class="pre">True</span></tt> でメッセージが multipart ではない場合、ペイロードはこのヘッダの値が <tt class="docutils literal"><span class="pre">quoted-printable</span></tt> または <tt class="docutils literal"><span class="pre">base64</span></tt>
のときにかぎりデコードされます。これ以外のエンコーディングが使われている場合、 <em class="mailheader">Content-Transfer-Encoding</em> ヘッダがない場合、あるいは曖昧なbase64データが含まれる場合は、ペイロードはそのまま
(デコードされずに) 返されます。もしメッセージが multipart で
<em>decode</em> フラグが <tt class="docutils literal"><span class="pre">True</span></tt> の場合は <tt class="docutils literal"><span class="pre">None</span></tt> が返されます。
<em>decode</em> のデフォルト値は <tt class="docutils literal"><span class="pre">False</span></tt> です。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_payload">
<tt class="descname">set_payload</tt><big>(</big><em>payload</em><span class="optional">[</span>, <em>charset</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.set_payload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ全体のオブジェクトのペイロードを <em>payload</em> に設定します。ペイロードの形式をととのえるのは呼び出し側の責任です。オプションの
<em>charset</em> はメッセージのデフォルト文字セットを設定します。詳しくは <a class="reference internal" href="#email.message.Message.set_charset" title="email.message.Message.set_charset"><tt class="xref py py-meth docutils literal"><span class="pre">set_charset()</span></tt></a> を参照してください。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2.2 で変更: </span><em>charset</em> 引数の追加.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_charset">
<tt class="descname">set_charset</tt><big>(</big><em>charset</em><big>)</big><a class="headerlink" href="#email.message.Message.set_charset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ペイロードの文字セットを <em>charset</em> に変更します。ここには <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><tt class="xref py py-class docutils literal"><span class="pre">Charset</span></tt></a> インスタンス (<a class="reference internal" href="email.charset.html#module-email.charset" title="email.charset: 文字セット"><tt class="xref py py-mod docutils literal"><span class="pre">email.charset</span></tt></a> 参照)、文字セット名をあらわす文字列、あるいは <tt class="docutils literal"><span class="pre">None</span></tt> のいずれかが指定できます。文字列を指定した場合、これは <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><tt class="xref py py-class docutils literal"><span class="pre">Charset</span></tt></a> インスタンスに変換されます。
<em>charset</em> が <tt class="docutils literal"><span class="pre">None</span></tt> の場合、 <tt class="docutils literal"><span class="pre">charset</span></tt> パラメータは
<em class="mailheader">Content-Type</em> ヘッダから除去されます
(それ以外にメッセージの変形は行われません)。これ以外のものを文字セットとして指定した場合、 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a>
が発生します。</p>
<p><em class="mailheader">MIME-Version</em> ヘッダが存在しなければ、追加されます。
<em class="mailheader">Content-Type</em> ヘッダが存在しなければ、
<em class="mimetype">text/plain</em> を値として追加されます。
<em class="mailheader">Content-Type</em> が存在していてもいなくても、
<tt class="docutils literal"><span class="pre">charset</span></tt> パラメタは <em>charset.output_charset</em> に設定されます。
<em>charset.input_charset</em> と <em>charset.output_charset</em> が異なるなら、ペイロードは <em>output_charset</em> に再エンコードされます。
<em class="mailheader">Content-Transfer-Encoding</em> ヘッダが存在しなければ、ペイロードは、必要なら指定された <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><tt class="xref py py-class docutils literal"><span class="pre">Charset</span></tt></a>
を使って transfer エンコードされ、適切な値のヘッダが追加されます。
<em class="mailheader">Content-Transfer-Encoding</em> ヘッダがすでに存在すれば、ペイロードはすでにその <em class="mailheader">Content-Transfer-Encoding</em> によって正しくエンコードされたものと見なされ、変形されません。</p>
<p>ここでいうメッセージとは、unicode 文字列か <em>charset.input_charset</em> でエンコードされたペイロードを持つ <em class="mimetype">text/*</em> 形式のものを仮定しています。これは、もし必要とあらばプレーンテキスト形式を変換するさいに <em>charset.output_charset</em> のトランスファーエンコードに変換されます。MIME ヘッダ (<em class="mailheader">MIME-Version</em>,
<em class="mailheader">Content-Type</em>,
<em class="mailheader">Content-Transfer-Encoding</em>) は必要に応じて追加されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_charset">
<tt class="descname">get_charset</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.get_charset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージ中のペイロードの <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><tt class="xref py py-class docutils literal"><span class="pre">Charset</span></tt></a> インスタンスを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<p>以下のメソッドは、メッセージの <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a> ヘッダにアクセスするためのマップ (辞書) 形式のインタフェイスを実装したものです。これらのメソッドと、通常のマップ (辞書) 型はまったく同じ意味をもつわけではないことに注意してください。たとえば辞書型では、同じキーが複数あることは許されていませんが、ここでは同じメッセージヘッダが複数ある場合があります。また、辞書型では <a class="reference internal" href="#email.message.Message.keys" title="email.message.Message.keys"><tt class="xref py py-meth docutils literal"><span class="pre">keys()</span></tt></a> で返されるキーの順序は保証されていませんが、
<a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクト内のヘッダはつねに元のメッセージ中に現れた順序、あるいはそのあとに追加された順序で返されます。削除され、その後ふたたび追加されたヘッダはリストの一番最後に現れます。</p>
<p>こういった意味のちがいは意図的なもので、最大の利便性をもつようにつくられています。</p>
<p>注意: どんな場合も、メッセージ中のエンベロープヘッダはこのマップ形式のインタフェイスには含まれません。</p>
<dl class="method">
<dt id="email.message.Message.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.__len__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>複製されたものもふくめてヘッダ数の合計を返します。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__contains__">
<tt class="descname">__contains__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#email.message.Message.__contains__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージオブジェクトが <em>name</em> という名前のフィールドを持っていれば
true を返します。この検査では名前の大文字小文字は区別されません。
<em>name</em> は最後にコロンをふくんでいてはいけません。このメソッドは以下のように
<tt class="docutils literal"><span class="pre">in</span></tt> 演算子で使われます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="s">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s">&#39;message-id&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#email.message.Message.__getitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された名前のヘッダフィールドの値を返します。
<em>name</em> は最後にコロンをふくんでいてはいけません。そのヘッダがない場合は <tt class="docutils literal"><span class="pre">None</span></tt>
が返され、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> 例外は発生しません。</p>
<p>注意: 指定された名前のフィールドがメッセージのヘッダに2回以上現れている場合、どちらの値が返されるかは未定義です。ヘッダに存在するフィールドの値をすべて取り出したい場合は <a class="reference internal" href="#email.message.Message.get_all" title="email.message.Message.get_all"><tt class="xref py py-meth docutils literal"><span class="pre">get_all()</span></tt></a> メソッドを使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>name</em>, <em>val</em><big>)</big><a class="headerlink" href="#email.message.Message.__setitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージヘッダに <em>name</em> という名前の <em>val</em> という値をもつフィールドをあらたに追加します。このフィールドは現在メッセージに存在するフィールドのいちばん後に追加されます。</p>
<p>注意: このメソッドでは、すでに同一の名前で存在するフィールドは上書き <em>されません</em> 。もしメッセージが名前 <em>name</em> をもつフィールドをひとつしか持たないようにしたければ、最初にそれを除去してください。たとえば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;PythonPythonPython!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__delitem__">
<tt class="descname">__delitem__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#email.message.Message.__delitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージのヘッダから、 <em>name</em> という名前をもつフィールドをすべて除去します。たとえこの名前をもつヘッダが存在していなくても例外は発生しません。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.has_key">
<tt class="descname">has_key</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#email.message.Message.has_key" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージが <em>name</em> という名前をもつヘッダフィールドを持っていれば真を、そうでなければ偽を返します。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ中にあるすべてのヘッダのフィールド名のリストを返します。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ中にあるすべてのフィールドの値のリストを返します。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ中にあるすべてのヘッダのフィールド名とその値を
2-タプルのリストとして返します。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get">
<tt class="descname">get</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>failobj</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された名前をもつフィールドの値を返します。これは指定された名前がないときにオプション引数の <em>failobj</em>
(デフォルトでは <tt class="docutils literal"><span class="pre">None</span></tt>) を返すことをのぞけば、
<a class="reference internal" href="#email.message.Message.__getitem__" title="email.message.Message.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> と同じです。</p>
</dd></dl>

<p>さらに、役に立つメソッドをいくつか紹介します:</p>
<dl class="method">
<dt id="email.message.Message.get_all">
<tt class="descname">get_all</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>failobj</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>name</em> の名前をもつフィールドのすべての値からなるリストを返します。該当する名前のヘッダがメッセージ中に含まれていない場合は <em>failobj</em>
(デフォルトでは <tt class="docutils literal"><span class="pre">None</span></tt>) が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.add_header">
<tt class="descname">add_header</tt><big>(</big><em>_name</em>, <em>_value</em>, <em>**_params</em><big>)</big><a class="headerlink" href="#email.message.Message.add_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張ヘッダ設定。このメソッドは <a class="reference internal" href="#email.message.Message.__setitem__" title="email.message.Message.__setitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></tt></a> と似ていますが、追加のヘッダ・パラメータをキーワード引数で指定できるところが違っています。
<em>_name</em> に追加するヘッダフィールドを、 <em>_value</em> にそのヘッダの
<em>最初の</em> 値を渡します。</p>
<p>キーワード引数辞書 <em>_params</em> の各項目ごとに、そのキーがパラメータ名として扱われ、キー名にふくまれるアンダースコアはハイフンに置換されます
(なぜならハイフンは通常の Python 識別子としては使えないからです)。ふつう、パラメータの値が <tt class="docutils literal"><span class="pre">None</span></tt> 以外のときは、
<tt class="docutils literal"><span class="pre">key=&quot;value&quot;</span></tt> の形で追加されます。パラメータの値が <tt class="docutils literal"><span class="pre">None</span></tt> のときはキーのみが追加されます。値が非 ASCII 文字を含むなら、それは <tt class="docutils literal"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></tt> の形式の 3 タプルでなくてはなりません。ここで <tt class="docutils literal"><span class="pre">CHARSET</span></tt> はその値をエンコードするのに使われる文字セットを指名する文字列で、 <tt class="docutils literal"><span class="pre">LANGUAGE</span></tt> は通常 <tt class="docutils literal"><span class="pre">None</span></tt> か空文字列にでき
(その他の可能性は <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a> を参照してください)、 <tt class="docutils literal"><span class="pre">VALUE</span></tt> は非 ASCII コードポイントを含む文字列値です。</p>
<p>例を示しましょう:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>こうするとヘッダには以下のように追加されます。</p>
<div class="highlight-python"><pre>Content-Disposition: attachment; filename="bud.gif"</pre>
</div>
<p>非 ASCII 文字を使った例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>は、以下のようになります:</p>
<div class="highlight-python"><pre>Content-Disposition: attachment; filename*="iso-8859-1''Fu%DFballer.ppt"</pre>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.replace_header">
<tt class="descname">replace_header</tt><big>(</big><em>_name</em>, <em>_value</em><big>)</big><a class="headerlink" href="#email.message.Message.replace_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ヘッダの置換。
<em>_name</em> と一致するヘッダで最初に見つかったものを置き換えます。このときヘッダの順序とフィールド名の大文字小文字は保存されます。一致するヘッダがない場合、 <a class="reference internal" href="exceptions.html#exceptions.KeyError" title="exceptions.KeyError"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> が発生します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_type">
<tt class="descname">get_content_type</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.get_content_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージの content-type を返します。返された文字列は強制的に小文字で <em class="mimetype">maintype/subtype</em>
の形式に変換されます。メッセージ中に <em class="mailheader">Content-Type</em> ヘッダがない場合、デフォルトの content-type は <a class="reference internal" href="#email.message.Message.get_default_type" title="email.message.Message.get_default_type"><tt class="xref py py-meth docutils literal"><span class="pre">get_default_type()</span></tt></a>
が返す値によって与えられます。 <span class="target" id="index-3"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a> によればメッセージはつねにデフォルトの
content-type をもっているので、 <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><tt class="xref py py-meth docutils literal"><span class="pre">get_content_type()</span></tt></a>
はつねになんらかの値を返すはずです。</p>
<p><span class="target" id="index-4"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a> はメッセージのデフォルト content-type を、それが <em class="mimetype">multipart/digest</em>
コンテナに現れているとき以外は <em class="mimetype">text/plain</em> に規定しています。あるメッセージが
<em class="mimetype">multipart/digest</em> コンテナ中にある場合、その content-type は
<em class="mimetype">message/rfc822</em> になります。もし <em class="mailheader">Content-Type</em> ヘッダが適切でない
content-type 書式だった場合、 <span class="target" id="index-5"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a> はそれのデフォルトを
<em class="mimetype">text/plain</em> として扱うよう定めています。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_maintype">
<tt class="descname">get_content_maintype</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.get_content_maintype" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージの主 content-type を返します。これは <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><tt class="xref py py-meth docutils literal"><span class="pre">get_content_type()</span></tt></a> によって返される文字列の
<em class="mimetype">maintype</em> 部分です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_subtype">
<tt class="descname">get_content_subtype</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.get_content_subtype" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージの副 content-type (sub content-type、subtype) を返します。これは <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><tt class="xref py py-meth docutils literal"><span class="pre">get_content_type()</span></tt></a> によって返される文字列の
<em class="mimetype">subtype</em> 部分です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_default_type">
<tt class="descname">get_default_type</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.get_default_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの content-type を返します。ほどんどのメッセージではデフォルトの content-type は
<em class="mimetype">text/plain</em> ですが、メッセージが <em class="mimetype">multipart/digest</em>
コンテナに含まれているときだけ例外的に <em class="mimetype">message/rfc822</em> になります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_default_type">
<tt class="descname">set_default_type</tt><big>(</big><em>ctype</em><big>)</big><a class="headerlink" href="#email.message.Message.set_default_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトの content-type を設定します。
<em>ctype</em> は <em class="mimetype">text/plain</em> あるいは
<em class="mimetype">message/rfc822</em> である必要がありますが、強制ではありません。デフォルトの content-type はヘッダの
<em class="mailheader">Content-Type</em> には格納されません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_params">
<tt class="descname">get_params</tt><big>(</big><span class="optional">[</span><em>failobj</em><span class="optional">[</span>, <em>header</em><span class="optional">[</span>, <em>unquote</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージの <em class="mailheader">Content-Type</em> パラメータをリストとして返します。返されるリストはキー/値の組からなる2要素タプルが連なったものであり、これらは <tt class="docutils literal"><span class="pre">'='</span></tt> 記号で分離されています。
<tt class="docutils literal"><span class="pre">'='</span></tt> の左側はキーになり、右側は値になります。パラメータ中に
<tt class="docutils literal"><span class="pre">'='</span></tt> がなかった場合、値の部分は空文字列になり、そうでなければその値は
<a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><tt class="xref py py-meth docutils literal"><span class="pre">get_param()</span></tt></a> で説明されている形式になります。また、オプション引数 <em>unquote</em> が <tt class="docutils literal"><span class="pre">True</span></tt> (デフォルト) である場合、この値は unquote されます。</p>
<p>オプション引数 <em>failobj</em> は、 <em class="mailheader">Content-Type</em> ヘッダが存在しなかった場合に返すオブジェクトです。オプション引数
<em>header</em> には <em class="mailheader">Content-Type</em> のかわりに検索すべきヘッダを指定します。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2.2 で変更: </span><em>unquote</em> が追加されました.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_param">
<tt class="descname">get_param</tt><big>(</big><em>param</em><span class="optional">[</span>, <em>failobj</em><span class="optional">[</span>, <em>header</em><span class="optional">[</span>, <em>unquote</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージの <em class="mailheader">Content-Type</em> ヘッダ中のパラメータ <em>param</em> を文字列として返します。そのメッセージ中に
<em class="mailheader">Content-Type</em> ヘッダが存在しなかった場合、
<em>failobj</em>  (デフォルトは <tt class="docutils literal"><span class="pre">None</span></tt>) が返されます。</p>
<p>オプション引数 <em>header</em> が与えられた場合、 <em class="mailheader">Content-Type</em>
のかわりにそのヘッダが使用されます。</p>
<p>パラメータのキー比較は常に大文字小文字を区別しません。返り値は文字列か 3 要素のタプルで、タプルになるのはパラメータが <span class="target" id="index-6"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a>
エンコードされている場合です。3 要素タプルの場合、各要素の値は
<tt class="docutils literal"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></tt> の形式になっています。
<tt class="docutils literal"><span class="pre">CHARSET</span></tt> と <tt class="docutils literal"><span class="pre">LAGUAGE</span></tt> は <tt class="docutils literal"><span class="pre">None</span></tt> になることがあり、その場合 <tt class="docutils literal"><span class="pre">VALUE</span></tt> は <tt class="docutils literal"><span class="pre">us-ascii</span></tt> 文字セットでエンコードされているとみなさねばならないので注意してください。普段は <tt class="docutils literal"><span class="pre">LANGUAGE</span></tt> を無視できます。</p>
<p>この関数を使うアプリケーションが、パラメータが <span class="target" id="index-7"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a> 形式でエンコードされているかどうかを気にしないのであれば、
<a class="reference internal" href="email.util.html#email.utils.collapse_rfc2231_value" title="email.utils.collapse_rfc2231_value"><tt class="xref py py-func docutils literal"><span class="pre">email.utils.collapse_rfc2231_value()</span></tt></a> に
<a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><tt class="xref py py-meth docutils literal"><span class="pre">get_param()</span></tt></a> の返り値を渡して呼び出すことで、このパラメータをひとつにまとめることができます。この値がタプルならばこの関数は適切にデコードされた Unicode 文字列を返し、そうでない場合は unquote された元の文字列を返します。たとえば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rawparam</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="n">param</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">collapse_rfc2231_value</span><span class="p">(</span><span class="n">rawparam</span><span class="p">)</span>
</pre></div>
</div>
<p>いずれの場合もパラメータの値は (文字列であれ3要素タプルの <tt class="docutils literal"><span class="pre">VALUE</span></tt> 項目であれ)
つねに unquote されます。ただし、
<em>unquote</em> が <tt class="docutils literal"><span class="pre">False</span></tt> に指定されている場合は unquote されません。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2.2 で変更: </span><em>unquote</em> 引数の追加、3要素タプルが返り値になる可能性あり。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_param">
<tt class="descname">set_param</tt><big>(</big><em>param</em>, <em>value</em><span class="optional">[</span>, <em>header</em><span class="optional">[</span>, <em>requote</em><span class="optional">[</span>, <em>charset</em><span class="optional">[</span>, <em>language</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.set_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> ヘッダ中のパラメータを設定します。指定されたパラメータがヘッダ中にすでに存在する場合、その値は
<em>value</em> に置き換えられます。
<em class="mailheader">Content-Type</em> ヘッダがまだこのメッセージ中に存在していない場合、
<span class="target" id="index-8"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a> にしたがいこの値には <em class="mimetype">text/plain</em>
が設定され、新しいパラメータ値が末尾に追加されます。</p>
<p>オプション引数 <em>header</em> が与えられた場合、
<em class="mailheader">Content-Type</em> のかわりにそのヘッダが使用されます。オプション引数
<em>unquote</em> が <tt class="docutils literal"><span class="pre">False</span></tt> でない限り、この値は unquote されます (デフォルトは <tt class="docutils literal"><span class="pre">True</span></tt>)。</p>
<p>オプション引数 <em>charset</em> が与えられると、そのパラメータは <span class="target" id="index-9"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a> に従ってエンコードされます。オプション引数
<em>language</em> は RFC 2231 の言語を指定しますが、デフォルトではこれは空文字列となります。 <em>charset</em> と <em>language</em>
はどちらも文字列である必要があります。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.del_param">
<tt class="descname">del_param</tt><big>(</big><em>param</em><span class="optional">[</span>, <em>header</em><span class="optional">[</span>, <em>requote</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.del_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたパラメータを <em class="mailheader">Content-Type</em> ヘッダ中から完全にとりのぞきます。ヘッダはそのパラメータと値がない状態に書き換えられます。
<em>requote</em> が <tt class="docutils literal"><span class="pre">False</span></tt> でない限り (デフォルトでは
<tt class="docutils literal"><span class="pre">True</span></tt> です)、すべての値は必要に応じて quote されます。オプション変数 <em>header</em> が与えられた場合、
<em class="mailheader">Content-Type</em> のかわりにそのヘッダが使用されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_type">
<tt class="descname">set_type</tt><big>(</big><em>type[, header][, requote]</em><big>)</big><a class="headerlink" href="#email.message.Message.set_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> ヘッダの maintype と subtype を設定します。
<em>type</em> は <em class="mimetype">maintype/subtype</em> という形の文字列でなければなりません。それ以外の場合は <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が発生します。</p>
<p>このメソッドは <em class="mailheader">Content-Type</em> ヘッダを置き換えますが、すべてのパラメータはそのままにします。
<em>requote</em> が <tt class="docutils literal"><span class="pre">False</span></tt> の場合、これはすでに存在するヘッダを quote せず放置しますが、そうでない場合は自動的に quote します (デフォルト動作)。</p>
<p>オプション変数 <em>header</em> が与えられた場合、
<em class="mailheader">Content-Type</em> のかわりにそのヘッダが使用されます。
<em class="mailheader">Content-Type</em> ヘッダが設定される場合には、
<em class="mailheader">MIME-Version</em> ヘッダも同時に付加されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_filename">
<tt class="descname">get_filename</tt><big>(</big><span class="optional">[</span><em>failobj</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージ中の <em class="mailheader">Content-Disposition</em> ヘッダにある、
<tt class="docutils literal"><span class="pre">filename</span></tt> パラメータの値を返します。目的のヘッダに <tt class="docutils literal"><span class="pre">filename</span></tt> パラメータがない場合には
<em class="mailheader">Content-Type</em> ヘッダにある <tt class="docutils literal"><span class="pre">name</span></tt>
パラメータを探します。それも無い場合またはヘッダが無い場合には <em>failobj</em> が返されます。返される文字列はつねに <a class="reference internal" href="email.util.html#email.utils.unquote" title="email.utils.unquote"><tt class="xref py py-meth docutils literal"><span class="pre">email.utils.unquote()</span></tt></a> によって unquote されます。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_boundary">
<tt class="descname">get_boundary</tt><big>(</big><span class="optional">[</span><em>failobj</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_boundary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージ中の <em class="mailheader">Content-Type</em> ヘッダにある、
<tt class="docutils literal"><span class="pre">boundary</span></tt> パラメータの値を返します。目的のヘッダが欠けていたり、 <tt class="docutils literal"><span class="pre">boundary</span></tt> パラメータがない場合には
<em>failobj</em> が返されます。返される文字列はつねに <a class="reference internal" href="email.util.html#email.utils.unquote" title="email.utils.unquote"><tt class="xref py py-meth docutils literal"><span class="pre">email.utils.unquote()</span></tt></a> によって unquote されます。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_boundary">
<tt class="descname">set_boundary</tt><big>(</big><em>boundary</em><big>)</big><a class="headerlink" href="#email.message.Message.set_boundary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ中の <em class="mailheader">Content-Type</em> ヘッダにある、 <tt class="docutils literal"><span class="pre">boundary</span></tt>
パラメータに値を設定します。
<a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><tt class="xref py py-meth docutils literal"><span class="pre">set_boundary()</span></tt></a> は必要に応じて <em>boundary</em> を quote します。そのメッセージが <em class="mailheader">Content-Type</em> ヘッダを含んでいない場合、
<tt class="xref py py-exc docutils literal"><span class="pre">HeaderParseError</span></tt> が発生します。</p>
<p>注意: このメソッドを使うのは、古い <em class="mailheader">Content-Type</em> ヘッダを削除して新しい boundary をもったヘッダを <a class="reference internal" href="#email.message.Message.add_header" title="email.message.Message.add_header"><tt class="xref py py-meth docutils literal"><span class="pre">add_header()</span></tt></a> で足すのとは少し違います。 <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><tt class="xref py py-meth docutils literal"><span class="pre">set_boundary()</span></tt></a> は一連のヘッダ中での
<em class="mailheader">Content-Type</em> ヘッダの位置を保つからです。しかし、これは元の
<em class="mailheader">Content-Type</em> ヘッダ中に存在していた連続する行の順番までは <em>保ちません</em> 。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_charset">
<tt class="descname">get_content_charset</tt><big>(</big><span class="optional">[</span><em>failobj</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_content_charset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのメッセージ中の <em class="mailheader">Content-Type</em> ヘッダにある、 <tt class="docutils literal"><span class="pre">charset</span></tt>
パラメータの値を返します。値はすべて小文字に変換されます。メッセージ中に <em class="mailheader">Content-Type</em> がなかったり、このヘッダ中に
<tt class="docutils literal"><span class="pre">boundary</span></tt> パラメータがない場合には <em>failobj</em> が返されます。</p>
<p>注意: これは <a class="reference internal" href="#email.message.Message.get_charset" title="email.message.Message.get_charset"><tt class="xref py py-meth docutils literal"><span class="pre">get_charset()</span></tt></a> メソッドとは異なります。こちらのほうは文字列のかわりに、そのメッセージボディのデフォルトエンコーディングの <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><tt class="xref py py-class docutils literal"><span class="pre">Charset</span></tt></a> インスタンスを返します。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2.2 で追加.</span></p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_charsets">
<tt class="descname">get_charsets</tt><big>(</big><span class="optional">[</span><em>failobj</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#email.message.Message.get_charsets" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ中に含まれる文字セットの名前をすべてリストにして返します。そのメッセージが <em class="mimetype">multipart</em> である場合、返されるリストの各要素がそれぞれの subpart のペイロードに対応します。それ以外の場合、これは長さ 1 のリストを返します。</p>
<p>リスト中の各要素は文字列であり、これは対応する subpart 中のそれぞれの <em class="mailheader">Content-Type</em> ヘッダにある
<tt class="docutils literal"><span class="pre">charset</span></tt> の値です。しかし、その subpart が
<em class="mailheader">Content-Type</em> をもってないか、
<tt class="docutils literal"><span class="pre">charset</span></tt> がないか、あるいは MIME maintype が <em class="mimetype">text</em> でないいずれかの場合には、リストの要素として <em>failobj</em> が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.walk">
<tt class="descname">walk</tt><big>(</big><big>)</big><a class="headerlink" href="#email.message.Message.walk" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><tt class="xref py py-meth docutils literal"><span class="pre">walk()</span></tt></a> メソッドは多目的のジェネレータで、これはあるメッセージオブジェクトツリー中のすべての part および subpart をわたり歩くのに使えます。順序は深さ優先です。おそらく典型的な用法は、
<a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><tt class="xref py py-meth docutils literal"><span class="pre">walk()</span></tt></a> を <tt class="docutils literal"><span class="pre">for</span></tt> ループ中でのイテレータとして使うことでしょう。ループを一回まわるごとに、次の subpart が返されるのです。</p>
<p>以下の例は、 multipart メッセージのすべての part において、その MIME タイプを表示していくものです。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">()</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
</pre></div>
</div>
</dd></dl>

<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span>以前の非推奨メソッド <tt class="xref py py-meth docutils literal"><span class="pre">get_type()</span></tt> 、 <tt class="xref py py-meth docutils literal"><span class="pre">get_main_type()</span></tt> 、
<tt class="xref py py-meth docutils literal"><span class="pre">get_subtype()</span></tt> は削除されました。</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> オブジェクトはオプションとして 2つのインスタンス属性をとることができます。これはある MIME メッセージからプレーンテキストを生成するのに使うことができます。</p>
<dl class="attribute">
<dt id="email.message.Message.preamble">
<tt class="descname">preamble</tt><a class="headerlink" href="#email.message.Message.preamble" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>MIME ドキュメントの形式では、ヘッダ直後にくる空行と最初の multipart 境界をあらわす文字列のあいだにいくらかのテキスト (訳注: preamble, 序文) を埋めこむことを許しています。このテキストは標準的な MIME の範疇からはみ出しているので、 MIME
形式を認識するメールソフトからこれらは通常まったく見えません。しかしメッセージのテキストを生で見る場合、あるいはメッセージを MIME
対応していないメールソフトで見る場合、このテキストは目に見えることになります。</p>
<p><em>preamble</em> 属性は MIME ドキュメントに加えるこの最初の MIME
範囲外テキストを含んでいます。 <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><tt class="xref py py-class docutils literal"><span class="pre">Parser</span></tt></a>
があるテキストをヘッダ以降に発見したが、それはまだ最初の MIME
境界文字列が現れる前だった場合、パーザはそのテキストをメッセージの <em>preamble</em>
属性に格納します。 <tt class="xref py py-class docutils literal"><span class="pre">Generator</span></tt> がある MIME メッセージからプレーンテキスト形式を生成するとき、これはそのテキストをヘッダと最初の MIME
境界の間に挿入します。詳細は <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: 電子メールメッセージのフラットなテキストを解析し、 メッセージオブジェクト構造体を生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">email.parser</span></tt></a> および
<tt class="xref py py-mod docutils literal"><span class="pre">email.Generator</span></tt> を参照してください。</p>
<p>注意: そのメッセージに preamble がない場合、
<em>preamble</em> 属性には <tt class="docutils literal"><span class="pre">None</span></tt> が格納されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="email.message.Message.epilogue">
<tt class="descname">epilogue</tt><a class="headerlink" href="#email.message.Message.epilogue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>epilogue</em> 属性はメッセージの最後の MIME 境界文字列からメッセージ末尾までのテキストを含むもので、それ以外は <em>preamble</em>
属性と同じです。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span><tt class="xref py py-class docutils literal"><span class="pre">Generator</span></tt> でファイル終端に改行を出力するため、
epilogue に空文字列を設定する必要はなくなりました。</p>
</dd></dl>

<dl class="attribute">
<dt id="email.message.Message.defects">
<tt class="descname">defects</tt><a class="headerlink" href="#email.message.Message.defects" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>defects</em> 属性はメッセージを解析する途中で検出されたすべての問題点
(defect、障害) のリストを保持しています。解析中に発見されうる障害についてのより詳細な説明は <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: email パッケージで使われる例外クラス"><tt class="xref py py-mod docutils literal"><span class="pre">email.errors</span></tt></a> を参照してください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="18.1.2. email: 電子メールメッセージを解析(パース)する"
             >次へ</a> |</li>
        <li class="right" >
          <a href="email.html" title="18.1. email — 電子メールと MIME 処理のためのパッケージ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li><a href="netdata.html" >18. インターネット上のデータの操作</a> &raquo;</li>
          <li><a href="email.html" >18.1. <tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">email</span></tt> &#8212; 電子メールと MIME 処理のためのパッケージ</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>