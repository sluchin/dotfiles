

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. 組み込み関数 &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python 標準ライブラリ" href="index.html" />
    <link rel="next" title="4. 組み込み定数" href="constants.html" />
    <link rel="prev" title="1. はじめに" href="intro.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="constants.html" title="4. 組み込み定数"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. はじめに"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python 標準ライブラリ</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. 組み込み関数</a></li>
<li><a class="reference internal" href="#non-essential-built-in-functions">3. 非必須組み込み関数 (Non-essential Built-in Functions)</a></li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="intro.html"
                        title="前の章へ">1. はじめに</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="constants.html"
                        title="次の章へ">4. 組み込み定数</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/library/functions.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="built-in-funcs">
<span id="id1"></span><h1>2. 組み込み関数<a class="headerlink" href="#built-in-funcs" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Python インタプリタは数多くの組み込み関数を持っていて、いつでも利用することができます。それらの関数をアルファベット順に挙げます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="19%" />
<col width="20%" />
<col width="19%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head">組み込み関数</th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#abs" title="abs"><tt class="xref py py-func docutils literal"><span class="pre">abs()</span></tt></a></td>
<td><a class="reference internal" href="#divmod" title="divmod"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a></td>
<td><a class="reference internal" href="#input" title="input"><tt class="xref py py-func docutils literal"><span class="pre">input()</span></tt></a></td>
<td><a class="reference internal" href="#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a></td>
<td><a class="reference internal" href="#staticmethod" title="staticmethod"><tt class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#all" title="all"><tt class="xref py py-func docutils literal"><span class="pre">all()</span></tt></a></td>
<td><a class="reference internal" href="#enumerate" title="enumerate"><tt class="xref py py-func docutils literal"><span class="pre">enumerate()</span></tt></a></td>
<td><a class="reference internal" href="#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a></td>
<td><a class="reference internal" href="#ord" title="ord"><tt class="xref py py-func docutils literal"><span class="pre">ord()</span></tt></a></td>
<td><a class="reference internal" href="#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#any" title="any"><tt class="xref py py-func docutils literal"><span class="pre">any()</span></tt></a></td>
<td><a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a></td>
<td><a class="reference internal" href="#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a></td>
<td><a class="reference internal" href="#pow" title="pow"><tt class="xref py py-func docutils literal"><span class="pre">pow()</span></tt></a></td>
<td><a class="reference internal" href="#sum" title="sum"><tt class="xref py py-func docutils literal"><span class="pre">sum()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#basestring" title="basestring"><tt class="xref py py-func docutils literal"><span class="pre">basestring()</span></tt></a></td>
<td><a class="reference internal" href="#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a></td>
<td><a class="reference internal" href="#issubclass" title="issubclass"><tt class="xref py py-func docutils literal"><span class="pre">issubclass()</span></tt></a></td>
<td><a class="reference internal" href="#print" title="print"><tt class="xref py py-func docutils literal"><span class="pre">print()</span></tt></a></td>
<td><a class="reference internal" href="#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#bin" title="bin"><tt class="xref py py-func docutils literal"><span class="pre">bin()</span></tt></a></td>
<td><a class="reference internal" href="#file" title="file"><tt class="xref py py-func docutils literal"><span class="pre">file()</span></tt></a></td>
<td><a class="reference internal" href="#iter" title="iter"><tt class="xref py py-func docutils literal"><span class="pre">iter()</span></tt></a></td>
<td><a class="reference internal" href="#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a></td>
<td><a class="reference internal" href="#tuple" title="tuple"><tt class="xref py py-func docutils literal"><span class="pre">tuple()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#bool" title="bool"><tt class="xref py py-func docutils literal"><span class="pre">bool()</span></tt></a></td>
<td><a class="reference internal" href="#filter" title="filter"><tt class="xref py py-func docutils literal"><span class="pre">filter()</span></tt></a></td>
<td><a class="reference internal" href="#len" title="len"><tt class="xref py py-func docutils literal"><span class="pre">len()</span></tt></a></td>
<td><a class="reference internal" href="#range" title="range"><tt class="xref py py-func docutils literal"><span class="pre">range()</span></tt></a></td>
<td><a class="reference internal" href="#type" title="type"><tt class="xref py py-func docutils literal"><span class="pre">type()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#bytearray" title="bytearray"><tt class="xref py py-func docutils literal"><span class="pre">bytearray()</span></tt></a></td>
<td><a class="reference internal" href="#float" title="float"><tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt></a></td>
<td><a class="reference internal" href="#list" title="list"><tt class="xref py py-func docutils literal"><span class="pre">list()</span></tt></a></td>
<td><a class="reference internal" href="#raw_input" title="raw_input"><tt class="xref py py-func docutils literal"><span class="pre">raw_input()</span></tt></a></td>
<td><a class="reference internal" href="#unichr" title="unichr"><tt class="xref py py-func docutils literal"><span class="pre">unichr()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#callable" title="callable"><tt class="xref py py-func docutils literal"><span class="pre">callable()</span></tt></a></td>
<td><a class="reference internal" href="#format" title="format"><tt class="xref py py-func docutils literal"><span class="pre">format()</span></tt></a></td>
<td><a class="reference internal" href="#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a></td>
<td><a class="reference internal" href="#reduce" title="reduce"><tt class="xref py py-func docutils literal"><span class="pre">reduce()</span></tt></a></td>
<td><a class="reference internal" href="#unicode" title="unicode"><tt class="xref py py-func docutils literal"><span class="pre">unicode()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#chr" title="chr"><tt class="xref py py-func docutils literal"><span class="pre">chr()</span></tt></a></td>
<td><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><tt class="xref py py-func docutils literal"><span class="pre">frozenset()</span></tt></a></td>
<td><a class="reference internal" href="#long" title="long"><tt class="xref py py-func docutils literal"><span class="pre">long()</span></tt></a></td>
<td><a class="reference internal" href="#reload" title="reload"><tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt></a></td>
<td><a class="reference internal" href="#vars" title="vars"><tt class="xref py py-func docutils literal"><span class="pre">vars()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a></td>
<td><a class="reference internal" href="#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a></td>
<td><a class="reference internal" href="#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a></td>
<td><a class="reference internal" href="repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a></td>
<td><a class="reference internal" href="#xrange" title="xrange"><tt class="xref py py-func docutils literal"><span class="pre">xrange()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cmp" title="cmp"><tt class="xref py py-func docutils literal"><span class="pre">cmp()</span></tt></a></td>
<td><a class="reference internal" href="#globals" title="globals"><tt class="xref py py-func docutils literal"><span class="pre">globals()</span></tt></a></td>
<td><a class="reference internal" href="#max" title="max"><tt class="xref py py-func docutils literal"><span class="pre">max()</span></tt></a></td>
<td><a class="reference internal" href="#reversed" title="reversed"><tt class="xref py py-func docutils literal"><span class="pre">reversed()</span></tt></a></td>
<td><a class="reference internal" href="#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a></td>
<td><a class="reference internal" href="#hasattr" title="hasattr"><tt class="xref py py-func docutils literal"><span class="pre">hasattr()</span></tt></a></td>
<td><a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><tt class="xref py py-func docutils literal"><span class="pre">memoryview()</span></tt></a></td>
<td><a class="reference internal" href="#round" title="round"><tt class="xref py py-func docutils literal"><span class="pre">round()</span></tt></a></td>
<td><a class="reference internal" href="#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#complex" title="complex"><tt class="xref py py-func docutils literal"><span class="pre">complex()</span></tt></a></td>
<td><a class="reference internal" href="#hash" title="hash"><tt class="xref py py-func docutils literal"><span class="pre">hash()</span></tt></a></td>
<td><a class="reference internal" href="#min" title="min"><tt class="xref py py-func docutils literal"><span class="pre">min()</span></tt></a></td>
<td><a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-func docutils literal"><span class="pre">set()</span></tt></a></td>
<td><a class="reference internal" href="#apply" title="apply"><tt class="xref py py-func docutils literal"><span class="pre">apply()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#delattr" title="delattr"><tt class="xref py py-func docutils literal"><span class="pre">delattr()</span></tt></a></td>
<td><a class="reference internal" href="#help" title="help"><tt class="xref py py-func docutils literal"><span class="pre">help()</span></tt></a></td>
<td><a class="reference internal" href="#next" title="next"><tt class="xref py py-func docutils literal"><span class="pre">next()</span></tt></a></td>
<td><a class="reference internal" href="#setattr" title="setattr"><tt class="xref py py-func docutils literal"><span class="pre">setattr()</span></tt></a></td>
<td><a class="reference internal" href="#buffer" title="buffer"><tt class="xref py py-func docutils literal"><span class="pre">buffer()</span></tt></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt></a></td>
<td><a class="reference internal" href="#hex" title="hex"><tt class="xref py py-func docutils literal"><span class="pre">hex()</span></tt></a></td>
<td><a class="reference internal" href="#object" title="object"><tt class="xref py py-func docutils literal"><span class="pre">object()</span></tt></a></td>
<td><a class="reference internal" href="#slice" title="slice"><tt class="xref py py-func docutils literal"><span class="pre">slice()</span></tt></a></td>
<td><a class="reference internal" href="#coerce" title="coerce"><tt class="xref py py-func docutils literal"><span class="pre">coerce()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a></td>
<td><a class="reference internal" href="#id" title="id"><tt class="xref py py-func docutils literal"><span class="pre">id()</span></tt></a></td>
<td><a class="reference internal" href="#oct" title="oct"><tt class="xref py py-func docutils literal"><span class="pre">oct()</span></tt></a></td>
<td><a class="reference internal" href="#sorted" title="sorted"><tt class="xref py py-func docutils literal"><span class="pre">sorted()</span></tt></a></td>
<td><a class="reference internal" href="#intern" title="intern"><tt class="xref py py-func docutils literal"><span class="pre">intern()</span></tt></a></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="abs">
<tt class="descname">abs</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#abs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値の絶対値を返します。引数として通常の整数、長整数、浮動小数点数をとることができます。引数が複素数の場合、その大きさ (magnitude) が返されます。</p>
</dd></dl>

<dl class="function">
<dt id="all">
<tt class="descname">all</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の全ての要素が真ならば (もしくは iterable が空ならば)
<a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> を返します。以下のコードと等価です。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="any">
<tt class="descname">any</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#any" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> のいずれかの要素が真ならば <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> を返します。
iterable が空なら <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> を返します。以下のコードと等価です。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="basestring">
<tt class="descname">basestring</tt><big>(</big><big>)</big><a class="headerlink" href="#basestring" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この抽象型は、 <a class="reference internal" href="#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> および <a class="reference internal" href="#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a> のスーパークラスです。この型は呼び出したりインスタンス化したりはできませんが、オブジェクトが <a class="reference internal" href="#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> や <a class="reference internal" href="#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a> のインスタンスであるかどうかを調べる際に利用できます。
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">basestring)</span></tt> は
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">(str,</span> <span class="pre">unicode))</span></tt> と等価です。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="bin">
<tt class="descname">bin</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#bin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数値をバイナリ文字列に変換します。結果は正常な Python の表現となります。
<em>x</em> が Python の <a class="reference internal" href="#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a> オブジェクトでない場合、整数値を返す
<a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><tt class="xref py py-meth docutils literal"><span class="pre">__index__()</span></tt></a> メソッドが定義されていなければなりません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="bool">
<tt class="descname">bool</tt><big>(</big><span class="optional">[</span><em>x</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#bool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準の真値テストを使って、値をブール値に変換します。
<em>x</em> が偽か省略された場合、 <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> を返します;
そうでなければ <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> を返します。
<tt class="docutils literal"><span class="pre">bool</span></tt> はクラスでもあり、 <tt class="docutils literal"><span class="pre">int</span></tt> のサブクラスになります。
<tt class="docutils literal"><span class="pre">bool</span></tt> クラスはそれ以上サブクラス化できません。このクラスのインスタンスは <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> および <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> だけです。</p>
<p class="versionadded" id="index-0">
<span class="versionmodified">バージョン 2.2.1 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>引数が与えられなかった場合、この関数は <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> を返します。</p>
</dd></dl>

<dl class="function">
<dt id="bytearray">
<tt class="descname">bytearray</tt><big>(</big><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#bytearray" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいバイトの配列を返します。 <a class="reference internal" href="#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> 型は範囲 0 &lt;= x &lt; 256 の整数のミュータブルなシーケンスです。これは、 <a class="reference internal" href="stdtypes.html#typesseq-mutable"><em>変更可能なシーケンス型</em></a> で書かれているような、ミュータブルなシーケンスの通常のメソッドのほとんどを持ちますし、 <a class="reference internal" href="stdtypes.html#string-methods"><em>文字列メソッド</em></a> にあるような、 <a class="reference internal" href="#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> 型が持つメソッドのほとんども持っています。</p>
<p>オプションの <em>source</em> パラメタは、配列をいくつかの異なる方法で初期化するのに使われます。</p>
<ul class="simple">
<li>これが <em>文字列</em> なら、 <em>encoding</em> (と、オプションの <em>errors</em>) パラメタも与えなければなりません。このとき <a class="reference internal" href="#bytearray" title="bytearray"><tt class="xref py py-func docutils literal"><span class="pre">bytearray()</span></tt></a> は文字列を
<a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><tt class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></tt></a> でバイト列に変換して返します。</li>
<li>これが <em>整数</em> なら、配列はそのサイズになり、null バイトで初期化されます。</li>
<li>これが <em>バッファ</em> インタフェースに適合するオブジェクトなら、そのオブジェクトの読み込み専用バッファがバイト配列の初期化に使われます。</li>
<li>これが <em>イテラブル</em> なら、それは範囲 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></tt> 内の整数のイテラブルであることが必要で、それらが配列の初期の内容になります。</li>
</ul>
<p>引数がなければ、長さ 0 の配列が生成されます。</p>
</dd></dl>

<dl class="function">
<dt id="callable">
<tt class="descname">callable</tt><big>(</big><em>object</em><big>)</big><a class="headerlink" href="#callable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>object</em> が呼び出し可能オブジェクトであれば、 <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a> を返します。そうでなければ、 <a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> を返します。この関数が真を返しても <em>object</em> の呼び出しは失敗する可能性がありますが、偽を返した場合は決して成功することはありません。クラスは呼び出し可能 (クラスを呼び出すと新しいインスタンスを返します) なことと、クラスのインスタンスがメソッド <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> を持つ場合には呼び出しが可能なことに注意してください。</p>
</dd></dl>

<dl class="function">
<dt id="chr">
<tt class="descname">chr</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#chr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ASCII コードが整数 <em>i</em> となるような文字 1 字からなる文字列を返します。例えば、 <tt class="docutils literal"><span class="pre">chr(97)</span></tt> は文字列 <tt class="docutils literal"><span class="pre">'a'</span></tt> を返します。この関数は <a class="reference internal" href="#ord" title="ord"><tt class="xref py py-func docutils literal"><span class="pre">ord()</span></tt></a> の逆です。引数は [0..255] の両端を含む範囲内に収まらなければなりません; <em>i</em> が範囲外の値のときには
<a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。 <a class="reference internal" href="#unichr" title="unichr"><tt class="xref py py-func docutils literal"><span class="pre">unichr()</span></tt></a> も参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="classmethod">
<tt class="descname">classmethod</tt><big>(</big><em>function</em><big>)</big><a class="headerlink" href="#classmethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>function</em> のクラスメソッドを返します。</p>
<p>クラスメソッドは、インスタンスメソッドが暗黙の第一引数としてインスタンスをとるように、第一引数としてクラスをとります。クラスメソッドを宣言するには、以下の書きならわしを使います。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">&#64;classmethod</span></tt> は関数 <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a> (デコレータ)形式です。詳しくは <a class="reference internal" href="../reference/compound_stmts.html#function"><em>関数定義</em></a> の関数定義についての説明を参照してください。</p>
<p>このメソッドはクラスで呼び出すこと (例えば C.f() ) も、インスタンスとして呼び出すこと (例えば C().f()) もできます。インスタンスはそのクラスが何であるかを除いて無視されます。クラスメソッドが派生クラスに対して呼び出された場合、派生したクラスオブジェクトが暗黙の第一引数として渡されます。</p>
<p>クラスメソッドは C++ や Java における静的メソッドとは異なります。そのような機能を求めているなら、 <a class="reference internal" href="#staticmethod" title="staticmethod"><tt class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></tt></a> を参照してください。</p>
<p>クラスメソッドについてさらに情報が必要ならば、 <a class="reference internal" href="../reference/datamodel.html#types"><em>標準型の階層</em></a> の型階層の項を参照下さい。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>関数デコレータ構文を追加しました.</p>
</dd></dl>

<dl class="function">
<dt id="cmp">
<tt class="descname">cmp</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#cmp" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つのオブジェクト <em>x</em> および <em>y</em> を比較し、その結果に従って整数を返します。戻り値は <tt class="docutils literal"><span class="pre">x</span></tt> &lt; <tt class="docutils literal"><span class="pre">y</span></tt> のときには負、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt> の時にはゼロ、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt> には厳密に正の値になります。</p>
</dd></dl>

<dl class="function">
<dt id="compile">
<tt class="descname">compile</tt><big>(</big><em>source</em>, <em>filename</em>, <em>mode</em><span class="optional">[</span>, <em>flags</em><span class="optional">[</span>, <em>dont_inherit</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#compile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>source</em> をコード、もしくは、 AST オブジェクトにコンパイルします。コードオブジェクトは <a class="reference internal" href="../reference/simple_stmts.html#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文により実行したり、
<a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> で評価したりすることができます。
<em>source</em> は、文字列と AST オブジェクトのどちらでもかまいません。
AST オブジェクトへの、また、 AST オブジェクトからのコンパイルの方法は、 <tt class="xref py py-mod docutils literal"><span class="pre">_ast</span></tt> モジュールのドキュメントを参照下さい。</p>
<p>引数 <em>filename</em> には、コードの読み出し元のファイルを与えなければなりません;
ファイルから読み出されたもので無い場合は、認識可能な値を渡して下さい (<tt class="docutils literal"><span class="pre">'&lt;string&gt;'</span></tt> が一般的に使われます ) 。</p>
<p>引数 <em>mode</em> は、どのような種類のコードがコンパイルされるべきかを指定します。 ;
もし、 <em>source</em> が一連の文から成る場合、 <tt class="docutils literal"><span class="pre">'exec'</span></tt> 、単一の式の場合、 <tt class="docutils literal"><span class="pre">'eval'</span></tt> 、単一の対話的文の場合 <tt class="docutils literal"><span class="pre">'single'</span></tt> が指定できます
( 後者の場合、 <tt class="docutils literal"><span class="pre">None</span></tt> 以外のものを評価する式が印字されます ) 。</p>
<p>オプションの引数 <em>flags</em> および <em>dont_inherit</em> (Python 2.2 で新たに追加) は、 <em>string</em> のコンパイル時にどの future 文 (<span class="target" id="index-1"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> 参照) の影響を及ぼすかを制御します。どちらも省略した場合 (または両方ともゼロの場合)、コンパイルを呼び出している側のコードで有効になっている future 文の内容を有効にして <em>string</em> をコンパイルします。
<em>flags</em> が指定されていて、かつ <em>dont_inherit</em> が指定されていない
(またはゼロ) の場合、上の場合に加えて <em>flags</em> に指定された future
文を使います。 <em>dont_inherit</em> がゼロでない整数の場合、 <em>flags</em> の値そのものを使い、この関数呼び出し周辺での future 文の効果は無視します。</p>
<p>future 文はビットで指定され、互いにビット単位の論理和を取って複数の文を指定できます。ある機能を指定するために必要なビットフィールドは、
<a class="reference internal" href="__future__.html#module-__future__" title="__future__: future 文の定義"><tt class="xref py py-mod docutils literal"><span class="pre">__future__</span></tt></a> モジュールの <tt class="xref py py-class docutils literal"><span class="pre">_Feature</span></tt> インスタンスにおける <tt class="xref py py-attr docutils literal"><span class="pre">compiler_flag</span></tt> 属性で得られます。</p>
<p>この関数は、コンパイルするソースが不正である場合、
<a class="reference internal" href="exceptions.html#exceptions.SyntaxError" title="exceptions.SyntaxError"><tt class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></tt></a> を送出します。ソースがNull Byteを含む場合、
<a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> を送出します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">複数行に渡るコードの文字列を <tt class="docutils literal"><span class="pre">'single'</span></tt> や <tt class="docutils literal"><span class="pre">'eval'</span></tt> モードでコンパイルするとき、入力は少なくともひとつの改行文字で終端されなければなりません。これは <a class="reference internal" href="code.html#module-code" title="code: read-eval-print ループを実装するのを助ける"><tt class="xref py py-mod docutils literal"><span class="pre">code</span></tt></a> モジュールで、文が不完全か完全かをわかりやすくするためです。</p>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加: </span><em>flags</em> と <em>dont_inherit</em> 引数が追加されました。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加: </span>AST オブジェクトのコンパイルをサポートしました。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.7 で変更: </span>Windows や Mac の改行文字を使えるようになりました。また、 <tt class="docutils literal"><span class="pre">'exec'</span></tt>
モードで改行文字は必要なくなりました。 <em>optimize</em> パラメタを追加しました。</p>
</dd></dl>

<dl class="function">
<dt id="complex">
<tt class="descname">complex</tt><big>(</big><span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#complex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値 <em>real</em> + <em>imag</em>*j の複素数型数を生成するか、文字列または数値を複素数型に変換します。最初の引数が文字列の場合、文字列を複素数として変換します。この場合関数は二つ目の引数無しで呼び出さなければなりません。二つ目の引数は文字列であってはなりません。それぞれの引数は
(複素数を含む) 任意の数値型をとることができます。 <em>imag</em> が省略された場合、標準の値はゼロで、関数は <a class="reference internal" href="#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a> 、 <a class="reference internal" href="#long" title="long"><tt class="xref py py-func docutils literal"><span class="pre">long()</span></tt></a> および
<a class="reference internal" href="#float" title="float"><tt class="xref py py-func docutils literal"><span class="pre">float()</span></tt></a> のような数値型への変換関数として動作します。全ての引数が省略された場合、 <tt class="docutils literal"><span class="pre">0j</span></tt> を返します。</p>
<p>複素数型については <a class="reference internal" href="stdtypes.html#typesnumeric"><em>数値型 int, float, long, complex</em></a> に説明があります。</p>
</dd></dl>

<dl class="function">
<dt id="delattr">
<tt class="descname">delattr</tt><big>(</big><em>object</em>, <em>name</em><big>)</big><a class="headerlink" href="#delattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#setattr" title="setattr"><tt class="xref py py-func docutils literal"><span class="pre">setattr()</span></tt></a> の親戚となる関数です。引数はオブジェクトと文字列です。文字列はオブジェクトの属性のどれか一つの名前でなければなりません。この関数は与えられた名前の属性を削除しますが、オブジェクトがそれを許す場合に限ります。例えば、 <tt class="docutils literal"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></tt> は <tt class="docutils literal"><span class="pre">del</span>
<span class="pre">x.foobar</span></tt> と等価です。</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">dict</tt><big>(</big><span class="optional">[</span><em>arg</em><span class="optional">]</span><big>)</big></dt>
<dd><p>新しい辞書型データを作成します。オプションとして引数 <em>arg</em> が与えることができます。辞書型については、 <a class="reference internal" href="stdtypes.html#typesmapping"><em>マップ型</em></a> に説明があります。</p>
<p>他のコンテナについては、組み込みクラスの <a class="reference internal" href="#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a> 、
<a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> 、 <a class="reference internal" href="#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> 、および、モジュールの
<a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> を参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="dir">
<tt class="descname">dir</tt><big>(</big><span class="optional">[</span><em>object</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#dir" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数がない場合、現在のローカルスコープにある名前のリストを返します。引数がある場合、そのオブジェクトの有効な属性からなるリストを返そうと試みます。</p>
<p>もし、オブジェクトが <tt class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></tt> メソッドを持つなら、このメソッドが呼び出され、属性のリストを必ず返します。これにより、 <a class="reference internal" href="#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> がオブジェクトの属性を返す方法をカスタマイズするために、
<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-func docutils literal"><span class="pre">__getattr__()</span></tt></a> や <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-func docutils literal"><span class="pre">__getattribute__()</span></tt></a> といったカスタム関数を実装することができます。</p>
<p>オブジェクトが <tt class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></tt> を提供していない場合、オブジェクトの
<tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> 属性が定義されていれば、そこから収集しようと試みます。また、定義されていれば型オブジェクトからも集められます。リストは完全なものになるとは限りません。また、カスタム関数 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-func docutils literal"><span class="pre">__getattr__()</span></tt></a> を持つ場合、不正確になるでしょう。</p>
<p>デフォルトの <a class="reference internal" href="#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> メカニズムの振る舞いは、異なる型のオブジェクトでは、異なります。それは、完全というよりは、より関連のある情報を生成しようとするためです。</p>
<ul class="simple">
<li>オブジェクトがモジュールオブジェクトの場合、リストにはモジュール属性の名前が含まれます。</li>
<li>オブジェクトが型オブジェクトやクラスオブジェクトの場合、リストにはそれらの属性が含まれ、かつそれらの基底クラスの属性も再帰的にたどられて含まれます。</li>
<li>それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、再帰的にたどった基底クラスの属性名が含まれます。</li>
</ul>
<p>返されるリストはアルファベット順に並べられています。例えば</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c"># doctest: +SKIP</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">[&#39;Struct&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;,</span>
<span class="go"> &#39;__package__&#39;, &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;kan&quot;</span><span class="p">,</span> <span class="s">&quot;ga&quot;</span><span class="p">,</span> <span class="s">&quot;roo&quot;</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[&#39;ga&#39;, &#39;kan&#39;, &#39;roo&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><a class="reference internal" href="#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> は主に対話プロンプトのために提供されているので、厳密さや一貫性をもって定義された名前のセットよりも、むしろ興味深い名前のセットを与えようとします。また、この関数の細かい動作はリリース間で変わる可能性があります。例えば、引数がクラスである場合、メタクラス属性は結果のリストに含まれません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="divmod">
<tt class="descname">divmod</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#divmod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2 つの (複素数でない) 数値を引数として取り、整数の除法を行ったときの商と剰余からなるペアを返します。被演算子が型混合である場合、 2 進算術演算子での規則が適用されます。通常の整数と長整数の場合、結果は  <tt class="docutils literal"><span class="pre">(a</span>
<span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></tt> と同じです。浮動小数点数の場合、結果は <tt class="docutils literal"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span>
<span class="pre">b)</span></tt> であり、 <em>q</em> は通常 <tt class="docutils literal"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></tt> ですが、そうではなく
1 になることもあります。いずれにせよ、 <tt class="docutils literal"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></tt> は <em>a</em> に非常に近い値になり、 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">%</span>
<span class="pre">b</span></tt> がゼロでない値の場合、その符号は <em>b</em> と同じで、 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span>
<span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></tt> になります。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>複素数に対する <a class="reference internal" href="#divmod" title="divmod"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a> の使用は廃用されました。</p>
</dd></dl>

<dl class="function">
<dt id="enumerate">
<tt class="descname">enumerate</tt><big>(</big><em>sequence</em><span class="optional">[</span>, <em>start=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#enumerate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>列挙オブジェクトを返します。 <em>sequence</em> はシーケンス型、イテレータ型、反復をサポートする他のオブジェクト型のいずれかでなければなりません。 <a class="reference internal" href="#enumerate" title="enumerate"><tt class="xref py py-func docutils literal"><span class="pre">enumerate()</span></tt></a> が返すイテレータの <tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt> メソッドは、
(ゼロから始まる) カウント値と、値だけ <em>iterable</em> を反復操作して得られる、対応するオブジェクトを含むタプルを返します。
<a class="reference internal" href="#enumerate" title="enumerate"><tt class="xref py py-func docutils literal"><span class="pre">enumerate()</span></tt></a> はインデクス付けされた値の列: <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">seq[0])</span></tt>,
<tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">seq[1])</span></tt>, <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">seq[2])</span></tt>, ... を得るのに便利です。例 :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">season</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;Spring&#39;</span><span class="p">,</span> <span class="s">&#39;Summer&#39;</span><span class="p">,</span> <span class="s">&#39;Fall&#39;</span><span class="p">,</span> <span class="s">&#39;Winter&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">season</span>
<span class="go">0 Spring</span>
<span class="go">1 Summer</span>
<span class="go">2 Fall</span>
<span class="go">3 Winter</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.3 で追加.</span></p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加: </span><em>start</em> 引数が追加されました。</p>
</dd></dl>

<dl class="function">
<dt id="eval">
<tt class="descname">eval</tt><big>(</big><em>expression</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#eval" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列とオプションの引数 <em>globals</em> 、 <em>locals</em> をとります。
<em>globals</em> を指定する場合には辞書でなくてはなりません。 <em>locals</em> は任意のマップ型にできます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>以前は <em>locals</em> も辞書でなければなりませんでした.</p>
<p>引数 <em>expression</em> は Python の表現式 (技術的にいうと、条件のリストです) として構文解釈され、評価されます。このとき辞書 <em>globals</em> および <em>locals</em> はそれぞれグローバルおよびローカルな名前空間として使われます。 <em>global</em> 辞書が存在するが、 &#8216;__builtins__&#8217; が欠けている場合、 <em>expression</em> を解析する前に現在のグローバル変数を <em>globals</em> にコピーします。このことから、 <em>expression</em> は通常、標準の
<a class="reference internal" href="__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a> モジュールへの完全なアクセスを有し、制限された環境が伝播するようになっています。 <em>locals</em> 辞書が省略された場合、標準の値として <em>globals</em> に設定されます。辞書が両方とも省略された場合、表現式は <a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> が呼び出されている環境の下で実行されます。構文エラーは例外として報告されます。</p>
<p>以下に例を示します :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>この関数は (<a class="reference internal" href="#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a> で生成されるような) 任意のコードオブジェクトを実行するために利用することもできます。この場合、文字列の代わりにコードオブジェクトを渡します。このコードオブジェクトが、引数
<em>mode</em> を <tt class="docutils literal"><span class="pre">'exec'</span></tt> としてコンパイルされている場合、 <a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a>
が返す値は、 <tt class="docutils literal"><span class="pre">None</span></tt> になります。</p>
<p>ヒント: 文の動的な実行は <a class="reference internal" href="../reference/simple_stmts.html#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文でサポートされています。ファイルからの文の実行は関数 <a class="reference internal" href="#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> でサポートされています。関数 <a class="reference internal" href="#globals" title="globals"><tt class="xref py py-func docutils literal"><span class="pre">globals()</span></tt></a> および <a class="reference internal" href="#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a> は、それぞれ現在のグローバルおよびローカルな辞書を返すので、 <a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> や
<a class="reference internal" href="#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> で使うことができます。</p>
<p>リテラルだけを含む式の文字列を安全に評価できる関数、
<a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><tt class="xref py py-func docutils literal"><span class="pre">ast.literal_eval()</span></tt></a> も参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="execfile">
<tt class="descname">execfile</tt><big>(</big><em>filename</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#execfile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="../reference/simple_stmts.html#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文に似ていますが、文字列の代わりにファイルに対して構文解釈を行います。 <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文と違って、モジュール管理機構を使いません &#8212; この関数はファイルを無条件に読み込み、新たなモジュールを生成しません。 <a class="footnote-reference" href="#id5" id="id2">[1]</a></p>
<p>引数は文字列とオプションの 2 つの辞書からなります。 <em>file</em> は読み込まれ、 (モジュールのように) Python 文の列として評価されます。このとき
<em>globals</em> および <em>locals</em> がそれぞれグローバル、および、ローカルな名前空間として使われます。 <em>locals</em> は任意のマップ型に指定できます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>以前は <em>locals</em> も辞書でなければなりませんでした.</p>
<p><em>locals</em> 辞書が省略された場合、標準の値として <em>globals</em> に設定されます。辞書が両方とも省略された場合、表現式は <tt class="xref py py-func docutils literal"><span class="pre">execfiles()</span></tt> が呼び出されている環境の下で実行されます。戻り値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">標準では <em>locals</em> は後に述べる関数 <a class="reference internal" href="#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a> のように動作します: 標準の <em>locals</em> 辞書に対する変更を試みてはいけません。
<a class="reference internal" href="#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> の呼び出しが返る時にコードが <em>locals</em> に与える影響を知りたいなら、明示的に <em>loacals</em> 辞書を渡してください。
<a class="reference internal" href="#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> は関数のローカルを変更するための信頼性のある方法として使うことはできません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="file">
<tt class="descname">file</tt><big>(</big><em>filename</em><span class="optional">[</span>, <em>mode</em><span class="optional">[</span>, <em>bufsize</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#file" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#file" title="file"><tt class="xref py py-class docutils literal"><span class="pre">file</span></tt></a> 型のコンストラクタです。詳しくは
<a class="reference internal" href="stdtypes.html#bltin-file-objects"><em>ファイルオブジェクト</em></a> 節を参照してください。コンストラクタの引数は後述の <a class="reference internal" href="#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> 組み込み関数と同じです。</p>
<p>ファイルを開くときは、このコンストラクタを直接呼ばずに <a class="reference internal" href="#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a>
を呼び出すのが望ましい方法です。 <a class="reference internal" href="#file" title="file"><tt class="xref py py-class docutils literal"><span class="pre">file</span></tt></a> は型テストにより適しています (たとえば <tt class="docutils literal"><span class="pre">isinstance(f,</span> <span class="pre">file)</span></tt> と書くような)。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="filter">
<tt class="descname">filter</tt><big>(</big><em>function</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> のうち、 <em>function</em> が真を返すような要素からなるリストを構築します。 <em>iterable</em> はシーケンスか、反復をサポートするコンテナか、イテレータです。 <em>iterable</em> が文字列型かタプル型の場合、結果も同じ型になります。そうでない場合はリストとなります。 <em>function</em> が
<tt class="docutils literal"><span class="pre">None</span></tt> の場合、恒等関数を仮定します。すなわち、 <em>iterable</em> の偽となる要素は除去されます。</p>
<p>function が <tt class="docutils literal"><span class="pre">None</span></tt> ではない場合、 <tt class="docutils literal"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></tt>
は <tt class="docutils literal"><span class="pre">[item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item)]</span></tt> と同等です。
function が <tt class="docutils literal"><span class="pre">None</span></tt> の場合 <tt class="docutils literal"><span class="pre">[item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item]</span></tt>
と同等です。</p>
<p>この関数のイテレータ版である <a class="reference internal" href="itertools.html#itertools.ifilter" title="itertools.ifilter"><tt class="xref py py-func docutils literal"><span class="pre">itertools.ifilter()</span></tt></a> と
<a class="reference internal" href="itertools.html#itertools.ifilterfalse" title="itertools.ifilterfalse"><tt class="xref py py-func docutils literal"><span class="pre">itertools.ifilterfalse()</span></tt></a> についても参照して下さい、変種として <em>function</em> が false を返す場合に要素を返す変種も含んでいます。</p>
</dd></dl>

<dl class="function">
<dt id="float">
<tt class="descname">float</tt><big>(</big><span class="optional">[</span><em>x</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列または数値を浮動小数点数に変換します。引数が文字列の場合、十進の数または浮動小数点数を含んでいなければなりません。符号が付いていてもかまいません。また、空白文字中に埋め込まれていてもかまいません。引数は [+|-]nan 、 [+|-]inf であっても構いません。それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができ、同じ値の浮動小数点数が (Python の浮動小数点精度で) 返されます。引数が指定されなかった場合、 <tt class="docutils literal"><span class="pre">0.0</span></tt> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last" id="index-2">文字列で値を渡す際、背後の C ライブラリによって NaN および
Infinity が返されるかもしれません。 float は文字列、 nan 、 inf
、および -inf を、それぞれ、 NaN 、正の無限大、負の無限大として解釈します。大文字小文字の違い、 + 記号、および、 nan に対する -
記号は無視されます。</p>
</div>
<p>浮動小数点数型については、 <a class="reference internal" href="stdtypes.html#typesnumeric"><em>数値型 int, float, long, complex</em></a> も参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="format">
<tt class="descname">format</tt><big>(</big><em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-3"><em>value</em> を <em>format_spec</em> で制御される &#8220;フォーマット化&#8221; 表現に変換します。
<em>format_spec</em> の評価は <em>value</em> 引数の型に依存しますが、ほとんどのビルト組み込み型で使われる標準的な構文が存在します <a class="reference internal" href="string.html#formatspec"><em>書式指定ミニ言語仕様 (Format Specification Mini-Language)</em></a> 。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last"><tt class="docutils literal"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></tt> は単に <tt class="docutils literal"><span class="pre">value.__format__(format_spec)</span></tt> を呼び出すだけです。</p>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">frozenset</tt><big>(</big><span class="optional">[</span><em>iterable</em><span class="optional">]</span><big>)</big></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><tt class="xref py py-class docutils literal"><span class="pre">frozenset</span></tt></a> オブジェクトを返します。オプションで
<em>iterable</em> から要素を取得します。
frozenset 型については、 <a class="reference internal" href="stdtypes.html#types-set"><em>set（集合）型 &#8212; set, frozenset</em></a> も参照下さい。</p>
<p>他のコンテナ型については、組み込みクラスの <a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>,
<a class="reference internal" href="#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, および , <a class="reference internal" href="#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> と、 <a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> モジュールを参照下さい。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="getattr">
<tt class="descname">getattr</tt><big>(</big><em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#getattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された <em>object</em> の属性を返します。 <em>name</em> は文字列でなくてはなりません。文字列がオブジェクトの属性名の一つであった場合、戻り値はその属性の値になります。例えば、 <tt class="docutils literal"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></tt> は
<tt class="docutils literal"><span class="pre">x.foobar</span></tt> と等価です。指定された属性が存在しない場合、 <em>default</em> が与えられている場合にはそれが返されます。そうでない場合には <a class="reference internal" href="exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a>
が送出されます。</p>
</dd></dl>

<dl class="function">
<dt id="globals">
<tt class="descname">globals</tt><big>(</big><big>)</big><a class="headerlink" href="#globals" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のグローバルシンボルテーブルを表す辞書を返します。常に現在のモジュールの辞書になります (関数またはメソッドの中ではそれらを定義しているモジュールを指し、この関数を呼び出したモジュールではありません)。</p>
</dd></dl>

<dl class="function">
<dt id="hasattr">
<tt class="descname">hasattr</tt><big>(</big><em>object</em>, <em>name</em><big>)</big><a class="headerlink" href="#hasattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つであった場合 <tt class="docutils literal"><span class="pre">True</span></tt> を、そうでない場合 <tt class="docutils literal"><span class="pre">False</span></tt> を返します (この関数は <tt class="docutils literal"><span class="pre">getattr(object,</span> <span class="pre">name)</span></tt> を呼び出し、例外を送出するかどうかを調べることで実装されています)。</p>
</dd></dl>

<dl class="function">
<dt id="hash">
<tt class="descname">hash</tt><big>(</big><em>object</em><big>)</big><a class="headerlink" href="#hash" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトのハッシュ値を (存在すれれば) 返します。ハッシュ値は整数です。これらは辞書を検索する際に辞書のキーを高速に比較するために使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と
1.0 のように型が異なっていてもです)。</p>
</dd></dl>

<dl class="function">
<dt id="help">
<tt class="descname">help</tt><big>(</big><span class="optional">[</span><em>object</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#help" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>組み込みヘルプシステムを起動します (この関数は対話的な使用のためのものです)。引数が与えられていない場合、対話的ヘルプシステムはインタプリタコンソール上で起動します。引数が文字列の場合、文字列はモジュール、関数、クラス、メソッド、キーワード、またはドキュメントの項目名として検索され、ヘルプページがコンソール上に印字されます。引数が何らかのオブジェクトの場合、そのオブジェクトに関するヘルプページが生成されます。</p>
<p>この関数は、 <a class="reference internal" href="site.html#module-site" title="site: サイト固有のモジュールを参照する標準の方法。"><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> モジュールから、組み込みの名前空間に移されました。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="hex">
<tt class="descname">hex</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(任意のサイズの) 整数を16進の文字列に変換します。結果は Python の式としても使える形式になります。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">浮動小数点数の16進文字列表記を得たい場合には、
<a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><tt class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></tt></a> メソッドを使って下さい。</p>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>以前は符号なしのリテラルしか返しませんでした.</p>
</dd></dl>

<dl class="function">
<dt id="id">
<tt class="descname">id</tt><big>(</big><em>object</em><big>)</big><a class="headerlink" href="#id" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの &#8220;識別値&#8221; を返します。この値は整数 (または長整数) で、このオブジェクトの有効期間は一意かつ定数であることが保証されています。オブジェクトの有効期間が重ならない 2 つのオブジェクトは同じ
<a class="reference internal" href="#id" title="id"><tt class="xref py py-func docutils literal"><span class="pre">id()</span></tt></a> 値を持つかもしれません。</p>
</dd></dl>

<dl class="function">
<dt id="input">
<tt class="descname">input</tt><big>(</big><span class="optional">[</span><em>prompt</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#input" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">eval(raw_input(prompt))</span></tt> と同じです。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">この関数はユーザのエラーに対して安全ではありません ! この関数は、入力は有効な Python の式であると期待しています; 入力が構文的に正しくない場合、 <a class="reference internal" href="exceptions.html#exceptions.SyntaxError" title="exceptions.SyntaxError"><tt class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></tt></a> が送出されます。式を評価する際にエラーが生じた場合、他の例外も送出されるかもしれません。
(一方、この関数はまさに、ときどき熟練者がすばやくスクリプトを書く際に必要とするものです)</p>
</div>
<p><a class="reference internal" href="readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">readline</span></tt></a> モジュールが読み込まれていれば、 <a class="reference internal" href="#input" title="input"><tt class="xref py py-func docutils literal"><span class="pre">input()</span></tt></a> は精緻な行編集およびヒストリ機能を提供します。</p>
<p>一般的なユーザからの入力のための関数としては <a class="reference internal" href="#raw_input" title="raw_input"><tt class="xref py py-func docutils literal"><span class="pre">raw_input()</span></tt></a> を使うことを検討してください。</p>
</dd></dl>

<dl class="function">
<dt id="int">
<tt class="descname">int</tt><big>(</big><span class="optional">[</span><em>x</em><span class="optional">[</span>, <em>base</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#int" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列または数値を通常の整数に変換します。引数が文字列の場合、
Python 整数として表現可能な十進の数でなければなりません。符号が付いていてもかまいません。また、空白文字中に埋め込まれていてもかまいません。 <em>base</em> 引数は変換の基数 (デフォルト値は10です) を表し、範囲 [2, 36] の整数またはゼロをとることができます。 <em>base</em>
がゼロの場合、文字列の内容から適切な基数を推測します; 変換は整数リテラルと同じです (<a class="reference internal" href="../reference/lexical_analysis.html#numbers"><em>数値リテラル</em></a> を参照下さい) 。
<em>base</em> が指定されており、 <em>x</em> が文字列でない場合、
<a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができます。浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸めます。引数が通常整数の範囲を超えている場合、長整数が代わりに返されます。引数が与えられなかった場合、 <tt class="docutils literal"><span class="pre">0</span></tt> を返します。</p>
<p>整数型については、 <a class="reference internal" href="stdtypes.html#typesnumeric"><em>数値型 int, float, long, complex</em></a> も参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="isinstance">
<tt class="descname">isinstance</tt><big>(</big><em>object</em>, <em>classinfo</em><big>)</big><a class="headerlink" href="#isinstance" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>object</em> が引数 <em>classinfo</em> のインスタンスであるか、 (直接または間接的な) サブクラスのインスタンスの場合に真を返します。また、 <em>classinfo</em> が型オブジェクト (新しい形式のクラス) であり、
<em>object</em> がその型のオブジェクトであるか、または、 (直接的または間接的な) サブクラスの場合にも真を返します。 <em>object</em> がクラスインスタンスや与えられた型のオブジェクトでない場合、この関数は常に偽を返します。
<em>classinfo</em> をクラスオブジェクトでも型オブジェクトにもせず、クラスや型オブジェクトからなるタプルや、そういったタプルを再帰的に含むタプル (他のシーケンス型は受理されません) でもかまいません。
<em>classinfo</em> がクラス、型、クラスや型からなるタプル、そういったタプルが再帰構造をとっているタプルのいずれでもない場合、例外
<a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2 で変更: </span>型情報をタプルにした形式のサポートが追加されました。</p>
</dd></dl>

<dl class="function">
<dt id="issubclass">
<tt class="descname">issubclass</tt><big>(</big><em>class</em>, <em>classinfo</em><big>)</big><a class="headerlink" href="#issubclass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>class</em> が <em>classinfo</em> の (直接または間接的な) サブクラスである場合に真を返します。クラスはそれ自身のサブクラスとみなされます。 <em>classinfo</em> はクラスオブジェクトからなるタプルでもよく、この場合には <em>classinfo</em>
のすべてのエントリが調べられます。その他の場合では、例外
<a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>型情報からなるタプルへのサポートが追加されました.</p>
</dd></dl>

<dl class="function">
<dt id="iter">
<tt class="descname">iter</tt><big>(</big><em>o</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#iter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><em class="xref std std-term">iterator</em></a> (イテレータ)オブジェクトを返します。 2 つ目の引数があるかどうかで、最初の引数の解釈は非常に異なります。 2 つ目の引数がない場合、 <em>o</em> は反復プロトコル (<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> メソッド) か、シーケンス型プロトコル (引数が <tt class="docutils literal"><span class="pre">0</span></tt> から開始する
<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> メソッド) をサポートする集合オブジェクトでなければなりません。これらのプロトコルが両方ともサポートされていない場合、 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。
2 つ目の引数 <em>sentinel</em> が与えられていれば、 <em>o</em> は呼び出し可能なオブジェクトでなければなりません。この場合に生成されるイテレータは、
<a class="reference internal" href="stdtypes.html#iterator.next" title="iterator.next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> を呼ぶ毎に <em>o</em> を引数無しで呼び出します。返された値が
<em>sentinel</em> と等しければ、 <a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> が送出されます。そうでない場合、戻り値がそのまま返されます。</p>
<p>ファイルの行を特定の行にたどりつくまで読むのに
<a class="reference internal" href="#iter" title="iter"><tt class="xref py py-func docutils literal"><span class="pre">iter()</span></tt></a> の第2の形式の便利に応用できます。以下の例では <tt class="docutils literal"><span class="pre">&quot;STOP&quot;</span></tt> にたどりつくまでファイルを読みます:</p>
<div class="highlight-python"><pre>with open("mydata.txt") as fp:
    for line in iter(fp.readline, "STOP"):
    process_line(line)</pre>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="len">
<tt class="descname">len</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#len" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの長さ (要素の数) を返します。引数はシーケンス型 (文字列、タプル、またはリスト) か、マップ型 (辞書) です。</p>
</dd></dl>

<dl class="function">
<dt id="list">
<tt class="descname">list</tt><big>(</big><span class="optional">[</span><em>iterable</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#list" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素と同じ要素をもち、かつ順番も同じなリストを返します。
<em>sequence</em> はシーケンス、反復処理をサポートするコンテナ、あるいはイテレータオブジェクトです。 <em>sequence</em> がすでにリストの場合、
<tt class="docutils literal"><span class="pre">iterable[:]</span></tt> と同様にコピーを作成して返します。例えば、 <tt class="docutils literal"><span class="pre">list('abc')</span></tt> は <tt class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></tt> および <tt class="docutils literal"><span class="pre">list((1,</span> <span class="pre">2,</span>
<span class="pre">3))</span></tt> は <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt> を返します。引数が与えられなかった場合、新しい空のリスト <tt class="docutils literal"><span class="pre">[]</span></tt> を返します。</p>
<p><a class="reference internal" href="#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a> は変更可能なシーケンス型であり、 <a class="reference internal" href="stdtypes.html#typesseq"><em>シーケンス型 &#8212; str, unicode, list, tuple, bytearray, buffer, xrange</em></a> に記述があります。他のコンテナ型については組み込み型の <a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>,
<a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a>, および <a class="reference internal" href="#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> クラスと、 <a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a>
モジュールを参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="locals">
<tt class="descname">locals</tt><big>(</big><big>)</big><a class="headerlink" href="#locals" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のローカルシンボルテーブルを表す辞書を更新して返します。関数ブロックで <a class="reference internal" href="#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a> を呼び出した場合自由変数が返されます、クラスブロックでは返されません。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">この辞書の内容は変更してはいけません; 値を変更しても、インタプリタが使うローカル変数や自由変数の値には影響しません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="long">
<tt class="descname">long</tt><big>(</big><span class="optional">[</span><em>x</em><span class="optional">[</span>, <em>base</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#long" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列または数値を長整数値に変換します。引数が文字列の場合、 Python
整数として表現可能な十進の数でなければなりません。符号が付いていてもかまいません。また、空白文字中に埋め込まれていてもかまいません。 <em>base</em> 引数は <a class="reference internal" href="#int" title="int"><tt class="xref py py-func docutils literal"><span class="pre">int()</span></tt></a> と同じように解釈され、
<em>x</em> が文字列の時だけ与えることができます。それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができ、同じ値の長整数が返されます。浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸めます。引数が与えられなかった場合、 <tt class="docutils literal"><span class="pre">0L</span></tt> を返します。</p>
<p>長整数型については、 <a class="reference internal" href="stdtypes.html#typesnumeric"><em>数値型 int, float, long, complex</em></a> も参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="map">
<tt class="descname">map</tt><big>(</big><em>function</em>, <em>iterable</em>, <em>...</em><big>)</big><a class="headerlink" href="#map" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>function</em> を <em>iterable</em> の全ての要素に適用し、返された値からなるリストを返します。追加の <em>iterable</em> 引数を与えた場合、 <em>function</em> はそれらを引数として取らなければならず、関数はそのリストの全ての要素について個別に適用されます; 他のリストより短いリストがある場合、要素 <tt class="docutils literal"><span class="pre">None</span></tt> で延長されます。 <em>function</em> が <tt class="docutils literal"><span class="pre">None</span></tt> の場合、恒等関数であると仮定されます; すなわち、複数のリスト引数が存在する場合、
<a class="reference internal" href="#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a> は全てのリスト引数に対し、対応する要素からなるタプルからなるリストを返します (転置操作のようなものです)。 <em>list</em> 引数はどのようなシーケンス型でもかまいません; 結果は常にリストになります。</p>
</dd></dl>

<dl class="function">
<dt id="max">
<tt class="descname">max</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>args...][key</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#max" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が <em>iterable</em> だけの場合、空でないシーケンス (文字列、タプルまたはリスト) の要素のうち最大のものを返します。 1 個よりも引数が多い場合、引数間で最大のものを返します。</p>
<p>オプションの <em>key</em> 引数には <tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> で使われるのと同じような 1 引数の順序付け関数を指定します。 <em>key</em> を指定する場合はキーワード形式でなければなりません (たとえば <tt class="docutils literal"><span class="pre">max(a,b,c,key=func)</span></tt>)。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span>オプションの <em>key</em> 引数が追加されました.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">memoryview</tt><big>(</big><em>obj</em><big>)</big></dt>
<dd><p>与えられたオブジェクトから作られた &#8220;メモリビュー&#8221; オブジェクトを返します。詳しくは <a class="reference internal" href="stdtypes.html#typememoryview"><em>メモリビュー型</em></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="min">
<tt class="descname">min</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>args...][key</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#min" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が <em>iterable</em> だけの場合、空でないシーケンス (文字列、タプルまたはリスト) の要素のうち最小のものを返します。 1  個よりも引数が多い場合、引数間で最小のものを返します。</p>
<p>オプションの <em>key</em> 引数には <tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> で使われるのと同じような 1 引数の順序付け関数を指定します。 <em>key</em> を指定する場合はキーワード形式でなければなりません (たとえば <tt class="docutils literal"><span class="pre">min(a,b,c,key=func)</span></tt>)。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span>オプションの <em>key</em> 引数が追加されました.</p>
</dd></dl>

<dl class="function">
<dt id="next">
<tt class="descname">next</tt><big>(</big><em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterator</em> から、 <a class="reference internal" href="stdtypes.html#iterator.next" title="iterator.next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドにより、次の要素を取得します。もし、 <em>default</em> が与えられると、イテレータが空である場合に、それが返されます。それ以外の場合は、 <a class="reference internal" href="exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> が送出されます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。
<a class="reference internal" href="#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object()</span></tt></a> は新スタイルのクラスの、基底クラスです。これは、新スタイルのクラスのインスタンスに共通のメソッド群を持ちます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>この関数はいかなる引数も受け付けません。以前は、引数を受理しまし
たが無視していました。</p>
</dd></dl>

<dl class="function">
<dt id="oct">
<tt class="descname">oct</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#oct" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>(任意のサイズの) 整数を 8 進の文字列に変換します。結果は Python の式としても使える形式になります。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>以前は符号なしのリテラルしか返しませんでした.</p>
</dd></dl>

<dl class="function">
<dt id="open">
<tt class="descname">open</tt><big>(</big><em>filename</em><span class="optional">[</span>, <em>mode</em><span class="optional">[</span>, <em>bufsize</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルを開いて、  <a class="reference internal" href="stdtypes.html#bltin-file-objects"><em>ファイルオブジェクト</em></a> にて説明される、
<a class="reference internal" href="#file" title="file"><tt class="xref py py-class docutils literal"><span class="pre">file</span></tt></a> オブジェクトを返します。もし、ファイルが開けないなら、
<a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> が送出されます。ファイルを開くときは <a class="reference internal" href="#file" title="file"><tt class="xref py py-class docutils literal"><span class="pre">file</span></tt></a>
のコンストラクタを直接呼ばずに <a class="reference internal" href="#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> を使うのが望ましい方法です。</p>
<p>最初の 2 つの引数は <tt class="docutils literal"><span class="pre">stdio</span></tt> の <tt class="xref c c-func docutils literal"><span class="pre">fopen()</span></tt> と同じです:
<em>filename</em> は開きたいファイルの名前で、 <em>mode</em> はファイルをどのようにして開くかを指定します。</p>
<p>最もよく使われる <em>mode</em> の値は、読み出しの <tt class="docutils literal"><span class="pre">'r'</span></tt> 、書き込み (ファイルがすでに存在すれば切り詰められます) の <tt class="docutils literal"><span class="pre">'w'</span></tt> 、追記書き込みの
<tt class="docutils literal"><span class="pre">'a'</span></tt> です ( <em>いくつかの</em> Unix システムでは、 <em>全て</em> の書き込みが現在のファイルシーク位置に関係なくファイルの末尾に追加されます)。
<em>mode</em> が省略された場合、標準の値は <tt class="docutils literal"><span class="pre">'r'</span></tt> になります。デフォルトではテキストモードでファイルを開きます。 <tt class="docutils literal"><span class="pre">'\n'</span></tt> 文字は、プラットフォームでの改行の表現に変換されます。移植性を高めるために、バイナリファイルを開くときには、 <em>mode</em> の値に <tt class="docutils literal"><span class="pre">'b'</span></tt> を追加しなければなりません。(バイナリファイルとテキストファイルを区別なく扱うようなシステムでも、ドキュメンテーションの代わりになるので便利です。) 他に
<em>mode</em> に与えられる可能性のある値については後述します。</p>
<p id="index-4">オプションの <em>bufsize</em> 引数は、ファイルのために必要とするバッファのサイズを指定します: 0 は非バッファリング、 1 は行単位バッファリング、その他の正の値は指定した値 (の近似値) のサイズをもつバッファを使用することを意味します。 <em>bufsize</em> の値が負の場合、システムの標準を使います。通常、tty 端末は行単位のバッファリングであり、その他のファイルは完全なバッファリングです。省略された場合、システムの標準の値が使われます。  <a class="footnote-reference" href="#id6" id="id3">[2]</a></p>
<p><tt class="docutils literal"><span class="pre">'r+'</span></tt>, <tt class="docutils literal"><span class="pre">'w+'</span></tt>, および <tt class="docutils literal"><span class="pre">'a+'</span></tt> はファイルを更新モードで開きます (<tt class="docutils literal"><span class="pre">'w+'</span></tt> はファイルがすでに存在すれば切り詰めるので注意してください)。バイナリとテキストファイルを区別するシステムでは、ファイルをバイナリモードで開くためには <tt class="docutils literal"><span class="pre">'b'</span></tt> を追加してください (区別しないシステムでは <tt class="docutils literal"><span class="pre">'b'</span></tt> は無視されます)。</p>
<p>標準の <tt class="xref c c-func docutils literal"><span class="pre">fopen()</span></tt> における <em>mode</em> の値に加えて、 <tt class="docutils literal"><span class="pre">'U'</span></tt> または
<tt class="docutils literal"><span class="pre">'rU'</span></tt> を使うことができます。 Python が全改行文字サポートを行っている (標準ではしています) 場合、ファイルがテキストファイルで開かれますが、行末文字として Unix における慣行である <tt class="docutils literal"><span class="pre">'\n'</span></tt> 、Macintosh
における慣行である <tt class="docutils literal"><span class="pre">'\r'</span></tt> 、 Windows における慣行である
<tt class="docutils literal"><span class="pre">'\r\n'</span></tt> のいずれを使うこともできます。これらの改行文字の外部表現はどれも、 Python プログラムからは <tt class="docutils literal"><span class="pre">'\n'</span></tt> に見えます。 Python が全改行文字サポートなしで構築されている場合、 <em>mode</em> <tt class="docutils literal"><span class="pre">'U'</span></tt> は通常のテキストモードと同様になります。開かれたファイルオブジェクトはまた、 <tt class="xref py py-attr docutils literal"><span class="pre">newlines</span></tt> と呼ばれる属性を持っており、その値は <tt class="docutils literal"><span class="pre">None</span></tt>
(改行が見つからなかった場合)、 <tt class="docutils literal"><span class="pre">'\n'</span></tt>, <tt class="docutils literal"><span class="pre">'\r'</span></tt>, <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>,
または見つかった全ての改行タイプを含むタプルになります。</p>
<p><tt class="docutils literal"><span class="pre">'U'</span></tt> を取り除いた後のモードは <tt class="docutils literal"><span class="pre">'r'</span></tt>, <tt class="docutils literal"><span class="pre">'w'</span></tt>, <tt class="docutils literal"><span class="pre">'a'</span></tt> のいずれかで始まる、というのが Python における規則です。</p>
<p>Python では、 <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: 標準入力もしくはファイルのリストをまたいでループする"><tt class="xref py py-mod docutils literal"><span class="pre">fileinput</span></tt></a>, <a class="reference internal" href="os.html#module-os" title="os: 雑多なオペレーティングシステムインタフェース。"><tt class="xref py py-mod docutils literal"><span class="pre">os</span></tt></a>, <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><tt class="xref py py-mod docutils literal"><span class="pre">os.path</span></tt></a>,
<a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: 一時的なファイルやディレクトリを生成。"><tt class="xref py py-mod docutils literal"><span class="pre">tempfile</span></tt></a>, <a class="reference internal" href="shutil.html#module-shutil" title="shutil: コピーを含む高レベルなファイル操作。"><tt class="xref py py-mod docutils literal"><span class="pre">shutil</span></tt></a> などの多数のファイル操作モジュールが提供されています。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span>モード文字列の先頭についての制限が導入されました.</p>
</dd></dl>

<dl class="function">
<dt id="ord">
<tt class="descname">ord</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#ord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さ 1 の与えられた文字列に対し、その文字列が unicode オブジェクトならば Unicode コードポイントを表す整数を、 8 ビット文字列ならばそのバイトの値を返します。たとえば、 <tt class="docutils literal"><span class="pre">ord('a')</span></tt> は整数 <tt class="docutils literal"><span class="pre">97</span></tt> を返し、 <tt class="docutils literal"><span class="pre">ord(u'\u2020')</span></tt> は <tt class="docutils literal"><span class="pre">8224</span></tt> を返します。この値は 8 ビット文字列に対する <a class="reference internal" href="#chr" title="chr"><tt class="xref py py-func docutils literal"><span class="pre">chr()</span></tt></a> の逆であり、 unicode オブジェクトに対する
<a class="reference internal" href="#unichr" title="unichr"><tt class="xref py py-func docutils literal"><span class="pre">unichr()</span></tt></a> の逆です。引数が unicode で Python が UCS2 Unicode
対応版ならば、その文字のコードポイントは両端を含めて [0..65535] の範囲に入っていなければなりません。この範囲から外れると文字列の長さが 2 になり、 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されることになります。</p>
</dd></dl>

<dl class="function">
<dt id="pow">
<tt class="descname">pow</tt><big>(</big><em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の <em>y</em> 乗を返します; <em>z</em> があれば、 <em>x</em> の <em>y</em> 乗に対する <em>z</em>
のモジュロを返します (<tt class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)%</span> <span class="pre">z</span></tt> より効率よく計算されます)。引数二つの <tt class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></tt> という形式は、冪乗演算子を使った <tt class="docutils literal"><span class="pre">x**y</span></tt>
と等価です。</p>
<p>引数は数値型でなくてはなりません。型混合の場合、 2 進算術演算における型強制規則が適用されます。通常整数、および、長整数の被演算子に対しては、二つ目の引数が負の数でない限り、結果は (型強制後の) 被演算子と同じ型になります;
負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型の結果が返されます。例えば、 <tt class="docutils literal"><span class="pre">10**2</span></tt> は <tt class="docutils literal"><span class="pre">100</span></tt> を返しますが、 <tt class="docutils literal"><span class="pre">10**-2</span></tt>
は <tt class="docutils literal"><span class="pre">0.01</span></tt> を返します。 (最後に述べた機能は Python 2.2 で追加されたものです。 Python 2.1 以前では、双方の引数が整数で二つ目の値が負の場合、例外が送出されます。) 二つ目の引数が負の場合、三つめの引数は無視されます。 <em>z</em> がある場合、 <em>x</em> および <em>y</em> は整数型でなければならず、 <em>y</em> は非負の値でなくてはなりません (この制限は Python 2.2
で追加されました。 Python 2.1 以前では、 3 つの浮動小数点引数を持つ
<tt class="docutils literal"><span class="pre">pow()</span></tt> は浮動小数点の丸めに関する偶発誤差により、プラットフォーム依存の結果を返します)。</p>
</dd></dl>

<dl class="function">
<dt id="print">
<tt class="descname">print</tt><big>(</big><em>[object, ...][, sep=' '][, end='\n'][, file=sys.stdout]</em><big>)</big><a class="headerlink" href="#print" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> (複数でも可) を <em>sep</em> で区切りながらストリーム、 <em>file</em> に表示し、最後に <em>end</em> を表示します。 <em>sep</em>, <em>end</em> そして <em>file</em> が与えられる場合、キーワード引数として与えられる必要があります。</p>
<p>キーワードなしの引数は、 <a class="reference internal" href="#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> がするように、すべて、文字列に変換され、 <em>sep</em> で区切られながらストリームに書き出され、最後に
<em>end</em> を書き出します。 <em>sep</em> と <em>end</em> の両方とも、文字列でなければなりません。; デフォルトの値を指定するために、 <tt class="docutils literal"><span class="pre">None</span></tt> であっても構いません。もし、 <em>object</em> が与えられなければ、 <a class="reference internal" href="#print" title="print"><tt class="xref py py-func docutils literal"><span class="pre">print()</span></tt></a> は、単純に <em>end</em> だけ書き出します。</p>
<p><em>file</em> 引数は、 <tt class="docutils literal"><span class="pre">write(string)</span></tt> メソッドを持つオブジェクトでなければなりません。指定されないか、 <tt class="docutils literal"><span class="pre">None</span></tt> であった場合には、
<a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><tt class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></tt></a> が使われます。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p>この関数は <tt class="docutils literal"><span class="pre">print</span></tt> という名前が <a class="reference internal" href="../reference/simple_stmts.html#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> ステートメントとして解釈されるため、通常は使用できません。ステートメントを無効化して、 <a class="reference internal" href="#print" title="print"><tt class="xref py py-func docutils literal"><span class="pre">print()</span></tt></a> 関数を使うためには、以下の future ステートメントをモジュールの最初に書いて下さい。:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</pre></div>
</div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.6 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="property">
<tt class="descname">property</tt><big>(</big><span class="optional">[</span><em>fget</em><span class="optional">[</span>, <em>fset</em><span class="optional">[</span>, <em>fdel</em><span class="optional">[</span>, <em>doc</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#property" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-new-style-class"><em class="xref std std-term">new-style class</em></a> (新しい形式のクラス) (<a class="reference internal" href="#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> から派生したクラス) におけるプロパティ属性を返します。</p>
<p><em>fget</em> は属性値を取得するための関数で、同様に <em>fset</em> は属性値を設定するための関数です。また、 <em>fdel</em> は属性を削除するための関数です。以下に属性 <tt class="docutils literal"><span class="pre">x</span></tt> を扱う典型的な利用法を示します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>もし <em>c</em> が <em>C</em> のインスタンスならば、 <tt class="docutils literal"><span class="pre">c.x</span></tt> は getter を呼び出し、
<tt class="docutils literal"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></tt> は setter を、 <tt class="docutils literal"><span class="pre">del</span> <span class="pre">c.x</span></tt> は deleter を呼び出します。</p>
<p><em>doc</em> がもし与えられたならばそれがプロパティ属性のドキュメント文字列になります。与えられない場合、プロパティは <em>fget</em> のドキュメント文字列(もしあれば)をコピーします。これにより、読み取り専用プロパティを
<a class="reference internal" href="#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a> を <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a> (デコレータ)として使って容易に作れるようになります。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Parrot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p>のようにすると、 <tt class="xref py py-meth docutils literal"><span class="pre">voltage()</span></tt> が同じ名前の読み取り専用属性の
&#8220;getter&#8221; になります。</p>
<p>プロパティオブジェクトは <tt class="xref py py-attr docutils literal"><span class="pre">getter</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">setter</span></tt>, および
<tt class="xref py py-attr docutils literal"><span class="pre">deleter</span></tt> メソッドを備えています。これらのメソッドは属性のコピーを生成するデコレータに適していて、デコレートした関数を対応する属性参照関数に割り当てます。これを説明するには、以下の例が最適でしょう。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x.setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x.deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>このコードは、最初の例と等価です。追加の関数に、元々の属性と同じ名前 (この例では、 <tt class="docutils literal"><span class="pre">x</span></tt> です) を与えることに注意して下さい。</p>
<p>返される属性も、コンストラクタの引数を反映した、 <tt class="docutils literal"><span class="pre">fget</span></tt>,
<tt class="docutils literal"><span class="pre">fset</span></tt>, そして <tt class="docutils literal"><span class="pre">fdel</span></tt> 属性を持ちます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span><em>doc</em> が与えられない場合に <em>fget</em> のドキュメント文字列を使う。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span><tt class="docutils literal"><span class="pre">getter</span></tt>, <tt class="docutils literal"><span class="pre">setter</span></tt> そして <tt class="docutils literal"><span class="pre">deleter</span></tt> 属性が追加されました。</p>
</dd></dl>

<dl class="function">
<dt id="range">
<tt class="descname">range</tt><big>(</big><span class="optional">[</span><em>start</em><span class="optional">]</span>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#range" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>等差数列を含むリストを生成するための多機能関数です。 <a class="reference internal" href="../reference/compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループでよく使われます。引数は通常の整数でなければなりません。 <em>step</em>
引数が無視された場合、標準の値 <tt class="docutils literal"><span class="pre">1</span></tt> になります。 <em>start</em> 引数が省略された場合、標準の値 <tt class="docutils literal"><span class="pre">0</span></tt> になります。完全な形式では、通常の整数列
<tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step,</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">step,</span> <span class="pre">...]</span></tt> を返します。
<em>step</em> が正の値の場合、最後の要素は <em>stop</em> よりも小さい <tt class="docutils literal"><span class="pre">start</span>
<span class="pre">+</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">step</span></tt> の最大値になります; <em>step</em> が負の値の場合、最後の要素は <em>stop</em> よりも大きい <tt class="docutils literal"><span class="pre">start</span> <span class="pre">+</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">step</span></tt> の最小値になります。
<em>step</em> はゼロであってはなりません (さもなければ <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a>
が送出されます)。以下に例を示します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="raw_input">
<tt class="descname">raw_input</tt><big>(</big><span class="optional">[</span><em>prompt</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#raw_input" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>prompt</em> が存在する場合、末尾の改行を除いて標準出力に出力されます。次に、この関数は入力から 1 行を読み込んで文字列に変換して (末尾の改行を除いて) 返します。 EOF が読み込まれると <a class="reference internal" href="exceptions.html#exceptions.EOFError" title="exceptions.EOFError"><tt class="xref py py-exc docutils literal"><span class="pre">EOFError</span></tt></a>
が送出されます。以下に例を示します。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&#39;--&gt; &#39;</span><span class="p">)</span>
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">readline</span></tt></a> モジュールが読み込まれていれば、 <a class="reference internal" href="#input" title="input"><tt class="xref py py-func docutils literal"><span class="pre">input()</span></tt></a> は精緻な行編集およびヒストリ機能を提供します。</p>
</dd></dl>

<dl class="function">
<dt id="reduce">
<tt class="descname">reduce</tt><big>(</big><em>function</em>, <em>iterable</em><span class="optional">[</span>, <em>initializer</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#reduce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素に対して、iterableを単一の値に短縮するような形で
2 つの引数をもつ <em>function</em> を左から右に累積的に適用します。例えば、 <tt class="docutils literal"><span class="pre">reduce(labmda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">x+y,</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5])</span></tt> は
<tt class="docutils literal"><span class="pre">((((1+2)+3)+4)+5)</span></tt> を計算します。左引数 <em>x</em> は累計の値になり、右引数 <em>y</em> は <tt class="docutils literal"><span class="pre">iterable</span></tt> から取り出した更新値になります。オプションの <em>initializer</em> が存在する場合、計算の際に iterable の先頭に置かれます。また、 iterable が空の場合には標準の値になります。
<em>initializer</em> が与えられておらず、 <em>iterable</em> が単一の要素しか持っていない場合、最初の要素が返されます。</p>
</dd></dl>

<dl class="function">
<dt id="reload">
<tt class="descname">reload</tt><big>(</big><em>module</em><big>)</big><a class="headerlink" href="#reload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>すでにインポートされた <em>module</em> を再解釈し、再初期化します。引数はモジュールオブジェクトでなければならないので、予めインポートに成功していなければなりません。この関数はモジュールのソースコードファイルを外部エディタで編集して、 Python インタプリタから離れることなく新しいバージョンを試したい際に有効です。戻り値は (<em>module</em> 引数と同じ) モジュールオブジェクトです。</p>
<p><tt class="docutils literal"><span class="pre">reload(module)</span></tt> を実行すると、以下の処理が行われます:</p>
<ul class="simple">
<li>Python モジュールのコードは再コンパイルされ、モジュールレベルのコードは再度実行されます。モジュールの辞書中にある、何らかの名前に結び付けられたオブジェクトを新たに定義します。拡張モジュール中の
<tt class="docutils literal"><span class="pre">init</span></tt> 関数が二度呼び出されることはありません。</li>
<li>Python における他のオブジェクトと同様、以前のオブジェクトのメモリ領域は、参照カウントがゼロにならないかぎり再利用されません。</li>
<li>モジュール名前空間内の名前は新しいオブジェクト (または更新されたオブジェクト) を指すよう更新されます。</li>
<li>以前のオブジェクトが (外部の他のモジュールなどからの) 参照を受けている場合、それらを新たなオブジェクトに再束縛し直すことはないので、必要なら自分で名前空間を更新せねばなりません。</li>
</ul>
<p>いくつか補足説明があります:</p>
<p>モジュールは文法的に正しいが、その初期化には失敗した場合、そのモジュールの最初の <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文はモジュール名をローカルにはバインドしませんが、(部分的に初期化された) モジュールオブジェクトを
<tt class="docutils literal"><span class="pre">sys.modules</span></tt> に記憶します。従って、そのモジュールをロードしなおすには、 <a class="reference internal" href="#reload" title="reload"><tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt></a> する前にまず <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> (モジュールの名前を部分的に初期化されたオブジェクトにバインドします) を再度行わなければなりません。</p>
<p>モジュールが再ロードされた再、その辞書 (モジュールのグローバル変数を含みます) はそのまま残ります。名前の再定義を行うと、以前の定義を上書きするので、一般的には問題はありません。新たなバージョンのモジュールが古いバージョンで定義された名前を定義していない場合、古い定義がそのまま残ります。辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、この機能をモジュールを有効性を引き出すために使うことができます &#8212;
つまり、 <a class="reference internal" href="../reference/compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> 文を使えば、必要に応じてテーブルがあるかどうかをテストし、その初期化を飛ばすことができます。:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>組み込みモジュールや動的にロードされるモジュールを再ロードすることは、不正なやり方ではありませんが、一般的にそれほど便利ではありません。例外は <a class="reference internal" href="sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: トップレベルスクリプトが実行される環境。"><tt class="xref py py-mod docutils literal"><span class="pre">__main__</span></tt></a> および <a class="reference internal" href="__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a> です。しかしながら、多くの場合、拡張モジュールは 1 度以上初期化されるようには設計されておらず、再ロードされた場合には何らかの理由で失敗するかもしれません。</p>
<p>一方のモジュールが <a class="reference internal" href="../reference/simple_stmts.html#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> ... <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> ...
を使って、オブジェクトを他方のモジュールからインポートしているなら、他方のモジュールを <a class="reference internal" href="#reload" title="reload"><tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt></a> で呼び出しても、そのモジュールからインポートされたオブジェクトを再定義することはできません &#8212; この問題を回避する一つの方法は、 <a class="reference internal" href="../reference/simple_stmts.html#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> 文を再度実行することで、もう一つの方法は <a class="reference internal" href="../reference/simple_stmts.html#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> 文の代わりに <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> と限定的な名前 (<em>module</em>.*name*) を使うことです。</p>
<p>あるモジュールがクラスのインスタンスを生成している場合、そのクラスを定義しているモジュールの再ロードはそれらインスタンスのメソッド定義に影響しません &#8212; それらは古いクラス定義を使いつづけます。これは派生クラスの場合でも同じです。</p>
</dd></dl>

<dl class="function">
<dt id="repr">
<tt class="descname">repr</tt><big>(</big><em>object</em><big>)</big><a class="headerlink" href="#repr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの印字可能な表現を含む文字列を返します。これは型変換で得られる (逆クオートの) 値と同じです。通常の関数としてこの操作にアクセスできるとたまに便利です。この関数は多くの型について、
<a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> に渡されたときに同じ値を持つようなオブジェクトを表す文字列を生成しようとします。そうでない場合は、角括弧に囲まれたオブジェクトの型の名前と追加の情報 (大抵の場合はオブジェクトの名前とアドレスを含みます) を返します。クラスは、 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><tt class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></tt></a> メソッドを定義することで、この関数によりそのクラスのインスタンスが返すものを制御することができます。</p>
</dd></dl>

<dl class="function">
<dt id="reversed">
<tt class="descname">reversed</tt><big>(</big><em>seq</em><big>)</big><a class="headerlink" href="#reversed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素を逆順に取り出すイテレータ (reverse <a class="reference internal" href="../glossary.html#term-iterator"><em class="xref std std-term">iterator</em></a>) を返します。
<em>seq</em> は <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><tt class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></tt></a> メソッドを持つオブジェクトであるか、シーケンス型プロトコル (<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><tt class="xref py py-meth docutils literal"><span class="pre">__len__()</span></tt></a> メソッド、および、 <tt class="docutils literal"><span class="pre">0</span></tt> から始まる整数を引数にとる <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> メソッド) をサポートしていなければなりません。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.6 で変更: </span>カスタムの <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><tt class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></tt></a> メソッドを書く可能性を追加しました。</p>
</dd></dl>

<dl class="function">
<dt id="round">
<tt class="descname">round</tt><big>(</big><em>x</em><span class="optional">[</span>, <em>n</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#round" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> を小数点以下 <em>n</em> 桁で丸めた浮動小数点数の値を返します。 <em>n</em> が省略されると、標準の値はゼロになります。結果は浮動小数点数です。値は最も近い 10 のマイナス <em>n</em> の倍数に丸められます。二つの倍数との距離が等しい場合、ゼロから離れる方向に丸められます (従って、例えば
<tt class="docutils literal"><span class="pre">round(0.5)</span></tt> は <tt class="docutils literal"><span class="pre">1.0</span></tt> になり、 <tt class="docutils literal"><span class="pre">round(-0.5)</span></tt> は <tt class="docutils literal"><span class="pre">-1.0</span></tt> になります)。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">浮動小数点数に対する <a class="reference internal" href="#round" title="round"><tt class="xref py py-func docutils literal"><span class="pre">round()</span></tt></a> の振る舞いは意外なものかもしれません:
例えば、 <tt class="docutils literal"><span class="pre">round(2.675,</span> <span class="pre">2)</span></tt> は予想通りの <tt class="docutils literal"><span class="pre">2.68</span></tt> ではなく
<tt class="docutils literal"><span class="pre">2.67</span></tt> を与えます。これはバグではありません: これはほとんどの少数が浮動小数点数で正確に表せないことの結果です。詳しくは
<a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><em>浮動小数点演算、その問題と制限</em></a> を参照してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set</tt><big>(</big><span class="optional">[</span><em>iterable</em><span class="optional">]</span><big>)</big></dt>
<dd><p>新しいセット型オブジェクトを返します。オプションで <em>iterable</em> からとった要素を持たせることもできます。
set 型については、 <a class="reference internal" href="stdtypes.html#types-set"><em>set（集合）型 &#8212; set, frozenset</em></a> に説明があります。</p>
<p>他のコンテナについては、組み込みクラスの <a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>,
<a class="reference internal" href="#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, および <a class="reference internal" href="#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> クラス、および、
<a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> モジュールを参照下さい。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="setattr">
<tt class="descname">setattr</tt><big>(</big><em>object</em>, <em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#setattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> と対をなす関数です。引数はそれぞれオブジェクト、文字列、そして任意の値です。文字列はすでに存在する属性の名前でも、新たな属性の名前でもかまいません。この関数は指定した値を指定した属性に関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。例えば、 <tt class="docutils literal"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></tt> は <tt class="docutils literal"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></tt> と等価です。</p>
</dd></dl>

<dl class="function">
<dt id="slice">
<tt class="descname">slice</tt><big>(</big><span class="optional">[</span><em>start</em><span class="optional">]</span>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#slice" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-5"><tt class="docutils literal"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></tt> で指定されるインデクスの集合を表すスライス(<a class="reference internal" href="../glossary.html#term-slice"><em class="xref std std-term">slice</em></a>)オブジェクトを返します。
<tt class="docutils literal"><span class="pre">range(start)</span></tt> スライスオブジェクトを返します。引数 <em>start</em> および <em>step</em> は標準では <tt class="docutils literal"><span class="pre">None</span></tt> です。スライスオブジェクトは読み出し専用の属性 <tt class="xref py py-attr docutils literal"><span class="pre">start</span></tt>,
<tt class="xref py py-attr docutils literal"><span class="pre">stop</span></tt> および <tt class="xref py py-attr docutils literal"><span class="pre">step</span></tt> を持ち、これらは単に引数で使われた値 (または標準の値) を返します。これらの値には、その他のはっきりとした機能はありません; しかしながら、これらの値は Numerical Python
および、その他のサードパーティによる拡張で利用されています。スライスオブジェクトは拡張されたインデクス指定構文が使われる際にも生成されます。例えば: <tt class="docutils literal"><span class="pre">a[start:stop:step]</span></tt> や <tt class="docutils literal"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></tt> です。イテレータを返すもうひとつの関数、 <a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><tt class="xref py py-func docutils literal"><span class="pre">itertools.islice()</span></tt></a> も参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="sorted">
<tt class="descname">sorted</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>cmp</em><span class="optional">[</span>, <em>key</em><span class="optional">[</span>, <em>reverse</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#sorted" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素をもとに、並べ替え済みの新たなリストを生成して返します。</p>
<p>オプション引数 <em>cmp</em>, <em>key</em>, および <em>reverse</em> の意味は
<tt class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></tt> メソッドと同じです。 (<a class="reference internal" href="stdtypes.html#typesseq-mutable"><em>変更可能なシーケンス型</em></a> 節に説明があります。)</p>
<p><em>cmp</em> は2つの引数 (iterable の要素) からなるカスタムの比較関数を指定します。これは始めの引数が 2 つ目の引数に比べて小さい、等しい、大きいかに応じて負数、ゼロ、正数を返します。 <tt class="docutils literal"><span class="pre">cmp=lambda</span> <span class="pre">x,y:</span> <span class="pre">cmp(x.lower(),</span>
<span class="pre">y.lower())</span></tt> 。デフォルト値は <tt class="docutils literal"><span class="pre">None</span></tt> です。</p>
<p><em>key</em> は 1 つの引数からなる関数を指定します。これは個々のリストの要素から比較のキーを取り出すのに使われます。 <tt class="docutils literal"><span class="pre">key=str.lower</span></tt> 。デフォルト値は <tt class="docutils literal"><span class="pre">None</span></tt> です (要素を直接比較します)。</p>
<p><em>reverse</em> は真偽値です。 <tt class="docutils literal"><span class="pre">True</span></tt> がセットされた場合、リストの要素は個々の比較が反転したものとして並び替えられます。</p>
<p>一般的に、 <em>key</em> および <em>reverse</em> の変換プロセスは同等の <em>cmp</em> 関数を指定するより早く動作します。これは <em>key</em> および <em>reverse</em> がそれぞれの要素に一度だけ触れる間に、 <em>cmp</em> はリストのそれぞれの要素に対して複数回呼ばれることによるものです。旧式の <em>cmp</em> 関数を <em>key</em> 関数に変換するには <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><tt class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></tt></a>
を使用してください。</p>
<p>並ベ替えの例と簡潔なチュートリアルとして、 <a class="reference external" href="http://wiki.python.org/moin/HowTo/Sorting/">Sorting HowTo</a> を参照して下さい。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.4 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="staticmethod">
<tt class="descname">staticmethod</tt><big>(</big><em>function</em><big>)</big><a class="headerlink" href="#staticmethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>function</em> の静的メソッドを返します。</p>
<p>静的メソッドは暗黙の第一引数を受け取りません。静的メソッドの宣言は、以下のように書き慣わされます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">&#64;staticmethod</span></tt> は関数 <a class="reference internal" href="../glossary.html#term-decorator"><em class="xref std std-term">decorator</em></a> (デコレータ)形式です。詳しくは <a class="reference internal" href="../reference/compound_stmts.html#function"><em>関数定義</em></a> の関数定義についての説明を参照してください。</p>
<p>このメソッドはクラスで呼び出すこと (例えば C.f() ) も、インスタンスとして呼び出すこと (例えば C().f()) もできます。インスタンスはそのクラスが何であるかを除いて無視されます。</p>
<p>Python における静的メソッドは Java や C++ における静的メソッドと類似しています。より進んだ概念については、 <a class="reference internal" href="#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a> を参照してください。</p>
<p>もっと静的メソッドについての情報が必要ならば、 <a class="reference internal" href="../reference/datamodel.html#types"><em>標準型の階層</em></a> の標準型階層についてのドキュメントを繙いてください。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>関数デコレータ構文を追加しました.</p>
</dd></dl>

<dl class="function">
<dt id="str">
<tt class="descname">str</tt><big>(</big><span class="optional">[</span><em>object</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#str" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトをうまく印字可能な形に表現したものを含む文字列を返します。文字列に対してはその文字列自体を返します。 <tt class="docutils literal"><span class="pre">repr(object)</span></tt> との違いは、 <tt class="docutils literal"><span class="pre">str(object)</span></tt> は常に <a class="reference internal" href="#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> が受理できるような文字列を返そうと試みるわけではないという点です;
この関数の目的は印字可能な文字列を返すところにあります。引数が与えられなかった場合、空の文字列 <tt class="docutils literal"><span class="pre">''</span></tt> を返します。</p>
<p>文字列についての詳細は、シーケンスの機能についての説明、
<a class="reference internal" href="stdtypes.html#typesseq"><em>シーケンス型 &#8212; str, unicode, list, tuple, bytearray, buffer, xrange</em></a> を参照下さい(文字列はシーケンスです)。また、文字列特有のメソッドについては、 <a class="reference internal" href="stdtypes.html#string-methods"><em>文字列メソッド</em></a> を参照下さい。整形した文字列を出力するためには、テンプレート文字列か、
<a class="reference internal" href="stdtypes.html#string-formatting"><em>文字列フォーマット操作</em></a> にて説明される <tt class="docutils literal"><span class="pre">%</span></tt> 演算子を使用して下さい。さらには、 <a class="reference internal" href="strings.html#stringservices"><em>文字列処理</em></a> と <a class="reference internal" href="#unicode" title="unicode"><tt class="xref py py-func docutils literal"><span class="pre">unicode()</span></tt></a> も参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<tt class="descname">sum</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>start</em> と <em>iterable</em> の要素を左から右へ合計し、総和を返します。 <em>start</em> はデフォルトで <tt class="docutils literal"><span class="pre">0</span></tt> です。 <em>iterable</em> の要素は通常は数値で、start の値は文字列であってはなりません。</p>
<p>使う場面によっては、 <a class="reference internal" href="#sum" title="sum"><tt class="xref py py-func docutils literal"><span class="pre">sum()</span></tt></a> よりもいい選択肢があります。文字列からなるシーケンスを結合する高速かつ望ましい方法は
<tt class="docutils literal"><span class="pre">''.join(sequence)</span></tt> を呼ぶことです。浮動小数点数値を拡張された精度で加算するには、
<a class="reference internal" href="math.html#math.fsum" title="math.fsum"><tt class="xref py py-func docutils literal"><span class="pre">math.fsum()</span></tt></a> を参照下さい。一連のイテラブルを連結するには、 <a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><tt class="xref py py-func docutils literal"><span class="pre">itertools.chain()</span></tt></a> の使用を考えてください。</p>
</dd></dl>

<dl class="function">
<dt id="super">
<tt class="descname">super</tt><big>(</big><span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#super" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メソッドの呼び出しを <em>type</em> の親または兄弟クラスに委譲する、プロキシオブジェクトを返します。これはクラスの中でオーバーライドされた継承メソッドにアクセスするのに便利です。探索の順序は、 <em>type</em> 自身が飛ばされるのをのぞいて <a class="reference internal" href="#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> と同じです。</p>
<p><em>type</em> の <tt class="xref py py-attr docutils literal"><span class="pre">__mro__</span></tt> 属性は、 <a class="reference internal" href="#getattr" title="getattr"><tt class="xref py py-func docutils literal"><span class="pre">getattr()</span></tt></a> と <a class="reference internal" href="#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> の両方で使われる、メソッド解決の探索順序を列記します。この属性は動的で、継承の階層構造が更新されれば、随時変化します。</p>
<p>第 2 引数が省かれたなら、返されるスーパーオブジェクトは束縛されません。第 2 引数がオブジェクトであれば、
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></tt> は真でなければなりません。第 2 引数が型であれば、
<tt class="docutils literal"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></tt> は真でなければなりません
(これはクラスメソッドに役に立つでしょう)。</p>
<p><em>super</em> の典型的な用途は 2 つあります。単一の継承をしているクラス階層構造では、 <em>super</em> は名前を明示することなく親クラスを参照するのに使え、これでコードはメンテナンスしやすくなります。この用途の
<em>super</em> は他のプログラミング言語で見られるものと近い方向性です。</p>
<p>2 つ目の用途は、動的な実行環境下での複数の継承の共同をサポートすることです。この用途は Python 特有で、静的にコンパイルされる言語や、単一の継承しかサポートしない言語では見られないものです。これは複数の基底クラスが同じメソッドを実装する &#8220;diamond diagram&#8221;
を実装できるようにします。良い設計のために、このメソッドがすべての場合に同じ形式で呼び出せるべきです (呼び出しの順序が実行時に決定されることや、順序がクラスの階層の変更に対応することや、その順序には実行時まで未知の兄弟クラスが含まれえることが理由です)。</p>
<p>両方のケースにおいて、典型的なスーパークラスの呼び出しはこのようになるでしょう。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> は <tt class="docutils literal"><span class="pre">super(C,</span> <span class="pre">self).__getitem__(name)</span></tt> のような明示的なドット表記による属性参照の一部として使うように実装されていることに注意して下さい。これは、 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> メソッドを、協調的な多重継承をサポートするための予測可能な順序でクラスを検索するように実装することで実現されています。従って、 <a class="reference internal" href="#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> は <tt class="docutils literal"><span class="pre">super()[name]</span></tt> のような文や演算子を使った非明示的な属性参照向けには定義されていないので注意してください。</p>
<p>また、 <a class="reference internal" href="#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> の使用がメソッド内部に限定されないことにも注目して下さい。引数を2つ渡す形式の呼び出しは、必要な要素を正確に指定するので、適当な参照を作ることができます。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="tuple">
<tt class="descname">tuple</tt><big>(</big><span class="optional">[</span><em>iterable</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#tuple" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素と要素が同じで、かつ順番も同じになるタプルを返します。
<em>iterable</em> はシーケンス型、反復をサポートするコンテナ型、およびイテレータオブジェクトをとることができます。 <em>iterable</em> がすでにタプルの場合、そのタプルを変更せずに返します。例えば、 <tt class="docutils literal"><span class="pre">tuple('abc')</span></tt> は <tt class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></tt> を返し、
<tt class="docutils literal"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></tt> は <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></tt> を返します。</p>
<p><a class="reference internal" href="#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a> クラスは、不変のシーケンス型で、 <a class="reference internal" href="stdtypes.html#typesseq"><em>シーケンス型 &#8212; str, unicode, list, tuple, bytearray, buffer, xrange</em></a> にて説明されます。他のコンテナ型については、組み込みクラスの
<a class="reference internal" href="stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>, <a class="reference internal" href="#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>, および <a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-class docutils literal"><span class="pre">set</span></tt></a> と、
<a class="reference internal" href="collections.html#module-collections" title="collections: High-performance container datatypes"><tt class="xref py py-mod docutils literal"><span class="pre">collections</span></tt></a> モジュールを参照下さい。</p>
</dd></dl>

<dl class="function">
<dt id="type">
<tt class="descname">type</tt><big>(</big><em>object</em><big>)</big><a class="headerlink" href="#type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> の型を返します。オブジェクトの型の検査には
<a class="reference internal" href="#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a> 組み込み関数を使うことが推奨されます。</p>
<p>3 引数で呼び出された場合には <a class="reference internal" href="#type" title="type"><tt class="xref py py-func docutils literal"><span class="pre">type()</span></tt></a> 関数は後述するようにコンストラクタとして働きます。</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">type</tt><big>(</big><em>name</em>, <em>bases</em>, <em>dict</em><big>)</big></dt>
<dd><p>新しい型オブジェクトを返します。本質的には <a class="reference internal" href="../reference/compound_stmts.html#class"><tt class="xref std std-keyword docutils literal"><span class="pre">class</span></tt></a> 文の動的な形です。 <em>name</em> 文字列はクラス名で、 <tt class="xref py py-attr docutils literal"><span class="pre">__name__</span></tt> 属性になります。 <em>bases</em> タプルは基底クラスの羅列で、 <tt class="xref py py-attr docutils literal"><span class="pre">__bases__</span></tt> 属性になります。 <em>dict</em> 辞書はクラス本体の定義を含む名前空間で、
<tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> 属性になります。たとえば、以下の二つの文は同じ
<a class="reference internal" href="#type" title="type"><tt class="xref py py-class docutils literal"><span class="pre">type</span></tt></a> オブジェクトを作ります。 :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.2 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="unichr">
<tt class="descname">unichr</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#unichr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Unicode におけるコードが整数 <em>i</em> になるような文字 1 文字からなる
Unicode 文字列を返します。例えば、 <tt class="docutils literal"><span class="pre">unichr(97)</span></tt> は文字列 <tt class="docutils literal"><span class="pre">u'a'</span></tt>
を返します。この関数は Unicode 文字列に対する <a class="reference internal" href="#ord" title="ord"><tt class="xref py py-func docutils literal"><span class="pre">ord()</span></tt></a> の逆です。引数の正当な範囲は Python がどのように構成されているかに依存しています &#8212; UCS2 ならば [0..0xFFFF] であり UCS4 ならば [0..0x10FFFF]
であり、このどちらかです。それ以外の値に対しては <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a>
が送出されます。ASCIIの 8 ビットの文字列に対しては、 <a class="reference internal" href="#chr" title="chr"><tt class="xref py py-func docutils literal"><span class="pre">chr()</span></tt></a> を参照下さい。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.0 で追加.</span></p>
</dd></dl>

<dl class="function">
<dt id="unicode">
<tt class="descname">unicode</tt><big>(</big><span class="optional">[</span><em>object</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#unicode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>以下のモードのうち一つを使って、 <em>object</em> のUnicode 文字列バージョンを返します:</p>
<p>もし <em>encoding</em> かつ/または <em>errors</em> が与えられていれば、
<tt class="docutils literal"><span class="pre">unicode()</span></tt> は 8 ビットの文字列または文字列バッファになっているオブジェクトを <em>encoding</em> の codec を使ってデコードします。
<em>encoding</em> 引数はエンコーディング名を与える文字列です; 未知のエンコーディングの場合、 <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><tt class="xref py py-exc docutils literal"><span class="pre">LookupError</span></tt></a> が送出されます。エラー処理は
<em>errors</em> に従って行われます; このパラメータは入力エンコーディング中で無効な文字の扱い方を指定します。 <em>errors</em> が <tt class="docutils literal"><span class="pre">'strict'</span></tt> (標準の設定です) の場合、エラー発生時には <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が送出されます。一方、 <tt class="docutils literal"><span class="pre">'ignore'</span></tt> では、エラーは暗黙のうちに無視されるようになり、
<tt class="docutils literal"><span class="pre">'replace'</span></tt> では公式の置換文字、 <tt class="docutils literal"><span class="pre">U+FFFD</span></tt> を使って、デコードできなかった文字を置き換えます。 <a class="reference internal" href="codecs.html#module-codecs" title="codecs: データやストリームのエンコード・デコード。"><tt class="xref py py-mod docutils literal"><span class="pre">codecs</span></tt></a> モジュールについても参照してください。</p>
<p>オプションのパラメータが与えられていない場合、 <tt class="docutils literal"><span class="pre">unicode()</span></tt> は
<tt class="docutils literal"><span class="pre">str()</span></tt> の動作をまねます。ただし、8 ビット文字列ではなく、
Unicode 文字列を返します。もっと詳しくいえば、 <em>object</em> が Unicode
文字列かそのサブクラスなら、デコード処理を一切介することなく
Unicode 文字列を返すということです。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__unicode__" title="object.__unicode__"><tt class="xref py py-meth docutils literal"><span class="pre">__unicode__()</span></tt></a> メソッドを提供しているオブジェクトの場合、
<a class="reference internal" href="#unicode" title="unicode"><tt class="xref py py-func docutils literal"><span class="pre">unicode()</span></tt></a> はこのメソッドを引数なしで呼び出して Unicode 文字列を生成します。それ以外のオブジェクトの場合、 8 ビットの文字列か、オブジェクトのデータ表現 (representation) を呼び出し、その後デフォルトエンコーディングで <tt class="docutils literal"><span class="pre">'strict'</span></tt> モードの codec を使って Unicode
文字列に変換します。</p>
<p>Unicode 文字列についてのさらなる情報については、シーケンス型の機能についての説明、 <a class="reference internal" href="stdtypes.html#typesseq"><em>シーケンス型 &#8212; str, unicode, list, tuple, bytearray, buffer, xrange</em></a> を参照下さい(Unicode 文字列はシーケンスです)。また、文字列特有のメソッドについては、
<a class="reference internal" href="stdtypes.html#string-methods"><em>文字列メソッド</em></a> を参照下さい。整形した文字列を出力するためには、テンプレート文字列か、 <a class="reference internal" href="stdtypes.html#string-formatting"><em>文字列フォーマット操作</em></a> にて説明される
<tt class="docutils literal"><span class="pre">%</span></tt> 演算子を使用して下さい。さらには、 <a class="reference internal" href="strings.html#stringservices"><em>文字列処理</em></a> と
<a class="reference internal" href="#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> も参照下さい。</p>
<p class="versionadded">
<span class="versionmodified">バージョン 2.0 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.2 で変更: </span><a class="reference internal" href="../reference/datamodel.html#object.__unicode__" title="object.__unicode__"><tt class="xref py py-meth docutils literal"><span class="pre">__unicode__()</span></tt></a> のサポートが追加されました.</p>
</dd></dl>

<dl class="function">
<dt id="vars">
<tt class="descname">vars</tt><big>(</big><span class="optional">[</span><em>object</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#vars" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数無しでは、 <a class="reference internal" href="#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a> のように動作します。</p>
<p>モジュール、クラス、またはクラスインスタンスオブジェクト (またはその他 <tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> 属性を持つもの) を引数として与えた場合、その属性を返します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">返される辞書は変更すべきではありません: 変更が対応するシンボルテーブルにもたらす影響は未定義です。 <a class="footnote-reference" href="#id7" id="id4">[3]</a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="xrange">
<tt class="descname">xrange</tt><big>(</big><span class="optional">[</span><em>start</em><span class="optional">]</span>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#xrange" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="#range" title="range"><tt class="xref py py-func docutils literal"><span class="pre">range()</span></tt></a> に非常によく似ていますが、リストの代わりに
&#8220;xrange オブジェクト&#8221; を返します。このオブジェクトは不透明なシーケンス型で、対応するリストと同じ値を持ちますが、それらの値全てを同時に記憶しません。 <tt class="xref py py-func docutils literal"><span class="pre">ragne()</span></tt> に対する <a class="reference internal" href="#xrange" title="xrange"><tt class="xref py py-func docutils literal"><span class="pre">xrange()</span></tt></a> の利点は微々たるものです (<a class="reference internal" href="#xrange" title="xrange"><tt class="xref py py-func docutils literal"><span class="pre">xrange()</span></tt></a> は要求に応じて値を生成するからです) ただし、メモリ量の厳しい計算機で巨大な範囲の値を使う時や、(ループがよく <a class="reference internal" href="../reference/simple_stmts.html#break"><tt class="xref std std-keyword docutils literal"><span class="pre">break</span></tt></a> で中断されるといったように) 範囲中の全ての値を使うとは限らない場合はその限りではありません。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> <a class="reference internal" href="#xrange" title="xrange"><tt class="xref py py-func docutils literal"><span class="pre">xrange()</span></tt></a> はシンプルさと速度のために定義されている関数であり、その実現のために実装上の制限を課している場合があります。
Python の C 実装では、全ての引数をネイティブの C long 型 (Python
の &#8220;short&#8221; 整数型) に制限しており、要素数がネイティブの C long
型の範囲内に収まるよう要求しています。もし大きな範囲が必要ならば、別の実装である <a class="reference internal" href="itertools.html#module-itertools" title="itertools: 効率的なループ実行のためのイテレータ生成関数。"><tt class="xref py py-mod docutils literal"><span class="pre">itertools</span></tt></a> モジュールの、
<tt class="docutils literal"><span class="pre">islice(count(start,</span> <span class="pre">step),</span> <span class="pre">(stop-start+step-1+2*(step&lt;0))//step)</span></tt>
を使うのが巧い方法かも知れません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="zip">
<tt class="descname">zip</tt><big>(</big><span class="optional">[</span><em>iterable</em>, <em>...</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#zip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数はタプルのリストを返します。このリストの <em>i</em> 番目のタプルは各引数のシーケンスまたはイテレート可能オブジェクト中の <em>i</em> 番目の要素を含みます。返されるリストは引数のシーケンスのうち長さが最小のものの長さに切り詰められます。引数が全て同じ長さの際には、 <a class="reference internal" href="#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a> は初期値引数が <tt class="docutils literal"><span class="pre">None</span></tt> の <a class="reference internal" href="#map" title="map"><tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt></a> と似ています。引数が単一のシーケンスの場合、1 要素のタプルからなるリストを返します。引数を指定しない場合、空のリストを返します。</p>
<p>iterable の、左から右への評価順序が保証されます。そのため
<tt class="docutils literal"><span class="pre">zip(*[iter(s)]*n)</span></tt> を使ってデータ系列を n 長のグループにするクラスタリングすることができます。</p>
<p><tt class="docutils literal"><span class="pre">*</span></tt> 演算子と共の論理積に対して、リストを upzip するために
<a class="reference internal" href="#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a> を使うこともできます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">バージョン 2.0 で追加.</span></p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>これまでは、 <a class="reference internal" href="#zip" title="zip"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a> は少なくとも一つの引数を要求しており、
空のリストを返す代わりに <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> を送出していました。</p>
</dd></dl>

<dl class="function">
<dt id="__import__">
<tt class="descname">__import__</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">[</span>, <em>fromlist</em><span class="optional">[</span>, <em>level</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#__import__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="admonition note" id="index-6">
<p class="first admonition-title">ノート</p>
<p class="last">これは日々の Python プログラミングでは必要ではない、高等な関数です。</p>
</div>
<p>この関数は <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> ステートメントにより呼び出されます。これは (<a class="reference internal" href="__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a> モジュールをインポートし、
<tt class="docutils literal"><span class="pre">__builtin__.__import__</span></tt> を割り当てることで) <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> ステートメントの意味を変更するための置き換えが可能ですが、今では、フックをインポートするほうが、大抵の場合簡単です (<span class="target" id="index-7"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> を参照下さい)。
<a class="reference internal" href="#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> を直接使用することは稀で、例外は、実行時に名前が決定するモジュールをインポートするときです。</p>
<p>この関数は、モジュール、 <em>name</em> をインポートし、 <em>globals</em> と
<em>locals</em> が与えられれば、パッケージのコンテキストで名前をどう解釈するか決定するのに使います。
<em>fromlist</em> はオブジェクト、もしくは、サブモジュールの名前を与え、
<em>name</em> で与えられるモジュールからインポートされる必要があります。標準的な実装では、 <em>locals</em> 引数はまったく使われず、 <em>globals</em> だけが <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> ステートメントのパッケージコンテキストを決定するために使われます。</p>
<p><em>level</em> は絶対、もしくは、相対のどちらのインポートを使うかを指定します。デフォルトは <tt class="docutils literal"><span class="pre">-1</span></tt> で絶対、相対インポートの両方を試みます。
<tt class="docutils literal"><span class="pre">0</span></tt> は絶対インポートのみ実行します。正の <em>level</em> の値は、
<a class="reference internal" href="#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> を呼び出したディレクトリから検索対象となる親ディレクトリの階層を示します。</p>
<p><em>name</em> は通常、 <tt class="docutils literal"><span class="pre">package.module</span></tt> の形式となり、 <em>name</em> で与えられた名前 <em>ではなく</em> 最上位のパッケージ (最初のドットまでの名前) が返されます。しかしながら、空でない <em>fromlist</em> 引数が与えられると、
<em>name</em> で与えられた名前が返されます。</p>
<p>例えば、 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">spam</span></tt> ステートメントは、以下のようなバイトコードに帰結します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">import</span> <span class="pre">spam.ham</span></tt> ステートメントは、以下となります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <a class="reference internal" href="#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> がどのように最上位モジュールを返しているかに注意して下さい。 <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> ステートメントにより、名前が飛び越されたオブジェクトになっています。</p>
<p>一方で、 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></tt> ステートメントは、以下となります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s">&#39;eggs&#39;</span><span class="p">,</span> <span class="s">&#39;sausage&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>ここで、 <tt class="docutils literal"><span class="pre">spam.ham</span></tt> モジュールが <a class="reference internal" href="#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> より返されます。このオブジェクトからインポートされる名前が取り出され、それぞれの名前として割り当てられます。</p>
<p>単純にモジュールをインポートする場合(パッケージの範囲内であるかも知れません)、 <a class="reference internal" href="#__import__" title="__import__"><tt class="xref py py-func docutils literal"><span class="pre">__import__()</span></tt></a> を呼び出して、 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> から見付けることもできます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;foo.bar.baz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">__import__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="go">&lt;module &#39;foo&#39; from &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baz</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baz</span>
<span class="go">&lt;module &#39;foo.bar.baz&#39; from &gt;</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span>level パラメータが追加されました。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.5 で変更: </span>Keyword サポートパラメータが追加されました。</p>
</dd></dl>

</div>
<div class="section" id="non-essential-built-in-functions">
<span id="non-essential-built-in-funcs"></span><h1>3. 非必須組み込み関数 (Non-essential Built-in Functions)<a class="headerlink" href="#non-essential-built-in-functions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性を維持するだけの目的で残されています。</p>
<p>Python のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ばしてもかまわず、その際に何か重要なことを忘れていると思う必要もありません。</p>
<dl class="function">
<dt id="apply">
<tt class="descname">apply</tt><big>(</big><em>function</em>, <em>args</em><span class="optional">[</span>, <em>keywords</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#apply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>function</em> は呼び出しができるオブジェクト (ユーザ定義および組み込みの関数またはメソッド、またはクラスオブジェクト) でなければなりません。 <em>args</em> はシーケンス型でなくてはなりません。 <em>function</em>
は引数リスト <em>args</em> を使って呼び出されます;
引数の数はタプルの長さになります。オプションの引数 <em>keywords</em> を与える場合、 <em>keywords</em> は文字列のキーを持つ辞書でなければなりません。これは引数リストの最後に追加されるキーワード引数です。
<a class="reference internal" href="#apply" title="apply"><tt class="xref py py-func docutils literal"><span class="pre">apply()</span></tt></a> の呼び出しは、単なる <tt class="docutils literal"><span class="pre">function(args)</span></tt> の呼び出しとは異なります。というのは、 <a class="reference internal" href="#apply" title="apply"><tt class="xref py py-func docutils literal"><span class="pre">apply()</span></tt></a> の場合、引数は常に一つだからです。 <a class="reference internal" href="#apply" title="apply"><tt class="xref py py-func docutils literal"><span class="pre">apply()</span></tt></a> は <tt class="docutils literal"><span class="pre">function(*args,</span> <span class="pre">**keywords)</span></tt> を使うのと等価です。</p>
<p class="deprecated">
<span class="versionmodified">バージョン 2.3 で撤廃: </span><tt class="docutils literal"><span class="pre">*args</span></tt> と <tt class="docutils literal"><span class="pre">**keywords</span></tt> を使った拡張呼び出し構文を使ってく
ださい。</p>
</dd></dl>

<dl class="function">
<dt id="buffer">
<tt class="descname">buffer</tt><big>(</big><em>object</em><span class="optional">[</span>, <em>offset</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>object</em> は (文字列、アレイ、バッファといった) バッファ呼び出しインタフェースをサポートするオブジェクトでなければなりません。引数 <em>object</em> を参照する新たなバッファオブジェクトが生成されます。返されるバッファオブジェクトは <em>object</em> の先頭 (または <em>offset</em>) からのスライスになります。スライスの末端は <em>object</em> の末端まで (または引数 <em>size</em> で与えられた長さになるまで) です。</p>
</dd></dl>

<dl class="function">
<dt id="coerce">
<tt class="descname">coerce</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを返します。変換に使われる規則は算術演算における規則と同じです。型変換が不可能である場合、 <a class="reference internal" href="exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="intern">
<tt class="descname">intern</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#intern" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>string</em> を &#8220;隔離&#8221; された文字列のテーブルに入力し、隔離された文字列を返します &#8211; この文字列は <em>string</em> 自体かコピーです。隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに有効です &#8211; 辞書中のキーが隔離されており、検索するキーが隔離されている場合、 (ハッシュ化後の) キーの比較は文字列の比較ではなくポインタの比較で行うことができるからです。通常、 Python プログラム内で利用されている名前は自動的に隔離され、モジュール、クラス、またはインスタンス属性を保持するための辞書は隔離されたキーを持っています。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>隔離された文字列の有効期限は (Python 2.2 またはそれ以前は永続的
でしたが) 永続的ではなくなりました; <a class="reference internal" href="#intern" title="intern"><tt class="xref py py-func docutils literal"><span class="pre">intern()</span></tt></a> の恩恵を受け
るためには、 <a class="reference internal" href="#intern" title="intern"><tt class="xref py py-func docutils literal"><span class="pre">intern()</span></tt></a> の返す値に対する参照を保持しなければ
なりません。</p>
</dd></dl>

<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>この関数は比較的利用されない関数なので、構文になるかどうかは保証できません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>現状では、 <tt class="xref c c-func docutils literal"><span class="pre">setvbuf()</span></tt> を持っていないシステムでは、バッファサイズを指定しても効果はありません。バッファサイズを指定するためのインタフェースは <tt class="xref c c-func docutils literal"><span class="pre">setvbuf()</span></tt> を使っては行われていません。何らかの I/O が実行された後で呼び出されるとコアダンプすることがあり、どのような場合にそうなるかを決定する信頼性のある方法がないからです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>現在の実装では、ローカルな値のバインディングは通常は影響を受けませんが、 (モジュールのような) 他のスコープから取り出した値は影響を受けるかもしれません。またこの実装は変更されるかもしれません。</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="constants.html" title="4. 組み込み定数"
             >次へ</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. はじめに"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>