

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>単純文 (simple statement) &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python 言語リファレンス" href="index.html" />
    <link rel="next" title="複合文 (compound statement)" href="compound_stmts.html" />
    <link rel="prev" title="式 (expression)" href="expressions.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="複合文 (compound statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="式 (expression)"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python 言語リファレンス</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">単純文 (simple statement)</a><ul>
<li><a class="reference internal" href="#expression-statement">式文 (expression statement)</a></li>
<li><a class="reference internal" href="#assignment-statement">代入文 (assignment statement)</a><ul>
<li><a class="reference internal" href="#augmented-assignment-statement">累算代入文 (augmented assignment statement)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assert"><tt class="docutils literal"><span class="pre">assert</span></tt> 文</a></li>
<li><a class="reference internal" href="#pass"><tt class="docutils literal"><span class="pre">pass</span></tt> 文</a></li>
<li><a class="reference internal" href="#del"><tt class="docutils literal"><span class="pre">del</span></tt> 文</a></li>
<li><a class="reference internal" href="#print"><tt class="docutils literal"><span class="pre">print</span></tt> 文</a></li>
<li><a class="reference internal" href="#return"><tt class="docutils literal"><span class="pre">return</span></tt> 文</a></li>
<li><a class="reference internal" href="#yield"><tt class="docutils literal"><span class="pre">yield</span></tt> 文</a></li>
<li><a class="reference internal" href="#raise"><tt class="docutils literal"><span class="pre">raise</span></tt> 文</a></li>
<li><a class="reference internal" href="#break"><tt class="docutils literal"><span class="pre">break</span></tt> 文</a></li>
<li><a class="reference internal" href="#continue"><tt class="docutils literal"><span class="pre">continue</span></tt> 文</a></li>
<li><a class="reference internal" href="#from"><tt class="docutils literal"><span class="pre">import</span></tt> 文</a><ul>
<li><a class="reference internal" href="#future-future-statement">future 文 (future statement)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#global"><tt class="docutils literal"><span class="pre">global</span></tt> 文</a></li>
<li><a class="reference internal" href="#exec"><tt class="docutils literal"><span class="pre">exec</span></tt> 文</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="expressions.html"
                        title="前の章へ">式 (expression)</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="compound_stmts.html"
                        title="次の章へ">複合文 (compound statement)</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/simple_stmts.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="simple-statement">
<span id="simple"></span><h1>単純文 (simple statement)<a class="headerlink" href="#simple-statement" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">単純文とは、単一の論理行内に収められる文です。単一の行内には、複数の単純文をセミコロンで区切って入れることができます。単純文の構文は以下の通りです:</p>
<pre>
<strong id="grammar-token-simple_stmt">simple_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-expression_stmt"><tt class="xref docutils literal"><span class="pre">expression_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-assert_stmt"><tt class="xref docutils literal"><span class="pre">assert_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-assignment_stmt"><tt class="xref docutils literal"><span class="pre">assignment_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-augmented_assignment_stmt"><tt class="xref docutils literal"><span class="pre">augmented_assignment_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-pass_stmt"><tt class="xref docutils literal"><span class="pre">pass_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-del_stmt"><tt class="xref docutils literal"><span class="pre">del_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-print_stmt"><tt class="xref docutils literal"><span class="pre">print_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-return_stmt"><tt class="xref docutils literal"><span class="pre">return_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-yield_stmt"><tt class="xref docutils literal"><span class="pre">yield_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-raise_stmt"><tt class="xref docutils literal"><span class="pre">raise_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-break_stmt"><tt class="xref docutils literal"><span class="pre">break_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-continue_stmt"><tt class="xref docutils literal"><span class="pre">continue_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-import_stmt"><tt class="xref docutils literal"><span class="pre">import_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-global_stmt"><tt class="xref docutils literal"><span class="pre">global_stmt</span></tt></a>
                 | <a class="reference internal" href="#grammar-token-exec_stmt"><tt class="xref docutils literal"><span class="pre">exec_stmt</span></tt></a>
</pre>
<div class="section" id="expression-statement">
<span id="exprstmts"></span><h2>式文 (expression statement)<a class="headerlink" href="#expression-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-1">式文は、 (主に対話的な使い方では) 値を計算して出力するために使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない関数のことです; Python では、プロシジャは値 <tt class="docutils literal"><span class="pre">None</span></tt> を返します) を呼び出すために使います。その他の使い方でも式文を使うことができますし、有用なこともあります。式文の構文は以下の通りです:</p>
<pre>
<strong id="grammar-token-expression_stmt">expression_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a>
</pre>
<p>式文は式のリスト (単一の式のこともあります) を値評価します。</p>
<p id="index-2">対話モードでは、値が <tt class="docutils literal"><span class="pre">None</span></tt> でない場合、値を組み込み関数 <a class="reference internal" href="../library/repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a> で文字列に変換して、その結果のみからなる一行を標準出力に書き出します ( <a class="reference internal" href="#print"><em>print 文</em></a> 節参照)。 (<tt class="docutils literal"><span class="pre">None</span></tt>
になる式文の値は書き出されないので、プロシジャ呼び出しを行っても出力は得られません。)</p>
</div>
<div class="section" id="assignment-statement">
<span id="assignment"></span><h2>代入文 (assignment statement)<a class="headerlink" href="#assignment-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-3">代入文は、名前を値に (再) 束縛したり、変更可能なオブジェクトの属性や要素を変更したりするために使われます:</p>
<pre>
<strong id="grammar-token-assignment_stmt">assignment_stmt</strong> ::=  (<a class="reference internal" href="#grammar-token-target_list"><tt class="xref docutils literal"><span class="pre">target_list</span></tt></a> &quot;=&quot;)+ (<a class="reference internal" href="expressions.html#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a> | <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><tt class="xref docutils literal"><span class="pre">yield_expression</span></tt></a>)
<strong id="grammar-token-target_list">target_list    </strong> ::=  <a class="reference internal" href="#grammar-token-target"><tt class="xref docutils literal"><span class="pre">target</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-target"><tt class="xref docutils literal"><span class="pre">target</span></tt></a>)* [&quot;,&quot;]
<strong id="grammar-token-target">target         </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>
                     | &quot;(&quot; <a class="reference internal" href="#grammar-token-target_list"><tt class="xref docutils literal"><span class="pre">target_list</span></tt></a> &quot;)&quot;
                     | &quot;[&quot; <a class="reference internal" href="#grammar-token-target_list"><tt class="xref docutils literal"><span class="pre">target_list</span></tt></a> &quot;]&quot;
                     | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><tt class="xref docutils literal"><span class="pre">attributeref</span></tt></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-subscription"><tt class="xref docutils literal"><span class="pre">subscription</span></tt></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-slicing"><tt class="xref docutils literal"><span class="pre">slicing</span></tt></a>
</pre>
<p>(末尾の三つのシンボルの構文については  <a class="reference internal" href="expressions.html#primaries"><em>一次語 (primary)</em></a> 節を参照してください。)</p>
<p id="index-4">代入文は式のリスト (これは単一の式でも、カンマで区切られた式リストでもよく、後者はタプルになることを思い出してください)
を評価し、得られた単一の結果オブジェクトをターゲット (target) のリストに対して左から右へと代入してゆきます。</p>
<p id="index-5">代入はターゲット (リスト) の形式に従って再帰的に行われます。ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス)
の一部である場合、この変更可能なオブジェクトは最終的に代入を実行して、その代入が有効な操作であるか判断しなければなりません。代入が不可能な場合には例外を発行することもできます。型ごとにみられる規則や、送出される例外は、そのオブジェクト型定義で与えられています (
<a class="reference internal" href="datamodel.html#types"><em>標準型の階層</em></a> 節を参照してください).</p>
<p id="index-6">ターゲットリストへのオブジェクトの代入は、以下のようにして再帰的に定義されています。</p>
<ul class="simple">
<li>ターゲットリストが単一のターゲットからなる場合: オブジェクトはそのターゲットに代入されます。</li>
<li>ターゲットリストが、カンマで区切られた複数のターゲットからなるリストの場合: オブジェクトはターゲットリスト中のターゲット数と同じ数の要素からなるイテレート可能オブジェクトでなければならず、その各要素は左から右へと対応するターゲットに代入されます。</li>
</ul>
<p>単一のターゲットへの単一のオブジェクトの代入は、以下のようにして再帰的に定義されています。</p>
<ul>
<li><p class="first">ターゲットが識別子 (名前) の場合:</p>
<blockquote>
<div><ul class="simple" id="index-7">
<li>名前が現在のコードブロック内の <a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文に書かれていない場合: 名前は現在のローカル名前空間内のオブジェクトに束縛されます。</li>
<li>それ以外の場合: 名前は現在のグローバル名前空間内のオブジェクトに束縛されます。</li>
</ul>
<p id="index-8">名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。再束縛によって、以前その名前に束縛されていたオブジェクトの参照カウント
(reference count) がゼロになった場合、オブジェクトは解放 (deallocate) され、デストラクタ  (destructor) が
(存在すれば) 呼び出されます。</p>
</div></blockquote>
</li>
<li><p class="first">ターゲットが丸括弧や角括弧で囲われたターゲットリストの場合: オブジェクトはターゲットリスト中のターゲット数と同じ数の要素からなるイテレート可能オブジェクトでなければならず、その各要素は左から右へと対応するターゲットに代入されます。</p>
</li>
<li id="index-9"><p class="first">ターゲットが属性参照の場合: 参照されている一次語の式が値評価されます。値は代入可能な属性を伴うオブジェクトでなければなりません; そうでなければ、
<a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> が送出されます。次に、このオブジェクトに対して、被代入オブジェクトを指定した属性に代入してよいか問い合わせます;
代入を実行できない場合、例外 (通常は <a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> ですが、必然ではありません) を送出します。</p>
<p id="attr-target-note">注意: オブジェクトがクラスインスタンスで、代入演算子の両辺に属性参照があるとき、右辺式の <tt class="docutils literal"><span class="pre">a.x</span></tt> はインスタンスの属性と (インスタンスの属性が存在しなければ) クラス属性のどちらにもアクセスする可能性があります。左辺のターゲット <tt class="docutils literal"><span class="pre">a.x</span></tt> は常にインスタンスの属性として割り当てられ、必要ならば生成されます。このとおり、現れる二つの <tt class="docutils literal"><span class="pre">a.x</span></tt> は同じ値を参照するとは限りません: 右辺式はクラス属性を参照し、左辺は新しいインスタンス属性を代入のターゲットとして生成するようなとき:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cls</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>             <span class="c"># class variable</span>
<span class="n">inst</span> <span class="o">=</span> <span class="n">Cls</span><span class="p">()</span>
<span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c"># writes inst.x as 4 leaving Cls.x as 3</span>
</pre></div>
</div>
<p>このことは、 <a class="reference internal" href="../library/functions.html#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a> で作成されたプロパティのようなデスクリプタ属性に対しては、必ずしもあてはまるとは限りません、</p>
</li>
<li id="index-10"><p class="first">ターゲットが添字表記の場合: 参照されている一次語の式が値評価されます。まず、値は変更可能な (リストのような) シーケンスオブジェクトか、
(辞書のような) マップオブジェクトでなければなりません。次に、添字表記の表す式が値評価されます。</p>
<p id="index-11">一次語が変更可能な (リストのような) シーケンスオブジェクトの場合、まず添字は整数でなければなりません。添字が負数の場合、シーケンスの長さが加算されます。添字は最終的に、シーケンスの長さよりも小さな非負の整数でなくてはなりません。次に、添字をインデクスに持つ要素に非代入オブジェクトを代入してよいか、シーケンスに問い合わせます。範囲を超えたインデクスに対しては <a class="reference internal" href="../library/exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><tt class="xref py py-exc docutils literal"><span class="pre">IndexError</span></tt></a>  が送出されます
(添字指定されたシーケンスに代入を行っても、リスト要素の新たな追加はできません)。</p>
<p id="index-12">一次語が (辞書のような) マップオブジェクトの場合、まず添字はマップのキー型と互換性のある型でなくてはなりません。次に、添字を被代入オブジェクトに関連付けるようなキー/データの対を生成するようマップオブジェクトに問い合わせます。この操作では、既存のキー/値の対を同じキーと別の値で置き換えてもよく、(同じ値を持つキーが存在しない場合) 新たなキー/値の対を挿入してもかまいません。</p>
</li>
<li id="index-13"><p class="first">ターゲットがスライスの場合: 参照されている一次語の式が値評価されます。まず、値は変更可能な (リストのような) シーケンスオブジェクトでなければなりません。被代入オブジェクトは同じ型を持ったシーケンスオブジェクトでなければなりません。次に、スライスの下境界と上境界を示す式があれば評価されます; デフォルト値はそれぞれゼロとシーケンスの長さです。上下境界は整数にならなければなりません。いずれかの境界が負数になった場合、シーケンスの長さが加算されます。最終的に、境界はゼロからシーケンスの長さまでの内包になるようにクリップされます。最後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに問い合わせます。オブジェクトで許されている限り、スライスの長さは被代入シーケンスの長さと異なっていてよく、この場合にはターゲットシーケンスの長さが変更されます。</p>
</li>
</ul>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 現在の実装では、ターゲットの構文は式の構文と同じであるとみなされており、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを伴って拒否されます。</p>
</div>
<p>警告: 代入の定義では、左辺値と右辺値がオーバラップするような代入 (例えば、 <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b,</span> <span class="pre">a</span></tt> を行うと、二つの変数を入れ替えます) を定義しても &#8216;安全 (safe)&#8217; に代入できますが、代入対象となる変数群 <em>の間で</em> オーバラップがある場合は安全ではありません！例えば、以下のプログラムは <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">2]</span></tt> を出力してしまいます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div>
</div>
<div class="section" id="augmented-assignment-statement">
<span id="augassign"></span><h3>累算代入文 (augmented assignment statement)<a class="headerlink" href="#augmented-assignment-statement" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-14">累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:</p>
<pre>
<strong id="grammar-token-augmented_assignment_stmt">augmented_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><tt class="xref docutils literal"><span class="pre">augtarget</span></tt></a> <a class="reference internal" href="#grammar-token-augop"><tt class="xref docutils literal"><span class="pre">augop</span></tt></a> (<a class="reference internal" href="expressions.html#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a> | <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><tt class="xref docutils literal"><span class="pre">yield_expression</span></tt></a>)
<strong id="grammar-token-augtarget">augtarget                </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><tt class="xref docutils literal"><span class="pre">attributeref</span></tt></a> | <a class="reference internal" href="expressions.html#grammar-token-subscription"><tt class="xref docutils literal"><span class="pre">subscription</span></tt></a> | <a class="reference internal" href="expressions.html#grammar-token-slicing"><tt class="xref docutils literal"><span class="pre">slicing</span></tt></a>
<strong id="grammar-token-augop">augop                    </strong> ::=  &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; | &quot;//=&quot; | &quot;%=&quot; | &quot;**=&quot;
                               | &quot;&gt;&gt;=&quot; | &quot;&lt;&lt;=&quot; | &quot;&amp;=&quot; | &quot;^=&quot; | &quot;|=&quot;
</pre>
<p>累算代入文は、ターゲット (通常の代入文と違って、アンパックは起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算代入型の二項演算を行い、結果をもとのターゲットに代入します。ターゲットは一度しか評価されません。</p>
<p><tt class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></tt> のような累算代入式は、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></tt> のように書き換えてほぼ同様の動作にできますが、厳密に等価にはなりません。累算代入の方では、 <tt class="docutils literal"><span class="pre">x</span></tt> は一度しか評価されません。また、実際の処理として、可能ならば <em>インプレース (in-place)</em> 演算が実行されます。これは、代入時に新たなオブジェクトを生成してターゲットに代入するのではなく、以前のオブジェクトの内容を変更するということです。</p>
<p>累算代入文で行われる代入は、タプルへの代入や、一文中に複数のターゲットが存在する場合を除き、通常の代入と同じように扱われます。同様に、累算代入で行われる二項演算は、場合によって <em>インプレース演算</em> が行われることを除き、通常の二項演算と同じです。</p>
<p>属性参照のターゲットの場合、 <a class="reference internal" href="#attr-target-note"><em>クラスとインスタンスの属性についての注意</em></a> と同様に通常の代入が適用されます。</p>
</div>
</div>
<div class="section" id="assert">
<span id="id1"></span><h2><a class="reference internal" href="#assert"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> 文<a class="headerlink" href="#assert" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-15">assert 文は、プログラム内にデバッグ用アサーション (debugging assertion) を仕掛けるための便利な方法です:</p>
<pre>
<strong id="grammar-token-assert_stmt">assert_stmt</strong> ::=  &quot;assert&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]
</pre>
<p>単純な形式 <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">expression</span></tt> は、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span>
</pre></div>
</div>
<p>と等価です。拡張形式 <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">expression1,</span> <span class="pre">expression2</span></tt> は、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">expression1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">expression2</span><span class="p">)</span>
</pre></div>
</div>
<p>と等価です。</p>
<p id="index-16">上記の等価関係は、 <tt class="docutils literal"><span class="pre">__debug__</span></tt> と <a class="reference internal" href="../library/exceptions.html#exceptions.AssertionError" title="exceptions.AssertionError"><tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt></a> が、同名の組み込み変数を参照しているという前提の上に成り立っています。現在の実装では、組み込み変数 <tt class="docutils literal"><span class="pre">__debug__</span></tt> は通常の状況では <tt class="docutils literal"><span class="pre">True</span></tt>
であり、最適化がリクエストされた場合（コマンドラインオプション -O）は <tt class="docutils literal"><span class="pre">False</span></tt> です。現状のコード生成器は、コンパイル時に最適化が要求されていると assert 文に対するコードを全く出力しません。実行に失敗した式のソースコードをエラーメッセージ内に入れる必要はありません;
コードはスタックトレース内で表示されます。</p>
<p><tt class="docutils literal"><span class="pre">__debug__</span></tt> への代入は不正な操作です。組み込み変数の値は、インタプリタが開始するときに決定されます。</p>
</div>
<div class="section" id="pass">
<span id="id2"></span><h2><a class="reference internal" href="#pass"><tt class="xref std std-keyword docutils literal"><span class="pre">pass</span></tt></a> 文<a class="headerlink" href="#pass" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-17">
<strong id="grammar-token-pass_stmt">pass_stmt</strong> ::=  &quot;pass&quot;
</pre>
<p><a class="reference internal" href="#pass"><tt class="xref std std-keyword docutils literal"><span class="pre">pass</span></tt></a> はヌル操作 (null operation) です &#8212; <a class="reference internal" href="#pass"><tt class="xref std std-keyword docutils literal"><span class="pre">pass</span></tt></a>
が実行されても、何も起きません。 <a class="reference internal" href="#pass"><tt class="xref std std-keyword docutils literal"><span class="pre">pass</span></tt></a> は、例えば:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> <span class="k">pass</span>    <span class="c"># a function that does nothing (yet)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>       <span class="c"># a class with no methods (yet)</span>
</pre></div>
</div>
<p>のように、構文法的には文が必要だが、コードとしては何も実行したくない場合のプレースホルダとして有用です。</p>
</div>
<div class="section" id="del">
<span id="id3"></span><h2><a class="reference internal" href="#del"><tt class="xref std std-keyword docutils literal"><span class="pre">del</span></tt></a> 文<a class="headerlink" href="#del" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-18">
<strong id="grammar-token-del_stmt">del_stmt</strong> ::=  &quot;del&quot; <a class="reference internal" href="#grammar-token-target_list"><tt class="xref docutils literal"><span class="pre">target_list</span></tt></a>
</pre>
<p>オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で再帰的に定義されています。ここでは完全な詳細を記述するよりもいくつかのヒントを述べるにとどめます。</p>
<p>ターゲットリストに対する削除は、各々のターゲットを左から右へと順に再帰的に削除します。</p>
<p id="index-19">名前に対して削除を行うと、ローカルまたはグローバル名前空間でのその名前の束縛を解除します。どちらの名前空間かは、名前が同じコードブロック内の
<a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文で宣言されているかどうかによります。名前が未束縛 (unbound) であるばあい、 <a class="reference internal" href="../library/exceptions.html#exceptions.NameError" title="exceptions.NameError"><tt class="xref py py-exc docutils literal"><span class="pre">NameError</span></tt></a>
例外が送出されます。</p>
<p id="index-20">ネストしたブロック中で自由変数になっているローカル名前空間上の名前に対する削除は不正な操作になります</p>
<p id="index-21">属性参照、添字表記、およびスライスの削除操作は、対象となる一次語オブジェクトに渡されます; スライスの削除は一般的には適切な型の空のスライスを代入するのと等価です (が、この仕様自体もスライスされるオブジェクトで決定されています)。</p>
</div>
<div class="section" id="print">
<span id="id4"></span><h2><a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> 文<a class="headerlink" href="#print" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-22">
<strong id="grammar-token-print_stmt">print_stmt</strong> ::=  &quot;print&quot; ([<a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>)* [&quot;,&quot;]]
                | &quot;&gt;&gt;&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> [(&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>)+ [&quot;,&quot;]])
</pre>
<p><a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> は、式を逐次的に評価し、得られたオブジェクトを標準出力に書き出します。オブジェクトが文字列でなければ、まず文字列変換規則を使って文字列に変換され、次いで (得られた文字列か、オリジナルの文字列が) 書き出されます。出力系の現在の書き出し位置が行頭にあると考えられる場合を除き、各オブジェクトの出力前にスペースが一つ出力されます。行頭にある場合とは、(1) 標準出力にまだ何も書き出されていない場合、(2)
標準出力に最後に書き出された文字が <tt class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></tt> を除く空白である、または (3) 標準出力に対する最後の書き出し操作が  <a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a>
文によるものではない場合、です。(こうした理由から、場合によっては空文字を標準出力に書き出すと便利なことがあります。)</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">組み込みのファイルオブジェクトでない、ファイルオブジェクトに似た動作をするオブジェクトでは、組み込みのファイルオブジェクトが持つ上記の性質を適切にエミュレートしていないことがあるため、当てにしないほうがよいでしょう。</p>
</div>
<p id="index-23"><a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> 文がカンマで終了していない限り、末尾には文字 <tt class="docutils literal"><span class="pre">'\n'</span></tt> が書き出されます。この仕様は、文に予約語
<a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> がある場合のみの動作です。</p>
<p id="index-24">標準出力は、組み込みモジュール <a class="reference internal" href="../library/sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a> 内で <tt class="docutils literal"><span class="pre">stdout</span></tt>  という名前のファイルオブジェクトとして定義されています。該当するオブジェクトが存在しないか、オブジェクトに <tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt> メソッドがない場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a>
例外が送出されます。.</p>
<p id="index-25"><a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> には、上で説明した構文の第二形式で定義されている拡張形式があります。この形式は、&#8221;山形 <a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a>
表記 (<a class="reference internal" href="#print"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> chevron)&#8221; と呼ばれます。この形式では、 <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> の直後にくる最初の式の値評価結果は &#8220;ファイル類似
(file-like)&#8221; なオブジェクト、とりわけ上で述べたように <tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt> メソッドを持つオブジェクトでなければなりません。この拡張形式では、ファイルオブジェクトを指定する式よりも後ろの式が、指定されたファイルオブジェクトに出力されます。最初の式の値評価結果が
<tt class="docutils literal"><span class="pre">None</span></tt> になった場合、 <tt class="docutils literal"><span class="pre">sys.stdout</span></tt>  が出力ファイルとして使われます。</p>
</div>
<div class="section" id="return">
<span id="id5"></span><h2><a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> 文<a class="headerlink" href="#return" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-26">
<strong id="grammar-token-return_stmt">return_stmt</strong> ::=  &quot;return&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a>]
</pre>
<p><a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> は、関数定義内で構文法的にネストして現れますが、ネストしたクラス定義内には現れません。</p>
<p>式リストがある場合、リストが値評価されます。それ以外の場合は <tt class="docutils literal"><span class="pre">None</span></tt> で置き換えられます。</p>
<p><a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> を使うと、式リスト (または <tt class="docutils literal"><span class="pre">None</span></tt>)  を戻り値として、現在の関数呼び出しから抜け出します。</p>
<p id="index-27"><a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> によって、 <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 節をともなう <a class="reference internal" href="compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a>
文の外に処理が引き渡されると、実際に関数から抜ける前に  <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 節が実行されます。</p>
<p>ジェネレータ関数の場合には、 <a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> 文の中に <a class="reference internal" href="expressions.html#grammar-token-expression_list"><tt class="xref std std-token docutils literal"><span class="pre">expression_list</span></tt></a> を入れることはできません。ジェネレータ関数の処理コンテキストでは、単体の <a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a>  はジェネレータ処理を終了し <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a>
を送出させることを示します。</p>
</div>
<div class="section" id="yield">
<span id="id6"></span><h2><a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文<a class="headerlink" href="#yield" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-28">
<strong id="grammar-token-yield_stmt">yield_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><tt class="xref docutils literal"><span class="pre">yield_expression</span></tt></a>
</pre>
<p><a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文は、ジェネレータ関数 (generator function) を定義するときだけ使われ、かつジェネレータ関数の本体の中でだけ用いられます。関数定義中で <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a>
文を使うだけで、関数定義は通常の関数でなくジェネレータ関数になります。</p>
<p>ジェネレータ関数が呼び出されると、ジェネレータイテレータ (generator iterator)、一般的にはジェネレータ (generator) を返します。ジェネレータ関数の本体は、ジェネレータの <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> が例外を発行するまで繰り返し呼び出して実行します。</p>
<p><a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文が実行されると、現在のジェネレータの状態は凍結 (freeze) され、 <a class="reference internal" href="expressions.html#grammar-token-expression_list"><tt class="xref std std-token docutils literal"><span class="pre">expression_list</span></tt></a>
の値が <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a>  の呼び出し側に返されます。ここでの &#8220;凍結&#8221; は、ローカルな変数への束縛、命令ポインタ (instruction
pointer)、および内部実行スタック (internal evaluation stack) を含む、全てのローカルな状態が保存されることを意味します:
すなわち、必要な情報を保存しておき、次に <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> が呼び出された際に、関数が <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文をあたかももう一つの外部呼出しであるかのように処理できるようにします。</p>
<p>Python バージョン 2.5 では、 <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文が  <a class="reference internal" href="compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> ...  <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a>
構造における  <a class="reference internal" href="compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> 節で許されるようになりました。ジェネレータが終了（finalized）される（参照カウントがゼロになるか、ガベージコレクションされる) までに再開されなければ、ジェネレータ-イテレータの <tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt> メソッドが呼ばれ、留保されている <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 節が実行できるようになります。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p>Python 2.2 では、 <tt class="docutils literal"><span class="pre">generators</span></tt> 機能が有効になっている場合にのみ <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文を使えました。この機能を有効にするための <tt class="docutils literal"><span class="pre">__future__</span></tt> import 文は次のとおりでした。</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">generators</span>
</pre></div>
</div>
</div>
<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-29"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0255"><strong>PEP 0255</strong></a> - 単純なジェネレータ</dt>
<dd>Python へのジェネレータと <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文の導入提案</dd>
<dt><span class="target" id="index-30"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - 改善されたジェネレータによるコルーチン (Coroutine)</dt>
<dd>その他のジェネレータの改善と共に、 <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> が <a class="reference internal" href="compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> ... <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a>
ブロックの中に存在することを可能にするための提案</dd>
</dl>
</div>
</div>
<div class="section" id="raise">
<span id="id7"></span><h2><a class="reference internal" href="#raise"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> 文<a class="headerlink" href="#raise" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-31">
<strong id="grammar-token-raise_stmt">raise_stmt</strong> ::=  &quot;raise&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]]]
</pre>
<p>式を伴わない場合、 <a class="reference internal" href="#raise"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> は現在のスコープで最終的に有効になっている例外を再送出します。そのような例外が現在のスコープでアクティブでない場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されて、これがエラーであることを示します (IDLE で実行した場合は、代わりに
exceptionQueue.Empty 例外を送出します)。</p>
<p>それ以外の場合、 <a class="reference internal" href="#raise"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> は式を値評価して、三つのオブジェクトを取得します。このとき、 <tt class="docutils literal"><span class="pre">None</span></tt>
を省略された式の値として使います。最初の二つのオブジェクトは、例外の <em>型 (type)</em> と例外の <em>値 (value)</em> を決定するために用いられます。</p>
<p>最初のオブジェクトがインスタンスである場合、例外の型はインスタンスのクラスになり、インスタンス自体が例外の値になります。このとき第二のオブジェクトは
<tt class="docutils literal"><span class="pre">None</span></tt> でなければなりません。</p>
<p>最初のオブジェクトがクラスの場合、例外の型になります。第二のオブジェクトは、例外の値を決めるために使われます:
第二のオブジェクトがインスタンスならば、そのインスタンスが例外の値になります。第二のオブジェクトがタプルの場合、クラスのコンストラクタに対する引数リストとして使われます; <tt class="docutils literal"><span class="pre">None</span></tt> なら、空の引数リストとして扱われ、それ以外の型ならコンストラクタに対する単一の引数として扱われます。このようにしてコンストラクタを呼び出して生成したインスタンスが例外の値になります。</p>
<p id="index-32">第三のオブジェクトが存在し、かつ <tt class="docutils literal"><span class="pre">None</span></tt> でなければ、オブジェクトはトレースバック  オブジェクトでなければなりません (
<a class="reference internal" href="datamodel.html#types"><em>標準型の階層</em></a> 節参照)。また、例外が発生した場所は現在の処理位置に置き換えられます。第三のオブジェクトが存在し、オブジェクトがトレースバックオブジェクトでも <tt class="docutils literal"><span class="pre">None</span></tt> でもなければ、 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a>
例外が送出されます。 <a class="reference internal" href="#raise"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> の三連式型は、 <a class="reference internal" href="compound_stmts.html#except"><tt class="xref std std-keyword docutils literal"><span class="pre">except</span></tt></a>
節から透過的に例外を再送出するのに便利ですが、再送出すべき例外が現在のスコープで発生した最も新しいアクティブな例外である場合には、式なしの
<a class="reference internal" href="#raise"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> を使うよう推奨します。</p>
<p>例外に関する追加情報は  <a class="reference internal" href="executionmodel.html#exceptions"><em>例外</em></a> 節にあります。また、例外処理に関する情報は  <a class="reference internal" href="compound_stmts.html#try"><em>try 文</em></a> 節にあります。</p>
</div>
<div class="section" id="break">
<span id="id8"></span><h2><a class="reference internal" href="#break"><tt class="xref std std-keyword docutils literal"><span class="pre">break</span></tt></a> 文<a class="headerlink" href="#break" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-33">
<strong id="grammar-token-break_stmt">break_stmt</strong> ::=  &quot;break&quot;
</pre>
<p><a class="reference internal" href="#break"><tt class="xref std std-keyword docutils literal"><span class="pre">break</span></tt></a> 文は、構文としては <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループや <a class="reference internal" href="compound_stmts.html#while"><tt class="xref std std-keyword docutils literal"><span class="pre">while</span></tt></a> ループの内側でのみ出現することができますが、ループ内の関数定義やクラス定義の内側には出現できません。</p>
<p id="index-34"><a class="reference internal" href="#break"><tt class="xref std std-keyword docutils literal"><span class="pre">break</span></tt></a> 文は、文を囲う最も内側のループを終了させ、ループにオプションの <a class="reference internal" href="compound_stmts.html#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a>
節がある場合にはそれをスキップします。</p>
<p id="index-35"><a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループを <a class="reference internal" href="#break"><tt class="xref std std-keyword docutils literal"><span class="pre">break</span></tt></a> によって終了すると、ループ制御ターゲットはその時の値を保持します。</p>
<p id="index-36"><a class="reference internal" href="#break"><tt class="xref std std-keyword docutils literal"><span class="pre">break</span></tt></a> が <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 節を伴う <a class="reference internal" href="compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> 文の外側に処理を渡す際には、ループを実際に抜ける前にその <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a>  節が実行されます。</p>
</div>
<div class="section" id="continue">
<span id="id9"></span><h2><a class="reference internal" href="#continue"><tt class="xref std std-keyword docutils literal"><span class="pre">continue</span></tt></a> 文<a class="headerlink" href="#continue" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-37">
<strong id="grammar-token-continue_stmt">continue_stmt</strong> ::=  &quot;continue&quot;
</pre>
<p><a class="reference internal" href="#continue"><tt class="xref std std-keyword docutils literal"><span class="pre">continue</span></tt></a> 文は <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループや <a class="reference internal" href="compound_stmts.html#while"><tt class="xref std std-keyword docutils literal"><span class="pre">while</span></tt></a> ループ内のネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、
<a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 句の中には現れません。
<a class="reference internal" href="#continue"><tt class="xref std std-keyword docutils literal"><span class="pre">continue</span></tt></a> 文は、文を囲う最も内側のループの次の周期に処理を継続します。</p>
<p><a class="reference internal" href="#continue"><tt class="xref std std-keyword docutils literal"><span class="pre">continue</span></tt></a> が <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 句を持った <a class="reference internal" href="compound_stmts.html#try"><tt class="xref std std-keyword docutils literal"><span class="pre">try</span></tt></a> 文を抜けるとき、その <a class="reference internal" href="compound_stmts.html#finally"><tt class="xref std std-keyword docutils literal"><span class="pre">finally</span></tt></a> 句が次のループサイクルを始める前に実行されます。</p>
</div>
<div class="section" id="from">
<span id="import"></span><span id="id10"></span><h2><a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文<a class="headerlink" href="#from" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-38">
<strong id="grammar-token-import_stmt">import_stmt    </strong> ::=  &quot;import&quot; <a class="reference internal" href="#grammar-token-module"><tt class="xref docutils literal"><span class="pre">module</span></tt></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>] ( &quot;,&quot; <a class="reference internal" href="#grammar-token-module"><tt class="xref docutils literal"><span class="pre">module</span></tt></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>] )*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative_module"><tt class="xref docutils literal"><span class="pre">relative_module</span></tt></a> &quot;import&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>]
                     ( &quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>] )*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative_module"><tt class="xref docutils literal"><span class="pre">relative_module</span></tt></a> &quot;import&quot; &quot;(&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>]
                     ( &quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>] )* [&quot;,&quot;] &quot;)&quot;
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-module"><tt class="xref docutils literal"><span class="pre">module</span></tt></a> &quot;import&quot; &quot;*&quot;
<strong id="grammar-token-module">module         </strong> ::=  (<a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;.&quot;)* <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>
<strong id="grammar-token-relative_module">relative_module</strong> ::=  &quot;.&quot;* <a class="reference internal" href="#grammar-token-module"><tt class="xref docutils literal"><span class="pre">module</span></tt></a> | &quot;.&quot;+
<strong id="grammar-token-name">name           </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>
</pre>
<p>import 文は、(1) モジュールを探し、必要なら初期化 (initialize) する; (<a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文のあるスコープにおける)
ローカルな名前空間で名前を定義する、の二つの段階を踏んで初期化されます。
<a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文には、 <a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> を使うか使わないかの2種類の形式があります。第一形式 (<a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> のない形式) は、上記の段階をリスト中にある各識別子に対して繰り返し実行していきます。 <a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> のある形式では、(1) を一度だけ行い、次いで
(2) を繰り返し実行します。</p>
<p id="index-39">ステップ(1)がどのように行われるのかを理解するには、まず、 Python が階層的なモジュール名をどう扱うのかを理解する必要があります。モジュールを組織化し名前に階層を持たせるために、Python は パッケージ という概念を持っています。モジュールが他のモジュールやパッケージを含むことができないのに対して、パッケージは他のパッケージやモジュールを含むことができます。ファイルシステムの視点から見ると、パッケージはディレクトリでモジュールはファイルです。オリジナルの <a class="reference external" href="http://www.python.org/doc/essays/packages.html">specification for packages</a> は今でも読むことができますが、小さい詳細部分はこのドキュメントが書かれた後に変更されています。</p>
<p id="index-40">モジュール名(特に記述していない場合は、 &#8220;モジュール&#8221; とはパッケージとモジュール両方を指しています)が判ったとき、モジュールかパッケージの検索が始まります。最初にチェックされる場所は、それまでにインポートされたすべてのモジュールのキャッシュである <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> です。もしモジュールがそこで見つかれば、それが import のステップ(2)で利用されます。</p>
<p id="index-41">キャッシュにモジュールが見つからなかった場合、次は <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> が検索されます。
(<a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> の仕様は <span class="target" id="index-42"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> に見つけることができます。)
これは <a class="reference internal" href="../glossary.html#term-finder"><em class="xref std std-term">finder</em></a> オブジェクトのリストで、そのモジュールを読み込む方法を知っているかどうかをその <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> メソッドをモジュール名を引数として呼び出すことで、順番に問い合せていきます。モジュールがパッケージに含まれていた(モジュール名の中にドットが含まれていた)場合、
<tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> の第2引数に親パッケージの <tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt> 属性が渡されます。
(モジュール名の最後のドットより前のすべてがインポートされます)
finder はモジュールを見つけたとき、(後で解説する) <a class="reference internal" href="../glossary.html#term-loader"><em class="xref std std-term">loader</em></a> か <a class="reference internal" href="../library/constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a>
を返します。</p>
<p id="index-43"><a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><tt class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></tt></a> に含まれるすべての finder が module を見つけられない場合、幾つかの暗黙的に定義されている finder に問い合わせられます。どんな暗黙の meta path finder が定義されているかは Python の実装によって様々です。すべての実装が定義しなければならない1つの finder は、 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a>
を扱います。</p>
<p>この暗黙の finder は要求されたモジュールを、2箇所のどちらかで定義されている &#8220;paths&#8221;
から探します。 (&#8220;paths&#8221; がファイルシステムパスである必要はありません)
インポートしようとしているモジュールがパッケージに含まれている場合、親パッケージの
<tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt> が <tt class="xref py py-meth docutils literal"><span class="pre">find_module()</span></tt> の第2引数として渡され、それが paths
として扱われます。モジュールがパッケージに含まれていない場合、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><tt class="xref py py-data docutils literal"><span class="pre">sys.path</span></tt></a>
が paths として扱われます。</p>
<p>paths が決定されたら、それを巡回してその path を扱える finder を探します。
<a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> 辞書は path に対する finder をキャッシュしており、
finder を探すときにチェックされます。
path がキャッシュに登録されていない場合は、 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></tt></a> の各オブジェクトを
1つの引数 path で呼び出します。各オブジェクトは finder を返すか、 <a class="reference internal" href="../library/exceptions.html#exceptions.ImportError" title="exceptions.ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>
を発生させます。
finder が返された場合、それを <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> にキャッシュして、その path に対してその finder を使います。
finder が見つからず、 path が存在している場合、 <a class="reference internal" href="../library/constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a>
が <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><tt class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></tt></a> に格納されて、暗黙の、単一のファイルとしてモジュールが格納されているとしてあつかうファイルベースの finder
をその path に対して利用することを示します。その path が存在しなかった場合、常に <a class="reference internal" href="../library/constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> を返す finder がその
path に対するキャッシュとして格納されます。</p>
<p id="index-44">全ての finder がそのモジュールを見つけられないときは、 <a class="reference internal" href="../library/exceptions.html#exceptions.ImportError" title="exceptions.ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>
が発生します。そうでなければ、どれかの finder が loader を返し、その <tt class="xref py py-meth docutils literal"><span class="pre">load_module()</span></tt>
メソッドがモジュール名を引数に呼び出されてロードを行ないます。
(ローダーのオリジナルの定義については <span class="target" id="index-45"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> を参照してください。)
loader はロードするモジュールに対して幾つかの責任があります。まず、そのモジュールがすでに <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> にあれば、
(ローダーが import 機構の外から呼ばれた場合に有り得ます)
そのモジュールを初期化に使い、新しいモジュールを使いません。
<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> にそのモジュールがなければ、初期化を始める前に <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a>
に追加します。 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> に追加したあと、モジュールのロード中にエラーが発生した場合は、その辞書から削除します。モジュールが既に <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><tt class="xref py py-data docutils literal"><span class="pre">sys.modules</span></tt></a> にあった場合は、エラーが発生してもその辞書に残しておきます。</p>
<p id="index-46">ローダーは幾つかの属性をモジュールに設定しなければなりません。モジュール名を <tt class="xref py py-data docutils literal"><span class="pre">__name__</span></tt> に設定します。ファイルの &#8220;path&#8221; を <tt class="xref py py-data docutils literal"><span class="pre">__file__</span></tt> に設定しますが、ビルトインモジュール
(<a class="reference internal" href="../library/sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><tt class="xref py py-data docutils literal"><span class="pre">sys.builtin_module_names</span></tt></a> にリストされている) の場合にはその属性を設定しません。インポートしているのがパッケージだった場合は、そのパッケージが含むモジュールやパッケージを探す場所の path のリストを <tt class="xref py py-data docutils literal"><span class="pre">__path_</span></tt> に設定します。
<tt class="xref py py-data docutils literal"><span class="pre">__package__</span></tt> はオプションですが、そのモジュールやパッケージを含むパッケージ名(パッケージに含まれていないモジュールには空文字列)を設定するべきです。 <tt class="xref py py-data docutils literal"><span class="pre">__loader__</span></tt> もオプションですが、そのモジュールをロードした loader オブジェクトを設定するべきです。</p>
<p id="index-47">ロード中にエラーが発生した場合、他の例外がすでに伝播していないのであれば、
loader は <a class="reference internal" href="../library/exceptions.html#exceptions.ImportError" title="exceptions.ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> を発生させます。それ以外の場合は、 loader はロードして初期化したモジュールを返します。</p>
<p>段階 (1) が例外を送出することなく完了したなら、段階 (2) を開始します。</p>
<p><a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文の第一形式は、ローカルな名前空間に置かれたモジュール名をモジュールオブジェクトに束縛し、import すべき次の識別子があればその処理に移ります。モジュール名の後ろに <a class="reference internal" href="compound_stmts.html#as"><tt class="xref std std-keyword docutils literal"><span class="pre">as</span></tt></a> がある場合、 <a class="reference internal" href="compound_stmts.html#as"><tt class="xref std std-keyword docutils literal"><span class="pre">as</span></tt></a> の後ろの名前はモジュールのローカルな名前として使われます。</p>
<p id="index-48"><a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> 形式は、モジュール名の束縛を行いません: <a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> 形式では、段階 (1) で見つかったモジュール内から、識別子リストの各名前を順に検索し、見つかったオブジェクトを識別子の名前でローカルな名前空間において束縛します。 <a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a>
の第一形式と同じように、&#8221;<a class="reference internal" href="compound_stmts.html#as"><tt class="xref std std-keyword docutils literal"><span class="pre">as</span></tt></a> localname&#8221; で別名を与えることができます。指定された名前が見つからない場合、
<a class="reference internal" href="../library/exceptions.html#exceptions.ImportError" title="exceptions.ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a> が送出されます。識別子のリストを星印 (<tt class="docutils literal"><span class="pre">'*'</span></tt>) で置き換えると、モジュールで公開されている名前 (public
name) 全てを <a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文のある場所のローカルな名前空間に束縛します。</p>
<p id="index-49">モジュールで <em>公開されている名前 (public names)</em> は、モジュールの名前空間内にある <tt class="docutils literal"><span class="pre">__all__</span></tt> という名前の変数を調べて決定します; <tt class="docutils literal"><span class="pre">__all__</span></tt> が定義されている場合、 <tt class="docutils literal"><span class="pre">__all__</span></tt> はモジュールで定義されていたり、import されているような名前の文字列からなるシーケンスでなければなりません。 <tt class="docutils literal"><span class="pre">__all__</span></tt> 内にある名前は、全て公開された名前であり、実在するものとみなされます。
<tt class="docutils literal"><span class="pre">__all__</span></tt> が定義されていない場合、モジュールの名前空間に見つかった名前で、アンダースコア文字 (<tt class="docutils literal"><span class="pre">'_'</span></tt>) で始まっていない全ての名前が公開された名前になります。 <tt class="docutils literal"><span class="pre">__all__</span></tt> には、公開されている API 全てを入れなければなりません。 <tt class="docutils literal"><span class="pre">__all__</span></tt>
には、(モジュール内で import されて使われているライブラリモジュールのように) API を構成しない要素を意に反して公開してしまうのを避けるという意図があります。</p>
<p><tt class="docutils literal"><span class="pre">*</span></tt> を使った <a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> 形式は、モジュールのスコープ内だけに作用します。関数内でワイルドカードの import 文 &#8212;
<tt class="docutils literal"><span class="pre">import</span> <span class="pre">*</span></tt> &#8212; を使い、関数が自由変数を伴うネストされたブロックであったり、ブロックを含んでいる場合、コンパイラは
<a class="reference internal" href="../library/exceptions.html#exceptions.SyntaxError" title="exceptions.SyntaxError"><tt class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></tt></a> を送出します。</p>
<p id="index-50">インポートするモジュールを指定するとき、そのモジュールの絶対名(absolute name)
を指定する必要はありません。モジュールやパッケージが他のパッケージに含まれている場合、共通のトップパッケージからそのパッケージ名を記述することなく相対インポートすることができます。
<a class="reference internal" href="#from"><tt class="xref std std-keyword docutils literal"><span class="pre">from</span></tt></a> の後に指定されるモジュールやパッケージの先頭に複数個のドットを付けることで、正確な名前を指定することなしに現在のパッケージ階層からいくつ上の階層へ行くかを指定することができます。先頭のドットが1つの場合、
import をおこなっているモジュールが存在する現在のパッケージを示します。
3つのドットは2つ上のレベルを示します。なので、 <tt class="docutils literal"><span class="pre">pkg</span></tt> パッケージの中のモジュールで <tt class="docutils literal"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">mod</span></tt> を実行すると、
<tt class="docutils literal"><span class="pre">pkg.mod</span></tt> をインポートすることになります。
<tt class="docutils literal"><span class="pre">pkg.subpkg1</span></tt> の中から <tt class="docutils literal"><span class="pre">from</span> <span class="pre">..subpkg2</span> <span class="pre">import</span> <span class="pre">mod</span></tt> を実行すると、
<tt class="docutils literal"><span class="pre">pkg.subpkg2.mod</span></tt> をインポートします。相対インポートの仕様は <span class="target" id="index-51"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> に含まれています。</p>
<p>どのモジュールがロードされるべきかを動的に決めたいアプリケーションのために、組み込み関数 <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><tt class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></tt></a> が提供されています;</p>
<div class="section" id="future-future-statement">
<span id="future"></span><h3>future 文 (future statement)<a class="headerlink" href="#future-future-statement" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-52"><em class="dfn">future 文</em> は、将来の特定の Python のリリースで利用可能になるような構文や意味付けを使って、特定のモジュールをコンパイルさせるための、コンパイラに対する指示句 (directive) です。 future
文は、言語仕様に非互換性がもたらされるような、将来の Python  のバージョンに容易に移行できるよう意図されています。 future
文によって、新たな機能が標準化されたリリースが出される前に、その機能をモジュール単位で使えるようにします。</p>
<pre>
<strong id="grammar-token-future_statement">future_statement</strong> ::=  &quot;from&quot; &quot;__future__&quot; &quot;import&quot; feature [&quot;as&quot; name]
                      (&quot;,&quot; feature [&quot;as&quot; name])*
                      | &quot;from&quot; &quot;__future__&quot; &quot;import&quot; &quot;(&quot; feature [&quot;as&quot; name]
                      (&quot;,&quot; feature [&quot;as&quot; name])* [&quot;,&quot;] &quot;)&quot;
</pre>
<p>future 文は、モジュールの先頭周辺に書かなければなりません。 future 文の前に書いてよい内容は:</p>
<ul class="simple">
<li>モジュールのドキュメンテーション文字列(あれば)</li>
<li>コメント</li>
<li>空行</li>
<li>その他の future 文</li>
</ul>
<p>です。</p>
<p>Python 2.6 が認識する機能は、 <tt class="docutils literal"><span class="pre">unicode_literals</span></tt>, <tt class="docutils literal"><span class="pre">print_function</span></tt>,
<tt class="docutils literal"><span class="pre">absolute_import</span></tt>, <tt class="docutils literal"><span class="pre">division</span></tt>, <tt class="docutils literal"><span class="pre">generators</span></tt>,
<tt class="docutils literal"><span class="pre">nested_scopes</span></tt>, <tt class="docutils literal"><span class="pre">with_statement</span></tt> です。 <tt class="docutils literal"><span class="pre">generators</span></tt>, <tt class="docutils literal"><span class="pre">with_statement</span></tt>,
<tt class="docutils literal"><span class="pre">nested_scopes</span></tt> は Python 2.6 以上では常に有効なので冗長です。</p>
<p>future 文は、コンパイル時に特別なやり方で認識され、扱われます: 言語の中核をなす構文構成 (construct) に対する意味付けが変更されている場合、変更部分はしばしば異なるコードを生成することで実現されています。新たな機能によって、(新たな予約語のような)
互換性のない新たな構文が取り入れられることさえあります。この場合、コンパイラはモジュールを別のやりかたで解析する必要があるかもしれません。こうしたコード生成に関する決定は、実行時まで先延ばしすることはできません。</p>
<p>これまでの全てのリリースにおいて、コンパイラはどの機能が定義済みかを知っており、future 文に未知の機能が含まれている場合にはコンパイル時エラーを送出します。</p>
<p>future 文の実行時における直接的な意味付けは、import 文と同じです。標準モジュール <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: future 文の定義"><tt class="xref py py-mod docutils literal"><span class="pre">__future__</span></tt></a>
があり、これについては後で述べます。 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: future 文の定義"><tt class="xref py py-mod docutils literal"><span class="pre">__future__</span></tt></a> は、future 文が実行される際に通常の方法で import  されます。</p>
<p>future 文の実行時における特別な意味付けは、future 文で有効化される特定の機能によって変わります。</p>
<p>以下の文:</p>
<div class="highlight-python"><pre>import __future__ [as name]</pre>
</div>
<p>には、何ら特殊な意味はないので注意してください。</p>
<p>これは future 文ではありません; この文は通常の import 文であり、その他の特殊な意味付けや構文的な制限はありません。</p>
<p>future 文の入ったモジュール <tt class="xref py py-mod docutils literal"><span class="pre">M</span></tt> 内で使われている <a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文、組み込み関数 <a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a> や
<a class="reference internal" href="../library/functions.html#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> によってコンパイルされるコードは、デフォルトの設定では、 future
文に関係する新たな構文や意味付けを使うようになっています。 Python 2.2 からは、この仕様を <a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a> のオプション引数で制御できるようになりました &#8212; 詳細はこの関数に関するドキュメントを参照してください。</p>
<p>対話的インタプリタのプロンプトでタイプ入力した future 文は、その後のインタプリタセッション中で有効になります。インタプリタを
<a class="reference internal" href="../using/cmdline.html#cmdoption-i"><em class="xref std std-option">-i</em></a> オプションで起動して実行すべきスクリプト名を渡し、スクリプト中に future 文を入れておくと、新たな機能はスクリプトが実行された後に開始する対話セッションで有効になります。</p>
<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-53"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> - Back to the __future__
__future__ 機構の原案</p>
</div>
</div>
</div>
<div class="section" id="global">
<span id="id11"></span><h2><a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文<a class="headerlink" href="#global" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-54">
<strong id="grammar-token-global_stmt">global_stmt</strong> ::=  &quot;global&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>)*
</pre>
<p><a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文は、現在のコードブロック全体で維持される宣言文です。 <a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a>
文は、列挙した識別子をグローバル変数として解釈するよう指定することを意味します。 <a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a>
を使わずにグローバル変数に代入を行うことは不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずにグローバル変数を参照することができます。</p>
<p><a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文で列挙する名前は、同じコードブロック中で、プログラムテキスト上 <a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文より前に使ってはなりません。</p>
<p><a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文で列挙する名前は、 <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループのループ制御ターゲットや、 <a class="reference internal" href="compound_stmts.html#class"><tt class="xref std std-keyword docutils literal"><span class="pre">class</span></tt></a>
定義、関数定義、 <a class="reference internal" href="#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文内で仮引数として使ってはなりません。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 現在の実装では、後ろ二つの制限については強制していませんが、プログラムでこの緩和された仕様を乱用すべきではありません。将来の実装では、この制限を強制したり、暗黙のうちにプログラムの意味付けを変更したりする可能性があります。</p>
</div>
<p id="index-55"><strong>プログラマのための注意点:</strong> <a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> はパーザに対する指示句 (directive) です。この指示句は、 <a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文と同時に読み込まれたコードに対してのみ適用されます。特に、 <a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文内に入っている
<a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文は、 <a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文を <em>含んでいる</em>
コードブロック内に効果を及ぼすことはなく、 <a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文内に含まれているコードは、 <a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文を含むコード内での
<a class="reference internal" href="#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文に影響を受けません。同様のことが、関数 <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> 、 <a class="reference internal" href="../library/functions.html#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> 、および
<a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-func docutils literal"><span class="pre">compile()</span></tt></a> にも当てはまります。</p>
</div>
<div class="section" id="exec">
<span id="id12"></span><h2><a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文<a class="headerlink" href="#exec" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-56">
<strong id="grammar-token-exec_stmt">exec_stmt</strong> ::=  &quot;exec&quot; <a class="reference internal" href="expressions.html#grammar-token-or_expr"><tt class="xref docutils literal"><span class="pre">or_expr</span></tt></a> [&quot;in&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]]
</pre>
<p>この文は、Python コードの動的な実行をサポートします。最初の式の値評価結果は文字列か、開かれたファイルオブジェクトか、コードオブジェクトでなければなりません。文字列の場合、一連の Python 実行文として解析し、(構文エラーが生じない限り)
実行します。 <a class="footnote-reference" href="#id14" id="id13">[1]</a>
開かれたファイルであれば、ファイルを EOF まで読んで解析し、実行します。コードオブジェクトなら、単にこれを実行します。全ての場合で、実行されたコードはファイル入力として有効であることが期待されます (セクション <a class="reference internal" href="toplevel_components.html#file-input"><em>ファイル入力</em></a> を参照)。
<a class="reference internal" href="#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> と <a class="reference internal" href="#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文は、 <a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> 文に渡されたコードの文脈中においても関数定義の外では使われない点に注意してください。</p>
<p>いずれの場合でも、オプションの部分が省略されると、コードは現在のスコープ内で実行されます。 <a class="reference internal" href="expressions.html#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> の後ろに一つだけ式を指定する場合、その式は辞書でなくてはならず、グローバル変数とローカル変数の両方に使われます。これらはそれぞれグローバル変数とローカル変数として使われます。 <em>locals</em> を指定する場合は何らかのマップ型オブジェクトにせねばなりません．</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span>以前は <em>locals</em> は辞書でなければなりませんでした.</p>
<p id="index-57"><a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> の副作用として実行されるコードで設定された変数名に対応する名前の他に、追加のキーを辞書に追加することがあります。例えば、現在の実装では、組み込みモジュール <a class="reference internal" href="../library/__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a>  の辞書に対する参照を、 <tt class="docutils literal"><span class="pre">__builtins__</span></tt> (!)
というキーで追加することがあります。</p>
<p id="index-58"><strong>プログラマのためのヒント:</strong> 式の動的な評価は、組み込み関数 <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> でサポートされています組み込み関数
<a class="reference internal" href="../library/functions.html#globals" title="globals"><tt class="xref py py-func docutils literal"><span class="pre">globals()</span></tt></a> および <a class="reference internal" href="../library/functions.html#locals" title="locals"><tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt></a> は、それぞれ現在のグローバル辞書とローカル辞書を返すので、
<a class="reference internal" href="#exec"><tt class="xref std std-keyword docutils literal"><span class="pre">exec</span></tt></a> に渡して使うと便利です。</p>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[1]</a></td><td>パーサーは Unix スタイルの行末の慣習しか許可しないことに注意してください。コードをファイルから読み込む場合、Windows や Mac スタイルの改行を変換するために必ずユニバーサル改行モード(universal newline mode)を利用してください。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="複合文 (compound statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="式 (expression)"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 言語リファレンス</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>