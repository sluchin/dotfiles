

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>式 (expression) &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python 言語リファレンス" href="index.html" />
    <link rel="next" title="単純文 (simple statement)" href="simple_stmts.html" />
    <link rel="prev" title="実行モデル" href="executionmodel.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="単純文 (simple statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="実行モデル"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python 言語リファレンス</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversion">算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atom">アトム、原子的要素 (atom)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#atom-literals">リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-form">丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#lists">リスト表現</a></li>
<li><a class="reference internal" href="#comprehensions">集合と辞書の表現</a></li>
<li><a class="reference internal" href="#genexpr">ジェネレータ式</a></li>
<li><a class="reference internal" href="#dict">辞書表現</a></li>
<li><a class="reference internal" href="#set">集合表現</a></li>
<li><a class="reference internal" href="#string-conversions">文字列変換</a></li>
<li><a class="reference internal" href="#yield">Yield 式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#primary">一次語 (primary)</a><ul>
<li><a class="reference internal" href="#attribute-references">属性参照</a></li>
<li><a class="reference internal" href="#subscription">添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicing">スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#call">呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#power-operator">べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operation">単項算術演算とビット単位演算(unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operation">二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operation">シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operation">ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#comparison">比較 (comparison)</a></li>
<li><a class="reference internal" href="#boolean-operation">ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#conditional-expressions">条件演算 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#exprlists">式のリスト</a></li>
<li><a class="reference internal" href="#evalorder">評価順序</a></li>
<li><a class="reference internal" href="#summary">まとめ</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="前の章へ">実行モデル</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="次の章へ">単純文 (simple statement)</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/expressions.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="expression">
<span id="expressions"></span><h1>式 (expression)<a class="headerlink" href="#expression" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">この章では、Python の式における個々の要素の意味について解説します。</p>
<p><strong>表記法に関する注意:</strong> この章と以降の章での拡張BNF  (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式</p>
<pre>
<strong id="grammar-token-name">name</strong> ::=  <tt class="xref docutils literal"><span class="pre">othername</span></tt>
</pre>
<p id="index-1">で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 <tt class="docutils literal"><span class="pre">name</span></tt>
の形式をとる構文の意味付けは <tt class="docutils literal"><span class="pre">othername</span></tt> の意味付けと同じになります。</p>
<div class="section" id="arithmetic-conversion">
<span id="conversions"></span><h2>算術変換 (arithmetic conversion)<a class="headerlink" href="#arithmetic-conversion" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-2">以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれている場合、引数は <a class="reference internal" href="datamodel.html#coercion-rules"><em>型強制規則 (coercion rule)</em></a> に記載されている型強制規則に基づいて型強制されます。引数がいずれも標準の数値型である場合、以下の型強制が適用されます:</p>
<ul class="simple">
<li>片方の引数が複素数型であれば、他方は複素数型に変換されます;</li>
<li>それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;</li>
<li>それ以外の場合で、片方の引数が長整数型であれば、他方は長整数型に変換されます;</li>
<li>それ以外の場合で、両方の引数が通常の整数型であれば、変換の必要はありません。</li>
</ul>
<p>特定の演算子 (文字列を左引数とする &#8216;%&#8217; 演算子など) では、さらに別の規則が適用されます。拡張をおこなうことで、個々の演算子に対する型強制を定義できます。</p>
</div>
<div class="section" id="atom">
<span id="atoms"></span><h2>アトム、原子的要素 (atom)<a class="headerlink" href="#atom" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-3">アトム (原子的要素: atom) は、式を構成する基本単位です。もっとも単純なアトムは、識別子またはリテラルになります。逆クオートや丸括弧、波括弧、または角括弧で囲われた形式 (form) もまた、文法的にはアトムに分類されます。アトムの構文定義は以下のようになります:</p>
<pre>
<strong id="grammar-token-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> | <a class="reference internal" href="#grammar-token-literal"><tt class="xref docutils literal"><span class="pre">literal</span></tt></a> | <a class="reference internal" href="#grammar-token-enclosure"><tt class="xref docutils literal"><span class="pre">enclosure</span></tt></a>
<strong id="grammar-token-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-parenth_form"><tt class="xref docutils literal"><span class="pre">parenth_form</span></tt></a> | <a class="reference internal" href="#grammar-token-list_display"><tt class="xref docutils literal"><span class="pre">list_display</span></tt></a>
               | <a class="reference internal" href="#grammar-token-generator_expression"><tt class="xref docutils literal"><span class="pre">generator_expression</span></tt></a> | <a class="reference internal" href="#grammar-token-dict_display"><tt class="xref docutils literal"><span class="pre">dict_display</span></tt></a> | <a class="reference internal" href="#grammar-token-set_display"><tt class="xref docutils literal"><span class="pre">set_display</span></tt></a>
               | <a class="reference internal" href="#grammar-token-string_conversion"><tt class="xref docutils literal"><span class="pre">string_conversion</span></tt></a> | <a class="reference internal" href="#grammar-token-yield_atom"><tt class="xref docutils literal"><span class="pre">yield_atom</span></tt></a>
</pre>
<div class="section" id="atom-identifiers">
<span id="identifier-name"></span><h3>識別子 (identifier、または名前 (name))<a class="headerlink" href="#atom-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-4">アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については <a class="reference internal" href="lexical_analysis.html#identifiers"><em>識別子 (identifier) およびキーワード (keyword)</em></a> 節を、名前付けや束縛については <a class="reference internal" href="executionmodel.html#naming"><em>名前づけと束縛 (naming and binding)</em></a> 節を参照してください。</p>
<p id="index-5">名前があるオブジェクトに束縛されている場合、名前アトムを評価するとそのオブジェクトになります。名前が束縛されていない場合、アトムを評価しようとすると <a class="reference internal" href="../library/exceptions.html#exceptions.NameError" title="exceptions.NameError"><tt class="xref py py-exc docutils literal"><span class="pre">NameError</span></tt></a> 例外を送出します。</p>
<p id="index-6"><strong>プライベートな名前の難号化 (mangling):</strong> クラス定義内にテキストの形で書かれた識別子で、二つ以上のアンダースコアから始まり、末尾が二つ以上のアンダースコアになっていないものは、そのクラスの <em class="dfn">プライベートな名前 (private name)</em> とみなされます。プライベートな名前は、コードが生成される前に、より長い形式の名前に変換されます。この変換では、クラス名の先頭にあるアンダースコアを全てはぎとり、先頭にアンダースコアを一つ挿入して、名前の前に付加します。例えば、クラス <tt class="docutils literal"><span class="pre">Ham</span></tt> 内の識別子 <tt class="docutils literal"><span class="pre">__spam</span></tt> は、
<tt class="docutils literal"><span class="pre">_Ham__spam</span></tt> に変換されます。変換は識別子が使われている構文的コンテキストとは独立しています。変換された名前が非常に長い (255 文字以上)
の場合には、実装によっては名前の切り詰めが起きるかもしれません。クラス名がアンダースコアだけから成り立つ場合には、変換は行われません。</p>
</div>
<div class="section" id="atom-literals">
<span id="id1"></span><h3>リテラル<a class="headerlink" href="#atom-literals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-7">Python では、文字列リテラルと、様々な数値リテラルをサポートしています:</p>
<pre>
<strong id="grammar-token-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-stringliteral"><tt class="xref docutils literal"><span class="pre">stringliteral</span></tt></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-longinteger"><tt class="xref docutils literal"><span class="pre">longinteger</span></tt></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-floatnumber"><tt class="xref docutils literal"><span class="pre">floatnumber</span></tt></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-imagnumber"><tt class="xref docutils literal"><span class="pre">imagnumber</span></tt></a>
</pre>
<p id="index-8">リテラルを評価すると、指定した型 (文字列、整数、長整数、浮動小数点数、複素数) の指定した値を持つオブジェクトになります。浮動小数点や虚数 (複素数)
リテラルの場合、値は近似値になる場合があります。詳しくは <a class="reference internal" href="lexical_analysis.html#literals"><em>リテラル (literal)</em></a> を参照してください。リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても)
同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。</p>
</div>
<div class="section" id="parenthesized-form">
<span id="parenthesized"></span><h3>丸括弧形式 (parenthesized form)<a class="headerlink" href="#parenthesized-form" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-9">丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:</p>
<pre>
<strong id="grammar-token-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a>] &quot;)&quot;
</pre>
<p>丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります;
そうでない場合、式のリストを構成している単一の式自体の値になります。</p>
<p id="index-10">中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。</p>
<p id="index-11">タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が <em>必要です</em> &#8212;
丸括弧のつかない &#8220;何も記述しない式 (nothing)&#8221; を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。</p>
</div>
<div class="section" id="lists">
<span id="id2"></span><h3>リスト表現<a class="headerlink" href="#lists" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-12">リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-list_display">list_display       </strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a> | <a class="reference internal" href="#grammar-token-list_comprehension"><tt class="xref docutils literal"><span class="pre">list_comprehension</span></tt></a>] &quot;]&quot;
<strong id="grammar-token-list_comprehension">list_comprehension </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> <a class="reference internal" href="#grammar-token-list_for"><tt class="xref docutils literal"><span class="pre">list_for</span></tt></a>
<strong id="grammar-token-list_for">list_for           </strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><tt class="xref docutils literal"><span class="pre">target_list</span></tt></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-old_expression_list"><tt class="xref docutils literal"><span class="pre">old_expression_list</span></tt></a> [<a class="reference internal" href="#grammar-token-list_iter"><tt class="xref docutils literal"><span class="pre">list_iter</span></tt></a>]
<strong id="grammar-token-old_expression_list">old_expression_list</strong> ::=  <a class="reference internal" href="#grammar-token-old_expression"><tt class="xref docutils literal"><span class="pre">old_expression</span></tt></a> [(&quot;,&quot; <a class="reference internal" href="#grammar-token-old_expression"><tt class="xref docutils literal"><span class="pre">old_expression</span></tt></a>)+ [&quot;,&quot;]]
<strong id="grammar-token-old_expression">old_expression     </strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><tt class="xref docutils literal"><span class="pre">or_test</span></tt></a> | <a class="reference internal" href="#grammar-token-old_lambda_form"><tt class="xref docutils literal"><span class="pre">old_lambda_form</span></tt></a>
<strong id="grammar-token-list_iter">list_iter          </strong> ::=  <a class="reference internal" href="#grammar-token-list_for"><tt class="xref docutils literal"><span class="pre">list_for</span></tt></a> | <a class="reference internal" href="#grammar-token-list_if"><tt class="xref docutils literal"><span class="pre">list_if</span></tt></a>
<strong id="grammar-token-list_if">list_if            </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-old_expression"><tt class="xref docutils literal"><span class="pre">old_expression</span></tt></a> [<a class="reference internal" href="#grammar-token-list_iter"><tt class="xref docutils literal"><span class="pre">list_iter</span></tt></a>]
</pre>
<p id="index-13">リスト表現は、新に作成されたリストオブジェクトを表します。新たなリストの内容は、式のリストを与えるか、リストの内包表記 (list
comprehension) で指定します。  カンマで区切られた式のリストを与えた場合、リストの各要素は左から右へと順に評価され、評価された順番にリスト内に配置されます。リストの内包表記を与える場合、内包表記はまず単一の式、続いて少なくとも一つの
<a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 節、続いてゼロ個以上の <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 節か <a class="reference internal" href="compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> 節になります。この場合、新たに作成されるリストの各要素は、各々の <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> や <a class="reference internal" href="compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>
節を左から右の順にネストしたブロックとみなして実行し、ネストの最内ブロックに到達する度に式を評価した値となります。  <a class="footnote-reference" href="#id21" id="id3">[1]</a></p>
</div>
<div class="section" id="comprehensions">
<span id="id4"></span><h3>集合と辞書の表現<a class="headerlink" href="#comprehensions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python は、集合や辞書を構成するために、&#8221;表現 (display)&#8221; と呼ばれる特殊な構文を、それぞれ二種類づつ提供していて、コンテナの内容は:</p>
<ul class="simple">
<li>明示的に列挙される、または</li>
<li><em class="dfn">内包表記 (comprehension)</em> と呼ばれる、ループ処理とフィルター処理の命令の組み合わせを通じて計算されます。</li>
</ul>
<p>内包表記の共通の構文要素はこの通りです:</p>
<pre>
<strong id="grammar-token-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> <a class="reference internal" href="#grammar-token-comp_for"><tt class="xref docutils literal"><span class="pre">comp_for</span></tt></a>
<strong id="grammar-token-comp_for">comp_for     </strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><tt class="xref docutils literal"><span class="pre">target_list</span></tt></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-or_test"><tt class="xref docutils literal"><span class="pre">or_test</span></tt></a> [<a class="reference internal" href="#grammar-token-comp_iter"><tt class="xref docutils literal"><span class="pre">comp_iter</span></tt></a>]
<strong id="grammar-token-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-comp_for"><tt class="xref docutils literal"><span class="pre">comp_for</span></tt></a> | <a class="reference internal" href="#grammar-token-comp_if"><tt class="xref docutils literal"><span class="pre">comp_if</span></tt></a>
<strong id="grammar-token-comp_if">comp_if      </strong> ::=  &quot;if&quot; <tt class="xref docutils literal"><span class="pre">expression_nocond</span></tt> [<a class="reference internal" href="#grammar-token-comp_iter"><tt class="xref docutils literal"><span class="pre">comp_iter</span></tt></a>]
</pre>
<p>内包表記はまず単一の式、続いて <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 節、さらに続いて 0 個以上の <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 節や <a class="reference internal" href="compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> 節からなります。この場合、新たなコンテナの各要素は、各々の <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> や <a class="reference internal" href="compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>
節を、左から右にネストしたブロックとみなして実行し、ネストの最内のブロックに到達する度に式を評価することで作成されたものになります。</p>
<p>なお、これらの内包表記は別のスコープで実行されるので、対象のリスト内で代入された名前が外側のスコープに &#8220;漏れる&#8221; ことはありません。</p>
</div>
<div class="section" id="genexpr">
<span id="id5"></span><h3>ジェネレータ式<a class="headerlink" href="#genexpr" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-14"></span><p>ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:</p>
<pre>
<strong id="grammar-token-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> <a class="reference internal" href="#grammar-token-comp_for"><tt class="xref docutils literal"><span class="pre">comp_for</span></tt></a> &quot;)&quot;
</pre>
<p>ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。</p>
<p>ジェネレータ式で使われる変数は、ジェネレータオブジェクトに
<a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドが呼び出されたときに遅延評価されます (通常のジェネレータと同じ流儀です)。しかし、最も左に位置する
<a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 節は直ちに評価されるため、そこで生じたエラーは、ジェネレータ式を扱うコードで起こりえる他のエラーの前に現れることがあります。その後に続く <a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> 節は、その前の
<a class="reference internal" href="compound_stmts.html#for"><tt class="xref std std-keyword docutils literal"><span class="pre">for</span></tt></a> ループに依存しているため、直ちには評価されません。例: <tt class="docutils literal"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">bar(x))</span></tt></p>
<p>関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは <a class="reference internal" href="#calls"><em>呼び出し (call)</em></a> 節を参照してください。</p>
</div>
<div class="section" id="dict">
<span id="id6"></span><h3>辞書表現<a class="headerlink" href="#dict" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-15">辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-key_datum_list"><tt class="xref docutils literal"><span class="pre">key_datum_list</span></tt></a> | <a class="reference internal" href="#grammar-token-dict_comprehension"><tt class="xref docutils literal"><span class="pre">dict_comprehension</span></tt></a>] &quot;}&quot;
<strong id="grammar-token-key_datum_list">key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-key_datum"><tt class="xref docutils literal"><span class="pre">key_datum</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-key_datum"><tt class="xref docutils literal"><span class="pre">key_datum</span></tt></a>)* [&quot;,&quot;]
<strong id="grammar-token-key_datum">key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
<strong id="grammar-token-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> <a class="reference internal" href="#grammar-token-comp_for"><tt class="xref docutils literal"><span class="pre">comp_for</span></tt></a>
</pre>
<p>辞書表現は、新たな辞書オブジェクトを表します。</p>
<p>カンマ区切りの一連のキー/データの対が与えられたときは、その要素は左から右へ評価され、辞書の項目を定義します。すなわち、それぞれのキーオブジェクトが、辞書内で対応するデータを保存するキーとして使われます。これにより、キー/データリストの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値は、最後に与えられたものになります。</p>
<p>辞書内包表記は、リストや集合の内包表記とは対照的に、通常の &#8220;for&#8221; や &#8220;if&#8221; 節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。</p>
<p id="index-16">キーの値として使える型に関する制限は <a class="reference internal" href="datamodel.html#types"><em>標準型の階層</em></a> 節ですでに列挙しています。(一言でいうと、キーは変更可能なオブジェクトを全て排除した <a class="reference internal" href="../glossary.html#term-hashable"><em class="xref std std-term">hashable</em></a> でなければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることはありません; あるキーに対して、最後に渡されたデータ
(プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。</p>
</div>
<div class="section" id="set">
<span id="id7"></span><h3>集合表現<a class="headerlink" href="#set" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-17">集合表現は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:</p>
<pre>
<strong id="grammar-token-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a> | <a class="reference internal" href="#grammar-token-comprehension"><tt class="xref docutils literal"><span class="pre">comprehension</span></tt></a>) &quot;}&quot;
</pre>
<p>集合表示は、一連の式または内包表記によって指定された内容の、ミュータブルな集合オブジェクトを与えます。カンマ区切りの一連の式が与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。内包表記が与えられたときは、内包表記の結果となる要素で集合が構成されます。</p>
<p>空集合は <tt class="docutils literal"><span class="pre">{}</span></tt> で構成できません。このリテラルは空の辞書を構成します。</p>
</div>
<div class="section" id="string-conversions">
<span id="id8"></span><h3>文字列変換<a class="headerlink" href="#string-conversions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-18">文字列変換は、逆クオート (reverse quite, 別名バッククオート:  backward quote) で囲われた式のリストです:</p>
<pre>
<strong id="grammar-token-string_conversion">string_conversion</strong> ::=  &quot;'&quot; <a class="reference internal" href="#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a> &quot;'&quot;
</pre>
<p>文字列変換は、逆クオート内の式リストを評価して、評価結果のオブジェクトを各オブジェクトの型特有の規則に従って文字列に変換します。</p>
<p>オブジェクトが文字列、数値、 <tt class="docutils literal"><span class="pre">None</span></tt> か、それらの型のオブジェクトのみを含むタプル、リストまたは辞書の場合、評価結果の文字列は有効な Python
式となり、組み込み関数 <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> に渡した場合に同じ値となります  (浮動小数点が含まれている場合には近似値の場合もあります)。</p>
<p>(特に、文字列を変換すると、値を安全に出力するために文字列の両側にクオートが付けられ、&#8221;変 (funny) な&#8221; 文字はエスケープシーケンスに変換されます。)</p>
<p id="index-19">再帰的な構造をもつオブジェクト (例えば自分自身を直接または間接的に含むリストや辞書) では <tt class="docutils literal"><span class="pre">...</span></tt> を使って再帰的参照であることが示され、オブジェクトの評価結果は <a class="reference internal" href="../library/functions.html#eval" title="eval"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> に渡しても等価な値を得ることができません (<a class="reference internal" href="../library/exceptions.html#exceptions.SyntaxError" title="exceptions.SyntaxError"><tt class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></tt></a> が送出されます)。</p>
<p id="index-20">組み込み関数 <a class="reference internal" href="../library/repr.html#module-repr" title="repr: 大きさに制限のある別のrepr()の実装。"><tt class="xref py py-func docutils literal"><span class="pre">repr()</span></tt></a> は、括弧内の引数に対して、逆クオート表記で囲われた中身と全く同じ変換を実行します。組み込み関数
<a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a> は似たような動作をしますが、もっとユーザフレンドリな変換になります。</p>
</div>
<div class="section" id="yield">
<span id="yieldexpr"></span><h3>Yield 式<a class="headerlink" href="#yield" title="このヘッドラインへのパーマリンク">¶</a></h3>
<pre id="index-21">
<strong id="grammar-token-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-yield_expression"><tt class="xref docutils literal"><span class="pre">yield_expression</span></tt></a> &quot;)&quot;
<strong id="grammar-token-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a>]
</pre>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
<p><a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式はジェネレータ関数を定義するときにその関数の内部でのみ使用されます。関数内で <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式を使用すると、普通の関数ではなくジェネレータ関数が作成されます。</p>
<p>ジェネレータ関数が呼び出されるとき、ジェネレータとしてのイテレータを返します。そのジェネレータはジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されるときに実行が開始されます。メソッドを呼び出すと、実行は <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> の最初の位置まで処理されて一時停止します。そして、ジェネレータの呼び出し元へ <a class="reference internal" href="#grammar-token-expression_list"><tt class="xref std std-token docutils literal"><span class="pre">expression_list</span></tt></a> の値を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタックを含めたローカルの全ての状態が保持されることを指します。再度、ジェネレータのメソッドを呼び出して実行を再開するとき、そのジェネレータ関数はまさに <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式がただの外部呼び出しであったかのように処理が継続されます。再開した後の <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式の値は実行を再開するメソッドに依存します。</p>
<p id="index-22">これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。</p>
<p id="index-23">以下のジェネレータメソッドはジェネレータ関数の実行を制御するために使用されます。</p>
<span class="target" id="index-24"></span><dl class="method">
<dt id="generator.next">
<tt class="descclassname">generator.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#generator.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の実行を開始する、または最後に <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式が実行された位置から再開します。ジェネレータ関数が <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドで再開されるとき、カレントの <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> は常に <a class="reference internal" href="../library/constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> に対して評価されます。それから実行は、次の <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式の位置まで継続されて、再度そのジェネレータは一時停止します。そして <a class="reference internal" href="#grammar-token-expression_list"><tt class="xref std std-token docutils literal"><span class="pre">expression_list</span></tt></a> の値が
<a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> の呼び出し元へ返されます。ジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> が発生します。</p>
</dd></dl>

<dl class="method">
<dt id="generator.send">
<tt class="descclassname">generator.</tt><tt class="descname">send</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#generator.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の内部へ値を &#8220;送り&#8221;、実行を再開します。引数の <tt class="docutils literal"><span class="pre">value</span></tt> はカレントの <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式の結果になります。
<a class="reference internal" href="#generator.send" title="generator.send"><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt></a> メソッドはジェネレータが生成した次の値、またはジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> が発生します。ジェネレータが再開するために <a class="reference internal" href="#generator.send" title="generator.send"><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt></a> を呼び出すときは、引数として <a class="reference internal" href="../library/constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> を指定しなければなりません。そうしないと、値を受け取る <a class="reference internal" href="simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 式が存在しないからです。</p>
</dd></dl>

<dl class="method">
<dt id="generator.throw">
<tt class="descclassname">generator.</tt><tt class="descname">throw</tt><big>(</big><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#generator.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータが中断した位置で <tt class="docutils literal"><span class="pre">type</span></tt> 型の例外を発生させて、ジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると
<a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。</p>
</dd></dl>

<span class="target" id="index-25"></span><dl class="method">
<dt id="generator.close">
<tt class="descclassname">generator.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#generator.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数が中断した位置で <a class="reference internal" href="../library/exceptions.html#exceptions.GeneratorExit" title="exceptions.GeneratorExit"><tt class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></tt></a> を発生させます。ジェネレータ関数が (通常の終了または既にクローズされたことで) <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> 、もしくは (例外を捕捉しないことで) <a class="reference internal" href="../library/exceptions.html#exceptions.GeneratorExit" title="exceptions.GeneratorExit"><tt class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></tt></a> を発生させる場合 close() は呼び出し元へ返されます。ジェネレータが値を生成する場合 <a class="reference internal" href="../library/exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> が発生します。
<a class="reference internal" href="#generator.close" title="generator.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> はジェネレータが通常の終了または例外により既に終了している場合は何もしません。</p>
</dd></dl>

<p>以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="s">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">generator</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">generator</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-26"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - 拡張されたジェネレータを用いたコルーチン</dt>
<dd>シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案です。</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="primary">
<span id="primaries"></span><h2>一次語 (primary)<a class="headerlink" href="#primary" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-27">一次語は、言語において最も結合の強い操作を表します。文法は以下のようになります:</p>
<pre>
<strong id="grammar-token-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-atom"><tt class="xref docutils literal"><span class="pre">atom</span></tt></a> | <a class="reference internal" href="#grammar-token-attributeref"><tt class="xref docutils literal"><span class="pre">attributeref</span></tt></a> | <a class="reference internal" href="#grammar-token-subscription"><tt class="xref docutils literal"><span class="pre">subscription</span></tt></a> | <a class="reference internal" href="#grammar-token-slicing"><tt class="xref docutils literal"><span class="pre">slicing</span></tt></a> | <a class="reference internal" href="#grammar-token-call"><tt class="xref docutils literal"><span class="pre">call</span></tt></a>
</pre>
<div class="section" id="attribute-references">
<span id="id9"></span><h3>属性参照<a class="headerlink" href="#attribute-references" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-28">属性参照は、一次語の後ろにピリオドと名前を連ねたものです:</p>
<pre>
<strong id="grammar-token-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><tt class="xref docutils literal"><span class="pre">primary</span></tt></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>
</pre>
<p id="index-29">一次語の値評価結果は、例えばモジュール、リスト、インスタンスといった、属性参照をサポートする型でなければなりません。オブジェクトは次に、指定した名前が識別子名となっているような属性を生成するよう問い合わせされます。問い合わせた属性が得られない場合、例外
<a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> が送出されます。それ以外の場合、オブジェクトは属性オブジェクトの型と値を決定し、生成して返します。同じ属性参照を複数回評価したとき、互いに異なる属性オブジェクトになることがあります。</p>
</div>
<div class="section" id="subscription">
<span id="subscriptions"></span><h3>添字表記 (subscription)<a class="headerlink" href="#subscription" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-30"></span><p id="index-31">添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェクトから、要素を一つ選択します:</p>
<pre>
<strong id="grammar-token-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><tt class="xref docutils literal"><span class="pre">primary</span></tt></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expression_list"><tt class="xref docutils literal"><span class="pre">expression_list</span></tt></a> &quot;]&quot;
</pre>
<p>一次語の値評価結果は、シーケンス型かマップ型のオブジェクトでなければなりません。</p>
<p>一次語がマップであれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマップ内の値 (value) を選択します。 (式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。)</p>
<p>一次語がシーケンスの場合、式 (リスト) の値評価結果は (通常の) 整数でなければなりません。値が負の場合、シーケンスの長さが加算されます
(<tt class="docutils literal"><span class="pre">x[-1]</span></tt> が <tt class="docutils literal"><span class="pre">x</span></tt> の最後の要素を指すことになります)。加算結果はシーケンス内の要素数よりも小さな非負の整数とならなければなりません。添字表記は、添字と同じシーケンス中の (ゼロから数えた) インデクスを持つ要素を選択します。</p>
<p id="index-32">文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1 文字だけからなる文字列です。</p>
</div>
<div class="section" id="slicing">
<span id="slicings"></span><h3>スライス表記 (slicing)<a class="headerlink" href="#slicing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-33"></span><p id="index-34">スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や
<a class="reference internal" href="simple_stmts.html#del"><tt class="xref std std-keyword docutils literal"><span class="pre">del</span></tt></a> 文の対象として用いたりできます。スライス表記の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-slicing">slicing         </strong> ::=  <a class="reference internal" href="#grammar-token-simple_slicing"><tt class="xref docutils literal"><span class="pre">simple_slicing</span></tt></a> | <a class="reference internal" href="#grammar-token-extended_slicing"><tt class="xref docutils literal"><span class="pre">extended_slicing</span></tt></a>
<strong id="grammar-token-simple_slicing">simple_slicing  </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><tt class="xref docutils literal"><span class="pre">primary</span></tt></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-short_slice"><tt class="xref docutils literal"><span class="pre">short_slice</span></tt></a> &quot;]&quot;
<strong id="grammar-token-extended_slicing">extended_slicing</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><tt class="xref docutils literal"><span class="pre">primary</span></tt></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-slice_list"><tt class="xref docutils literal"><span class="pre">slice_list</span></tt></a> &quot;]&quot;
<strong id="grammar-token-slice_list">slice_list      </strong> ::=  <a class="reference internal" href="#grammar-token-slice_item"><tt class="xref docutils literal"><span class="pre">slice_item</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-slice_item"><tt class="xref docutils literal"><span class="pre">slice_item</span></tt></a>)* [&quot;,&quot;]
<strong id="grammar-token-slice_item">slice_item      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> | <a class="reference internal" href="#grammar-token-proper_slice"><tt class="xref docutils literal"><span class="pre">proper_slice</span></tt></a> | <a class="reference internal" href="#grammar-token-ellipsis"><tt class="xref docutils literal"><span class="pre">ellipsis</span></tt></a>
<strong id="grammar-token-proper_slice">proper_slice    </strong> ::=  <a class="reference internal" href="#grammar-token-short_slice"><tt class="xref docutils literal"><span class="pre">short_slice</span></tt></a> | <a class="reference internal" href="#grammar-token-long_slice"><tt class="xref docutils literal"><span class="pre">long_slice</span></tt></a>
<strong id="grammar-token-short_slice">short_slice     </strong> ::=  [<a class="reference internal" href="#grammar-token-lower_bound"><tt class="xref docutils literal"><span class="pre">lower_bound</span></tt></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-upper_bound"><tt class="xref docutils literal"><span class="pre">upper_bound</span></tt></a>]
<strong id="grammar-token-long_slice">long_slice      </strong> ::=  <a class="reference internal" href="#grammar-token-short_slice"><tt class="xref docutils literal"><span class="pre">short_slice</span></tt></a> &quot;:&quot; [<a class="reference internal" href="#grammar-token-stride"><tt class="xref docutils literal"><span class="pre">stride</span></tt></a>]
<strong id="grammar-token-lower_bound">lower_bound     </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
<strong id="grammar-token-upper_bound">upper_bound     </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
<strong id="grammar-token-stride">stride          </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
<strong id="grammar-token-ellipsis">ellipsis        </strong> ::=  &quot;...&quot;
</pre>
<p id="index-35">上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。この場合には、(スライスリストの評価結果が、適切なスライスや省略表記 (ellipsis)
にならない場合)、スライス表記としての解釈よりも添字表記としての解釈の方が高い優先順位を持つように定義することで、構文法をより難解にすることなくあいまいさを取り除いています。同様に、スライスリストが厳密に一つだけの短いスライスで、末尾にカンマが続いていない場合、拡張スライスとしての解釈より、単純なスライスとしての解釈が優先されます。</p>
<p>単純なスライスに対する意味付けは以下のようになります。一次語の値評価結果は、シーケンス型のオブジェクトでなければなりません。下境界および上境界を表す式がある場合、それらの値評価結果は整数でなくてはなりません; デフォルトの値は、それぞれゼロと <tt class="docutils literal"><span class="pre">sys.maxint</span></tt>
です。どちらかの境界値が負である場合、シーケンスの長さが加算されます。こうして、スライスは <em>i</em> および <em>j</em> をそれぞれ指定した下境界、上境界として、インデクス <em>k</em> が <tt class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></tt> となる全ての要素を選択します。選択の結果、空のシーケンスになることもあります。 <em>i</em> や <em>j</em> が有効なインデクス範囲の外側にある場合でも、エラーにはなりません (範囲外の要素は存在しないので、選択されないだけです)。</p>
<p id="index-36">拡張スライスに対する意味付けは、以下のようになります。一次語の値評価結果は、辞書型のオブジェクトでなければなりません。また、辞書は以下に述べるようにしてスライスリストから生成されたキーによってインデクス指定できなければなりません。スライスリストに少なくとも一つのカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります;
それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。一個の式でできたスライス要素の変換は、その式になります。省略表記スライス要素の変換は、組み込みの <tt class="docutils literal"><span class="pre">Ellipsis</span></tt> オブジェクトになります。適切なスライスの変換は、スライスオブジェクト
(<a class="reference internal" href="datamodel.html#types"><em>標準型の階層</em></a> 参照) で <tt class="xref py py-attr docutils literal"><span class="pre">start</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">stop</span></tt> および <tt class="xref py py-attr docutils literal"><span class="pre">step</span></tt>
属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。式がない場合には <tt class="docutils literal"><span class="pre">None</span></tt> に置き換えられます。</p>
</div>
<div class="section" id="call">
<span id="calls"></span><h3>呼び出し (call)<a class="headerlink" href="#call" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-37"></span><p id="index-38">呼び出し (call) は、呼び出し可能オブジェクト (callable object, 例えば関数など)
を、引数列とともに呼び出します。引数列は空のシーケンスでもかまいません:</p>
<pre>
<strong id="grammar-token-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><tt class="xref docutils literal"><span class="pre">primary</span></tt></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-argument_list"><tt class="xref docutils literal"><span class="pre">argument_list</span></tt></a> [&quot;,&quot;]
                          | <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> <tt class="xref docutils literal"><span class="pre">genexpr_for</span></tt>] &quot;)&quot;
<strong id="grammar-token-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-positional_arguments"><tt class="xref docutils literal"><span class="pre">positional_arguments</span></tt></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><tt class="xref docutils literal"><span class="pre">keyword_arguments</span></tt></a>]
                            [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>] [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><tt class="xref docutils literal"><span class="pre">keyword_arguments</span></tt></a>]
                            [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]
                          | <a class="reference internal" href="#grammar-token-keyword_arguments"><tt class="xref docutils literal"><span class="pre">keyword_arguments</span></tt></a> [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]
                            [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]
                          | &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>] [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]
                          | &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
<strong id="grammar-token-positional_arguments">positional_arguments</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>)*
<strong id="grammar-token-keyword_arguments">keyword_arguments   </strong> ::=  <a class="reference internal" href="#grammar-token-keyword_item"><tt class="xref docutils literal"><span class="pre">keyword_item</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><tt class="xref docutils literal"><span class="pre">keyword_item</span></tt></a>)*
<strong id="grammar-token-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
</pre>
<p>固定引数やキーワード引数の後ろにカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。</p>
<p>一次語の値評価結果は、呼び出し可能オブジェクトでなければなりません (ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェクト、クラスインスタンスのメソッド、そして特定のクラスインスタンス自体が呼び出し可能です; 拡張によって、その他の呼び出し可能オブジェクト型を定義することができます)。引数式は全て、呼び出しを試みる前に値評価されます。仮引数 (formal parameter)
リストの構文については <a class="reference internal" href="compound_stmts.html#function"><em>関数定義</em></a>  を参照してください。</p>
<p>キーワード引数が存在する場合、以下のようにして最初に固定引数 (positional argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の固定引数がある場合、固定引数は先頭の N スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数パラメタ名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が <tt class="docutils literal"><span class="pre">None</span></tt> であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。)
デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 実際の実装では、名前を持たない固定引数を受け取る組み込み関数を提供するかもしれません。そういった組み込み関数がドキュメント化の目的で &#8216;名前&#8217; を設けていたとしても、実際には持っていないのでキーワードによって提供されません。
CPython では、C 言語で実装された関数の名前を持たない固定引数を解析するために
<a class="reference internal" href="../c-api/arg.html#PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> を使用します。</p>
</div>
<p>仮引数スロットの数よりも多くの固定引数がある場合、構文  <tt class="docutils literal"><span class="pre">*identifier</span></tt> を使って指定された仮引数がないかぎり、
<a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されます;  仮引数 <tt class="docutils literal"><span class="pre">*identifier</span></tt> がある場合、この仮引数は余分な固定引数が入ったタプル
(もしくは、余分な固定引数がない場合には空のタプル) を受け取ります。</p>
<p>キーワード引数のいずれかが仮引数名に対応しない場合、構文 <tt class="docutils literal"><span class="pre">**identifier</span></tt> を使って指定された仮引数がない限り、
<a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されます; 仮引数 <tt class="docutils literal"><span class="pre">**identifier</span></tt> がある場合、この仮引数は余分なキーワード引数が入った
(キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。</p>
<p>関数呼び出しの際に <tt class="docutils literal"><span class="pre">*expression</span></tt> 構文が使われる場合、 <tt class="docutils literal"><span class="pre">expression</span></tt> の値評価結果はシーケンスでなくてはなりません。このシーケンスの要素は、追加の固定引数のように扱われます; すなわち、固定引数 <em>x1</em> ,..., <em>xN</em> と、 <em>y1</em> ,..., <em>yM</em> になるシーケンス
<tt class="docutils literal"><span class="pre">expression</span></tt> を使った場合、M+N 個の固定引数 <em>x1</em> ,..., <em>xN</em> , <em>y1</em> ,..., <em>yM</em> を使った呼び出しと同じになります。</p>
<p><tt class="docutils literal"><span class="pre">*expression</span></tt> 構文はキーワード引数の <em>後ろ</em> で指定しても良いですが、キーワード引数よりも <em>前</em> で指定されたものとして処理されます
( <tt class="docutils literal"><span class="pre">**expression</span></tt> 引数を指定したときの振る舞いは以下を参照)。従って:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>となります。</p>
<p>キーワード引数と <tt class="docutils literal"><span class="pre">*expression</span></tt> 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が生じることはありません。</p>
<p>関数呼び出しで <tt class="docutils literal"><span class="pre">**expression</span></tt> 構文が使われた場合、 <tt class="docutils literal"><span class="pre">expression</span></tt> の値評価結果はマップ型でなければなりません。辞書の内容は追加のキーワード引数として扱われます。明示的なキーワード引数が <tt class="docutils literal"><span class="pre">expression</span></tt> 内のキーワードと重複した場合には <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されます。</p>
<p><tt class="docutils literal"><span class="pre">*identifier</span></tt> や <tt class="docutils literal"><span class="pre">**identifier</span></tt> 構文を使った仮引数は、固定引数スロットやキーワード引数名にすることができません。
<tt class="docutils literal"><span class="pre">(sublist)</span></tt> 構文を使った仮引数は、キーワード引数名には使えません; sublist は、リスト全体が一つの無名の引数スロットに対応しており、sublist 中の引数は、他の全てのパラメタに対する処理が終わった後に、通常のタプル形式の代入規則を使ってスロットに入れられます。</p>
<p>呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 <tt class="docutils literal"><span class="pre">None</span></tt> を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。</p>
<p>呼び出し可能オブジェクトが。。。</p>
<dl class="docutils">
<dt>ユーザ定義関数のとき:</dt>
<dd><p class="first last" id="index-39">関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については
<a class="reference internal" href="compound_stmts.html#function"><em>関数定義</em></a> で記述しています。コードブロックで <a class="reference internal" href="simple_stmts.html#return"><tt class="xref std std-keyword docutils literal"><span class="pre">return</span></tt></a> 文が実行される際に、関数呼び出しの戻り値
(return value) が決定されます。</p>
</dd>
<dt>組み込み関数や組み込みメソッドのとき:</dt>
<dd><p class="first last" id="index-40">結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は <a class="reference internal" href="../library/functions.html#built-in-funcs"><em>組み込み関数</em></a> を参照してください。</p>
</dd>
<dt>クラスオブジェクトのとき:</dt>
<dd><p class="first last" id="index-41">そのクラスの新しいインスタンスが返されます。</p>
</dd>
<dt>クラスインスタンスメソッドのとき:</dt>
<dd><p class="first last" id="index-42">対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。</p>
</dd>
<dt>クラスインスタンスのとき:</dt>
<dd><p class="first last" id="index-43">クラスで <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> メソッドが定義されていなければなりません; <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>
メソッドが呼び出された場合と同じ効果をもたらします。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="power-operator">
<span id="power"></span><h2>べき乗演算 (power operator)<a class="headerlink" href="#power-operator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>べき乗演算は、左側にある単項演算子よりも強い結合優先順位があります; 一方、右側にある単項演算子よりは低い結合優先順位になっています。構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-power">power</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><tt class="xref docutils literal"><span class="pre">primary</span></tt></a> [&quot;**&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a>]
</pre>
<p>従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。つまり <tt class="docutils literal"><span class="pre">-1**2</span></tt> は <tt class="docutils literal"><span class="pre">-1</span></tt> になります)。</p>
<p>べき乗演算子は、二つの引数で呼び出される組み込み関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><tt class="xref py py-func docutils literal"><span class="pre">pow()</span></tt></a>  と同じ意味付けを持っています。引数はまず共通の型に変換されます。結果の型は、型強制後の引数の型になります。</p>
<p>引数型を混合すると、二項算術演算における型強制規則が適用されます。整数や長整数の被演算子の場合、第二引数が負でない限り、結果は  (型強制後の)
被演算子と同じになります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば <tt class="docutils literal"><span class="pre">10**2</span></tt> は <tt class="docutils literal"><span class="pre">100</span></tt>
を返しますが、 <tt class="docutils literal"><span class="pre">10**-2</span></tt>  は <tt class="docutils literal"><span class="pre">0.01</span></tt> を返します。 (上述の仕様のうち、最後のものは Python 2.2 で追加されました。
Python 2.1 以前では、双方の引数が整数型で、第二引数が負の場合、例外が送出されていました。)</p>
<p><tt class="docutils literal"><span class="pre">0.0</span></tt> を負の数でべき乗すると <a class="reference internal" href="../library/exceptions.html#exceptions.ZeroDivisionError" title="exceptions.ZeroDivisionError"><tt class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></tt></a> を送出します。負の数を小数でべき乗すると
<a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> になります。</p>
</div>
<div class="section" id="unary-arithmetic-and-bitwise-operation">
<span id="unary"></span><h2>単項算術演算とビット単位演算(unary arithmetic and bitwise operation)<a class="headerlink" href="#unary-arithmetic-and-bitwise-operation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-44">全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:</p>
<pre>
<strong id="grammar-token-u_expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-power"><tt class="xref docutils literal"><span class="pre">power</span></tt></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a>
</pre>
<p id="index-45">単項演算子 <tt class="docutils literal"><span class="pre">-</span></tt> (マイナス) は、引数となる数値の符号を反転 (invert) します。</p>
<p id="index-46">単項演算子 <tt class="docutils literal"><span class="pre">+</span></tt> (プラス) は、数値引数を変更しません。</p>
<p id="index-47">単項演算子 <tt class="docutils literal"><span class="pre">~</span></tt> (反転) は、整数または長整数の引数をビット単位反転 (bitwise invert) します。 <tt class="docutils literal"><span class="pre">x</span></tt> のビット単位反転は、
<tt class="docutils literal"><span class="pre">-(x+1)</span></tt> として定義されています。この演算子は整数にのみ適用されます。</p>
<p id="index-48">上記の三つはいずれも、引数が正しい型でない場合には <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> 例外が送出されます。</p>
</div>
<div class="section" id="binary-arithmetic-operation">
<span id="binary"></span><h2>二項算術演算 (binary arithmetic operation)<a class="headerlink" href="#binary-arithmetic-operation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-49">二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power)
演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:</p>
<pre>
<strong id="grammar-token-m_expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a>
            | <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-u_expr"><tt class="xref docutils literal"><span class="pre">u_expr</span></tt></a>
<strong id="grammar-token-a_expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-a_expr"><tt class="xref docutils literal"><span class="pre">a_expr</span></tt></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-a_expr"><tt class="xref docutils literal"><span class="pre">a_expr</span></tt></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-m_expr"><tt class="xref docutils literal"><span class="pre">m_expr</span></tt></a>
</pre>
<p id="index-50"><tt class="docutils literal"><span class="pre">*</span></tt> (乗算: multiplication) 演算は、引数間の積になります。引数の組は、双方ともに数値型であるか、片方が整数 (通常の整数または長整数) 型で他方がシーケンス型かのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスになります。</p>
<p id="index-51"><tt class="docutils literal"><span class="pre">/</span></tt> (除算: division) および <tt class="docutils literal"><span class="pre">//</span></tt> (切り捨て除算: floor division)
は、引数間の商になります。数値引数はまず共通の型に変換されます。整数または長整数の除算結果は、同じ型の整数になります; この場合、結果は数学的な除算に関数
&#8216;floor&#8217; を適用したものになります。ゼロによる除算を行うと <a class="reference internal" href="../library/exceptions.html#exceptions.ZeroDivisionError" title="exceptions.ZeroDivisionError"><tt class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></tt></a> 例外を送出します。</p>
<p id="index-52"><tt class="docutils literal"><span class="pre">%</span></tt> (モジュロ: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には <a class="reference internal" href="../library/exceptions.html#exceptions.ZeroDivisionError" title="exceptions.ZeroDivisionError"><tt class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></tt></a> 例外が送出されます。引数値は浮動小数点でもよく。例えば <tt class="docutils literal"><span class="pre">3.14%0.7</span></tt>
は <tt class="docutils literal"><span class="pre">0.34</span></tt> になります (<tt class="docutils literal"><span class="pre">3.14</span></tt> は <tt class="docutils literal"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></tt>  だからです)。モジュロ演算子は常に第二引数と同じ符号
(またはゼロ) の結果になります; モジュロ演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 <a class="footnote-reference" href="#id22" id="id10">[2]</a></p>
<p>整数による除算演算やモジュロ演算は、恒等式:  <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x/y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></tt> と関係しています。整数除算やモジュロはまた、組み込み関数
<a class="reference internal" href="../library/functions.html#divmod" title="divmod"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a>: <tt class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x/y,</span> <span class="pre">x%y)</span></tt> と関係しています。これらの恒等関係は浮動小数点の場合には維持されません; <tt class="docutils literal"><span class="pre">x/y</span></tt> が <tt class="docutils literal"><span class="pre">floor(x/y)</span></tt> や <tt class="docutils literal"><span class="pre">floor(x/y)</span> <span class="pre">-</span> <span class="pre">1</span></tt> に置き換えられた場合、これらの恒等式は近似性を維持します。  <a class="footnote-reference" href="#id23" id="id11">[3]</a></p>
<p>数値に対するモジュロ演算の実行に加えて <tt class="docutils literal"><span class="pre">%</span></tt> 演算子は文字列 (string) とユニコードオブジェクトにオーバーロードされ、文字列の書式化
(文字列の挿入としても知られる) を行います。文字列の書式化の構文は Python ライブラリリファレンス <a class="reference internal" href="../library/stdtypes.html#string-formatting"><em>文字列フォーマット操作</em></a> 節を参照してください。</p>
<p class="deprecated">
<span class="versionmodified">バージョン 2.3 で撤廃: </span>切り捨て除算演算子、モジュロ演算子、および <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a> 関数は、複素数に対してはもはや定義されていません。目的に合うならば、代わりに
<a class="reference internal" href="../library/functions.html#abs" title="abs"><tt class="xref py py-func docutils literal"><span class="pre">abs()</span></tt></a> を使って浮動小数点に変換してください。</p>
<p id="index-53"><tt class="docutils literal"><span class="pre">+</span></tt> (加算) 演算は、引数を加算した値を返します。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。</p>
<p id="index-54"><tt class="docutils literal"><span class="pre">-</span></tt> (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。</p>
</div>
<div class="section" id="shifting-operation">
<span id="shifting"></span><h2>シフト演算 (shifting operation)<a class="headerlink" href="#shifting-operation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-55">シフト演算は、算術演算よりも低い優先順位を持っています:</p>
<pre>
<strong id="grammar-token-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-a_expr"><tt class="xref docutils literal"><span class="pre">a_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-shift_expr"><tt class="xref docutils literal"><span class="pre">shift_expr</span></tt></a> ( &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; ) <a class="reference internal" href="#grammar-token-a_expr"><tt class="xref docutils literal"><span class="pre">a_expr</span></tt></a>
</pre>
<p>シフトの演算子は整数または長整数を引数にとります。引数は共通の型に変換されます。シフト演算では、最初の引数を二つ目の引数に応じたビット数だけ、左または右にビットシフトします。</p>
<p id="index-56"><em>n</em> ビットの右シフトは <tt class="docutils literal"><span class="pre">pow(2,n)</span></tt> による除算として定義されています。 <em>n</em> ビットの左シフトは <tt class="docutils literal"><span class="pre">pow(2,n)</span></tt>
による乗算として定義されます。負のビット数でシフトを行うと <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> 例外を送出します。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">現在の実装では、右辺被演算子は最大でも <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><tt class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></tt></a> でなければなりません。右辺被演算子が <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><tt class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></tt></a> よりも大きいと、
<a class="reference internal" href="../library/exceptions.html#exceptions.OverflowError" title="exceptions.OverflowError"><tt class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></tt></a> 例外が送出されます。</p>
</div>
</div>
<div class="section" id="binary-bitwise-operation">
<span id="bitwise"></span><h2>ビット単位演算の二項演算 (binary bitwise operation)<a class="headerlink" href="#binary-bitwise-operation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-57">以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:</p>
<pre>
<strong id="grammar-token-and_expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-shift_expr"><tt class="xref docutils literal"><span class="pre">shift_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-and_expr"><tt class="xref docutils literal"><span class="pre">and_expr</span></tt></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-shift_expr"><tt class="xref docutils literal"><span class="pre">shift_expr</span></tt></a>
<strong id="grammar-token-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-and_expr"><tt class="xref docutils literal"><span class="pre">and_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-xor_expr"><tt class="xref docutils literal"><span class="pre">xor_expr</span></tt></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-and_expr"><tt class="xref docutils literal"><span class="pre">and_expr</span></tt></a>
<strong id="grammar-token-or_expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-xor_expr"><tt class="xref docutils literal"><span class="pre">xor_expr</span></tt></a> | <a class="reference internal" href="#grammar-token-or_expr"><tt class="xref docutils literal"><span class="pre">or_expr</span></tt></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-xor_expr"><tt class="xref docutils literal"><span class="pre">xor_expr</span></tt></a>
</pre>
<p id="index-58"><tt class="docutils literal"><span class="pre">&amp;</span></tt> 演算子は、引数間でビット単位の AND をとった値になります。引数は整数または長整数でなければなりません。引数は共通の型に変換されます。</p>
<p id="index-59"><tt class="docutils literal"><span class="pre">^</span></tt> 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値になります。引数は整数または長整数でなければなりません。引数は共通の型に変換されます。</p>
<p id="index-60"><tt class="docutils literal"><span class="pre">|</span></tt> 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値になります。引数は整数または長整数でなければなりません。引数は共通の型に変換されます。</p>
</div>
<div class="section" id="comparison">
<span id="not-in"></span><span id="in"></span><span id="is-not"></span><span id="is"></span><span id="comparisons"></span><h2>比較 (comparison)<a class="headerlink" href="#comparison" title="このヘッドラインへのパーマリンク">¶</a></h2>
<span class="target" id="index-61"></span><p id="index-62">C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また <tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></tt> が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:</p>
<pre>
<strong id="grammar-token-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-or_expr"><tt class="xref docutils literal"><span class="pre">or_expr</span></tt></a> ( <a class="reference internal" href="#grammar-token-comp_operator"><tt class="xref docutils literal"><span class="pre">comp_operator</span></tt></a> <a class="reference internal" href="#grammar-token-or_expr"><tt class="xref docutils literal"><span class="pre">or_expr</span></tt></a> )*
<strong id="grammar-token-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>比較演算の結果はブール値: <tt class="docutils literal"><span class="pre">True</span></tt> または <tt class="docutils literal"><span class="pre">False</span></tt> になります。</p>
<p id="index-63">比較はいくらでも連鎖することができます。例えば <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></tt>  は <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></tt>
と等価になります。ただしこの場合、前者では <tt class="docutils literal"><span class="pre">y</span></tt> はただ一度だけ評価される点が異なります (どちらの場合でも、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt> が偽になると
<tt class="docutils literal"><span class="pre">z</span></tt> の値はまったく評価されません)。</p>
<p>形式的には、 <em>a</em>, <em>b</em>, <em>c</em>, ..., <em>y</em>, <em>z</em>  が式で <em>op1</em>, <em>op2</em>, ..., <em>opN</em> が比較演算子である場合、 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></tt> は <tt class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></tt>
と等価になります。ただし、前者では各式は多くても一度しか評価されません。</p>
<p><tt class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></tt> と書いた場合、 <em>a</em> から <em>c</em> までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></tt> は (きれいな書き方ではありませんが) 完全に正しい文法です。</p>
<p><tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt> と <tt class="docutils literal"><span class="pre">!=</span></tt> の二つの形式は等価です; C との整合性を持たせるためには <tt class="docutils literal"><span class="pre">!=</span></tt> を推奨します; 以下で <tt class="docutils literal"><span class="pre">!=</span></tt> について触れている部分では <tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt> を使うこともできます。 <tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt> のような書き方は、現在では古い書き方とみなされています。</p>
<p>演算子 <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, および <tt class="docutils literal"><span class="pre">!=</span></tt> は、二つのオブジェクト間の値を比較します。オブジェクトは同じ型である必要はありません。双方のオブジェクトが数値であれば、共通型への変換が行われます。それ以外の場合、異なる型のオブジェクトは <em>常に</em> 不等であるとみなされ、一貫してはいるが規定されていない方法で並べられます。組み込み型でないオブジェクト比較の振る舞いは  <tt class="docutils literal"><span class="pre">__cmp__</span></tt> メソッドや <tt class="docutils literal"><span class="pre">__gt__</span></tt> といったリッチな比較メソッドを定義することでコントロールすることができます。これは  <a class="reference internal" href="datamodel.html#specialnames"><em>特殊メソッド名</em></a> セクションで説明されています。</p>
<p>(このような比較演算の変則的な定義は、ソートのような操作や <a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> および <a class="reference internal" href="#not-in"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt></a> といった演算子の定義を単純化するためのものです。将来、異なる型のオブジェクト間における比較規則は変更されるかもしれません。)</p>
<p>同じ型のオブジェクト間における比較は、型によって異なります:</p>
<ul>
<li><p class="first">数値間の比較では、算術的な比較が行われます。</p>
</li>
<li><p class="first">文字列間の比較では、各文字に対する等価な数値型 (組み込み関数  <a class="reference internal" href="../library/functions.html#ord" title="ord"><tt class="xref py py-func docutils literal"><span class="pre">ord()</span></tt></a> の結果) を使って辞書的な (lexicographically)
比較が行われます。Unicode および 8 ビット文字列は、この動作に関しては完全に互換です。 <a class="footnote-reference" href="#id24" id="id12">[4]</a></p>
</li>
<li><p class="first">タプルやリスト間の比較では、対応する各要素の比較結果を使って辞書的な比較が行われます。このため、二つのシーケンスを等価にするためには、各要素が完全に等価でなくてはならず、シーケンスは同じ型で同じ長さをもっていなければなりません。</p>
<p>二つのシーケンスが等価でない場合、異なる値を持つ最初の要素間での比較に従った順序関係になります。例えば <tt class="docutils literal"><span class="pre">cmp([1,2,x],</span> <span class="pre">[1,2,y])</span></tt> は
<tt class="docutils literal"><span class="pre">cmp(x,y)</span></tt> と等しい結果を返します。片方の要素に対応する要素が他方にない場合、より短いシーケンスが前に並びます
(例えば、 <tt class="docutils literal"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></tt> となります)。</p>
</li>
<li><p class="first">マップ (辞書) 間の比較では、(key, value) からなるリストをソートしたものが等しい場合に等価になります。 <a class="footnote-reference" href="#id25" id="id13">[5]</a>
等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないかのいずれかです。 <a class="footnote-reference" href="#id26" id="id14">[6]</a></p>
</li>
<li><p class="first">その他のほとんどの組み込み型のオブジェクト比較では、同じオブジェクトでないかぎり等価にはなりません；あるオブジェクトの他のオブジェクトに対する大小関係は任意に決定され、一つのプログラムの実行中は一貫したものとなります。</p>
</li>
</ul>
<p id="membership-test-details">演算子 <a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> および <a class="reference internal" href="#not-in"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt></a> は、コレクション型の要素であるかどうか (メンバシップ、membership)
を調べます。 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></tt> は、 <em>x</em> がコレクション型 <em>s</em> のメンバである場合には真となり、それ以外の場合には偽となります。 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></tt>
は <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></tt> の否定 (negation) を返します。コレクション型のメンバシップテストは、伝統的にはシーケンス型に限定されてきました;
すなわち、あるオブジェクトがコレクション型のメンバとなるのは、そのコレクション型がシーケンスであり、シーケンスがオブジェクトと等価な要素を含む場合でした。しかし、他の多くのオブジェクトのためにシーケンスでなくてもメンバシップテストをサポートしています。特に、辞書型では、(キーのための)メンバシップテストをサポートしています。</p>
<p>リストやタプル型について <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></tt> は <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></tt> となるようなインデクス <em>i</em>
が存在するとき、かつそのときに限り真になります。</p>
<p>Unicode 文字列または文字列型については、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></tt>  は <em>x</em> が <em>y</em> の部分文字列であるとき、かつそのときに限り真になります。この演算と等価なテストは <tt class="docutils literal"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></tt> です。 <em>x</em> および <em>y</em> は同じ型である必要はないので注意してください。すなわち <tt class="docutils literal"><span class="pre">u'ab'</span> <span class="pre">in</span> <span class="pre">'abc'</span></tt> は <tt class="docutils literal"><span class="pre">True</span></tt> を返すことになります。空文字列は、他のどんな文字列に対しても常に部分文字列とみなされます。従って <tt class="docutils literal"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></tt> は <tt class="docutils literal"><span class="pre">True</span></tt> を返すことになります。</p>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.3 で変更: </span>以前は、 <em>x</em> は長さ <tt class="docutils literal"><span class="pre">1</span></tt> の文字列型でなければなりませんでした.</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><tt class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></tt></a> メソッドの定義されたユーザ定義クラスでは、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></tt> が真となるのは
<tt class="docutils literal"><span class="pre">y.__contains__(x)</span></tt> が真となるとき、かつそのときに限ります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><tt class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></tt></a> を定義していないが <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> は定義しているユーザ定義クラスでは、
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></tt> は <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></tt> となるようなある値 <cite>z</cite> が <tt class="docutils literal"><span class="pre">y</span></tt> 内にわたる反復で生成された場合、
true となります。もし、反復の間に例外が発生すれば、 <a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> が例外を発生させたようにみえます。</p>
<p>最終的には、旧式の反復プロトコルの実行を試みます、もし
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a> を定義しているようなユーザ定義クラスでは、 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></tt>  は
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></tt> となるような非負の整数インデクス <em>i</em> が存在するとき、かつそのときにかぎり真となります。インデクス <em>i</em> が負である場合に <a class="reference internal" href="../library/exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><tt class="xref py py-exc docutils literal"><span class="pre">IndexError</span></tt></a> 例外が送出されることはありません。
(別の何らかの例外が送出された場合、例外は <a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> から送出されたかのようになります)。</p>
<p id="index-64">演算子 <a class="reference internal" href="#not-in"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt></a> は <a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a> の真値を反転した値として定義されています。</p>
<p id="index-65">演算子 <a class="reference internal" href="#is"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span></tt></a> および <a class="reference internal" href="#is-not"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></tt></a> は、オブジェクトのアイデンティティに対するテストを行います:
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></tt> は、 <em>x</em> と <em>y</em> が同じオブジェクトを指すとき、かつそのときに限り真になります。 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></tt> は <a class="reference internal" href="#is"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span></tt></a>
の真値を反転したものになります。 <a class="footnote-reference" href="#id27" id="id15">[7]</a></p>
</div>
<div class="section" id="boolean-operation">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2>ブール演算 (boolean operation)<a class="headerlink" href="#boolean-operation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-66">
<strong id="grammar-token-or_test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-and_test"><tt class="xref docutils literal"><span class="pre">and_test</span></tt></a> | <a class="reference internal" href="#grammar-token-or_test"><tt class="xref docutils literal"><span class="pre">or_test</span></tt></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-and_test"><tt class="xref docutils literal"><span class="pre">and_test</span></tt></a>
<strong id="grammar-token-and_test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-not_test"><tt class="xref docutils literal"><span class="pre">not_test</span></tt></a> | <a class="reference internal" href="#grammar-token-and_test"><tt class="xref docutils literal"><span class="pre">and_test</span></tt></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-not_test"><tt class="xref docutils literal"><span class="pre">not_test</span></tt></a>
<strong id="grammar-token-not_test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-comparison"><tt class="xref docutils literal"><span class="pre">comparison</span></tt></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-not_test"><tt class="xref docutils literal"><span class="pre">not_test</span></tt></a>
</pre>
<p>ブール演算のコンテキストや、式が制御フロー文中で使われる最には、以下の値: <tt class="docutils literal"><span class="pre">False</span></tt> 、 <tt class="docutils literal"><span class="pre">None</span></tt> 、すべての型における数値のゼロ、空の文字列とコンテナ (文字列、タプル、リスト、辞書、set、frozenset を含む) は偽 (false) であると解釈されます。それ以外の値は真 (true)
であると解釈されます。
(この振る舞いを変更する方法については特殊メソッド <a class="reference internal" href="datamodel.html#object.__nonzero__" title="object.__nonzero__"><tt class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></tt></a> を参照してください)</p>
<p id="index-67">演算子 <a class="reference internal" href="#not"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span></tt></a> は、引数が偽である場合には <tt class="docutils literal"><span class="pre">1</span></tt> を、それ以外の場合には <tt class="docutils literal"><span class="pre">0</span></tt> になります。</p>
<p id="index-68">式 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></tt> は、まず <em>x</em> を評価します; <em>x</em> が偽なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em>
の値を評価し、その結果を返します。</p>
<p id="index-69">式 <tt class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></tt> は、まず <em>x</em> を評価します;  <em>x</em> が真なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em>
の値を評価し、その結果を返します。</p>
<p>(<a class="reference internal" href="#and"><tt class="xref std std-keyword docutils literal"><span class="pre">and</span></tt></a> も <a class="reference internal" href="#not"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span></tt></a> も、返す値を <tt class="docutils literal"><span class="pre">0</span></tt> や <tt class="docutils literal"><span class="pre">1</span></tt> に制限するのではなく、最後に評価した引数の値を返すので注意してください。この仕様は、例えば <tt class="docutils literal"><span class="pre">s</span></tt> を文字列として <tt class="docutils literal"><span class="pre">s</span></tt> が空文字列の場合にデフォルトの値に置き換えるような場合に、 <tt class="docutils literal"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></tt>  と書くと期待通りの値になるために便利なことがあります。
<a class="reference internal" href="#not"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span></tt></a> は、式の値でなく独自に値を作成して返すので、引数と同じ型の値を返すような処理に煩わされることはありません。例えば、 <tt class="docutils literal"><span class="pre">not</span>
<span class="pre">'foo'</span></tt> は、 <tt class="docutils literal"><span class="pre">''</span></tt> ではなく <tt class="docutils literal"><span class="pre">0</span></tt> になります)</p>
</div>
<div class="section" id="conditional-expressions">
<h2>条件演算 (Conditional Expressions)<a class="headerlink" href="#conditional-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p class="versionadded">
<span class="versionmodified">バージョン 2.5 で追加.</span></p>
<pre id="index-70">
<strong id="grammar-token-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><tt class="xref docutils literal"><span class="pre">or_test</span></tt></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-or_test"><tt class="xref docutils literal"><span class="pre">or_test</span></tt></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>]
<strong id="grammar-token-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-conditional_expression"><tt class="xref docutils literal"><span class="pre">conditional_expression</span></tt></a> | <a class="reference internal" href="#grammar-token-lambda_form"><tt class="xref docutils literal"><span class="pre">lambda_form</span></tt></a>
</pre>
<p>条件演算式 (しばしば、&#8221;三項演算子&#8221; と呼ばれます) は最も優先度が低いPython の操作です。</p>
<p><tt class="docutils literal"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></tt> という式は最初に条件 <em>C</em> (<em>x</em> では <em>ありません</em>) を評価します;
<em>C</em> が true の場合 <em>x</em> が評価され値が返されます; それ以外の場合には <em>y</em> が評価され返されます。</p>
<p>条件演算に関してより詳しくは <span class="target" id="index-71"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> を参照してください。</p>
</div>
<div class="section" id="lambda">
<span id="id16"></span><h2>ラムダ (lambda)<a class="headerlink" href="#lambda" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-72">
<strong id="grammar-token-lambda_form">lambda_form    </strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><tt class="xref docutils literal"><span class="pre">parameter_list</span></tt></a>]: <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>
<strong id="grammar-token-old_lambda_form">old_lambda_form</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><tt class="xref docutils literal"><span class="pre">parameter_list</span></tt></a>]: <a class="reference internal" href="#grammar-token-old_expression"><tt class="xref docutils literal"><span class="pre">old_expression</span></tt></a>
</pre>
<p>ラムダ形式 (lambda form, ラムダ式 (lambda expression)) は、構文法的には式と同じ位置付けになります。ラムダは、無名関数を作成できる省略記法です; 式 <tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">arguments:</span> <span class="pre">expression</span></tt>
は、関数オブジェクトになります。ラムダが表す無名オブジェクトは、以下のコード</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">arguments</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expression</span>
</pre></div>
</div>
<p>で定義された関数と同様に動作します。</p>
<p>引数リストの構文法については <a class="reference internal" href="compound_stmts.html#function"><em>関数定義</em></a> 節を参照してください。ラムダ形式で作成された関数は、実行文 (statement)
を含むことができないので注意してください。</p>
</div>
<div class="section" id="exprlists">
<span id="id17"></span><h2>式のリスト<a class="headerlink" href="#exprlists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-73">
<strong id="grammar-token-expression_list">expression_list</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> )* [&quot;,&quot;]
</pre>
<p id="index-74">少なくとも一つのカンマを含む式のリストは、タプルになります。タプルの長さは、リスト中の式の数に等しくなります。リスト中の式は左から右へと順に評価されます。</p>
<p id="index-75">単一要素のタプル (別名 <em>単集合 (singleton)</em> ) を作りたければ、末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: <tt class="docutils literal"><span class="pre">()</span></tt> を使います。)</p>
</div>
<div class="section" id="evalorder">
<span id="id18"></span><h2>評価順序<a class="headerlink" href="#evalorder" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-76">Python は、式を左から右へと順に評価してゆきます。ただし、代入式を評価する最には、代入演算子の右側項が左側項よりも先に評価されるので注意してください。</p>
<p>以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<span id="id19"></span><h2>まとめ<a class="headerlink" href="#summary" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-77">以下の表は、Python における演算子を、優先順位  の最も低い (結合度が最も低い) ものから最も高い (結合度が最も高い) ものの順に並べたものです。同じボックス内に示された演算子は同じ優先順位を持ちます。演算子の文法が示されていないかぎり、演算子は全て二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます (値のテストを含む比較演算子を除きます。比較演算子は、左から右に連鎖します &#8212;
<a class="reference internal" href="#comparisons"><em>比較 (comparison)</em></a> を参照してください。また、べき乗演算子も除きます。べき乗演算子は右から左にグループ化されます)。</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算子</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#lambda"><tt class="xref std std-keyword docutils literal"><span class="pre">lambda</span></tt></a></td>
<td>ラムダ式</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a> &#8211; <a class="reference internal" href="compound_stmts.html#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a></td>
<td>条件演算</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#or"><tt class="xref std std-keyword docutils literal"><span class="pre">or</span></tt></a></td>
<td>ブール演算 OR</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#and"><tt class="xref std std-keyword docutils literal"><span class="pre">and</span></tt></a></td>
<td>ブール演算 AND</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#not"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span></tt></a> <em>x</em></td>
<td>ブール演算 NOT</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">==</span></tt>
<a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a>, <a class="reference internal" href="#not"><tt class="xref std std-keyword docutils literal"><span class="pre">not</span></tt></a> <a class="reference internal" href="#in"><tt class="xref std std-keyword docutils literal"><span class="pre">in</span></tt></a>,
<a class="reference internal" href="#is"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span></tt></a>, <a class="reference internal" href="#is-not"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></tt></a>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>,
<tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt>, <tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">==</span></tt></td>
<td>メンバシップテスト、アイデンティティテストを含めた比較</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">|</span></tt></td>
<td>ビット単位 OR</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">^</span></tt></td>
<td>ビット単位 XOR</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td>
<td>ビット単位 AND</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt></td>
<td>シフト演算</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt></td>
<td>加算および減算</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">//</span></tt>, <tt class="docutils literal"><span class="pre">%</span></tt></td>
<td>乗算、除算、剰余</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">+x</span></tt>, <tt class="docutils literal"><span class="pre">-x</span></tt>, <tt class="docutils literal"><span class="pre">~x</span></tt></td>
<td>正符号、負符号、ビット単位 NOT</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">**</span></tt></td>
<td>べき乗 <a class="footnote-reference" href="#id28" id="id20">[8]</a></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x[index]</span></tt>, <tt class="docutils literal"><span class="pre">x[index:index]</span></tt>,
<tt class="docutils literal"><span class="pre">x(arguments...)</span></tt>, <tt class="docutils literal"><span class="pre">x.attribute</span></tt></td>
<td>添字指定、スライス操作属性参照</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">(expressions...)</span></tt>,
<tt class="docutils literal"><span class="pre">[expressions...]</span></tt>,
<tt class="docutils literal"><span class="pre">{key:datum...}</span></tt>,
<tt class="docutils literal"><span class="pre">`expressions...`</span></tt></td>
<td>式結合またはタプル表現、リスト表現、辞書表現、文字列への型変換</td>
</tr>
</tbody>
</table>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Python 2.3 以降のリスト内包は <tt class="docutils literal"><span class="pre">for</span></tt> の中で使う制御変数を内包表記内のスコープに「リーク」します。しかし、この挙動は廃止予定です。Python 3.0 ではこの挙動に依存したコードは動作しなくなります。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[2]</a></td><td><tt class="docutils literal"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></tt> は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォームを仮定すると、 <tt class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">%</span>
<span class="pre">1e100</span></tt> は <tt class="docutils literal"><span class="pre">1e100</span></tt> と同じ符号になるはずなのに、計算結果は <tt class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></tt> となります。これは数値計算的には厳密に <tt class="docutils literal"><span class="pre">1e100</span></tt> と等価です。関数 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><tt class="xref py py-func docutils literal"><span class="pre">math.fmod()</span></tt></a> は、最初の引数と符号が一致するような値を返すので、上記の場合には <tt class="docutils literal"><span class="pre">-1e-100</span></tt> を返します。どちらのアプローチが適切かは、アプリケーションに依存します。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[3]</a></td><td>x が y の整数倍に非常に近い場合、丸め誤差によって <tt class="docutils literal"><span class="pre">floor(x/y)</span></tt> は <tt class="docutils literal"><span class="pre">(x-x%y)/y</span></tt> よりも大きな値になる可能性があります。そのような場合、 Python は <tt class="docutils literal"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></tt> が <tt class="docutils literal"><span class="pre">x</span></tt>
に非常に近くなるという関係を保つために、後者の値を返します。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[4]</a></td><td>ユニコード文字列間の比較はバイトレベルでは当然とはいえ、ユーザにとっては直感的ではないかもしれません。例えば、文字列 <tt class="docutils literal"><span class="pre">u&quot;\u00C7&quot;</span></tt> と <tt class="docutils literal"><span class="pre">u&quot;\u0043\u0327&quot;</span></tt> の比較は、両方の文字列が同じユニコード文字(LATIN CAPITAL LETTER C WITH CEDILLA)で表されたとしても違います。人間が分かり易い方法で文字列を比較するために <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><tt class="xref py py-func docutils literal"><span class="pre">unicodedata.normalize()</span></tt></a> を使用して比較してください。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[5]</a></td><td>実装では、この演算をリストを構築したりソートしたりすることなく効率的に行います。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[6]</a></td><td>Python の初期のバージョンでは、ソートされた (key, value) のリストに対して辞書的な比較を行っていましたが、これは等価性の計算のようなよくある操作を実現するには非常にコストの高い操作でした。もっと以前のバージョンの Python では、辞書はアイデンティティだけで比較されていました。しかしこの仕様は、 <tt class="docutils literal"><span class="pre">{}</span></tt> との比較によって辞書が空であるか確かめられると期待していた人々を混乱させていました。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[7]</a></td><td>自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに <a class="reference internal" href="#is"><tt class="xref std std-keyword docutils literal"><span class="pre">is</span></tt></a> 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[8]</a></td><td><tt class="docutils literal"><span class="pre">%</span></tt> 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td>べき乗演算子 <tt class="docutils literal"><span class="pre">**</span></tt> はその右側にある単項演算子かビット単位演算子よりも優先して束縛されます。つまり <tt class="docutils literal"><span class="pre">2**-1</span></tt> は <tt class="docutils literal"><span class="pre">0.5</span></tt> になります。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="単純文 (simple statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="実行モデル"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python 言語リファレンス</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>