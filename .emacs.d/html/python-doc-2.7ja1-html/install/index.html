

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Python モジュールのインストール &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="next" title="このドキュメントについて" href="jptranslation.html" />
    <link rel="prev" title="このドキュメントについて" href="../distutils/jptranslation.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="jptranslation.html" title="このドキュメントについて"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="../distutils/jptranslation.html" title="このドキュメントについて"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python モジュールのインストール</a><ul>
<li><a class="reference internal" href="#inst-intro">はじめに</a><ul>
<li><a class="reference internal" href="#inst-trivial-install">もっとも簡単な場合: ありふれたインストール作業</a></li>
<li><a class="reference internal" href="#distutils">新しい標準: Distutils</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inst-standard-install">標準的なビルド・インストール作業</a><ul>
<li><a class="reference internal" href="#inst-platform-variations">プラットフォームによる違い</a></li>
<li><a class="reference internal" href="#inst-splitting-up">ビルド作業とインストール作業を分割する</a></li>
<li><a class="reference internal" href="#inst-how-build-works">ビルドの仕組み</a></li>
<li><a class="reference internal" href="#inst-how-install-works">インストールの仕組み</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inst-alt-install">別の場所へのインストール</a><ul>
<li><a class="reference internal" href="#home">別の場所へのインストール: home スキーム</a></li>
<li><a class="reference internal" href="#unix-prefix">別の場所へのインストール: Unix (prefix スキーム)</a></li>
<li><a class="reference internal" href="#prefix-windows">別の場所へのインストール (prefix を使う方法): Windows</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inst-custom-install">カスタムのインストール</a><ul>
<li><a class="reference internal" href="#inst-search-path">Python サーチパスの変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inst-config-files">Distutils 設定ファイル</a><ul>
<li><a class="reference internal" href="#inst-config-filenames">設定ファイルの場所と名前</a></li>
<li><a class="reference internal" href="#inst-config-syntax">設定ファイルの構文</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inst-building-ext">拡張モジュールのビルド: 小技と豆知識</a><ul>
<li><a class="reference internal" href="#inst-tweak-flags">コンパイラ/リンカのフラグをいじるには</a></li>
<li><a class="reference internal" href="#windows-microsoft">Windows で非 Microsoft コンパイラを使ってビルドするには</a><ul>
<li><a class="reference internal" href="#borland-codegear-c">Borland/CodeGear C++</a></li>
<li><a class="reference internal" href="#gnu-c-cygwin-mingw">GNU C / Cygwin / MinGW</a><ul>
<li><a class="reference internal" href="#python-mingw">古いバージョンの Python と MinGW</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id22">日本語訳について</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="../distutils/jptranslation.html"
                        title="前の章へ">このドキュメントについて</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="jptranslation.html"
                        title="次の章へ">このドキュメントについて</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/install/index.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="python">
<span id="install-index"></span><h1>Python モジュールのインストール<a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Greg Ward &#8212;  日本語訳: Python ドキュメント翻訳プロジェクト</td>
</tr>
<tr class="field-even field"><th class="field-name">Release:</th><td class="field-body">2.7</td>
</tr>
<tr class="field-odd field"><th class="field-name">Date:</th><td class="field-body">2011年 12月 26日</td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">Abstract</p>
<p>このドキュメントでは、 Python モジュール配布ユーティリティ (Python Distribution Utilities, &#8220;Distutils&#8221;)
について、  エンドユーザの視点に立ち、サードパーティ製のモジュールや拡張モジュールの構築やインストールによって標準の Python に機能を追加する方法について述べます。</p>
</div>
<div class="section" id="inst-intro">
<span id="id1"></span><h2>はじめに<a class="headerlink" href="#inst-intro" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の広範な標準ライブラリは、プログラミングにおける多くの要求をカバーしていますが、時には何らかの新たな機能をサードパーティ製モジュールの形で追加する必要に迫られます。自分がプログラムを書くときのサポートとして必要な場合もあるし、自分が使いたいアプリケーションがたまたま
Python で書かれていて、そのサポートとして必要な場合もあるでしょう。</p>
<p>以前は、すでにインストール済みの Python に対して、サードパーティ製モジュールを追加するためのサポートはほとんどありませんでした。しかしPython
配布ユーティリティ (Python Distribution Utilities,  略して Distutils) が Python 2.0
から取り入れられ、状況は変わりました。</p>
<p>このドキュメントが主要な対象としているのは、サードパーティモジュールをインストールする必要がある人たち: 単に何らかの Python アプリケーションを稼動させたいだけのエンドユーザやシステム管理者、そしてすでに Python プログラマであって、新たな道具を自分のツールキットに加えたいと思っている人たちです。このドキュメントを読むために、 Python について知っておく必要はありません; インストールしたモジュールを調べるために
Python の対話モードにちょっとだけ手を出す必要がありますが、それだけです。自作の Python モジュールを他人が使えるようにするために配布する方法を探しているのなら、 <a class="reference internal" href="../distutils/index.html#distutils-index"><em>Python モジュールの配布</em></a>
マニュアルを参照してください。</p>
<div class="section" id="inst-trivial-install">
<span id="id2"></span><h3>もっとも簡単な場合: ありふれたインストール作業<a class="headerlink" href="#inst-trivial-install" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最も楽なのは、インストールしたいモジュール配布物の特殊なバージョンをインストールしたいプラットフォーム向けに誰かがすでに用意してくれていて、他のアプリケーションと同じようにインストールするだけであるような場合です。例えば Windows ユーザ向けには実行可能形式のインストーラ、 RPM ベースの
Linux システム (Red Hat, SuSE, Mandrake その他多数)  向けには RPM パッケージ、 Debian ベースの Linux
システム向けには  Debian パッケージといった具合に、モジュール開発者はビルド済み配布物を作成しているかもしれません。</p>
<p>このような場合、自分のプラットフォームに合ったインストーラをダウンロードして、実行可能形式なら実行し、RPM なら <tt class="docutils literal"><span class="pre">rpm</span> <span class="pre">--install</span></tt>
するといった、分かりきった作業をするだけです。 Python を起動したり、 setup スクリプトを実行する必要はなく、何もコンパイルする必要はありません
&#8212; 説明書きを読む必要すら全くないかもしれません (とはいえ、説明書きを読むのはよいことですが)。</p>
<p>もちろん、いつもこう簡単とは限りません。自分のプラットフォーム向けのお手軽なインストーラがないモジュール配布物に興味を持つこともあるでしょう。そんな場合には、モジュールの作者やメンテナがリリースしているソース配布物から作業をはじめねばなりません。ソース配布物からのインストールは、モジュールが標準的な方法でパッケージ化されている限りさほど大変ではありません。このドキュメントの大部分は、標準的なソース配布物からのビルドとインストールに関するものです。</p>
</div>
<div class="section" id="distutils">
<span id="inst-new-standard"></span><h3>新しい標準: Distutils<a class="headerlink" href="#distutils" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールのソースコード配布物をダウンロードしたら、配布物が標準のやり方、すなわち Distutils のやり方に従ってパッケージされて配布されているかどうかすぐに分かります。Distutils の場合、まず配布物の名前とバージョン番号が、例えば <tt class="file docutils literal"><span class="pre">foo-1.0.tar.gz</span></tt>
や <tt class="file docutils literal"><span class="pre">widget-0.9.7.zip</span></tt> のように、ダウンロードされたアーカイブファイルの名前にはっきりと反映されます。次に、アーカイブは同様の名前のディレクトリ、例えば <tt class="file docutils literal"><span class="pre">foo-1.0</span></tt> や <tt class="file docutils literal"><span class="pre">widget-0.9.7</span></tt>
に展開されます。さらに、配布物には setup スクリプト <tt class="file docutils literal"><span class="pre">setup.py</span></tt> が入っています。また、 <tt class="file docutils literal"><span class="pre">README.txt</span></tt>
場合によっては <tt class="file docutils literal"><span class="pre">README</span></tt> という名前のファイルも入っていて、そこには、モジュール配布物の構築とインストールは簡単で、</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install
</pre></div>
</div>
<p>とするだけだ、という説明が書かれているはずです。</p>
<p>上記の全てが当てはまるなら、ダウンロードしたものをビルドしてインストールする方法はすでに知っていることになります: 上記のコマンドを実行するだけです。非標準の方法でインストールを行ったり、ビルドプロセスをカスタマイズ行いたいのでない限り、このマニュアルは必要ありません。別の言葉で言えば、上のコマンドこそが、このマニュアルから習得すべき全てということになります。</p>
</div>
</div>
<div class="section" id="inst-standard-install">
<span id="id3"></span><h2>標準的なビルド・インストール作業<a class="headerlink" href="#inst-standard-install" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#inst-new-standard"><em>新しい標準: Distutils</em></a> 節で述べたよいうに、 Distutils を使ったモジュール配布物のビルドとインストールは、通常は単純なコマンド:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install
</pre></div>
</div>
<p>で行います。</p>
<p>Unixでは、このコマンドをシェルプロンプトで行います; Windows では、コマンドプロンプトウィンドウ (&#8220;DOS ボックス&#8221;) を開いて、そこで行います; Mac OS X の場合、 <strong class="command">Terminal</strong> ウィンドウを開いてシェルプロンプトを出してください。</p>
<div class="section" id="inst-platform-variations">
<span id="id4"></span><h3>プラットフォームによる違い<a class="headerlink" href="#inst-platform-variations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>setup コマンドは常に配布物ルートディレクトリ、すなわちモジュールのソース配布物を展開した際のトップレベルのサブディレクトリ内で実行しなければなりません。例えば、あるモジュールのソース配布物 <tt class="file docutils literal"><span class="pre">foo-1.0.tar.gz</span></tt> を Unix システム上にダウンロードしたなら、通常は以下の操作を行います:</p>
<div class="highlight-none"><div class="highlight"><pre>gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
cd foo-1.0
python setup.py install
</pre></div>
</div>
<p>Windows では、おそらく <tt class="file docutils literal"><span class="pre">foo-1.0.zip</span></tt> をダウンロードしているでしょう。アーカイブファイルを <tt class="file docutils literal"><span class="pre">C:\Temp</span></tt>
にダウンロードしたのなら、(WinZip のような) グラフィカルユーザインタフェースつきのアーカイブ操作ソフトや、 (<strong class="program">unzip</strong> や
<strong class="program">pkunzip</strong> のような) コマンドラインツールを使ってアーカイブを展開します。次に、コマンドプロンプトウィンドウ (&#8220;DOS
ボックス&#8221;) を開いて、以下を実行します:</p>
<div class="highlight-none"><div class="highlight"><pre>cd c:\Temp\foo-1.0
python setup.py install
</pre></div>
</div>
</div>
<div class="section" id="inst-splitting-up">
<span id="id5"></span><h3>ビルド作業とインストール作業を分割する<a class="headerlink" href="#inst-splitting-up" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></tt> を実行すると、一度の実行で全てのモジュールをビルドしてインストールします。段階的に作業をしたい場合 &#8212; ビルドプロセスをカスタマイズしたり、作業がうまくいかない場合に特に便利です &#8212; には、setup スクリプトに一度に一つづつ作業を行わせるようにできます。この機能は、ビルドとインストールを異なるユーザで行う場合にも便利です &#8212; 例えば、モジュール配布物をビルドしておいてシステム管理者に渡して
(または、自分でスーパユーザになって) 、インストールしたくなるかもしれません.</p>
<p>最初のステップでは全てをビルドしておき、次のステップで全てをインストールするには、 setup スクリプトを二度起動します:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build
python setup.py install
</pre></div>
</div>
<p>この作業を行ってみれば、 <strong class="command">install</strong> コマンドを実行するとまず <strong class="command">build</strong> コマンドを実行し、さらに  &#8212;
この場合には &#8212;  <tt class="file docutils literal"><span class="pre">build</span></tt> ディレクトリの中が全て最新の状態になっているので、 <strong class="command">build</strong>
は何も行わなくてよいと判断していることがわかるでしょう。</p>
<p>インターネットからダウンロードしたモジュールをインストールしたいだけなら、上のように作業を分割する機能は必要ないかもしれませんが、この機能はより進んだ使い方をする際にはとても便利です。自作の Python モジュールや拡張モジュールを配布することになれば、個々の Distutils
コマンドを自分で何度も実行することになるでしょう。</p>
</div>
<div class="section" id="inst-how-build-works">
<span id="id6"></span><h3>ビルドの仕組み<a class="headerlink" href="#inst-how-build-works" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上で示唆したように、 <strong class="command">build</strong> コマンドは、インストールすべきファイルを <em>ビルドディレクトリ (build directory)</em>
に置く働きがあります。デフォルトでは、ビルドディレクトリは配布物ルート下の  <tt class="file docutils literal"><span class="pre">build</span></tt> になります;
システムの処理速度に強いこだわりがあったり、ソースツリーに指一本触れたくないのなら、 <em class="xref std std-option">--build-base</em>
オプションを使ってビルドディレクトリを変更できます。例えば:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --build-base=/tmp/pybuild/foo-1.0
</pre></div>
</div>
<p>(あるいは、システム全体向け、あるいは個人用の Distutils 設定ファイルにディレクティブを書いて、永続的に設定を変えられます;
<a class="reference internal" href="#inst-config-files"><em>Distutils 設定ファイル</em></a> 節を参照してください。)  通常は必要ない作業です。</p>
<p>ビルドツリーのデフォルトのレイアウトは以下のようになっています:</p>
<div class="highlight-none"><div class="highlight"><pre>--- build/ --- lib/
または
--- build/ --- lib.&lt;plat&gt;/
               temp.&lt;plat&gt;/
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">&lt;plat&gt;</span></tt> は、現在の OS/ハードウェアプラットフォームと Python のバージョンを記述する短い文字列に展開されます。第一の
<tt class="file docutils literal"><span class="pre">lib</span></tt> ディレクトリだけの形式は、 &#8220;pure モジュール配布物&#8221; &#8212; すなわち、pure Python
モジュールだけの入ったモジュール配布物 &#8212; の場合に使われます。モジュール配布物に何らかの拡張モジュール (C/C++ で書かれたモジュール)
が入っている場合、第二の <tt class="docutils literal"><span class="pre">&lt;plat&gt;</span></tt> 付きディレクトリが二つある形式が使われます。この場合、  <tt class="file docutils literal"><span class="pre">temp.</span><em><span class="pre">plat</span></em></tt>
ディレクトリには、コンパイル/リンク過程で生成され、実際にはインストールされない一時ファイルが収められます。どちらの場合にも、 <tt class="file docutils literal"><span class="pre">lib</span></tt>
(または <tt class="file docutils literal"><span class="pre">lib.</span><em><span class="pre">plat</span></em></tt>)  ディレクトリには、最終的にインストールされることになる全ての Python  モジュール (pure
Python モジュールおよび拡張モジュール) が入ります。</p>
<p>今後、 Python スクリプト、ドキュメント、バイナリ実行可能形式、その他 Python モジュールやアプリケーションのインストール作業に必要なディレクトリが追加されるかもしれません。</p>
</div>
<div class="section" id="inst-how-install-works">
<span id="id7"></span><h3>インストールの仕組み<a class="headerlink" href="#inst-how-install-works" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong class="command">build</strong> コマンドを実行した後 (明示的に実行した場合も、 <strong class="command">install</strong>
コマンドが代わりに実行してくれた場合も) は、 <strong class="command">install</strong> コマンドの仕事は比較的単純なもの: <tt class="file docutils literal"><span class="pre">build/lib</span></tt>
(または <tt class="file docutils literal"><span class="pre">build/lib.</span><em><span class="pre">plat</span></em></tt>) の下にあるもの全ての指定したインストールディレクトリへのコピー、になります。</p>
<p>インストールディレクトリを選ばなかった場合 &#8212; すなわち、 <tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></tt> を実行しただけの場合 &#8212;
には、 <strong class="command">install</strong> コマンドはサードパーティ製 Python モジュールを置くための標準の場所にインストールを行います。この場所は、プラットフォームや、Python 自体をどのようにビルド/インストールしたかで変わります。 Unix (と、Unix
をベースとしたMac OS X) では、インストールしようとするモジュール配布物が pure Python なのか、拡張モジュールを含む (&#8220;非 pure&#8221;)
のかによっても異なります:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="42%" />
<col width="38%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">プラットフォーム</th>
<th class="head">標準のインストール場所</th>
<th class="head">デフォルト値</th>
<th class="head">注記</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Unix (pure)</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td><tt class="file docutils literal"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td>Unix (non-pure)</td>
<td><tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td><tt class="file docutils literal"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td>Windows</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></tt></td>
<td><tt class="file docutils literal"><span class="pre">C:\Python</span><em><span class="pre">XY</span></em><span class="pre">\Lib\site-packages</span></tt></td>
<td>(2)</td>
</tr>
</tbody>
</table>
<p>注記:</p>
<ol class="arabic simple">
<li>ほとんどの Linux ディストリビューションには、システムの標準インストール物として Python が入っているので、 Linux では普通、
<tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> や <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> はどちらも <tt class="file docutils literal"><span class="pre">/usr</span></tt>  になります。 Linux (または
Unixライクなシステム) 上で自分で Python  をビルドした場合、デフォルトの <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> および
<tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> は <tt class="file docutils literal"><span class="pre">/usr/local</span></tt> になります。</li>
<li>Windows での Python のデフォルトインストールディレクトリは、 Python 1.6a1、 1.5.2、およびそれ以前のバージョンでは
<tt class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></tt> です。</li>
</ol>
<p><tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> および <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> は、 Python がインストールされているディレクトリと、実行時にライブラリを探しにいく場所を表します。これらのディレクトリは、Windows では常に同じで、 Unixと Mac OS X
でもほぼ常に同じです。自分の Python がどんな <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> や <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt>
を使っているかは、Python を対話モードで起動して、単純なコマンドをいくつか入力すればわかります。 Windows
では、 <em class="menuselection">スタート ‣ (すべての) プログラム ‣  Python X.Y ‣ Python
(command line)</em> を選びます。 Mac OS 9 では、 <tt class="file docutils literal"><span class="pre">PythonInterpreter</span></tt> を起動します。インタプリタを起動すると、プロンプトに Python コードを入力できます。例えば、作者の使っている Linux システムで、三つの Python
文を以下のように入力すると、出力から作者のシステムの <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> と <tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em></tt> を得られます:</p>
<div class="highlight-none"><div class="highlight"><pre>Python 2.4 (#26, Aug  7 2004, 17:19:02)
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.prefix
&#39;/usr&#39;
&gt;&gt;&gt; sys.exec_prefix
&#39;/usr&#39;
</pre></div>
</div>
<p>モジュールを標準の場所にインストールしたくない場合や、標準の場所にインストールするためのファイル権限を持っていない場合、
<a class="reference internal" href="#inst-alt-install"><em>別の場所へのインストール</em></a> 節にある、別の場所へのインストール方法の説明を読んでください。インストール先のディレクトリを大幅にカスタマイズしければ、
<a class="reference internal" href="#inst-custom-install"><em>カスタムのインストール</em></a> 節のカスタムインストールに関する説明を読んでください。</p>
</div>
</div>
<div class="section" id="inst-alt-install">
<span id="id8"></span><h2>別の場所へのインストール<a class="headerlink" href="#inst-alt-install" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>しばしば、サードパーティ製 Python モジュールをインストールするための標準の場所以外にモジュールをインストールしなければならなかったり、単にそうしたくなるときがあります。例えばUnix システムでは、標準のサードパーティ製モジュールディレクトリに対する書き込み権限を持っていないかもしれません。または、あるモジュールを、ローカルで使っている Python に標準のモジュールの一部として組み込む前にテストしてみたいと思うかもしれません。既存の配布物をアップグレードする際には特にそうでしょう: 実際にアップグレードする前に、既存のスクリプトの基本となる部分が新たなバージョンでも動作するか確認したいはずです。</p>
<p>Distutils の <strong class="command">install</strong> コマンドは、別の場所へ配布物をインストールする作業を単純で苦労のない作業にするように設計されています。基本的なアイデアは、インストール先のベースディレクトリを指定しておき、
<strong class="command">install</strong> コマンドがそのベースディレクトリ下にファイル群をインストールするための一連のディレクトリ (<em>インストールスキーム :
installation scheme</em>) を作成するというものです。詳細はプラットフォームによって異なるので、以下の節から自分のプラットフォームに当てはまるものを読んでください。</p>
<div class="section" id="home">
<span id="inst-alt-install-prefix"></span><h3>別の場所へのインストール: home スキーム<a class="headerlink" href="#home" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>&#8220;home スキーム&#8221; の背後にある考え方は、Python モジュールを個人用のモジュール置き場でビルドし、維持するというものです。このスキームの名前は
Unixの「ホーム」ディレクトリの概念からとりました。というのも、 Unixのユーザにとって、自分のホームディレクトリを <tt class="file docutils literal"><span class="pre">/usr/</span></tt> や
<tt class="file docutils literal"><span class="pre">/usr/local/</span></tt> のようにレイアウトするのはよくあることだからです。とはいえ、このスキームはどのオペレーティングシステムのユーザでも使えます。新たなモジュールのインストールは単純で、</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=&lt;dir&gt;
</pre></div>
</div>
<p>のようにします。このとき、 <em class="xref std std-option">--home</em> オプションを使ってディレクトリを指定します。面倒臭がりの人は、単にチルダ (<tt class="docutils literal"><span class="pre">~</span></tt>)
をタイプするだけでかまいません;  <strong class="command">install</strong> コマンドがチルダをホームディレクトリに展開してくれます。</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~
</pre></div>
</div>
<p><em class="xref std std-option">--home</em> オプションは、インストールのベースディレクトリを指定します。ファイルはインストールベース下の以下のディレクトリに保存されます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="31%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type of file</th>
<th class="head">Installation Directory</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pure module distribution</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/lib/python</span></tt></td>
<td><em class="xref std std-option">--install-purelib</em></td>
</tr>
<tr class="row-odd"><td>non-pure module distribution</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/lib/python</span></tt></td>
<td><em class="xref std std-option">--install-platlib</em></td>
</tr>
<tr class="row-even"><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/bin</span></tt></td>
<td><em class="xref std std-option">--install-scripts</em></td>
</tr>
<tr class="row-odd"><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/share</span></tt></td>
<td><em class="xref std std-option">--install-data</em></td>
</tr>
</tbody>
</table>
<p class="versionchanged">
<span class="versionmodified">バージョン 2.4 で変更: </span><em class="xref std std-option">--home</em> は Unixでしかサポートされていませんでした。</p>
</div>
<div class="section" id="unix-prefix">
<span id="inst-alt-install-home"></span><h3>別の場所へのインストール: Unix (prefix スキーム)<a class="headerlink" href="#unix-prefix" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>あるインストール済みの Python を使ってモジュールのビルド/インストールを (例えば setup スクリプトを実行して) 行いたいけれども、別のインストール済みの Python のサードパーティ製モジュール置き場 (あるいは、そう見えるようなディレクトリ構造) に、ビルドされたモジュールをインストールしたい場合には、&#8221;prefix スキーム&#8221; が便利です。そんな作業はまったくありえそうにない、と思うなら、確かにその通りです &#8212;
&#8220;home スキーム&#8221; を先に説明したのもそのためです。とはいえ、prefix スキームが有用なケースは少なくとも二つあります。</p>
<p>まず、多くの Linux ディストリビューションは、 Python を <tt class="file docutils literal"><span class="pre">/usr/local</span></tt> ではなく <tt class="file docutils literal"><span class="pre">/usr</span></tt>
に置いていることを考えてください。この場合は、 Python はローカルの計算機ごとのアドオン (add-on) ではなく、&#8221;システム&#8221;
の一部となっているので、 <tt class="file docutils literal"><span class="pre">/usr</span></tt> に置くのは全く正当なことです。しかしながら、 Python モジュールをソースコードからインストールしていると、モジュールを <tt class="file docutils literal"><span class="pre">/usr/lib/python2.</span><em><span class="pre">X</span></em></tt> ではなく
<tt class="file docutils literal"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></tt> に置きたいと思うかもしれません。これを行うには</p>
<div class="highlight-none"><div class="highlight"><pre>/usr/bin/python setup.py install --prefix=/usr/local
</pre></div>
</div>
<p>と指定します。</p>
<p>もう一つありえるのは、ネットワークファイルシステムにおいて、遠隔のディレクトリに対する読み出しと書き込みの際に違う名前を使う場合です。例えば、
<tt class="file docutils literal"><span class="pre">/usr/local/bin/python</span></tt> でアクセスするような Python  インタプリタは、
<tt class="file docutils literal"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></tt> からモジュールを探すでしょうが、モジュールは別の場所、例えば
<tt class="file docutils literal"><span class="pre">/mnt/</span><em><span class="pre">&#64;server</span></em><span class="pre">/export/lib/python2.</span><em><span class="pre">X</span></em></tt> にインストールしなければならないかもしれません。この場合には、</p>
<div class="highlight-none"><div class="highlight"><pre>/usr/local/bin/python setup.py install --prefix=/mnt/@server/export
</pre></div>
</div>
<p>のようにします。</p>
<p>どちらの場合も、 <em class="xref std std-option">--prefix</em> オプションでインストールベースディレクトリを決め、 <em class="xref std std-option">--exec-prefix</em> でプラットフォーム固有のファイル置き場名として使う、プラットフォーム固有インストールベースディレクトリを決めます。
(プラットフォーム固有のファイルとは、現状では単に非 pure モジュール配布物のことを意味しますが、 C ライブラリやバイナリ実行可能形式などに拡張されるかもしれません。) <em class="xref std std-option">--exec-prefix</em>  が指定されていなければ、デフォルトの <em class="xref std std-option">--prefix</em>
になります。ファイルは以下のようにインストールされます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="47%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type of file</th>
<th class="head">Installation Directory</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pure module distribution</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td><em class="xref std std-option">--install-purelib</em></td>
</tr>
<tr class="row-odd"><td>non-pure module distribution</td>
<td><tt class="file docutils literal"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></tt></td>
<td><em class="xref std std-option">--install-platlib</em></td>
</tr>
<tr class="row-even"><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/bin</span></tt></td>
<td><em class="xref std std-option">--install-scripts</em></td>
</tr>
<tr class="row-odd"><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/share</span></tt></td>
<td><em class="xref std std-option">--install-data</em></td>
</tr>
</tbody>
</table>
<p><em class="xref std std-option">--prefix</em> や <em class="xref std std-option">--exec-prefix</em> が実際に他のインストール済み Python
の場所を指している必要はありません; 上に挙げたディレクトリがまだ存在しなければ、インストール時に作成されます。</p>
<p>ちなみに、prefix スキームが重要な本当の理由は、単に標準の Unix  インストールが prefix スキームを使っているからです。ただし、そのときには、 <em class="xref std std-option">--prefix</em> や <em class="xref std std-option">--exec-prefix</em>  は Python 自体が
<tt class="docutils literal"><span class="pre">sys.prefix</span></tt> や <tt class="docutils literal"><span class="pre">sys.exec_prefix</span></tt> を使って決めます。というわけで、読者は prefix スキームを決して使うことはあるまいと思っているかもしれませんが、 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></tt>  をオプションを何もつけずに実行していれば、常に prefix
スキームを使っていることになるのです。</p>
<p>拡張モジュールを別のインストール済み Python にインストールしても、拡張モジュールのビルド方法による影響を受けることはありません:
特に、拡張モジュールをコンパイルする際には、 setup スクリプトを実行する際に使う Python インタプリタと一緒にインストールされている Python
ヘッダファイル (<tt class="file docutils literal"><span class="pre">Python.h</span></tt>  とその仲間たち) を使います。上で述べてきたやり方でインストールされた拡張モジュールを実行するインタプリタと、インタプリタをビルドする際に用いた別のインタプリタとの互換性を保証するのはユーザの責任です。</p>
<p>これを行うには、二つのインタプリタが同じバージョンの Python  (ビルドが違っていたり、同じビルドのコピーということもあり得ます) であるかどうかを確かめます。(もちろん、 <em class="xref std std-option">--prefix</em> や  <em class="xref std std-option">--exec-prefix</em> が別のインストール済み Python
の場所すら指していなければどうにもなりません。)</p>
</div>
<div class="section" id="prefix-windows">
<span id="inst-alt-install-windows"></span><h3>別の場所へのインストール (prefix を使う方法): Windows<a class="headerlink" href="#prefix-windows" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Windows はユーザのホームディレクトリという概念がなく、 Windows 環境下で標準的にインストールされた Python は Unixよりも単純な構成をしているので、 Windows で追加のパッケージを別の場所に入れる場合には、伝統的に <em class="xref std std-option">--prefix</em> が使われてきました。</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --prefix=&quot;\Temp\Python&quot;
</pre></div>
</div>
<p>とすると、モジュールを現在のドライブの <tt class="file docutils literal"><span class="pre">\Temp\Python</span></tt> ディレクトリにインストールします</p>
<p>インストールベースディレクトリは、 <em class="xref std std-option">--prefix</em> オプションだけで決まります; <em class="xref std std-option">--exec-prefix</em>
オプションは、Windows ではサポートされていません。ファイルは以下のような構成でインストールされます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="31%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type of file</th>
<th class="head">Installation Directory</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pure module distribution</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt></td>
<td><em class="xref std std-option">--install-purelib</em></td>
</tr>
<tr class="row-odd"><td>non-pure module distribution</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt></td>
<td><em class="xref std std-option">--install-platlib</em></td>
</tr>
<tr class="row-even"><td>scripts</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Scripts</span></tt></td>
<td><em class="xref std std-option">--install-scripts</em></td>
</tr>
<tr class="row-odd"><td>data</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Data</span></tt></td>
<td><em class="xref std std-option">--install-data</em></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="inst-custom-install">
<span id="id9"></span><h2>カスタムのインストール<a class="headerlink" href="#inst-custom-install" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>たまに、 <a class="reference internal" href="#inst-alt-install"><em>別の場所へのインストール</em></a> 節で述べたような別の場所へのインストールスキームが、自分のやりたいインストール方法と違うことがあります。もしかすると、同じベースディレクトリ下にあるディレクトリのうち、一つか二つだけをいじりたかったり、インストールスキームを完全に再定義したいと思うかもしれません。どちらの場合にせよ、こうした操作では <em>カスタムのインストールスキーム</em> を作成することになります。</p>
<p>別の場所へのインストールスキームに関するこれまでの説明で、 &#8220;オーバライドするためのオプション&#8221; というコラムにお気づきかもしれません。このオプションは、カスタムのインストールスキームを定義するための手段です。各オーバライドオプションには、相対パスを指定しても、絶対パスを指定しても、インストールベースディレクトリのいずれかを明示的に指定してもかまいません。
(インストールベースディレクトリは二種類あり、それら二つは通常は同じディレクトリです &#8212; Unix の &#8220;prefix スキーム&#8221; を使っていて、
<em class="xref std std-option">--prefix</em> と <em class="xref std std-option">--exec-prefix</em> オプションを使っているときだけ異なります。)</p>
<p>例えば、 Unix環境でモジュール配布物をホームディレクトリにインストールしたい &#8212; とはいえ、スクリプトは <tt class="file docutils literal"><span class="pre">~/bin</span></tt> ではなく
<tt class="file docutils literal"><span class="pre">~/scripts</span></tt> に置きたい &#8212; とします。ご想像の通り、スクリプトを置くディレクトリは、
<em class="xref std std-option">--install-scripts</em> オプションで上書きできます; この場合は相対パスで指定もでき、インストールベースディレクトリ
(この場合にはホームディレクトリ) からの相対パスとして解釈されます:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~ --install-scripts=scripts
</pre></div>
</div>
<p>Unix 環境での例をもう一つ紹介します: インストール済みの Python が、 <tt class="file docutils literal"><span class="pre">/usr/local/python</span></tt> を prefix
にしてビルドされ、インストールされていて、標準のインストールスクリプトは <tt class="file docutils literal"><span class="pre">/usr/local/python/bin</span></tt>
に入るようになっているとします。 <tt class="file docutils literal"><span class="pre">/usr/local/bin</span></tt> に入るようにしたければ、絶対パスを
<em class="xref std std-option">--install-scripts</em> オプションに与えて上書きすることになるでしょう:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --install-scripts=/usr/local/bin
</pre></div>
</div>
<p>(この操作を行うと、 &#8220;prefix スキーム&#8221; を使ったインストールになり、 prefix は Python インタプリタがインストールされている場所
&#8212; この場合には <tt class="file docutils literal"><span class="pre">/usr/local/python</span></tt> になります。)</p>
<p>Windows 用の Python を管理しているのなら、サードパーティ製モジュールを <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> そのものの下ではなく、
<tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> の下にあるサブディレクトリに置きたいと考えるかもしれません。この作業は、インストールディレクトリのカスタマイズとほぼ同じくらい簡単です &#8212; 覚えておかねばならないのは、モジュールには二つのタイプ、 pure
モジュールと非 pure モジュール (非 pure モジュール配布物内のモジュール) があるということです。例えば以下のようにします:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --install-purelib=Site --install-platlib=Site
</pre></div>
</div>
<p>指定したインストール先ディレクトリは、 <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> からの相対です。もちろん、 <tt class="file docutils literal"><em><span class="pre">prefix</span></em></tt> を
<tt class="file docutils literal"><span class="pre">.pth</span></tt> ファイルに入れるなどして、これらのディレクトリが Python のモジュール検索パス内に入るようにしなければなりません。
Python のモジュール検索パスを修正する方法は、  <a class="reference internal" href="#inst-search-path"><em>Python サーチパスの変更</em></a> 節を参照してください。</p>
<p>インストールスキーム全体を定義したいのなら、全てのインストールディレクトリオプションを指定しなければなりません。この作業には、相対パスを使った指定を勧めます; 例えば、全ての Python モジュール関連ファイルをホームディレクトリ下の <tt class="file docutils literal"><span class="pre">python</span></tt> ディレクトリの下に置き、そのホームディレクトリをマウントしている各プラットフォームごとに別のディレクトリを置きたければ、以下のようにインストールスキームを定義します:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~ \
                        --install-purelib=python/lib \
                        --install-platlib=python/lib.$PLAT \
                        --install-scripts=python/scripts
                        --install-data=python/data
</pre></div>
</div>
<p>また、以下のようにも指定できます:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --home=~/python \
                        --install-purelib=lib \
                        --install-platlib=&#39;lib.$PLAT&#39; \
                        --install-scripts=scripts
                        --install-data=data
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">$PLAT</span></tt> は、(必ずしも) 環境変数ではありません &#8212;  この表記は、 Distutils がコマンドラインオプションの解釈と同じやり方で展開します。設定ファイルを解釈する際と同じです。</p>
<p>言うまでもないことですが、毎回新たなモジュール配布物をインストールする度にインストールスキーム全体の指定を行っていては面倒です。そこで、オプションは
Distutils 設定ファイル (<a class="reference internal" href="#inst-config-files"><em>Distutils 設定ファイル</em></a> 参照) にも指定できます:</p>
<div class="highlight-none"><div class="highlight"><pre>[install]
install-base=$HOME
install-purelib=python/lib
install-platlib=python/lib.$PLAT
install-scripts=python/scripts
install-data=python/data
</pre></div>
</div>
<p>あるいは、以下のようにも指定できます:</p>
<div class="highlight-none"><div class="highlight"><pre>[install]
install-base=$HOME/python
install-purelib=lib
install-platlib=lib.$PLAT
install-scripts=scripts
install-data=data
</pre></div>
</div>
<p>これら二つは、 setup スクリプトを異なるインストールベースディレクトリから実行した場合には同じには <em>ならない</em> ので注意してください。例えば、</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py install --install-base=/tmp
</pre></div>
</div>
<p>とすると、最初の書き方では pure モジュールが <tt class="file docutils literal"><em><span class="pre">/tmp/python/lib</span></em></tt>  に入り、二番目の書き方では
<tt class="file docutils literal"><em><span class="pre">/tmp/lib</span></em></tt> に入ります。(二番目のケースでは、インストールベースを <tt class="file docutils literal"><span class="pre">/tmp/python</span></tt> に指定しようと考えるでしょう。)</p>
<p>読者は、設定ファイル例で、入力値に <tt class="docutils literal"><span class="pre">$HOME</span></tt> や <tt class="docutils literal"><span class="pre">$PLAT</span></tt> を使っていることに気づいているかもしれませんね。これらは Distutils
の設定変数で、環境変数を彷彿とさせます。実際、この表記が使えるプラットフォーム上では、設定ファイル中に環境変数を入れられますが、 Distutils
は他にも、例えば <tt class="docutils literal"><span class="pre">$PLAT</span></tt> のようにおそらくユーザの環境中にないような変数をいくつか持っています。(そしてもちろん、 Mac OS 9
のような環境変数のないシステムでは、設定ファイル中で使える変数は Distutils が提供しているものだけです。)
詳細は <a class="reference internal" href="#inst-config-files"><em>Distutils 設定ファイル</em></a> を参照してください。</p>
<div class="section" id="inst-search-path">
<span id="id10"></span><h3>Python サーチパスの変更<a class="headerlink" href="#inst-search-path" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python インタプリタが <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文を実行するとき、インタプリタは Python コードや拡張モジュールをモジュール検索パス中から探します。検索パスのデフォルト値は、インタプリタをビルドする際に Python のバイナリ内に設定されます。検索パスは、 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a> を
import して、 <tt class="docutils literal"><span class="pre">sys.path</span></tt> を出力すればわかります。</p>
<div class="highlight-none"><div class="highlight"><pre>$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/usr/local/lib/python2.3&#39;, &#39;/usr/local/lib/python2.3/plat-linux2&#39;,
 &#39;/usr/local/lib/python2.3/lib-tk&#39;, &#39;/usr/local/lib/python2.3/lib-dynload&#39;,
 &#39;/usr/local/lib/python2.3/site-packages&#39;]
&gt;&gt;&gt;
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">sys.path</span></tt> 内の空文字列は、現在の作業ディレクトリを表します。</p>
<p>ローカルでインストールされるパッケージは、 <tt class="file docutils literal"><em><span class="pre">...</span></em><span class="pre">/site-packages/</span></tt>
ディレクトリに入るのが決まりですが、ユーザはどこか任意のディレクトリに Python モジュールをインストールしたいと思うかもしれません。例えば、自分のサイトでは、 web サーバに関連する全てのソフトウェアを <tt class="file docutils literal"><span class="pre">/www</span></tt> に置くという決まりがあるかもしれません。そこで、アドオンの Python モジュールが <tt class="file docutils literal"><span class="pre">/www/python</span></tt> 置かれることになると、モジュールを import するためにはディレクトリを
<tt class="docutils literal"><span class="pre">sys.path</span></tt> に追加せねばなりません。ディレクトリを検索パスに追加するには、いくつかの異なる方法が存在します。</p>
<p>最も手軽な方法は、パス設定ファイルをすでに Python の検索パスに含まれるディレクトリ、通常は <tt class="file docutils literal"><span class="pre">.../site-packages/</span></tt>
ディレクトリに置くというものです。パス設定ファイルは拡張子が <tt class="file docutils literal"><span class="pre">.pth</span></tt> で、ファイルには <tt class="docutils literal"><span class="pre">sys.path</span></tt>
に追加するパスを一行に一つづつ記述しなければなりません。 (新たなパスは今の <tt class="docutils literal"><span class="pre">sys.path</span></tt> の後ろに追加されるので、追加されたディレクトリ内にあるモジュールが標準のモジュールセットを上書きすることはありません。つまり、このメカニズムを使って、標準モジュールに対する修正版のインストールはできないということです。)</p>
<p>パスは絶対パスでも相対パスでもよく、相対パスの場合には <tt class="file docutils literal"><span class="pre">.pth</span></tt> ファイルのあるパスからの相対になります。詳しくは <a class="reference internal" href="../library/site.html#module-site" title="site: サイト固有のモジュールを参照する標準の方法。"><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> モジュールを参照してください。</p>
<p>やや便利さには欠けますが、Python の標準ライブラリ中にある  <tt class="file docutils literal"><span class="pre">site.py</span></tt> ファイルを編集することでも、 <tt class="docutils literal"><span class="pre">sys.path</span></tt> を変更できます。 <tt class="file docutils literal"><span class="pre">site.py</span></tt> は、 <a class="reference internal" href="../using/cmdline.html#cmdoption-S"><em class="xref std std-option">-S</em></a> スイッチを与えて抑制しないかぎり、Python インタプリタが実行される際に自動的に
import  されます。ただし、設定するには、単に <tt class="file docutils literal"><span class="pre">site.py</span></tt> を編集して、例えば以下のような二行を加えます:</p>
<div class="highlight-none"><div class="highlight"><pre>import sys
sys.path.append(&#39;/www/python/&#39;)
</pre></div>
</div>
<p>しかしながら、(例えば 2.2 から 2.2.2 にアップグレードするときのように) 同じメジャーバージョンの Python を再インストールすると、
<tt class="file docutils literal"><span class="pre">site.py</span></tt> は手持ちのバージョンで上書きされてしまいます。ファイルが変更されていることを覚えておき、インストールを行う前にコピーを忘れずとっておかねばなりません。</p>
<p>また、 <tt class="docutils literal"><span class="pre">sys.path</span></tt> を修正できる二つの環境変数があります。 <span class="target" id="index-0"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></tt></a> を使うと、インストールされている Python
のプレフィクスを別の値に設定できます。例えば、 <span class="target" id="index-1"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></tt></a> を <tt class="docutils literal"><span class="pre">/www/python</span></tt> に設定すると、検索パスは
<tt class="docutils literal"><span class="pre">['',</span> <span class="pre">'/www/python/lib/pythonX.Y/',</span> <span class="pre">'/www/python/lib/pythonX.Y/plat-linux2',</span> <span class="pre">...]</span></tt> といった具合になります。</p>
<p><span class="target" id="index-2"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> を使うと、 <tt class="docutils literal"><span class="pre">sys.path</span></tt> の先頭に一連のパスを追加できます。例えば、 <span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> を <tt class="docutils literal"><span class="pre">/www/python:/opt/py</span></tt> に設定すると、検索パスは
<tt class="docutils literal"><span class="pre">['/www/python',</span> <span class="pre">'/opt/py']</span></tt> から始まります。  (<tt class="docutils literal"><span class="pre">sys.path</span></tt> にディレクトリを追加するには、そのディレクトリが実在しなければなりません; <a class="reference internal" href="../library/site.html#module-site" title="site: サイト固有のモジュールを参照する標準の方法。"><tt class="xref py py-mod docutils literal"><span class="pre">site</span></tt></a> は実在しないディレクトリを除去します。)</p>
<p>最後に、 <tt class="docutils literal"><span class="pre">sys.path</span></tt> はただの普通の Python のリストなので、どんな Python アプリケーションもエントリを追加したり除去したりといった修正を行えます。</p>
</div>
</div>
<div class="section" id="inst-config-files">
<span id="id11"></span><h2>Distutils 設定ファイル<a class="headerlink" href="#inst-config-files" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>上で述べたように、 Distutils 設定ファイルを使えば、任意の  Distutils オプションに対して個人的な設定やサイト全体の設定を記録できます。すなわち、任意のコマンドの任意のオプションを二つか三つ (プラットフォームによって異なります) の設定ファイルに保存でき、コマンドラインを解釈する前にオプションを問い合わせさせるようにできます。つまり、設定ファイルはデフォルトの値を上書きし、さらにコマンドライン上で与えた値が設定ファイルの内容を上書きするわけです。さらに、複数の設定ファイルが適用されると、&#8221;先に&#8221; 適用されたファイルに指定されていた値は &#8220;後に&#8221; 適用されたファイル内の値で上書きされます。</p>
<div class="section" id="inst-config-filenames">
<span id="id12"></span><h3>設定ファイルの場所と名前<a class="headerlink" href="#inst-config-filenames" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>設定ファイルの名前と場所は、非常にわずかですがプラットフォーム間で異なります。Unix と Mac OS X では、三種類の設定ファイルは以下のようになります
(処理される順に並んでいます):</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="67%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">設定ファイルのタイプ</th>
<th class="head">場所とファイル名</th>
<th class="head">注記</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>system</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">ver</span></em><span class="pre">/distutils/distutils.cfg</span></tt></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td>personal</td>
<td><tt class="file docutils literal"><span class="pre">$HOME/.pydistutils.cfg</span></tt></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td>local</td>
<td><tt class="file docutils literal"><span class="pre">setup.cfg</span></tt></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p>Windows では設定ファイルは以下のようになります:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="64%" />
<col width="8%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">設定ファイルのタイプ</th>
<th class="head">場所とファイル名</th>
<th class="head">注記</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>system</td>
<td><tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\distutils\distutils.cfg</span></tt></td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td>personal</td>
<td><tt class="file docutils literal"><span class="pre">%HOME%\pydistutils.cfg</span></tt></td>
<td>(5)</td>
</tr>
<tr class="row-even"><td>local</td>
<td><tt class="file docutils literal"><span class="pre">setup.cfg</span></tt></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p>全てのプラットフォームにおいて、&#8221;個人の&#8221; ファイルは <cite>&#8211;no-user-cfg</cite> オプションを使って一時的に無効にすることができます。</p>
<p>注記:</p>
<ol class="arabic simple">
<li>厳密に言えば、システム全体向けの設定ファイルは、 Distutils がインストールされているディレクトリになります; Unixの Python 1.6
以降では、表の通りの場所になります。 Python 1.5.2 では、 Distutils は通常
<tt class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python1.5/site-packages/distutils</span></tt> にインストールされるため、 Python
1.5.2 では設定ファイルをそこに置かなければなりません。</li>
<li>Unixでは、環境変数 <span class="target" id="index-4"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> が定義されていない場合、標準モジュール <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: パスワードデータベースへのアクセスを提供する (getpwnam() など)。 (Unix)"><tt class="xref py py-mod docutils literal"><span class="pre">pwd</span></tt></a>
の <tt class="xref py py-func docutils literal"><span class="pre">getpwuid()</span></tt> 関数を使ってユーザのホームディレクトリを決定します。このとき同時に Distutils によって <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><tt class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></tt></a> が実行されます。</li>
<li>現在のディレクトリ (通常は setup スクリプトがある場所) です。</li>
<li>(注記 (1) も参照してください)  Python 1.6 およびそれ以降のバージョンでは、 Python のデフォルトの &#8220;インストールプレフィクス&#8221; は
<tt class="file docutils literal"><span class="pre">C:\Python</span></tt> なので、システム設定ファイルは通常
<tt class="file docutils literal"><span class="pre">C:\Python\Lib\distutils\distutils.cfg</span></tt> になります。Python 1.5.2 ではデフォルトのプレフィクスは <tt class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></tt> であり、Distutils は標準ライブラリの一部ではありません &#8212;
従って、システム設定ファイルは、 Windows 用の標準の Python 1.5.2 では <tt class="file docutils literal"><span class="pre">C:\Program</span>
<span class="pre">Files\Python\distutils\distutils.cfg</span></tt> になります。</li>
<li>Windows では、環境変数 <span class="target" id="index-5"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> が設定されていない場合、
<span class="target" id="index-6"></span><tt class="xref std std-envvar docutils literal"><span class="pre">USERPROFILE</span></tt> 、 <span class="target" id="index-7"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOMEDRIVE</span></tt> 、 <span class="target" id="index-8"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOMEPATH</span></tt> を順々に試します。このとき同時に Distutils によって <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><tt class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></tt></a> が実行されます。</li>
</ol>
</div>
<div class="section" id="inst-config-syntax">
<span id="id13"></span><h3>設定ファイルの構文<a class="headerlink" href="#inst-config-syntax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Distutils 設定ファイルは、全て同じ構文をしています。設定ファイルはセクションでグループ分けされています。各 Distutils
コマンドごとにセクションがあり、それに加えて全てのコマンドに影響するグローバルオプションを設定するための <tt class="docutils literal"><span class="pre">global</span></tt>
セクションがあります。各セクションには <tt class="docutils literal"><span class="pre">option=value</span></tt> の形で、一行あたり一つのオプションを指定します。</p>
<p>例えば、以下は全てのコマンドに対してデフォルトでメッセージを出さないよう強制するための完全な設定ファイルです:</p>
<div class="highlight-none"><div class="highlight"><pre>[global]
verbose=0
</pre></div>
</div>
<p>この内容のファイルがシステム全体用の設定ファイルとしてインストールされていれば、そのシステムの全てのユーザによる全ての Python モジュール配布物に対する処理に影響します。ファイルが (個人用の設定をサポートしているシステムで) 個人用の設定ファイルとしてインストールされていれば、そのユーザが処理するモジュール配布物にのみ影響します。この内容を特定のモジュール配布物の <tt class="file docutils literal"><span class="pre">setup.cfg</span></tt> として使えば、その配布物だけに影響します。</p>
<p>以下のようにして、デフォルトの &#8220;ビルドベース&#8221; ディレクトリをオーバライドしたり、 <strong class="command">build*</strong> コマンドが常に強制的にリビルドを行うようにもできます:</p>
<div class="highlight-none"><div class="highlight"><pre>[build]
build-base=blib
force=1
</pre></div>
</div>
<p>この設定は、コマンドライン引数の</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --build-base=blib --force
</pre></div>
</div>
<p>に対応します。ただし、後者ではコマンドライン上で <strong class="command">build</strong>  コマンドを含めて、そのコマンドを実行するよう意味しているところが違います。特定のコマンドに対するオプションを設定ファイルに含めると、このような関連付けの必要はなくなります;
あるコマンドが実行されると、そのコマンドに対するオプションが適用されます。 (また、設定ファイル内からオプションを取得するような他のコマンドを実行した場合、それらのコマンドもまた設定ファイル内の対応するオプションの値を使います。)</p>
<p>あるコマンドに対するオプションの完全なリストは、例えば以下のように、 <a class="reference internal" href="../using/cmdline.html#cmdoption--help"><em class="xref std std-option">--help</em></a> を使って調べます:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --help
</pre></div>
</div>
<p>グローバルオプションの完全なリストを得るには、コマンドを指定せずに <a class="reference internal" href="../using/cmdline.html#cmdoption--help"><em class="xref std std-option">--help</em></a> オプションを使います:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py --help
</pre></div>
</div>
<p>&#8220;Python モジュールの配布&#8221; マニュアルの、 &#8220;リファレンスマニュアル&#8221; の節も参照してください。</p>
</div>
</div>
<div class="section" id="inst-building-ext">
<span id="id14"></span><h2>拡張モジュールのビルド: 小技と豆知識<a class="headerlink" href="#inst-building-ext" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Distutils は、可能なときにはいつでも、 <tt class="file docutils literal"><span class="pre">setup.py</span></tt> スクリプトを実行する Python
インタプリタが提供する設定情報を使おうとします。例えば、拡張モジュールをコンパイルする際には、コンパイラやリンカのフラグには Python
をコンパイルした際と同じものが使われます。通常、この設定はうまくいきますが、状況が複雑になると不適切な設定になることもあります。この節では、通常の
Distutils の動作をオーバライドする方法について議論します。</p>
<div class="section" id="inst-tweak-flags">
<span id="id15"></span><h3>コンパイラ/リンカのフラグをいじるには<a class="headerlink" href="#inst-tweak-flags" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>C や C++ で書かれた Python 拡張をコンパイルする際、しばしば特定のライブラリを使ったり、特定の種類のオブジェクトコードを生成したりする上で、コンパイラやリンカに与えるフラグをカスタマイズする必要があります。ある拡張モジュールが自分のプラットフォームではテストされていなかったり、クロスコンパイルを行わねばならない場合にはこれが当てはまります。</p>
<p>最も一般的なケースでは、拡張モジュールの作者はすでに拡張モジュールのコンパイルが複雑になることを見越していて、 <tt class="file docutils literal"><span class="pre">Setup</span></tt>
ファイルを提供して編集できるようにしています。 <tt class="file docutils literal"><span class="pre">Setup</span></tt> ファイルの編集は、モジュール配布物に多くの個別の拡張モジュールがあったり、コンパイラに拡張モジュールをコンパイルさせるために細かくフラグをセットする必要があるような場合にのみ行うことになるでしょう。</p>
<p><tt class="file docutils literal"><span class="pre">Setup</span></tt> ファイルが存在する場合、ビルドするべき拡張モジュールのリストを得るために解釈されます。 <tt class="file docutils literal"><span class="pre">Setup</span></tt>
ファイルの各行には単一のモジュールを書きます。各行は以下のような構造をとります:</p>
<div class="highlight-none"><div class="highlight"><pre>module ... [sourcefile ...] [cpparg ...] [library ...]
</pre></div>
</div>
<p>次に、各フィールドについて見てみましょう。</p>
<ul class="simple">
<li><em>module</em> はビルドする拡張モジュールの名前で、Python の識別子名として有効でなければなりません。モジュールの名前変更は、このフィールドを変えるだけではできない (ソースコードの編集も必要です)  ので、このフィールドに手を加えるべきではありません。</li>
<li><em>sourcefile</em> は、少なくともファイル名から何の言語で書かれているかがわかるようになっているソースコードファイル名です。 <tt class="file docutils literal"><span class="pre">.c</span></tt>
で終わるファイルは C で書かれているとみなされ、 <tt class="file docutils literal"><span class="pre">.C</span></tt> 、 <tt class="file docutils literal"><span class="pre">.cc</span></tt> 、および <tt class="file docutils literal"><span class="pre">.c++</span></tt> で終わるファイルは C++
で書かれているとみなされます。 <tt class="file docutils literal"><span class="pre">.m</span></tt> や <tt class="file docutils literal"><span class="pre">.mm</span></tt> で終わるファイルは Objective C で書かれているとみなされます。</li>
<li><em>cpparg</em> は C プリプロセッサへの引数で、 <em class="xref std std-option">-I</em> 、 <em class="xref std std-option">-D</em> 、 <a class="reference internal" href="../using/cmdline.html#cmdoption-U"><em class="xref std std-option">-U</em></a> または
<em class="xref std std-option">-C</em> のいずれかから始まる文字列です。</li>
<li><em>library</em> は <tt class="file docutils literal"><span class="pre">.a</span></tt> で終わるか、 <em class="xref std std-option">-l</em> または <em class="xref std std-option">-L</em> のいずれかから始まる文字列です。</li>
</ul>
<p>特定のプラットフォームにおいて、プラットフォーム上の特殊なライブラリが必要な場合、 <tt class="file docutils literal"><span class="pre">Setup</span></tt> ファイルを編集して <tt class="docutils literal"><span class="pre">python</span>
<span class="pre">setup.py</span> <span class="pre">build</span></tt> を実行すればライブラリを追加できます。例えば、以下の行</p>
<div class="highlight-none"><div class="highlight"><pre>foo foomodule.c
</pre></div>
</div>
<p>で定義されたモジュールを、自分のプラットフォーム上の数学ライブラリ <tt class="file docutils literal"><span class="pre">libm.a</span></tt> とリンクしなければならない場合、 <tt class="file docutils literal"><span class="pre">Setup</span></tt>
内の行に <em class="xref std std-option">-lm</em> を追加するだけです:</p>
<div class="highlight-none"><div class="highlight"><pre>foo foomodule.c -lm
</pre></div>
</div>
<p>コンパイラやリンカ向けの任意のスイッチオプションは、 <em class="xref std std-option">-Xcompiler</em> <em>arg</em> や <em class="xref std std-option">-Xlinker</em> <em>arg</em>
オプションで与えます:</p>
<div class="highlight-none"><div class="highlight"><pre>foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm
</pre></div>
</div>
<p><em class="xref std std-option">-Xcompiler</em> および <em class="xref std std-option">-Xlinker</em> の後にくるオプションは、それぞれ適切なコマンドラインに追加されます。従って、上の例では、コンパイラには <em class="xref std std-option">-o32</em> オプションが渡され、リンカには <em class="xref std std-option">-shared</em> が渡されます。コンパイラオプションに引数が必要な場合、複数の <em class="xref std std-option">-Xcompiler</em>  オプションを与えます; 例えば、 <tt class="docutils literal"><span class="pre">-x</span> <span class="pre">c++</span></tt> を渡すには、
<tt class="file docutils literal"><span class="pre">Setup</span></tt> ファイルには <tt class="docutils literal"><span class="pre">-Xcompiler</span> <span class="pre">-x</span> <span class="pre">-Xcompiler</span> <span class="pre">c++</span></tt> を渡さねばなりません。</p>
<p>コンパイラフラグは、環境変数 <span class="target" id="index-9"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></tt> の設定でも与えられます。 <span class="target" id="index-10"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></tt>
が設定されていれば、 <tt class="file docutils literal"><span class="pre">Setup</span></tt> ファイル内で指定されているコンパイラフラグに <span class="target" id="index-11"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></tt> の内容が追加されます。</p>
</div>
<div class="section" id="windows-microsoft">
<span id="inst-non-ms-compilers"></span><h3>Windows で非 Microsoft コンパイラを使ってビルドするには<a class="headerlink" href="#windows-microsoft" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="borland-codegear-c">
<h4>Borland/CodeGear C++<a class="headerlink" href="#borland-codegear-c" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この小節では、 Borland C++ コンパイラのバージョン 5.5 で Distutils を使うために必要な手順について述べています。  まず、
Borland のオブジェクトファイル形式 (OMF) は、Python 公式サイトや ActiveState の Web サイトからダウンロードできるバージョンの Python が使っている形式とは違うことを知っておかねばなりません (Python は通常、 Microsoft Visual C++
でビルドされています。Microsoft Visual C++ は COFF をオブジェクトファイル形式に使います。) このため、以下のようにして、
Python のライブラリ <tt class="file docutils literal"><span class="pre">python25.lib</span></tt>  を Borland の形式に変換する必要があります:</p>
<div class="highlight-none"><div class="highlight"><pre>coff2omf python25.lib python25_bcpp.lib
</pre></div>
</div>
<p><tt class="file docutils literal"><span class="pre">coff2omf</span></tt> プログラムは、 Borland コンパイラに付属しています。 <tt class="file docutils literal"><span class="pre">python25.lib</span></tt> は Python
インストールディレクトリの <tt class="file docutils literal"><span class="pre">Libs</span></tt>  ディレクトリ内にあります。拡張モジュールで他のライブラリ (zlib, ...)
を使っている場合、それらのライブラリも変換しなければなりません。</p>
<p>変換されたファイルは、通常のライブラリと同じディレクトリに置かねばなりません。</p>
<p>さて、 Distutils は異なる名前を持つこれらのライブラリをどのように扱うのでしょうか? 拡張モジュールで (例えば <tt class="file docutils literal"><span class="pre">foo</span></tt>
という名の) ライブラリが必要な場合、 Distutils はまず <tt class="file docutils literal"><span class="pre">_bcpp</span></tt> が後ろに付いたライブラリ (例えば
<tt class="file docutils literal"><span class="pre">foo_bcpp.lib</span></tt>) が見つかるかどうか調べ、あればそのライブラリを使います。該当するライブラリがなければ、デフォルトの名前
(<tt class="file docutils literal"><span class="pre">foo.lib</span></tt>) を使います <a class="footnote-reference" href="#id19" id="id16">[1]</a> 。</p>
<p>Borland C++ を使って Distutils に拡張モジュールをコンパイルさせるには、以下のように入力します:</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --compiler=bcpp
</pre></div>
</div>
<p>Borland C++ コンパイラをデフォルトにしたいなら、自分用、またはシステム全体向けに、 Distutils の設定ファイルを書くことを検討した方がよいでしょう (<a class="reference internal" href="#inst-config-files"><em>Distutils 設定ファイル</em></a> 節を参照してください)。</p>
<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://www.codegear.com/downloads/free/cppbuilder">C++Builder Compiler</a></dt>
<dd>Borland によるフリーの C++ コンパイラに関する情報で、コンパイラのダウンロードページへのリンクもあります。</dd>
<dt><a class="reference external" href="http://www.cyberus.ca/%7eg_will/pyExtenDL.shtml">Creating Python Extensions Using Borland&#8217;s Free Compiler</a></dt>
<dd>Borland 製のフリーのコマンドライン C++ を使って Python をビルドする方法について述べたドキュメントです。</dd>
</dl>
</div>
</div>
<div class="section" id="gnu-c-cygwin-mingw">
<h4>GNU C / Cygwin / MinGW<a class="headerlink" href="#gnu-c-cygwin-mingw" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この節では、 Cygwin や MinGW  <a class="footnote-reference" href="#id20" id="id17">[2]</a> 配布物中の GNU C/C++ コンパイラで Distutils
を使うために必要な手順について述べます。 Cygwin 向けにビルドされている Python インタプリタを使っているなら、以下の手順をとらなくても
Distutils はまったく問題なく動作します。</p>
<p>全ての拡張ライブラリが MinGW や Cygwin でビルドできるわけではありませんが、多くの場合はビルドできます。ビルドできない拡張ライブラリは、大抵C++を利用していたり Microsoft Visual Cの拡張に依存していたりします。</p>
<p>distutils に Cygwin を使って拡張をコンパイルさせるには次のようにタイプします。</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --compiler=cygwin
</pre></div>
</div>
<p>Cygwin を no-cygwin モード <a class="footnote-reference" href="#id21" id="id18">[3]</a> で使うときや MinGW を使うときは次のようにします。</p>
<div class="highlight-none"><div class="highlight"><pre>python setup.py build --compiler=mingw32
</pre></div>
</div>
<p>これらのオプションやコンパイラをデフォルトにしたい場合、 Distutils の個人用あるいはシステム全体用の設定ファイルを書くことを検討するべきです。
(<a class="reference internal" href="#inst-config-files"><em>Distutils 設定ファイル</em></a> を参照してください)</p>
<div class="section" id="python-mingw">
<h5>古いバージョンの Python と MinGW<a class="headerlink" href="#python-mingw" title="このヘッドラインへのパーマリンク">¶</a></h5>
<p>以下の手順は Python 2.4.1 以前と MinGW 3.0.0 (binutils-2.13.90-20030111-1)
以前を利用しているときのものです。</p>
<p>上記のコンパイラは、いくつかの特殊なライブラリを必要とします。この作業は Borland の C++ よりもやや複雑です。というのは、ライブラリを変換するためのプログラムが存在しないからです。  まず、 Python DLL が公開している全てのシンボルからなるリストを作成しなければなりません。 (この作業むけの良いプログラムは、
<a class="reference external" href="http://www.emmestech.com/software/pexports-0.43/download_pexports.html">http://www.emmestech.com/software/pexports-0.43/download_pexports.html</a>
から入手できます。)</p>
<div class="highlight-none"><div class="highlight"><pre>pexports python25.dll &gt;python25.def
</pre></div>
</div>
<p>これで、上で得られた情報をもとに、 gcc 用の import ライブラリを作成できます。</p>
<p>インストールされた <tt class="file docutils literal"><span class="pre">python25.dll</span></tt> の位置はインストールオプションと、
Windowsのバージョンと言語に依存します。&#8221;自分だけのため&#8221;のインストールの場合には、インストールディレクトリのルートに配置されます。共有インストールの場合にはシステムディレクトリに配置されます。</p>
<div class="highlight-none"><div class="highlight"><pre>dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a
</pre></div>
</div>
<p>出来上がったライブラリは、 <tt class="file docutils literal"><span class="pre">python25.lib</span></tt> と同じディレクトリ (Python インストールディレクトリの <tt class="file docutils literal"><span class="pre">libs</span></tt>
ディレクトリになるはずです) に置かなければなりません。</p>
<p>拡張モジュールが他のライブラリ (zlib, ... ) を必要とする場合、それらのライブラリも変換しなければなりません。変換されたファイルは、それぞれ通常のライブラリが置かれているのと同じディレクトリに置かねばなりません。</p>
<div class="admonition- admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://www.zope.org/Members/als/tips/win32_mingw_modules">Building Python modules on MS Windows platform with MinGW</a></dt>
<dd>MinGW 環境で必要なライブラリのビルドに関する情報があります。</dd>
</dl>
</div>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[1]</a></td><td>つまり、全ての既存の COFF ライブラリを同名の OMF ライブラリに置き換えてもかまわないということです</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[2]</a></td><td>詳しくは <a class="reference external" href="http://sources.redhat.com/cygwin/">http://sources.redhat.com/cygwin/</a> や <a class="reference external" href="http://www.mingw.org/">http://www.mingw.org/</a> を参照してください</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[3]</a></td><td>このモードでは POSIX エミュレーションを利用できませんが、 <tt class="file docutils literal"><span class="pre">cygwin1.dll</span></tt> も必要なくなります。</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="section" id="id22">
<h2>日本語訳について<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="jptranslation.html">このドキュメントについて</a><ul>
<li class="toctree-l2"><a class="reference internal" href="jptranslation.html#id2">翻訳者一覧 (敬称略)</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="jptranslation.html" title="このドキュメントについて"
             >次へ</a> |</li>
        <li class="right" >
          <a href="../distutils/jptranslation.html" title="このドキュメントについて"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>