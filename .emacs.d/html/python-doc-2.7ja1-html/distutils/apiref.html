

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API リファレンス &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python モジュールの配布" href="index.html" />
    <link rel="next" title="このドキュメントについて" href="jptranslation.html" />
    <link rel="prev" title="コマンドリファレンス" href="commandref.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="jptranslation.html" title="このドキュメントについて"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="commandref.html" title="コマンドリファレンス"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python モジュールの配布</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">API リファレンス</a><ul>
<li><a class="reference internal" href="#module-distutils.core"><tt class="docutils literal"><span class="pre">distutils.core</span></tt> &#8212; Distutils のコア機能</a></li>
<li><a class="reference internal" href="#module-distutils.ccompiler"><tt class="docutils literal"><span class="pre">distutils.ccompiler</span></tt> &#8212; CCompiler ベースクラス</a></li>
<li><a class="reference internal" href="#module-distutils.unixccompiler"><tt class="docutils literal"><span class="pre">distutils.unixccompiler</span></tt> &#8212; Unix C コンパイラ</a></li>
<li><a class="reference internal" href="#module-distutils.msvccompiler"><tt class="docutils literal"><span class="pre">distutils.msvccompiler</span></tt> &#8212; Microsoft コンパイラ</a></li>
<li><a class="reference internal" href="#module-distutils.bcppcompiler"><tt class="docutils literal"><span class="pre">distutils.bcppcompiler</span></tt> &#8212; Borland コンパイラ</a></li>
<li><a class="reference internal" href="#module-distutils.cygwinccompiler"><tt class="docutils literal"><span class="pre">distutils.cygwincompiler</span></tt> &#8212; Cygwin コンパイラ</a></li>
<li><a class="reference internal" href="#module-distutils.emxccompiler"><tt class="docutils literal"><span class="pre">distutils.emxccompiler</span></tt> &#8212; OS/2 EMX コンパイラ</a></li>
<li><a class="reference internal" href="#module-distutils.archive_util"><tt class="docutils literal"><span class="pre">distutils.archive_util</span></tt> &#8212;  アーカイブユーティリティ</a></li>
<li><a class="reference internal" href="#module-distutils.dep_util"><tt class="docutils literal"><span class="pre">distutils.dep_util</span></tt> &#8212; 依存関係のチェック</a></li>
<li><a class="reference internal" href="#module-distutils.dir_util"><tt class="docutils literal"><span class="pre">distutils.dir_util</span></tt> &#8212; ディレクトリツリーの操作</a></li>
<li><a class="reference internal" href="#module-distutils.file_util"><tt class="docutils literal"><span class="pre">distutils.file_util</span></tt> &#8212; 1ファイルの操作</a></li>
<li><a class="reference internal" href="#module-distutils.util"><tt class="docutils literal"><span class="pre">distutils.util</span></tt> &#8212; その他のユーティリティ関数</a></li>
<li><a class="reference internal" href="#module-distutils.dist"><tt class="docutils literal"><span class="pre">distutils.dist</span></tt> &#8212; Distribution クラス</a></li>
<li><a class="reference internal" href="#module-distutils.extension"><tt class="docutils literal"><span class="pre">distutils.extension</span></tt> &#8212; Extension クラス</a></li>
<li><a class="reference internal" href="#module-distutils.debug"><tt class="docutils literal"><span class="pre">distutils.debug</span></tt> &#8212; Distutils デバッグモード</a></li>
<li><a class="reference internal" href="#module-distutils.errors"><tt class="docutils literal"><span class="pre">distutils.errors</span></tt> &#8212; Distutils 例外</a></li>
<li><a class="reference internal" href="#module-distutils.fancy_getopt"><tt class="docutils literal"><span class="pre">distutils.fancy_getopt</span></tt> &#8212; 標準 getopt モジュールのラッパ</a></li>
<li><a class="reference internal" href="#module-distutils.filelist"><tt class="docutils literal"><span class="pre">distutils.filelist</span></tt> &#8212;  FileList クラス</a></li>
<li><a class="reference internal" href="#module-distutils.log"><tt class="docutils literal"><span class="pre">distutils.log</span></tt> &#8212; シンプルな PEP 282 スタイルのロギング</a></li>
<li><a class="reference internal" href="#module-distutils.spawn"><tt class="docutils literal"><span class="pre">distutils.spawn</span></tt> &#8212; サブプロセスの生成</a></li>
<li><a class="reference internal" href="#module-distutils.sysconfig"><tt class="docutils literal"><span class="pre">distutils.sysconfig</span></tt> &#8212; システム設定情報</a></li>
<li><a class="reference internal" href="#module-distutils.text_file"><tt class="docutils literal"><span class="pre">distutils.text_file</span></tt> &#8212; TextFile クラス</a></li>
<li><a class="reference internal" href="#module-distutils.version"><tt class="docutils literal"><span class="pre">distutils.version</span></tt> &#8212; バージョン番号クラス</a></li>
<li><a class="reference internal" href="#module-distutils.cmd"><tt class="docutils literal"><span class="pre">distutils.cmd</span></tt> &#8212; Distutils コマンドの抽象クラス</a></li>
<li><a class="reference internal" href="#distutils">新しいDistutilsコマンドの作成</a></li>
<li><a class="reference internal" href="#module-distutils.command"><tt class="docutils literal"><span class="pre">distutils.command</span></tt> &#8212;  Distutils 各コマンド</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist"><tt class="docutils literal"><span class="pre">distutils.command.bdist</span></tt> &#8212; バイナリインストーラの構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_packager"><tt class="docutils literal"><span class="pre">distutils.command.bdist_packager</span></tt> &#8212; パッケージの抽象ベースクラス</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_dumb"><tt class="docutils literal"><span class="pre">distutils.command.bdist_dumb</span></tt> &#8212; &#8220;ダム&#8221;インストーラを構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_msi"><tt class="docutils literal"><span class="pre">distutils.command.bdist_msi</span></tt> &#8212; Microsoft Installer バイナリパッケージをビルドする</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_rpm"><tt class="docutils literal"><span class="pre">distutils.command.bdist_rpm</span></tt> &#8212; Redhat RPMとSRPM形式のバイナリディストリビューションを構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.bdist_wininst"><tt class="docutils literal"><span class="pre">distutils.command.bdist_wininst</span></tt> &#8212; Windowsインストーラの構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.sdist"><tt class="docutils literal"><span class="pre">distutils.command.sdist</span></tt> &#8212; ソース配布物の構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.build"><tt class="docutils literal"><span class="pre">distutils.command.build</span></tt> &#8212; パッケージ中の全ファイルを構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_clib"><tt class="docutils literal"><span class="pre">distutils.command.build_clib</span></tt> &#8212; パッケージ中のCライブラリを構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_ext"><tt class="docutils literal"><span class="pre">distutils.command.build_ext</span></tt> &#8212; パッケージ中の拡張を構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_py"><tt class="docutils literal"><span class="pre">distutils.command.build_py</span></tt> &#8212; パッケージ中の.py/.pyc ファイルを構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.build_scripts"><tt class="docutils literal"><span class="pre">distutils.command.build_scripts</span></tt> &#8212; パッケージ中のスクリプトを構築</a></li>
<li><a class="reference internal" href="#module-distutils.command.clean"><tt class="docutils literal"><span class="pre">distutils.command.clean</span></tt> &#8212; パッケージのビルドエリアを消去</a></li>
<li><a class="reference internal" href="#module-distutils.command.config"><tt class="docutils literal"><span class="pre">distutils.command.config</span></tt> &#8212; パッケージの設定</a></li>
<li><a class="reference internal" href="#module-distutils.command.install"><tt class="docutils literal"><span class="pre">distutils.command.install</span></tt> &#8212; パッケージのインストール</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_data"><tt class="docutils literal"><span class="pre">distutils.command.install_data</span></tt> &#8212; パッケージ中のデータファイルをインストール</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_headers"><tt class="docutils literal"><span class="pre">distutils.command.install_headers</span></tt> &#8212; パッケージから C/C++ ヘッダファイルをインストール</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_lib"><tt class="docutils literal"><span class="pre">distutils.command.install_lib</span></tt> &#8212; パッケージからライブラリファイルをインストール</a></li>
<li><a class="reference internal" href="#module-distutils.command.install_scripts"><tt class="docutils literal"><span class="pre">distutils.command.install_scripts</span></tt> &#8212; パッケージからスクリプトファイルをインストール</a></li>
<li><a class="reference internal" href="#module-distutils.command.register"><tt class="docutils literal"><span class="pre">distutils.command.register</span></tt> &#8212; モジュールをPython Package Indexに登録する</a></li>
<li><a class="reference internal" href="#module-distutils.command.check"><tt class="docutils literal"><span class="pre">distutils.command.check</span></tt> &#8212; パッケージのメタデータをチェックする</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="commandref.html"
                        title="前の章へ">コマンドリファレンス</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="jptranslation.html"
                        title="次の章へ">このドキュメントについて</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/distutils/apiref.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api">
<span id="api-reference"></span><h1>API リファレンス<a class="headerlink" href="#api" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="module-distutils.core">
<span id="distutils-core-distutils"></span><h2><a class="reference internal" href="#module-distutils.core" title="distutils.core: Distutils のコア機能"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.core</span></tt></a> &#8212; Distutils のコア機能<a class="headerlink" href="#module-distutils.core" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Distutilsを使うためにインストールする必要がある唯一のモジュールが
<a class="reference internal" href="#module-distutils.core" title="distutils.core: Distutils のコア機能"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.core</span></tt></a> モジュールです。 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a> 関数 (セットアップスクリプトから呼び出されます)を提供します。間接的に
<tt class="xref py py-class docutils literal"><span class="pre">distutils.dist.Distribution</span></tt> クラスと <a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><tt class="xref py py-class docutils literal"><span class="pre">distutils.cmd.Command</span></tt></a>
クラスを提供します。</p>
<dl class="function">
<dt id="distutils.core.setup">
<tt class="descclassname">distutils.core.</tt><tt class="descname">setup</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#distutils.core.setup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全てを実行する基本的な関数で、Distutilsでできるほとんどのことを実行します。</p>
<p>setup関数はたくさんの引数をとります。以下のテーブルにまとめます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="41%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">引数名</th>
<th class="head">値</th>
<th class="head">型</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>name</em></td>
<td>パッケージの名前</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>version</em></td>
<td>パッケージのバージョン番号</td>
<td><a class="reference internal" href="#module-distutils.version" title="distutils.version: モジュールのバージョン番号を表すクラスの実装"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.version</span></tt></a> を参照してください</td>
</tr>
<tr class="row-even"><td><em>description</em></td>
<td>1行で書いたパッケージ解説</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>long_description</em></td>
<td>パッケージの長い解説</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>author</em></td>
<td>パッケージ作者の名前</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>author_email</em></td>
<td>パッケージ作者のemailアドレス</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>maintainer</em></td>
<td>現在のメンテナの名前(パッケージ作者と異なる場合)</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>maintainer_email</em></td>
<td>現在のメンテナのemailアドレス(パッケージ作者と異なる場合)</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><em>url</em></td>
<td>パッケージのURL(ホームページ)</td>
<td>URL</td>
</tr>
<tr class="row-odd"><td><em>download_url</em></td>
<td>パッケージダウンロード用URL</td>
<td>URL</td>
</tr>
<tr class="row-even"><td><em>packages</em></td>
<td>distutilsが操作するPythonパッケージのリスト</td>
<td>文字列のリスト</td>
</tr>
<tr class="row-odd"><td><em>py_modules</em></td>
<td>distutilsが操作するPythonモジュールのリスト</td>
<td>文字列のリスト</td>
</tr>
<tr class="row-even"><td><em>scripts</em></td>
<td>ビルドおよびインストールする単体スクリプトファイルのリスト</td>
<td>文字列のリスト</td>
</tr>
<tr class="row-odd"><td><em>ext_modules</em></td>
<td>ビルドする拡張モジュール</td>
<td><a class="reference internal" href="#distutils.core.Extension" title="distutils.core.Extension"><tt class="xref py py-class docutils literal"><span class="pre">distutils.core.Extension</span></tt></a> インスタンスのリスト</td>
</tr>
<tr class="row-even"><td><em>classifiers</em></td>
<td>パッケージのカテゴリのリスト</td>
<td>利用可能なカテゴリ一覧は
<a class="reference external" href="http://cheeseshop.python.org/pypi?:action=list_classifiers">http://cheeseshop.python.org/pypi?:action=list_classifiers</a>
にあります。</td>
</tr>
<tr class="row-odd"><td><em>distclass</em></td>
<td>使用する <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> クラス</td>
<td><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">distutils.core.Distribution</span></tt></a> のサブクラス</td>
</tr>
<tr class="row-even"><td><em>script_name</em></td>
<td>setup.pyスクリプトの名前 -
デフォルトでは <tt class="docutils literal"><span class="pre">sys.argv[0]</span></tt></td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>script_args</em></td>
<td>セットアップスクリプトの引数</td>
<td>文字列のリスト</td>
</tr>
<tr class="row-even"><td><em>options</em></td>
<td>セットアップスクリプトのデフォルト引数</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>license</em></td>
<td>パッケージのライセンス</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>keywords</em></td>
<td>説明用メタデータ。 <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0314"><strong>PEP 314</strong></a> を参照してください</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><em>platforms</em></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><em>cmdclass</em></td>
<td>コマンド名から <a class="reference internal" href="#distutils.core.Command" title="distutils.core.Command"><tt class="xref py py-class docutils literal"><span class="pre">Command</span></tt></a>
サブクラスへのマッピング</td>
<td>辞書</td>
</tr>
<tr class="row-odd"><td><em>data_files</em></td>
<td>インストールするデータファイルのリスト</td>
<td>リスト</td>
</tr>
<tr class="row-even"><td><em>package_dir</em></td>
<td>パッケージからディレクトリ名へのマッピング</td>
<td>辞書</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="distutils.core.run_setup">
<tt class="descclassname">distutils.core.</tt><tt class="descname">run_setup</tt><big>(</big><em>script_name</em><span class="optional">[</span>, <em>script_args=None</em>, <em>stop_after='run'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.core.run_setup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>制御された環境でセットアップスクリプトを実行し、いろいろなものを操作する
<tt class="xref py py-class docutils literal"><span class="pre">distutils.dist.Distribution</span></tt> クラスのインスタンスを返します。これはディストリビューションのメタデータ(キーワード引数 <em>script</em> として関数 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a> に渡される)を参照したり、設定ファイルやコマンドラインの内容を調べる時に便利です。</p>
<p><em>script_name</em> は <a class="reference internal" href="../library/functions.html#execfile" title="execfile"><tt class="xref py py-func docutils literal"><span class="pre">execfile()</span></tt></a> で実行されるファイルです。 <tt class="docutils literal"><span class="pre">sys.argv[0]</span></tt> は、呼び出しのために <em>script_name</em> と置換されます。  <em>script_args</em> は文字列のリストです。もし提供されていた場合、
<tt class="docutils literal"><span class="pre">sys.argv[1:]</span></tt> は、呼び出しのために <em>script_args</em> で置換されます。</p>
<p><em>stop_after</em> はいつ動作を停止するか関数 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a> に伝えます。とりうる値は:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">値</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>init</em></td>
<td><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> インスタンスを作成し、キーワード引数を
<a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a> に渡したあとに停止する。</td>
</tr>
<tr class="row-odd"><td><em>config</em></td>
<td>設定ファイルをパーズしたあと停止する(そしてそのデータは
<a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> インスタンスに保存される)。</td>
</tr>
<tr class="row-even"><td><em>commandline</em></td>
<td>コマンドライン (<tt class="docutils literal"><span class="pre">sys.argv[1:]</span></tt> または
<em>script_args</em>) がパーズされたあとに停止する (そしてそのデータは
<a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> インスタンスに保存される)。</td>
</tr>
<tr class="row-odd"><td><em>run</em></td>
<td>全てのコマンドを実行したあとに停止する(関数 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a>
を通常の方法で呼び出した場合と同じ)。デフォルト値。</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>これに加えて、 <a class="reference internal" href="#module-distutils.core" title="distutils.core: Distutils のコア機能"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.core</span></tt></a> モジュールは他のモジュールにあるいくつかのクラスを公開しています。</p>
<ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">Extension</span></tt> は <a class="reference internal" href="#module-distutils.extension" title="distutils.extension: セットアップスクリプトでC/C++ 拡張モジュールをあらわす Extension クラスを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.extension</span></tt></a> から。</li>
<li><a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><tt class="xref py py-class docutils literal"><span class="pre">Command</span></tt></a> は <a class="reference internal" href="#module-distutils.cmd" title="distutils.cmd: このモジュールは Command 抽象ベースクラスを提供します。このクラスは distutils.command サブパッケージ中のモジュールでサブクラスを作るために利用されます。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.cmd</span></tt></a> から。</li>
<li><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt> は <a class="reference internal" href="#module-distutils.dist" title="distutils.dist: 構築/インストール/配布される配布物を表す Distribution クラスを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.dist</span></tt></a> から。</li>
</ul>
<p>それぞれの簡単な説明を以下に記します。完全な説明についてはそれぞれのモジュールをごらんください。</p>
<dl class="class">
<dt id="distutils.core.Extension">
<em class="property">class </em><tt class="descclassname">distutils.core.</tt><tt class="descname">Extension</tt><a class="headerlink" href="#distutils.core.Extension" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Extension クラスは、セットアップスクリプト中で C または C++拡張モジュールを表します。コンストラクタで以下のキーワード引数をとります。</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="62%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">引数名</th>
<th class="head">値</th>
<th class="head">型</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>name</em></td>
<td>拡張のフルネーム(パッケージを含む) &#8212;
ファイル名やパス名では <em>なく</em> 、Pythonのピリオド区切りの名前</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>sources</em></td>
<td>ソースファイル名のリスト。配布物ルートディレクトリ
(setupスクリプトのある場所)
からの相対パス、プラットフォーム独立のため Unix
形式(スラッシュで区切る)で記述します。ソースファイルは
C, C++, SWIG
(.i)、特定プラットフォーム用のリソースファイル、その他
<strong class="command">build_ext</strong> コマンドがソースファイルだと認識するどの形式でもありえます。</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>include_dirs</em></td>
<td>C/C++ヘッダファイルを検索するディレクトリのリスト(プラットフォーム独立のため Unix 形式で記述する)</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>define_macros</em></td>
<td>定義するマクロのリスト; それぞれのマクロは2要素のタプル <tt class="docutils literal"><span class="pre">(name,</span> <span class="pre">value)</span></tt>
で定義されます。 <em>value</em> には定義しようとしている文字列、または内容なしで定義する場合は <tt class="docutils literal"><span class="pre">None</span></tt>
(ソースコード中で <tt class="docutils literal"><span class="pre">#define</span> <span class="pre">FOO</span></tt> と書く、または Unix
Cコンパイラのコマンドラインで <em class="xref std std-option">-DFOO</em>
を指定するのと等価です)を指定します。</td>
<td>(文字列, 文字列) または
(文字列, <tt class="docutils literal"><span class="pre">None</span></tt>) のタプル</td>
</tr>
<tr class="row-even"><td><em>undef_macros</em></td>
<td>定義を消すマクロのリスト</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>library_dirs</em></td>
<td>リンク時にC/C++ライブラリを検索するディレクトリのリスト</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>libraries</em></td>
<td>リンクするライブラリ名のリスト (ファイル名やパスではない)</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>runtime_library_dirs</em></td>
<td>実行時(shared extensionでは、拡張が読み込まれる時)に
C/C++ライブラリを探索するディレクトリのリスト</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>extra_objects</em></td>
<td>追加でリンクするファイル(&#8216;sources&#8217;に対応するコードが含まれていないファイル、バイナリ形式のリソースファイルなど)のリスト</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>extra_compile_args</em></td>
<td>&#8216;sources&#8217;のソースをコンパイルする時に追加するプラットフォーム特有またはコンパイラ特有の情報コマンドラインを利用できるプラットホームとコンパイラでは、これは通常コマンドライン引数のリストですが、他のプラットホームでも、それは何かに使えます。</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>extra_link_args</em></td>
<td>オブジェクトファイルをリンクして拡張(または新しいPythonインタプリタ)を作る時に追加するプラットフォーム特有またはコンパイラ特有の情報
&#8216;extra_compile_args&#8217;に似た実装です。</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>export_symbols</em></td>
<td>shared
extensionからエクスポートされるシンボルのリスト。全てのプラットフォームでは使われず、
Python拡張(典型的には <tt class="docutils literal"><span class="pre">init</span></tt> +
extension_name という1つのシンボルだけエクスポートする)に一般的に必要なものでもない。</td>
<td>文字列</td>
</tr>
<tr class="row-even"><td><em>depends</em></td>
<td>拡張が依存するファイルのリスト</td>
<td>文字列</td>
</tr>
<tr class="row-odd"><td><em>language</em></td>
<td>拡張の言語 (例: <tt class="docutils literal"><span class="pre">'c'</span></tt>, <tt class="docutils literal"><span class="pre">'c++'</span></tt>,
<tt class="docutils literal"><span class="pre">'objc'</span></tt>)。指定しなければソースの拡張子で検出される。</td>
<td>文字列</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="distutils.core.Distribution">
<em class="property">class </em><tt class="descclassname">distutils.core.</tt><tt class="descname">Distribution</tt><a class="headerlink" href="#distutils.core.Distribution" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> はPythonソフトウェアパッケージをどのようにビルド、インストール、パッケージするかを定義する。</p>
<p><a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> のコンストラクタが取りうるキーワード引数のリストに関しては、 <a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a> 関数を見てください。
<a class="reference internal" href="#distutils.core.setup" title="distutils.core.setup"><tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt></a> は <a class="reference internal" href="#distutils.core.Distribution" title="distutils.core.Distribution"><tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt></a> のインスタンスを作ります。</p>
</dd></dl>

<dl class="class">
<dt id="distutils.core.Command">
<em class="property">class </em><tt class="descclassname">distutils.core.</tt><tt class="descname">Command</tt><a class="headerlink" href="#distutils.core.Command" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.core.Command" title="distutils.core.Command"><tt class="xref py py-class docutils literal"><span class="pre">Command</span></tt></a> クラス(そのサブクラスのインスタンス)はdistutilsのあるコマンドを実装します。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.ccompiler">
<span id="distutils-ccompiler-ccompiler"></span><h2><a class="reference internal" href="#module-distutils.ccompiler" title="distutils.ccompiler: 抽象 CCompiler class"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.ccompiler</span></tt></a> &#8212; CCompiler ベースクラス<a class="headerlink" href="#module-distutils.ccompiler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt></a> クラスの抽象ベースクラスを提供します。
<a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt></a> のインスタンスはプロジェクトにおける全てのコンパイルおよびリンクに使われます。コンパイラのオプションを設定するためのメソッドが提供されます &#8212; マクロ定義、includeディレクトリ、リンクパス、ライブラリなど。</p>
<p>このモジュールは以下の関数を提供します。</p>
<dl class="function">
<dt id="distutils.ccompiler.gen_lib_options">
<tt class="descclassname">distutils.ccompiler.</tt><tt class="descname">gen_lib_options</tt><big>(</big><em>compiler</em>, <em>library_dirs</em>, <em>runtime_library_dirs</em>, <em>libraries</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.gen_lib_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリを探索するディレクトリ、特定のライブラリとのリンクをするためのリンカオプションを生成します。 <em>libraries</em> と
<em>library_dirs</em> はそれぞれライブラリ名(ファイル名ではありません!)のリストと、探索ディレクトリのリストです。
compilerで利用できるコマンドラインオプションのリスト(指定されたフォーマット文字列に依存します)を返します。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.gen_preprocess_options">
<tt class="descclassname">distutils.ccompiler.</tt><tt class="descname">gen_preprocess_options</tt><big>(</big><em>macros</em>, <em>include_dirs</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.gen_preprocess_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Cプリプロセッサオプション(<em class="xref std std-option">-D</em>, <a class="reference internal" href="../using/cmdline.html#cmdoption-U"><em class="xref std std-option">-U</em></a>,
<em class="xref std std-option">-I</em>)を生成します。これらは少なくとも2つのコンパイラで利用可能です。典型的な Unix のコンパイラと、VisualC++です。
<em>macros</em> は1または2要素のタプルで <tt class="docutils literal"><span class="pre">(name,)</span></tt> は <em>name</em> マクロの削除 (-U)を意味し、
<em>(name,value)</em> は <em>name</em> マクロを <em>value</em> として定義(<em class="xref std std-option">-D</em>)します。 <em>include_dirs</em> はディレクトリ名のリストで、ヘッダファイルのサーチパスに追加されます(<em class="xref std std-option">-I</em>)。 Unix のコンパイラと、Visual C++で利用できるコマンドラインオプションのリストを返します。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.get_default_compiler">
<tt class="descclassname">distutils.ccompiler.</tt><tt class="descname">get_default_compiler</tt><big>(</big><em>osname</em>, <em>platform</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.get_default_compiler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたプラットフォームのデフォルトコンパイラを返します。</p>
<p>問い合わせの <em>osname</em> はPython標準のOS名(<tt class="docutils literal"><span class="pre">os.name</span></tt> で返されるもの)のひとつであるべきで、 <em>platform</em> は <tt class="docutils literal"><span class="pre">sys.platform</span></tt> で返される共通の値です。</p>
<p>パラメータが指定されていない場合のデフォルト値は <tt class="docutils literal"><span class="pre">os.name</span></tt> と <tt class="docutils literal"><span class="pre">sys.platform</span></tt> です。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.new_compiler">
<tt class="descclassname">distutils.ccompiler.</tt><tt class="descname">new_compiler</tt><big>(</big><em>plat=None</em>, <em>compiler=None</em>, <em>verbose=0</em>, <em>dry_run=0</em>, <em>force=0</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.new_compiler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたプラットフォーム/コンパイラの組み合わせ向けに、 CCompilerサブクラスのインスタンスを生成するファクトリ関数です。 <em>plat</em>
のデフォルト値は <tt class="docutils literal"><span class="pre">os.name</span></tt> (例: <tt class="docutils literal"><span class="pre">'posix'</span></tt>, <tt class="docutils literal"><span class="pre">'nt'</span></tt>), <em>compiler</em>)、
<em>compiler</em> のデフォルト値はプラトフォームのデフォルトコンパイラです。現在は
<tt class="docutils literal"><span class="pre">'posix'</span></tt> と <tt class="docutils literal"><span class="pre">'nt'</span></tt> だけがサポートされています、デフォルトのコンパイラは &#8220;traditional Unix
interface&#8221; (<tt class="xref py py-class docutils literal"><span class="pre">UnixCCompiler</span></tt> クラス) と、 Visual C++ (<tt class="xref py py-class docutils literal"><span class="pre">MSVCCompiler</span></tt> クラス)
です。 WindowsでUnixコンパイラオブジェクトを要求することも、UnixでMicrosoft
コンパイラオブジェクトを要求することも可能です。 <em>compiler</em> 引数を与えると <em>plat</em> は無視されます。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.ccompiler.show_compilers">
<tt class="descclassname">distutils.ccompiler.</tt><tt class="descname">show_compilers</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.ccompiler.show_compilers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>利用可能なコンパイラのリストを表示します(<strong class="command">build</strong>, <strong class="command">build_ext</strong>,
<strong class="command">build_clib</strong> の、 <em class="xref std std-option">--help-compiler</em> オプションで使われます。)</p>
</dd></dl>

<dl class="class">
<dt id="distutils.ccompiler.CCompiler">
<em class="property">class </em><tt class="descclassname">distutils.ccompiler.</tt><tt class="descname">CCompiler</tt><big>(</big><span class="optional">[</span><em>verbose=0</em>, <em>dry_run=0</em>, <em>force=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>抽象ベースクラス <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt></a> は実際のコンパイラクラスで実装される必要のあるインタフェースを定義しています。このクラスはコンパイラクラスで利用されるユーティリティメソッドも定義しています。</p>
<p>コンパイラ抽象クラスの基本的な前提は、各インスタンスはあるプロジェクトをビルドするときの全コンパイル/リンクで利用できるということです。そこで、コンパイルとリンクステップで共通する属性 &#8212;  インクルードディレクトリ、マクロ定義、リンクするライブラリなど &#8212; はコンパイラインスタンスの属性になります。どのように各ファイルが扱われるかを変更できるように、ほとんどの属性はコンパイルごと、またはリンクごとに与えることができます。</p>
<p>各サブクラスのコンストラクタは Compiler クラスのインスタンスを作ります。フラグは <em>verbose</em> (冗長な出力を表示します)、
<em>dry_run</em> (実際にはそのステップを実行しません)、そして <em>force</em> (依存関係を無視して全て再ビルドします)です。これらのフラグは全てデフォルト値が <tt class="docutils literal"><span class="pre">0</span></tt> (無効)になっています。
<a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt></a> またはサブクラスを直接インスタンス化したくない場合には、かわりに <tt class="xref py py-func docutils literal"><span class="pre">distutils.CCompiler.new_compiler()</span></tt> ファクトリ関数を利用してください。</p>
<p>以下のメソッドで、Compilerクラスのインスタンスが使うコンパイラオプションを手動で変更できます。</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_include_dir">
<tt class="descname">add_include_dir</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_include_dir" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>dir</em> をヘッダファイル探索ディレクトリのリストに追加します。コンパイラは <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><tt class="xref py py-meth docutils literal"><span class="pre">add_include_dir()</span></tt></a> を呼び出した順にディレクトリを探索するよう指定されます。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_include_dirs">
<tt class="descname">set_include_dirs</tt><big>(</big><em>dirs</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_include_dirs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>探索されるディレクトリのリストを <em>dirs</em> (文字列のリスト)に設定します。先に実行された
<a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><tt class="xref py py-meth docutils literal"><span class="pre">add_include_dir()</span></tt></a> は上書きされます。後で実行する <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><tt class="xref py py-meth docutils literal"><span class="pre">add_include_dir()</span></tt></a> は <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_include_dirs" title="distutils.ccompiler.CCompiler.set_include_dirs"><tt class="xref py py-meth docutils literal"><span class="pre">set_include_dirs()</span></tt></a> のリストにディレクトリを追加します。これはコンパイラがデフォルトで探索する標準インクルードディレクトリには影響しません。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_library">
<tt class="descname">add_library</tt><big>(</big><em>libname</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>libname</em> をコンパイラオブジェクトによるリンク時に使われるライブラリのリストに追加します。 <em>libname</em> はライブラリを含むファイル名ではなく、ライブラリそのものの名前です: 実際のファイル名はリンカ、コンパイラ、またはコンパイラクラス(プラットフォームに依存します)から推測されます。</p>
<p>リンカは <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library" title="distutils.ccompiler.CCompiler.add_library"><tt class="xref py py-meth docutils literal"><span class="pre">add_library()</span></tt></a> と <tt class="xref py py-meth docutils literal"><span class="pre">set_library()</span></tt>
で渡された順にライブラリをリンクしようとします。ライブラリ名が重なることは問題ありません。リンカは指定された回数だけライブラリとリンクしようとします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_libraries">
<tt class="descname">set_libraries</tt><big>(</big><em>libnames</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_libraries" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンパイラオブジェクトによるリンク時に使われるライブラリのリストを
<em>libnames</em> (文字列のリスト)に設定します。これはリンカがデフォルトでリンクする標準のシステムライブラリには影響しません。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_library_dir">
<tt class="descname">add_library_dir</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_library_dir" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library" title="distutils.ccompiler.CCompiler.add_library"><tt class="xref py py-meth docutils literal"><span class="pre">add_library()</span></tt></a> と <a class="reference internal" href="#distutils.ccompiler.CCompiler.set_libraries" title="distutils.ccompiler.CCompiler.set_libraries"><tt class="xref py py-meth docutils literal"><span class="pre">set_libraries()</span></tt></a> で指定されたライブラリを探索するディレクトリのリストに <em>dir</em> を追加します。リンカは <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library_dir" title="distutils.ccompiler.CCompiler.add_library_dir"><tt class="xref py py-meth docutils literal"><span class="pre">add_library_dir()</span></tt></a> と
<a class="reference internal" href="#distutils.ccompiler.CCompiler.set_library_dirs" title="distutils.ccompiler.CCompiler.set_library_dirs"><tt class="xref py py-meth docutils literal"><span class="pre">set_library_dirs()</span></tt></a> で指定された順にディレクトリを探索されます。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_library_dirs">
<tt class="descname">set_library_dirs</tt><big>(</big><em>dirs</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_library_dirs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリを探索するディレクトリを <em>dirs</em> (文字列のリスト)に設定します。これはリンカがデフォルトで探索する標準ライブラリ探索パスには影響しません。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_runtime_library_dir">
<tt class="descname">add_runtime_library_dir</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_runtime_library_dir" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時に共有ライブラリを探索するディレクトリのリストに <em>dir</em> を追加します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_runtime_library_dirs">
<tt class="descname">set_runtime_library_dirs</tt><big>(</big><em>dirs</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_runtime_library_dirs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時に共有ライブラリを探索するディレクトリのリストを <em>dir</em> に設定します。これはランタイムリンカがデフォルトで利用する標準探索パスには影響しません。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.define_macro">
<tt class="descname">define_macro</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>value=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.define_macro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンパイラオブジェクトで実行される全てのコンパイルで利用されるプリプロセッサのマクロを定義します。省略可能なパラメータ <em>value</em> は文字列であるべきです。省略された場合は、マクロは特定の値をとらずに定義され、具体的な結果は利用されるコンパイラに依存します。 (XXX 本当に?
これについてANSIで言及されている?)</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.undefine_macro">
<tt class="descname">undefine_macro</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.undefine_macro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンパイラオブジェクトで実行される全てのコンパイルで利用されるプリプロセッサのマクロ定義を消します。同じマクロを <a class="reference internal" href="#distutils.ccompiler.CCompiler.define_macro" title="distutils.ccompiler.CCompiler.define_macro"><tt class="xref py py-meth docutils literal"><span class="pre">define_macro()</span></tt></a> で定義し、 <a class="reference internal" href="#distutils.ccompiler.CCompiler.undefine_macro" title="distutils.ccompiler.CCompiler.undefine_macro"><tt class="xref py py-meth docutils literal"><span class="pre">undefine_macro()</span></tt></a> で定義を削除した場合、後で呼び出されたものが優先される(複数の再定義と削除を含みます)。もしコンパイルごと(すなわち <a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-meth docutils literal"><span class="pre">compile()</span></tt></a> の呼び出しごと)にマクロが再定義/削除される場合も後で呼び出されたものが優先されます。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.add_link_object">
<tt class="descname">add_link_object</tt><big>(</big><em>object</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.add_link_object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンパイラオブジェクトによる全てのリンクで利用されるオブジェクトファイル(または類似のライブラリファイルや
&#8220;リソースコンパイラ&#8221;の出力)のリストに <em>object</em> を追加します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_link_objects">
<tt class="descname">set_link_objects</tt><big>(</big><em>objects</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_link_objects" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコンパイラオブジェクトによる全てのリンクで利用されるオブジェクトファイル(または類似のもの)のリストを <em>objects</em> に設定します。これはリンカがデフォルト利用する標準オブジェクトファイル(システムライブラリなど)には影響しません。</p>
</dd></dl>

<p>以下のメソッドはコンパイラオプションの自動検出を実装しており、 GNU <strong class="program">autoconf</strong> に似たいくつかの機能を提供します。</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.detect_language">
<tt class="descname">detect_language</tt><big>(</big><em>sources</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.detect_language" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたファイルまたはファイルのリストの言語を検出します。インスタンス属性 <tt class="xref py py-attr docutils literal"><span class="pre">language_map</span></tt> (辞書)と、
<tt class="xref py py-attr docutils literal"><span class="pre">language_order</span></tt> (リスト)を仕事に使います。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.find_library_file">
<tt class="descname">find_library_file</tt><big>(</big><em>dirs</em>, <em>lib</em><span class="optional">[</span>, <em>debug=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.find_library_file" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたディレクトリのリストから、スタティックまたは共有ライブラリファイル <em>lib</em> を探し、そのファイルのフルパスを返します。もし <em>debug</em> が真なら、(現在のプラットフォームで意味があれば)デバッグ版を探します。指定されたどのディレクトリでも <em>lib</em> が見つからなければ
<tt class="docutils literal"><span class="pre">None</span></tt> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.has_function">
<tt class="descname">has_function</tt><big>(</big><em>funcname</em><span class="optional">[</span>, <em>includes=None</em>, <em>include_dirs=None</em>, <em>libraries=None</em>, <em>library_dirs=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.has_function" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>funcname</em> が現在のプラットフォームでサポートされているかどうかをブール値で返します。省略可能引数は追加のインクルードファイルやパス、ライブラリやパスを与えることでコンパイル環境を指定します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.library_dir_option">
<tt class="descname">library_dir_option</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.library_dir_option" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>dir</em> をライブラリ探索ディレクトリに追加するコンパイラオプションを返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.library_option">
<tt class="descname">library_option</tt><big>(</big><em>lib</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.library_option" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有ライブラリまたは実行ファイルにリンクされるライブラリ一覧に <em>lib</em> を追加するコンパイラオプションを返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.runtime_library_dir_option">
<tt class="descname">runtime_library_dir_option</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.runtime_library_dir_option" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ランタイムライブラリを検索するディレクトリのリストに  <em>dir</em> を追加するコンパイラオプションを返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.set_executables">
<tt class="descname">set_executables</tt><big>(</big><em>**args</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.set_executables" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンパイルのいろいろなステージで実行される実行ファイル(とその引数)を定義します。コンパイラクラス(の &#8216;executables&#8217; 属性)によって実行ファイルのセットは変わる可能性がありますが、ほとんどは以下のものを持っています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">attribute</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>compiler</em></td>
<td>C/C++ コンパイラ</td>
</tr>
<tr class="row-odd"><td><em>linker_so</em></td>
<td>シェアードオブジェクト、ライブラリを作るために使うリンカ</td>
</tr>
<tr class="row-even"><td><em>linker_exe</em></td>
<td>バイナリ実行可能ファイルを作るために使うリンカ</td>
</tr>
<tr class="row-odd"><td><em>archiver</em></td>
<td>静的ライブラリを作るアーカイバ</td>
</tr>
</tbody>
</table>
<p>コマンドラインをもつプラットフォーム(Unix, DOS/Windows)では、それぞれの文字列は実行ファイル名と(省略可能な)引数リストに分割されます。(文字列の分割は Unix のシェルが行うものに似ています: 単語はスペースで区切られますが、クォートとバックスラッシュでオーバーライドできます。  <a class="reference internal" href="#distutils.util.split_quoted" title="distutils.util.split_quoted"><tt class="xref py py-func docutils literal"><span class="pre">distutils.util.split_quoted()</span></tt></a> をごらんください。)</p>
</dd></dl>

<p>以下のメソッドはビルドプロセスのステージを呼び出します。</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.compile">
<tt class="descname">compile</tt><big>(</big><em>sources</em><span class="optional">[</span>, <em>output_dir=None</em>, <em>macros=None</em>, <em>include_dirs=None</em>, <em>debug=0</em>, <em>extra_preargs=None</em>, <em>extra_postargs=None</em>, <em>depends=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.compile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つ以上のソースファイルをコンパイルします。オブジェクトファイルを生成 (たとえば <tt class="file docutils literal"><span class="pre">.c</span></tt> ファイルを
<tt class="file docutils literal"><span class="pre">.o</span></tt> ファイルに変換)します。</p>
<p><em>sources</em> はファイル名のリストである必要があります。おそらく C/C++ ファイルですが、実際にはコンパイラとコンパイラクラスで扱えるもの(例:
<tt class="xref py py-class docutils literal"><span class="pre">MSVCCompiler</span></tt> はリソースファイルを <em>sources</em> にとることができます)なら何でも指定できます。
<em>sources</em> のソースファイルひとつずつに対応するオブジェクトファイル名のリストを返します。実装に依存しますが、全てのソースファイルがコンパイルされる必要はありません。しかし全ての対応するオブジェクトファイル名が返ります。</p>
<p>もし <em>output_dir</em> が指定されていれば、オブジェクトファイルはその下に、オリジナルのパスを維持した状態で置かれます。つまり、
<tt class="file docutils literal"><span class="pre">foo/bar.c</span></tt> は通常コンパイルされて <tt class="file docutils literal"><span class="pre">foo/bar.o</span></tt> になります (Unix実装の場合)が、もし <em>output_dir</em> が
<em>build</em> であれば、 <tt class="file docutils literal"><span class="pre">build/foo/bar.o</span></tt> になります。</p>
<p><em>macros</em> は(もし指定されていれば)マクロ定義のリストである必要があります。マクロ定義は <tt class="docutils literal"><span class="pre">(name,</span>
<span class="pre">value)</span></tt> という形式の2要素のタプル、または <tt class="docutils literal"><span class="pre">(name,)</span></tt> という形式の1要素のタプルのどちらかです。前者はマクロを定義します。もし value が <tt class="docutils literal"><span class="pre">None</span></tt> であれば、マクロは特定の値をもたないで定義されます。1要素のタプルはマクロ定義を削除します。後で実行された定義/再定義/削除が優先されます。</p>
<p><em>include_dirs</em> は(もし指定されていれば)文字列のリストである必要があります。このコンパイルだけで有効な、デフォルトのインクルードファイルの検索ディレクトリに追加するディレクトリ群を指定します。</p>
<p><em>debug</em> はブーリアン値です。もし真なら、コンパイラはデバッグシンボルをオブジェクトファイルに(または別ファイルに)出力します。</p>
<p><em>extra_postargs</em> と <em>extra_postargs</em> は実装依存です。コマンドラインをもっているプラットフォーム(例 Unix,
DOS/Windows)では、おそらく文字列のリスト: コンパイラのコマンドライン引数の前/後に追加するコマンドライン引数です。他のプラットフォームでは、実装クラスのドキュメントを参照してください。どの場合でも、これらの引数は抽象コンパイラフレームワークが期待に沿わない時の脱出口として意図されています。</p>
<p><em>depends</em> は(もし指定されていれば)ターゲットが依存しているファイル名のリストです。ソースファイルが依存しているファイルのどれかより古ければ、ソースファイルは再コンパイルされます。これは依存関係のトラッキングをサポートしていますが、荒い粒度でしか行われません。</p>
<p>失敗すると <tt class="xref py py-exc docutils literal"><span class="pre">CompileError</span></tt> を起こします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.create_static_lib">
<tt class="descname">create_static_lib</tt><big>(</big><em>objects</em>, <em>output_libname</em><span class="optional">[</span>, <em>output_dir=None</em>, <em>debug=0</em>, <em>target_lang=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.create_static_lib" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>静的ライブラリファイルを作るために元ファイル群をリンクします。「元ファイル群」は <em>objects</em> で指定されたオブジェクトファイルのリストを基礎にしています。追加のオブジェクトファイルを <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_link_object" title="distutils.ccompiler.CCompiler.add_link_object"><tt class="xref py py-meth docutils literal"><span class="pre">add_link_object()</span></tt></a> および/または
<a class="reference internal" href="#distutils.ccompiler.CCompiler.set_link_objects" title="distutils.ccompiler.CCompiler.set_link_objects"><tt class="xref py py-meth docutils literal"><span class="pre">set_link_objects()</span></tt></a> で指定し、追加のライブラリを <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library" title="distutils.ccompiler.CCompiler.add_library"><tt class="xref py py-meth docutils literal"><span class="pre">add_library()</span></tt></a> および/または
<a class="reference internal" href="#distutils.ccompiler.CCompiler.set_libraries" title="distutils.ccompiler.CCompiler.set_libraries"><tt class="xref py py-meth docutils literal"><span class="pre">set_libraries()</span></tt></a> で指定します。そして <em>libraries</em> で指定されたライブラリです。</p>
<p><em>output_libname</em> はライブラリ名で、ファイル名ではありません; ファイル名はライブラリ名から作られます。 <em>output_dir</em> はライブラリファイルが起かれるディレクトリです。
<em>debug</em> はブール値です。真なら、デバッグ情報がライブラリに含まれます(ほとんどのプラットフォームではコンパイルステップで意味をもちます:
<em>debug</em> フラグは一貫性のためにここにもあります。)。</p>
<p><em>target_lang</em> はオブジェクトがコンパイルされる対象になる言語です。これはその言語特有のリンク時の処理を可能にします。</p>
<p>失敗すると <tt class="xref py py-exc docutils literal"><span class="pre">LibError</span></tt> を起こします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link">
<tt class="descname">link</tt><big>(</big><em>target_desc</em>, <em>objects</em>, <em>output_filename</em><span class="optional">[</span>, <em>output_dir=None</em>, <em>libraries=None</em>, <em>library_dirs=None</em>, <em>runtime_library_dirs=None</em>, <em>export_symbols=None</em>, <em>debug=0</em>, <em>extra_preargs=None</em>, <em>extra_postargs=None</em>, <em>build_temp=None</em>, <em>target_lang=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.link" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行ファイルまたは共有ライブラリファイルを作るために元ファイル群をリンクします。</p>
<p>「元ファイル群」は <em>objects</em> で指定されたオブジェクトファイルのリストを基礎にしています。 <em>output_filename</em> はファイル名です。もし
<em>output_dir</em> が指定されていれば、それに対する相対パスとして
<em>output_filename</em> は扱われます(必要ならば <em>output_filename</em> はディレクトリ名を含むことができます。)。</p>
<p><em>libraries</em> はリンクするライブラリのリストです。これはファイル名ではなくライブラリ名で指定します。プラットフォーム依存の方式でファイル名に変換されます(例: <em>foo</em> はUnix では <tt class="file docutils literal"><span class="pre">libfoo.a</span></tt> に、DOS/Windowsでは
<tt class="file docutils literal"><span class="pre">foo.lib</span></tt> になります。 )。ただしこれらはディレクトリ名を含むことができ、その場合はリンカは通常の場所全体を探すのではなく特定のディレクトリを参照します。</p>
<p><em>library_dirs</em> はもし指定されるならば、修飾されていない(ディレクトリ名を含んでいない)ライブラリ名で指定されたライブラリを探索するディレクトリのリストです。これはシステムのデフォルトより優先され、 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_library_dir" title="distutils.ccompiler.CCompiler.add_library_dir"><tt class="xref py py-meth docutils literal"><span class="pre">add_library_dir()</span></tt></a> と/または
<a class="reference internal" href="#distutils.ccompiler.CCompiler.set_library_dirs" title="distutils.ccompiler.CCompiler.set_library_dirs"><tt class="xref py py-meth docutils literal"><span class="pre">set_library_dirs()</span></tt></a> に渡されます。 <em>runtime_library_dirs</em> は共有ライブラリに埋め込まれるディレクトリのリストで、実行時にそれが依存する共有ライブラリのパスを指定します(これはUnixでだけ意味があるかもしれません。)。</p>
<p><em>export_symbols</em> は共有ライブラリがエクスポートするシンボルのリストです。 (これはWindowsだけで意味があるようです。)</p>
<p><em>debug</em> は <a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-meth docutils literal"><span class="pre">compile()</span></tt></a> や <a class="reference internal" href="#distutils.ccompiler.CCompiler.create_static_lib" title="distutils.ccompiler.CCompiler.create_static_lib"><tt class="xref py py-meth docutils literal"><span class="pre">create_static_lib()</span></tt></a> と同じですが、少しだけ違いがあり、(<a class="reference internal" href="#distutils.ccompiler.CCompiler.create_static_lib" title="distutils.ccompiler.CCompiler.create_static_lib"><tt class="xref py py-meth docutils literal"><span class="pre">create_static_lib()</span></tt></a> では <em>debug</em> フラグは形式をあわせるために存在していたのに対して)ほとんどのプラットフォームで意識されます。</p>
<p><em>extra_preargs</em> と <em>extra_postargs</em> は <a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-meth docutils literal"><span class="pre">compile()</span></tt></a>
と同じですが、コンパイラではなくリンカへの引数として扱われます。</p>
<p><em>target_lang</em> は指定されたオブジェクトがコンパイルされた対象言語です。リンク時に言語特有の処理を行えるようにします。</p>
<p>失敗すると <tt class="xref py py-exc docutils literal"><span class="pre">LinkError</span></tt> が起きます。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link_executable">
<tt class="descname">link_executable</tt><big>(</big><em>objects</em>, <em>output_progname</em><span class="optional">[</span>, <em>output_dir=None</em>, <em>libraries=None</em>, <em>library_dirs=None</em>, <em>runtime_library_dirs=None</em>, <em>debug=0</em>, <em>extra_preargs=None</em>, <em>extra_postargs=None</em>, <em>target_lang=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.link_executable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行ファイルをリンクします。 <em>output_progname</em> は実行ファイルの名前です。 <em>objects</em> はリンクされるオブジェクトのファイル名のリストです。他の引数は <a class="reference internal" href="#distutils.ccompiler.CCompiler.link" title="distutils.ccompiler.CCompiler.link"><tt class="xref py py-meth docutils literal"><span class="pre">link()</span></tt></a> メソッドと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link_shared_lib">
<tt class="descname">link_shared_lib</tt><big>(</big><em>objects</em>, <em>output_libname</em><span class="optional">[</span>, <em>output_dir=None</em>, <em>libraries=None</em>, <em>library_dirs=None</em>, <em>runtime_library_dirs=None</em>, <em>export_symbols=None</em>, <em>debug=0</em>, <em>extra_preargs=None</em>, <em>extra_postargs=None</em>, <em>build_temp=None</em>, <em>target_lang=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.link_shared_lib" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有ライブラリをリンクします。 <em>output_libname</em> は出力先のライブラリ名です。 <em>objects</em> はリンクされるオブジェクトのファイル名のリストです。他の引数は <a class="reference internal" href="#distutils.ccompiler.CCompiler.link" title="distutils.ccompiler.CCompiler.link"><tt class="xref py py-meth docutils literal"><span class="pre">link()</span></tt></a> メソッドと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.link_shared_object">
<tt class="descname">link_shared_object</tt><big>(</big><em>objects</em>, <em>output_filename</em><span class="optional">[</span>, <em>output_dir=None</em>, <em>libraries=None</em>, <em>library_dirs=None</em>, <em>runtime_library_dirs=None</em>, <em>export_symbols=None</em>, <em>debug=0</em>, <em>extra_preargs=None</em>, <em>extra_postargs=None</em>, <em>build_temp=None</em>, <em>target_lang=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.link_shared_object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有オブジェクトをリンクします。 <em>output_filename</em> は出力先の共有オブジェクト名です。 <em>objects</em> はリンクされるオブジェクトのファイル名のリストです。他の引数は <a class="reference internal" href="#distutils.ccompiler.CCompiler.link" title="distutils.ccompiler.CCompiler.link"><tt class="xref py py-meth docutils literal"><span class="pre">link()</span></tt></a> メソッドと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.preprocess">
<tt class="descname">preprocess</tt><big>(</big><em>source</em><span class="optional">[</span>, <em>output_file=None</em>, <em>macros=None</em>, <em>include_dirs=None</em>, <em>extra_preargs=None</em>, <em>extra_postargs=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.preprocess" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>source</em> で指定されたひとつの C/C++ソースファイルをプリプロセスします。出力先のファイルは <em>output_file</em> か、もし
<em>output_file</em> が指定されていなければ <em>stdout</em> になります。 <em>macro</em> は <a class="reference internal" href="../library/functions.html#compile" title="compile"><tt class="xref py py-meth docutils literal"><span class="pre">compile()</span></tt></a> と同様にマクロ定義のリストで、
<a class="reference internal" href="#distutils.ccompiler.CCompiler.define_macro" title="distutils.ccompiler.CCompiler.define_macro"><tt class="xref py py-meth docutils literal"><span class="pre">define_macro()</span></tt></a> や <a class="reference internal" href="#distutils.ccompiler.CCompiler.undefine_macro" title="distutils.ccompiler.CCompiler.undefine_macro"><tt class="xref py py-meth docutils literal"><span class="pre">undefine_macro()</span></tt></a> によって引数になります。
<em>include_dirs</em> はデフォルトのリストに追加されるディレクトリ名のリストで、 <a class="reference internal" href="#distutils.ccompiler.CCompiler.add_include_dir" title="distutils.ccompiler.CCompiler.add_include_dir"><tt class="xref py py-meth docutils literal"><span class="pre">add_include_dir()</span></tt></a> と同じ方法で扱われます。</p>
<p>失敗すると <tt class="xref py py-exc docutils literal"><span class="pre">PreprocessError</span></tt> が起きます。</p>
</dd></dl>

<p>以下のユーティリティメソッドは具体的なサブクラスで使うために、 <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt></a> クラスで定義されています。</p>
<dl class="method">
<dt id="distutils.ccompiler.CCompiler.executable_filename">
<tt class="descname">executable_filename</tt><big>(</big><em>basename</em><span class="optional">[</span>, <em>strip_dir=0</em>, <em>output_dir=''</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.executable_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>basename</em> で指定された実行ファイルのファイル名を返します。
Windows以外の典型的なプラットフォームではbasenameそのままが、Windowsでは <tt class="file docutils literal"><span class="pre">.exe</span></tt> が追加されたものが返ります。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.library_filename">
<tt class="descname">library_filename</tt><big>(</big><em>libname</em><span class="optional">[</span>, <em>lib_type='static'</em>, <em>strip_dir=0</em>, <em>output_dir=''</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.library_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のプラットフォームでのライブラリファイル名を返します。
Unixで <em>lib_type</em> が <tt class="docutils literal"><span class="pre">'static'</span></tt> の場合、 <tt class="file docutils literal"><span class="pre">liblibname.a</span></tt> の形式を返し、 <em>lib_type</em> が
<tt class="docutils literal"><span class="pre">'dynamic'</span></tt> の場合は <tt class="file docutils literal"><span class="pre">liblibname.so</span></tt> の形式を返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.object_filenames">
<tt class="descname">object_filenames</tt><big>(</big><em>source_filenames</em><span class="optional">[</span>, <em>strip_dir=0</em>, <em>output_dir=''</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.object_filenames" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたソースファイルに対応するオブジェクトファイル名を返します。 <em>source_filenames</em> はファイル名のリストです。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.shared_object_filename">
<tt class="descname">shared_object_filename</tt><big>(</big><em>basename</em><span class="optional">[</span>, <em>strip_dir=0</em>, <em>output_dir=''</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.shared_object_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>basename</em> に対応する共有オブジェクトファイルのファイル名を返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.execute">
<tt class="descname">execute</tt><big>(</big><em>func</em>, <em>args</em><span class="optional">[</span>, <em>msg=None</em>, <em>level=1</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.execute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.util.execute" title="distutils.util.execute"><tt class="xref py py-func docutils literal"><span class="pre">distutils.util.execute()</span></tt></a> を呼びだします。このメソッドはログを取り、 <em>dry_run</em> フラグを考慮にいれて、
Python関数 <em>func</em> に引数 <em>args</em> を与えて呼びだします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.spawn">
<tt class="descname">spawn</tt><big>(</big><em>cmd</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.spawn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="xref py py-func docutils literal"><span class="pre">distutils.util.spawn()</span></tt> を呼び出します。これは指定したコマンドを実行する外部プロセスを呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.mkpath">
<tt class="descname">mkpath</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>mode=511</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.mkpath" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.dir_util.mkpath" title="distutils.dir_util.mkpath"><tt class="xref py py-func docutils literal"><span class="pre">distutils.dir_util.mkpath()</span></tt></a> を呼び出します。これは親ディレクトリ込みでディレクトリを作成します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.move_file">
<tt class="descname">move_file</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.move_file" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.file_util.move_file" title="distutils.file_util.move_file"><tt class="xref py py-meth docutils literal"><span class="pre">distutils.file_util.move_file()</span></tt></a> を呼び出します。 <em>src</em> を <em>dst</em> にリネームします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.announce">
<tt class="descname">announce</tt><big>(</big><em>msg</em><span class="optional">[</span>, <em>level=1</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.announce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="xref py py-func docutils literal"><span class="pre">distutils.log.debug()</span></tt> 関数を使ってメッセージを書き出します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.warn">
<tt class="descname">warn</tt><big>(</big><em>msg</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.warn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>警告メッセージ <em>msg</em> を標準エラー出力に書き出します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.ccompiler.CCompiler.debug_print">
<tt class="descname">debug_print</tt><big>(</big><em>msg</em><big>)</big><a class="headerlink" href="#distutils.ccompiler.CCompiler.debug_print" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もしこの <a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt></a> インスタンスで <em>debug</em> フラグが指定されていれば <em>msg</em> を標準出力に出力し、そうでなければ何も出力しません。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-distutils.unixccompiler">
<span id="distutils-unixccompiler-unix-c"></span><h2><a class="reference internal" href="#module-distutils.unixccompiler" title="distutils.unixccompiler: UNIX C Compiler"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.unixccompiler</span></tt></a> &#8212; Unix C コンパイラ<a class="headerlink" href="#module-distutils.unixccompiler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">UnixCCompiler</span></tt> クラスを提供します。
<tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt> クラスのサブクラスで、典型的なUnixスタイルのコマンドラインCコンパイラを扱います:</p>
<ul class="simple">
<li>マクロは <em class="xref std std-option">-Dname[=value]</em> で定義されます。</li>
<li>マクロは <em class="xref std std-option">-Uname</em> で削除されます。</li>
<li>インクルードファイルの探索ディレクトリは <em class="xref std std-option">-Idir</em> で指定されます。</li>
<li>ライブラリは <em class="xref std std-option">-llib</em> で指定されます。</li>
<li>ライブラリの探索ディレクトリは <em class="xref std std-option">-Ldir</em> で指定されます。</li>
<li>コンパイルは <strong class="program">cc</strong> (またはそれに似た) 実行ファイルに、 <a class="reference internal" href="../using/cmdline.html#cmdoption-c"><em class="xref std std-option">-c</em></a> オプションをつけて実行します:
<tt class="file docutils literal"><span class="pre">.c</span></tt> を <tt class="file docutils literal"><span class="pre">.o</span></tt> にコンパイルします。</li>
<li>静的ライブラリは <strong class="program">ar</strong> コマンドで処理されます (<strong class="program">ranlib</strong> を使うかもしれません)</li>
<li>共有ライブラリのリンクは <strong class="program">cc</strong> <em class="xref std std-option">-shared</em> で処理されます。</li>
</ul>
</div>
<div class="section" id="module-distutils.msvccompiler">
<span id="distutils-msvccompiler-microsoft"></span><h2><a class="reference internal" href="#module-distutils.msvccompiler" title="distutils.msvccompiler: Microsoft Compiler"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.msvccompiler</span></tt></a> &#8212; Microsoft コンパイラ<a class="headerlink" href="#module-distutils.msvccompiler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">MSVCCompiler</span></tt> クラスを提供します。抽象クラス <tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt> の具象クラスでMicrosoft
Visual Studio向けのものです。一般的に、拡張モジュールはPythonをコンパイルしたのと同じコンパイラでコンパイルする必要があります。Python 2.3 やそれ以前では、コンパイラはVisual Studio 6でした。 Python 2.4 と Python 2.5
では、コンパイラは Visual Studio .NET 2003 です。 AMD64 と Itanium バイナリは Platform SDK
を利用して作成されました。</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">MSVCCompiler</span></tt> は大体正しいコンパイラ、リンカその他を選びます。この選択を上書きするためには、環境変数
<em>DISTUTILS_USE_SDK</em> と <em>MSSdk</em> の両方を設定する必要があります。 <em>MSSdk</em> は現在の環境をセットアップした
<tt class="docutils literal"><span class="pre">SetEnv.Cmd</span></tt> スクリプト、もしくは環境変数がSDKをインストールした時に登録されたものであることを示します。
<em>DISTUTILS_USE_SDK</em> はdistutilsのユーザーが明示的に <tt class="xref py py-class docutils literal"><span class="pre">MSVCCompiler</span></tt> が選んだコンパイラを上書きすることを示します。</p>
</div>
<div class="section" id="module-distutils.bcppcompiler">
<span id="distutils-bcppcompiler-borland"></span><h2><a class="reference internal" href="#module-distutils.bcppcompiler" title="distutils.bcppcompiler"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.bcppcompiler</span></tt></a> &#8212; Borland コンパイラ<a class="headerlink" href="#module-distutils.bcppcompiler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">BorlandCCompiler</span></tt> クラスを提供します。抽象クラス <tt class="xref py py-class docutils literal"><span class="pre">CCompiler</span></tt> の具象クラスでBorland C++ コンパイラ向けです。</p>
</div>
<div class="section" id="module-distutils.cygwinccompiler">
<span id="distutils-cygwincompiler-cygwin"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">distutils.cygwincompiler</span></tt> &#8212; Cygwin コンパイラ<a class="headerlink" href="#module-distutils.cygwinccompiler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">CygwinCCompiler</span></tt> クラスを提供します。 <tt class="xref py py-class docutils literal"><span class="pre">UnixCCompiler</span></tt> のサブクラスで
Cygwinに移植されたWindows用の GNU C コンパイラ向けです。さらに <tt class="xref py py-class docutils literal"><span class="pre">Mingw32CCompiler</span></tt>
クラスを含んでおり、これは mingw32 向けに移植された GCC (cygwinの no-cygwin モードと同じ)向けです。</p>
</div>
<div class="section" id="module-distutils.emxccompiler">
<span id="distutils-emxccompiler-os-2-emx"></span><h2><a class="reference internal" href="#module-distutils.emxccompiler" title="distutils.emxccompiler: OS/2 EMX Compiler support"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.emxccompiler</span></tt></a> &#8212; OS/2 EMX コンパイラ<a class="headerlink" href="#module-distutils.emxccompiler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">EMXCCompiler</span></tt> クラスを提供します。 <tt class="xref py py-class docutils literal"><span class="pre">UnixCCompiler</span></tt> のサブクラスで GNU C
コンパイラの  OS/2 向け EMX ポートを扱います。</p>
</div>
<div class="section" id="module-distutils.archive_util">
<span id="distutils-archive-util"></span><h2><a class="reference internal" href="#module-distutils.archive_util" title="distutils.archive_util: Utility functions for creating archive files (tarballs, zip files, ...)"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.archive_util</span></tt></a> &#8212;  アーカイブユーティリティ<a class="headerlink" href="#module-distutils.archive_util" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールはアーカイブファイル(tarやzip)を作成する関数を提供します。</p>
<dl class="function">
<dt id="distutils.archive_util.make_archive">
<tt class="descclassname">distutils.archive_util.</tt><tt class="descname">make_archive</tt><big>(</big><em>base_name</em>, <em>format</em><span class="optional">[</span>, <em>root_dir=None</em>, <em>base_dir=None</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.archive_util.make_archive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アーカイブファイル(例: <tt class="docutils literal"><span class="pre">zip</span></tt> や <tt class="docutils literal"><span class="pre">tar</span></tt>)を作成します。 <em>base_name</em> は作成するファイル名からフォーマットの拡張子を除いたものです。
<em>format</em> はアーカイブのフォーマットで <tt class="docutils literal"><span class="pre">zip</span></tt>, <tt class="docutils literal"><span class="pre">tar</span></tt>, <tt class="docutils literal"><span class="pre">ztar</span></tt>, <tt class="docutils literal"><span class="pre">gztar</span></tt> のいずれかです。
<em>root_dir</em> はアーカイブのルートディレクトリになるディレクトリです: つまりアーカイブを作成する前に <em>root_dir</em> に <em>chdir</em> します。
<em>base_dir</em> はアーカイブの起点となるディレクトリです: つまり <em>base_dir</em> はアーカイブ中の全ファイルおよびディレクトリの前につくディレクトリ名です。 <em>root_dir</em> と
<em>base_dir</em> はともにカレントディレクトリがデフォルト値です。アーカイブファイル名を返します。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.archive_util.make_tarball">
<tt class="descclassname">distutils.archive_util.</tt><tt class="descname">make_tarball</tt><big>(</big><em>base_name</em>, <em>base_dir</em><span class="optional">[</span>, <em>compress='gzip'</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.archive_util.make_tarball" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>base_dir</em> 以下の全ファイルから、tarファイルを作成(オプションで圧縮)します。
<em>compress</em> は <tt class="docutils literal"><span class="pre">'gzip'</span></tt>, <tt class="docutils literal"><span class="pre">'compress'</span></tt>, <tt class="docutils literal"><span class="pre">'bzip2'</span></tt>,または
<tt class="docutils literal"><span class="pre">None</span></tt> である必要があります。 <strong class="program">tar</strong> と <em>compress</em> で指定された圧縮ユーティリティにはパスが通っている必要があるので、これはおそらくUnix だけで有効です。出力tarファイルは
<tt class="file docutils literal"><span class="pre">base_dir.tar</span></tt> という名前になり、圧縮によって拡張子がつきます(<tt class="file docutils literal"><span class="pre">.gz</span></tt>, <tt class="file docutils literal"><span class="pre">.bz2</span></tt> または
<tt class="file docutils literal"><span class="pre">.Z</span></tt>)。出力ファイル名が返ります。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.archive_util.make_zipfile">
<tt class="descclassname">distutils.archive_util.</tt><tt class="descname">make_zipfile</tt><big>(</big><em>base_name</em>, <em>base_dir</em><span class="optional">[</span>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.archive_util.make_zipfile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>base_dir</em> 以下の全ファイルから、zipファイルを作成します。出力されるzipファイルは <em>base_name</em> +
<tt class="file docutils literal"><span class="pre">.zip</span></tt> という名前になります。 <a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: ZIP-フォーマットのアーカイブファイルを読み書きする"><tt class="xref py py-mod docutils literal"><span class="pre">zipfile</span></tt></a> Pythonモジュール(利用可能なら)またはInfoZIP
<tt class="file docutils literal"><span class="pre">zip</span></tt> ユーティリティ(インストールされていてパスが通っているなら)を使います。もしどちらも利用できなければ、 <tt class="xref py py-exc docutils literal"><span class="pre">DistutilsExecError</span></tt> が起きます。出力zipファイル名が返ります。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.dep_util">
<span id="distutils-dep-util"></span><h2><a class="reference internal" href="#module-distutils.dep_util" title="distutils.dep_util: Utility functions for simple dependency checking"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.dep_util</span></tt></a> &#8212; 依存関係のチェック<a class="headerlink" href="#module-distutils.dep_util" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールはシンプルなタイムスタンプを元にしたファイルやファイル群の依存関係を処理する関数を提供します。さらに、それらの依存関係解析を元にした関数を提供します。</p>
<dl class="function">
<dt id="distutils.dep_util.newer">
<tt class="descclassname">distutils.dep_util.</tt><tt class="descname">newer</tt><big>(</big><em>source</em>, <em>target</em><big>)</big><a class="headerlink" href="#distutils.dep_util.newer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>source</em> が存在して、 <em>target</em> より最近変更されている、または <em>source</em> が存在して、 <em>target</em> が存在していない場合は真を返します。両方が存在していて、 <em>target</em> のほうが <em>source</em> より新しいか同じ場合には偽を返します。 <em>source</em> が存在しない場合には
<tt class="xref py py-exc docutils literal"><span class="pre">DistutilsFileError</span></tt> を起こします。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dep_util.newer_pairwise">
<tt class="descclassname">distutils.dep_util.</tt><tt class="descname">newer_pairwise</tt><big>(</big><em>sources</em>, <em>targets</em><big>)</big><a class="headerlink" href="#distutils.dep_util.newer_pairwise" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ふたつのファイル名リストを並列に探索して、それぞれのソースが対応するターゲットより新しいかをテストします。 <a class="reference internal" href="#distutils.dep_util.newer" title="distutils.dep_util.newer"><tt class="xref py py-func docutils literal"><span class="pre">newer()</span></tt></a> の意味でターゲットよりソースが新しいペアのリスト(<em>sources</em>,*targets*)を返します。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dep_util.newer_group">
<tt class="descclassname">distutils.dep_util.</tt><tt class="descname">newer_group</tt><big>(</big><em>sources</em>, <em>target</em><span class="optional">[</span>, <em>missing='error'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.dep_util.newer_group" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>target</em> が <em>source</em> にリストアップされたどれかのファイルより古ければ真を返します。言い換えれば、 <em>target</em> が存在して
<em>sources</em> の全てより新しいなら偽を返し、そうでなければ真を返します。 <em>missing</em> はソースファイルが存在しなかった時の振る舞いを決定します。デフォルト(<tt class="docutils literal"><span class="pre">'error'</span></tt>)は <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><tt class="xref py py-func docutils literal"><span class="pre">os.stat()</span></tt></a> で <a class="reference internal" href="../library/exceptions.html#exceptions.OSError" title="exceptions.OSError"><tt class="xref py py-exc docutils literal"><span class="pre">OSError</span></tt></a>
例外を起こします。もし <tt class="docutils literal"><span class="pre">'ignore'</span></tt> なら、単に存在しないソースファイルを無視します。もし <tt class="docutils literal"><span class="pre">'newer'</span></tt> なら、存在しないソースファイルについては <em>target</em> が古いとみなします(これは&#8221;dry-tun&#8221;モードで便利です:
入力がないのでコマンドは実行できませんが実際に実行しようとしていないので問題になりません)。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.dir_util">
<span id="distutils-dir-util"></span><h2><a class="reference internal" href="#module-distutils.dir_util" title="distutils.dir_util: Utility functions for operating on directories and directory trees"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.dir_util</span></tt></a> &#8212; ディレクトリツリーの操作<a class="headerlink" href="#module-distutils.dir_util" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールはディレクトリとディレクトリツリーを操作する関数を提供します。</p>
<dl class="function">
<dt id="distutils.dir_util.mkpath">
<tt class="descclassname">distutils.dir_util.</tt><tt class="descname">mkpath</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>mode=0777</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.dir_util.mkpath" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ディレクトリと、必要な親ディレクトリを作成します。もしディレクトリが既に存在している(<em>name</em> が空文字列の場合、カレントディレクトリを示すのでもちろん存在しています)場合、何もしません。ディレクトリを作成できなかった場合(例: ディレクトリと同じ名前のファイルが既に存在していた)、 <tt class="xref py py-exc docutils literal"><span class="pre">DistutilsFileError</span></tt> を起こします。もし
<em>verbose</em> が真なら、それぞれのmkdirについて1行、標準出力に出力します。実際に作成されたディレクトリのリストを返します。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dir_util.create_tree">
<tt class="descclassname">distutils.dir_util.</tt><tt class="descname">create_tree</tt><big>(</big><em>base_dir</em>, <em>files</em><span class="optional">[</span>, <em>mode=0777</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.dir_util.create_tree" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>files</em> を置くために必要な空ディレクトリを <em>base_dir</em> 以下に作成します。 <em>base_dir</em> ディレクトリは存在している必要はありません。
<em>files</em> はファイル名のリストで <em>base_dir</em> からの相対パスとして扱われます。 <em>base_dir</em> + <em>files</em> のディレクトリ部分が(既に存在していなければ)作成されます。 <em>mode</em>, <em>verbose</em> と <em>dry_run</em> フラグは <a class="reference internal" href="#distutils.dir_util.mkpath" title="distutils.dir_util.mkpath"><tt class="xref py py-func docutils literal"><span class="pre">mkpath()</span></tt></a> と同じです。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dir_util.copy_tree">
<tt class="descclassname">distutils.dir_util.</tt><tt class="descname">copy_tree</tt><big>(</big><em>src</em>, <em>dst</em><span class="optional">[</span>, <em>preserve_mode=1</em>, <em>preserve_times=1</em>, <em>preserve_symlinks=0</em>, <em>update=0</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.dir_util.copy_tree" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>src</em> ディレクトリツリー全体を <em>dst</em> にコピーします。 <em>src</em> と <em>dst</em> はどちらもディレクトリ名である必要があります。もし <em>src</em> がディレクトリでなければ、 <tt class="xref py py-exc docutils literal"><span class="pre">DistutilsFileError</span></tt>
を起こします。もし <em>dst</em> が存在しなければ、 <a class="reference internal" href="#distutils.dir_util.mkpath" title="distutils.dir_util.mkpath"><tt class="xref py py-func docutils literal"><span class="pre">mkpath()</span></tt></a> で作成されます。実行結果は、 <em>src</em> 以下の全てのファイルが <em>dst</em> にコピーされ、
<em>src</em> 以下の全てのディレクトリが <em>dst</em> に再帰的にコピーされます。コピーされた(またはされるはず)のファイルのリストを返します。返り値は
<em>update</em> または <em>dry_run</em> に影響されません: <em>src</em> 以下の全ファイルを単に <em>dst</em> 以下に改名したリストが返されます。</p>
<p><em>preserve_mode</em> と <em>preserve_times</em> は
<a class="reference internal" href="#module-distutils.file_util" title="distutils.file_util: 1ファイルを操作するユーティリティ関数"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.file_util</span></tt></a> の <tt class="xref py py-func docutils literal"><span class="pre">copy_file()</span></tt> と同じです:
通常のファイルには適用されますが、ディレクトリには適用されません。  もし <em>preserve_symlinks</em> が真なら、シンボリックリンクは(サポートされているシステムでは)シンボリックリンクとしてコピーされます。そうでなければ(デフォルト)シンボリックリンクは参照されている実体ファイルがコピーされます。
<em>update</em> と <em>verbose</em> は <tt class="xref py py-func docutils literal"><span class="pre">copy_file()</span></tt> と同じです。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.dir_util.remove_tree">
<tt class="descclassname">distutils.dir_util.</tt><tt class="descname">remove_tree</tt><big>(</big><em>directory</em><span class="optional">[</span>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.dir_util.remove_tree" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>再帰的に <em>directory</em> とその下の全ファイルを削除します。エラーは無視されます(<em>verbose</em> が真の時は <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> に出力されます)</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.file_util">
<span id="distutils-file-util-1"></span><h2><a class="reference internal" href="#module-distutils.file_util" title="distutils.file_util: 1ファイルを操作するユーティリティ関数"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.file_util</span></tt></a> &#8212; 1ファイルの操作<a class="headerlink" href="#module-distutils.file_util" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールはそれぞれのファイルを操作するユーティリティ関数を提供します。</p>
<dl class="function">
<dt id="distutils.file_util.copy_file">
<tt class="descclassname">distutils.file_util.</tt><tt class="descname">copy_file</tt><big>(</big><em>src</em>, <em>dst</em><span class="optional">[</span>, <em>preserve_mode=1</em>, <em>preserve_times=1</em>, <em>update=0</em>, <em>link=None</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.file_util.copy_file" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイル <em>src</em> を <em>dst</em> にコピーします。もし <em>dst</em> がディレクトリなら、 <em>src</em> はそこへ同じ名前でコピーされます; そうでなければ、ファイル名として扱われます。 (もしファイルが存在するなら、上書きされます。)
mosil <em>preserve_mode</em> が真(デフォルト)なら、ファイルのモード (タイプやパーミッション、その他プラットフォームがサポートするもの)もコピーされます。もし <em>preserve_times</em> が真(デフォルト)なら、最終更新、最終アクセス時刻もコピーされます。もし <em>update</em> が真なら、 <em>src</em> は <em>dst</em> が存在しない場合か、 <em>dst</em> が <em>src</em> より古い時にだけコピーします。</p>
<p><em>link</em> は値を <tt class="docutils literal"><span class="pre">'hard'</span></tt> または <tt class="docutils literal"><span class="pre">'sym'</span></tt> に設定することでコピーのかわりにハードリンク(<a class="reference internal" href="../library/os.html#os.link" title="os.link"><tt class="xref py py-func docutils literal"><span class="pre">os.link()</span></tt></a> を使います)またはシンボリックリンク(<a class="reference internal" href="../library/os.html#os.symlink" title="os.symlink"><tt class="xref py py-func docutils literal"><span class="pre">os.symlink()</span></tt></a> を使います)を許可します。 <tt class="docutils literal"><span class="pre">None</span></tt> (デフォルト)の時には、ファイルはコピーされます。 <em>link</em> をサポートしていないシステムで有効にしないでください。
<a class="reference internal" href="#distutils.file_util.copy_file" title="distutils.file_util.copy_file"><tt class="xref py py-func docutils literal"><span class="pre">copy_file()</span></tt></a> はハードリンク、シンボリックリンクが可能かチェックしていません。ファイルの内容をコピーするために
<tt class="xref py py-func docutils literal"><span class="pre">_copy_file_contents()</span></tt> を利用しています。</p>
<p><tt class="docutils literal"><span class="pre">(dest_name,</span> <span class="pre">copied)</span></tt> のタプルを返します: <em>dest_name</em> は出力ファイルの実際の名前、 <em>copied</em> はファイルがコピーされた(<em>dry_run</em> が真の時にはコピーされることになった)場合には真です。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.file_util.move_file">
<tt class="descclassname">distutils.file_util.</tt><tt class="descname">move_file</tt><big>(</big><em>src</em>, <em>dst</em><span class="optional">[</span>, <em>verbose</em>, <em>dry_run</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.file_util.move_file" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイル <em>src</em> を <em>dst</em> に移動します。もし <em>dst</em> がディレクトリなら、ファイルはそのディレクトリに同じ名前で移動されます。そうでなければ、 <em>src</em> は <em>dst</em> に単にリネームされます。新しいファイルの名前を返します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>Unix ではデバイスをまたがる移動は <a class="reference internal" href="#distutils.file_util.copy_file" title="distutils.file_util.copy_file"><tt class="xref py py-func docutils literal"><span class="pre">copy_file()</span></tt></a> を利用して扱っています。</p>
<p class="last">(todo:他のシステムではどうなっている?)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="distutils.file_util.write_file">
<tt class="descclassname">distutils.file_util.</tt><tt class="descname">write_file</tt><big>(</big><em>filename</em>, <em>contents</em><big>)</big><a class="headerlink" href="#distutils.file_util.write_file" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>filename</em> を作成し、 <em>contents</em> (行末文字がない文字列のシーケンス)を書き込みます。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.util">
<span id="distutils-util"></span><h2><a class="reference internal" href="#module-distutils.util" title="distutils.util: その他のユーティリティ関数"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.util</span></tt></a> &#8212; その他のユーティリティ関数<a class="headerlink" href="#module-distutils.util" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは他のユーティリティモジュールにあわないものを提供しています。</p>
<dl class="function">
<dt id="distutils.util.get_platform">
<tt class="descclassname">distutils.util.</tt><tt class="descname">get_platform</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.util.get_platform" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のプラットフォームを示す文字列を返します。これはプラットフォーム依存のビルドディレクトリやプラットフォーム依存の配布物を区別するために使われます。典型的には、(&#8216;os.uname()&#8217; のように) OSの名前とバージョン、アーキテクチャを含みますが、厳密にはOSに依存します。たとえば
IRIXではアーキテクチャはそれほど重要ではありません(IRIXはSGIのハードウェアだけで動作する)が、
Linuxではカーネルのバージョンはそれほど重要ではありません。</p>
<p>返り値の例:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">linux-i586</span></tt></li>
<li><tt class="docutils literal"><span class="pre">linux-alpha</span></tt></li>
<li><tt class="docutils literal"><span class="pre">solaris-2.6-sun4u</span></tt></li>
<li><tt class="docutils literal"><span class="pre">irix-5.3</span></tt></li>
<li><tt class="docutils literal"><span class="pre">irix64-6.2</span></tt></li>
</ul>
<p>POSIX でないプラットフォームでは、今のところ単に <tt class="docutils literal"><span class="pre">sys.platform</span></tt> が返されます。</p>
<p>Mac OS X システムでは、 OS バージョンは、現在のOSバージョンではなく、実行するバイナリの最小バージョンを表しています。
(これは、Python をビルドするときの <tt class="docutils literal"><span class="pre">MACOSX_DEPLOYMENT_TARGET</span></tt> の値です。)</p>
<p>Mac OS X のユニバーサルバイナリビルドでは、アーキテクチャの値は現在のプロセッサではなく、ユニバーサルバイナリの状態を表しています。
32bit ユニバーサルバイナリではアーキテクチャは <tt class="docutils literal"><span class="pre">fat</span></tt> で、
64bit ユニバーサルバイナリではアーキテクチャは <tt class="docutils literal"><span class="pre">fat64</span></tt> で、
4-way ユニバーサルバイナリではアーキテクチャは <tt class="docutils literal"><span class="pre">universal</span></tt> になります。
Python 2.7 と Python 3.2 から 3-way ユニバーサルバイナリ (ppc, i386, x86_64) には
<tt class="docutils literal"><span class="pre">fat3</span></tt> が i386 と x86_64 ユニバーサルバイナリには <tt class="docutils literal"><span class="pre">intel</span></tt> が使われるようになりました。</p>
<p>Mac OS X で返される値の例:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">macosx-10.3-ppc</span></tt></li>
<li><tt class="docutils literal"><span class="pre">macosx-10.3-fat</span></tt></li>
<li><tt class="docutils literal"><span class="pre">macosx-10.5-universal</span></tt></li>
<li><tt class="docutils literal"><span class="pre">macosx-10.6-intel</span></tt></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="distutils.util.convert_path">
<tt class="descclassname">distutils.util.</tt><tt class="descname">convert_path</tt><big>(</big><em>pathname</em><big>)</big><a class="headerlink" href="#distutils.util.convert_path" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&#8216;pathname&#8217; をファイルシステムで利用できる名前にして返します。すなわち、&#8217;/&#8217;で分割し、現在のディレクトリセパレータで接続しなおします。セットアップスクリプト中のファイル名はUnixスタイルで提供され、実際に利用する前に変換する必要があるため、この関数が必要になります。もし
<em>pathname</em> の最初または最後がスラッシュの場合、Unix的でないシステムでは <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> が起きます。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.change_root">
<tt class="descclassname">distutils.util.</tt><tt class="descname">change_root</tt><big>(</big><em>new_root</em>, <em>pathname</em><big>)</big><a class="headerlink" href="#distutils.util.change_root" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>pathname</em> の前に <em>new_root</em> を追加したものを返します。もし <em>pathname</em> が相対パスなら、
<tt class="docutils literal"><span class="pre">os.path.join(new_root,pathname)</span></tt> と等価です。そうでなければ、
<em>pathname</em> を相対パスに変換したあと接続します。これはDOS/Windows ではトリッキーな作業になります。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.check_environ">
<tt class="descclassname">distutils.util.</tt><tt class="descname">check_environ</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.util.check_environ" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&#8216;os.environ&#8217;に、ユーザがconfigファイル、コマンドラインオプションなどで利用できることを保証している環境変数があることを確認します。現在は以下のものが含まれています:</p>
<ul class="simple">
<li><span class="target" id="index-1"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> - ユーザのホームディレクトリ (Unix のみ)</li>
<li><span class="target" id="index-2"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PLAT</span></tt> - ハードウェアとOSを含む現在のプラットフォームの説明。 (<a class="reference internal" href="#distutils.util.get_platform" title="distutils.util.get_platform"><tt class="xref py py-func docutils literal"><span class="pre">get_platform()</span></tt></a> を参照)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="distutils.util.subst_vars">
<tt class="descclassname">distutils.util.</tt><tt class="descname">subst_vars</tt><big>(</big><em>s</em>, <em>local_vars</em><big>)</big><a class="headerlink" href="#distutils.util.subst_vars" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>shell/Perlスタイルの変数置換を <em>s</em> について行います。全ての <tt class="docutils literal"><span class="pre">$</span></tt> に名前が続いたものは変数とみなされ、辞書 <em>local_vars</em> でみつかった値に置換されます。 <em>local_vars</em> で見つからなかった場合には <tt class="docutils literal"><span class="pre">os.environ</span></tt> で置換されます。
<em>os.environ</em> は最初にある値を含んでいることをチェックされます: <a class="reference internal" href="#distutils.util.check_environ" title="distutils.util.check_environ"><tt class="xref py py-func docutils literal"><span class="pre">check_environ()</span></tt></a> を参照。  <em>local_vars</em> or
<tt class="docutils literal"><span class="pre">os.environ</span></tt> のどちらにも値が見つからなかった場合、 <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を起こします。</p>
<p>これは完全な文字列挿入関数ではないことに注意してください。 <tt class="docutils literal"><span class="pre">$variable</span></tt> の名前には大小英字、数字、アンダーバーだけを含むことができます。 { }
や ( ) を使った引用形式は利用できません。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.grok_environment_error">
<tt class="descclassname">distutils.util.</tt><tt class="descname">grok_environment_error</tt><big>(</big><em>exc</em><span class="optional">[</span>, <em>prefix='error: '</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.util.grok_environment_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>例外オブジェクト <a class="reference internal" href="../library/exceptions.html#exceptions.EnvironmentError" title="exceptions.EnvironmentError"><tt class="xref py py-exc docutils literal"><span class="pre">EnvironmentError</span></tt></a> (<a class="reference internal" href="../library/exceptions.html#exceptions.IOError" title="exceptions.IOError"><tt class="xref py py-exc docutils literal"><span class="pre">IOError</span></tt></a> または <a class="reference internal" href="../library/exceptions.html#exceptions.OSError" title="exceptions.OSError"><tt class="xref py py-exc docutils literal"><span class="pre">OSError</span></tt></a>)
から、エラーメッセージを生成します。 Python 1.5.1 またはそれ以降の形式を扱い、ファイル名を含んでいない例外オブジェクトも扱います。このような状況はエラーが2つのファイルに関係する操作、たとえば <tt class="xref py py-func docutils literal"><span class="pre">rename()</span></tt> や <tt class="xref py py-func docutils literal"><span class="pre">link()</span></tt> で発生します。
<em>prefix</em> をプレフィクスに持つエラーメッセージを返します。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.split_quoted">
<tt class="descclassname">distutils.util.</tt><tt class="descname">split_quoted</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#distutils.util.split_quoted" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をUnixのシェルのようなルール(引用符やバックスラッシュの扱い)で分割します。つまり、バックスラッシュでエスケープされるか、引用符で囲まれていなければ各語はスペースで区切られます。一重引用符と二重引用符は同じ意味です。引用符もバックスラッシュでエスケープできます。
2文字でのエスケープシーケンスに使われているバックスラッシュは削除され、エスケープされていた文字だけが残ります。引用符は文字列から削除されます。語のリストが返ります。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.execute">
<tt class="descclassname">distutils.util.</tt><tt class="descname">execute</tt><big>(</big><em>func</em>, <em>args</em><span class="optional">[</span>, <em>msg=None</em>, <em>verbose=0</em>, <em>dry_run=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.util.execute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>外部に影響するいくつかのアクション(たとえば、ファイルシステムへの書き込み)を実行します。そのようなアクションは <em>dry_run</em> フラグで無効にする必要があるので特別です。この関数はその繁雑な処理を行います。関数と引数のタプル、(実行する「アクション」をはっきりさせるための)表示に使われる任意のメッセージを渡してください。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.strtobool">
<tt class="descclassname">distutils.util.</tt><tt class="descname">strtobool</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#distutils.util.strtobool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>真偽値をあらわす文字列を真(1)または偽(0)に変換します。</p>
<p>真の値は <tt class="docutils literal"><span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">yes</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt>, <tt class="docutils literal"><span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">on</span></tt>  そして <tt class="docutils literal"><span class="pre">1</span></tt> です。偽の値は <tt class="docutils literal"><span class="pre">n</span></tt>, <tt class="docutils literal"><span class="pre">no</span></tt>,
<tt class="docutils literal"><span class="pre">f</span></tt>, <tt class="docutils literal"><span class="pre">false</span></tt>,  <tt class="docutils literal"><span class="pre">off</span></tt> そして <tt class="docutils literal"><span class="pre">0</span></tt> です。 <em>val</em> が上のどれでもない時は
<a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> を起こします。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.byte_compile">
<tt class="descclassname">distutils.util.</tt><tt class="descname">byte_compile</tt><big>(</big><em>py_files</em><span class="optional">[</span>, <em>optimize=0</em>, <em>force=0</em>, <em>prefix=None</em>, <em>base_dir=None</em>, <em>verbose=1</em>, <em>dry_run=0</em>, <em>direct=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.util.byte_compile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Pythonソースファイル群をバイトコンパイルして <tt class="file docutils literal"><span class="pre">.pyc</span></tt> または
<tt class="file docutils literal"><span class="pre">.pyo</span></tt> ファイルを同じディレクトリに作成します。 <em>py_files</em>
はコンパイルされるファイルのリストです。
<tt class="file docutils literal"><span class="pre">.py</span></tt> で終わっていないファイルはスキップされます。 <em>optimize</em> は以下のどれかです:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">0</span></tt> - 最適化しない (<tt class="file docutils literal"><span class="pre">.pyc</span></tt> ファイルを作成します)</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> - 通常の最適化 (<tt class="docutils literal"><span class="pre">python</span> <span class="pre">-O</span></tt> のように)</li>
<li><tt class="docutils literal"><span class="pre">2</span></tt> - さらに最適化 (<tt class="docutils literal"><span class="pre">python</span> <span class="pre">-OO</span></tt> のように)</li>
</ul>
<p>もし <em>force</em> が真なら、全てのファイルがタイムスタンプに関係なく再コンパイルされます。</p>
<p>バイトコード(<a class="reference internal" href="../glossary.html#term-bytecode"><em class="xref std std-term">bytecode</em></a>)ファイルにエンコードされるソースファイル名は、デフォルトでは <em>py_files</em> が使われます。これを <em>prefix</em> と <em>base_dir</em> で変更することができます。 <em>prefix</em> はそれぞれのソースファイル名から削除される文字列で、
<em>base_dir</em> は(<em>prefix</em> を削除したあと)先頭に追加されるディレクトリ名です。任意に <em>prefix</em> と <em>base_dir</em> のどちらか、両方を与える(与えない)ことができます。</p>
<p>もし <em>dry_run</em> が真なら、ファイルシステムに影響することは何もされません。</p>
<p>バイトコンパイルは現在のインタプリタプロセスによって標準の <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Python ソースファイルからバイトコードファイルを生成する。"><tt class="xref py py-mod docutils literal"><span class="pre">py_compile</span></tt></a> モジュールを使って直接行われるか、テンポラリスクリプトを書いて間接的に行われます。通常は <a class="reference internal" href="#distutils.util.byte_compile" title="distutils.util.byte_compile"><tt class="xref py py-func docutils literal"><span class="pre">byte_compile()</span></tt></a> に直接かそうでないかをまかせます (詳細についてはソースをごらんください)。
<em>direct</em> フラグは関節モードで作成されたスクリプトで使用されます。何をやっているか理解していない時は <tt class="docutils literal"><span class="pre">None</span></tt> のままにしておいてください。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.util.rfc822_escape">
<tt class="descclassname">distutils.util.</tt><tt class="descname">rfc822_escape</tt><big>(</big><em>header</em><big>)</big><a class="headerlink" href="#distutils.util.rfc822_escape" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><span class="target" id="index-3"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> ヘッダに含められるよう加工した <em>header</em> を返します。改行のあとには8つのスペースが追加されます。この関数は文字列に他の変更はしません。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.dist">
<span id="distutils-dist-distribution"></span><h2><a class="reference internal" href="#module-distutils.dist" title="distutils.dist: 構築/インストール/配布される配布物を表す Distribution クラスを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.dist</span></tt></a> &#8212; Distribution クラス<a class="headerlink" href="#module-distutils.dist" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt> クラスを提供します。これは構築/インストール/配布される配布物をあらわします。</p>
</div>
<div class="section" id="module-distutils.extension">
<span id="distutils-extension-extension"></span><h2><a class="reference internal" href="#module-distutils.extension" title="distutils.extension: セットアップスクリプトでC/C++ 拡張モジュールをあらわす Extension クラスを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.extension</span></tt></a> &#8212; Extension クラス<a class="headerlink" href="#module-distutils.extension" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-class docutils literal"><span class="pre">Extension</span></tt> クラスを提供します。 C/C++拡張モジュールをセットアップスクリプトで表すために使われます。</p>
</div>
<div class="section" id="module-distutils.debug">
<span id="distutils-debug-distutils"></span><h2><a class="reference internal" href="#module-distutils.debug" title="distutils.debug: distutilsのデバッグフラグを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.debug</span></tt></a> &#8212; Distutils デバッグモード<a class="headerlink" href="#module-distutils.debug" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールはDEBUGフラグを提供します。</p>
</div>
<div class="section" id="module-distutils.errors">
<span id="distutils-errors-distutils"></span><h2><a class="reference internal" href="#module-distutils.errors" title="distutils.errors: distutils の標準的な例外を提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.errors</span></tt></a> &#8212; Distutils 例外<a class="headerlink" href="#module-distutils.errors" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>distutilsのモジュールで使用される例外を提供します。 distutilsのモジュールは標準的な例外を起こします。特に、 SystemExit はエンドユーザによる失敗(コマンドライン引数の間違いなど)で起きます。</p>
<p>このモジュールは <tt class="docutils literal"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">*</span></tt> で安全に使用することができます。このモジュールは <tt class="docutils literal"><span class="pre">Distutils</span></tt> ではじまり、 <tt class="docutils literal"><span class="pre">Error</span></tt> で終わるシンボルしかexportしません。</p>
</div>
<div class="section" id="module-distutils.fancy_getopt">
<span id="distutils-fancy-getopt-getopt"></span><h2><a class="reference internal" href="#module-distutils.fancy_getopt" title="distutils.fancy_getopt: getopt 追加機能"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.fancy_getopt</span></tt></a> &#8212; 標準 getopt モジュールのラッパ<a class="headerlink" href="#module-distutils.fancy_getopt" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは以下の機能を標準の <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: ポータブルなコマンドラインオプションのパーサ。 長短の両方の形式をサポートします。"><tt class="xref py py-mod docutils literal"><span class="pre">getopt</span></tt></a> モジュールに追加するラッパを提供します:</p>
<ul class="simple">
<li>短いオプションと長いオプションを関連づけます</li>
<li>オプションはヘルプ文字列を持ちます。可能性としては <a class="reference internal" href="#distutils.fancy_getopt.fancy_getopt" title="distutils.fancy_getopt.fancy_getopt"><tt class="xref py py-func docutils literal"><span class="pre">fancy_getopt()</span></tt></a> に完全な利用方法サマリを作らせることができます。</li>
<li>オプションは渡されたオブジェクトの属性を設定します。</li>
<li>真偽値をとるオプションは &#8220;負のエイリアス&#8221; を持ちます。&#8212; たとえば <em class="xref std std-option">--quiet</em> の &#8220;負のエイリアス&#8221; が
<em class="xref std std-option">--verbose</em> の場合、コマンドラインで <em class="xref std std-option">--quiet</em> を指定すると <em>verbose</em> は偽になります。</li>
</ul>
<dl class="function">
<dt id="distutils.fancy_getopt.fancy_getopt">
<tt class="descclassname">distutils.fancy_getopt.</tt><tt class="descname">fancy_getopt</tt><big>(</big><em>options</em>, <em>negative_opt</em>, <em>object</em>, <em>args</em><big>)</big><a class="headerlink" href="#distutils.fancy_getopt.fancy_getopt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ラッパ関数。 <em>options</em> は <a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><tt class="xref py py-class docutils literal"><span class="pre">FancyGetopt</span></tt></a> のコンストラクタで説明されている <tt class="docutils literal"><span class="pre">(long_option,</span>
<span class="pre">short_option,</span> <span class="pre">help_string)</span></tt> の3要素タプルのリストです。 <em>negative_opt</em>
はオプション名からオプション名のマッピングになっている辞書で、キー、値のどちらも <em>options</em> リストに含まれている必要があります。
<em>object</em> は値を保存するオブジェクト(<a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><tt class="xref py py-class docutils literal"><span class="pre">FancyGetopt</span></tt></a> クラスの <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: ポータブルなコマンドラインオプションのパーサ。 長短の両方の形式をサポートします。"><tt class="xref py py-meth docutils literal"><span class="pre">getopt()</span></tt></a> メソッドを参照してください)です。
<em>args</em> は引数のリストです。 <em>args</em> として <tt class="docutils literal"><span class="pre">None</span></tt> を渡すと、 <tt class="docutils literal"><span class="pre">sys.argv[1:]</span></tt> が使われます。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.fancy_getopt.wrap_text">
<tt class="descclassname">distutils.fancy_getopt.</tt><tt class="descname">wrap_text</tt><big>(</big><em>text</em>, <em>width</em><big>)</big><a class="headerlink" href="#distutils.fancy_getopt.wrap_text" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>text</em> を <em>width</em> 以下の幅で折り返します。</p>
</dd></dl>

<dl class="class">
<dt id="distutils.fancy_getopt.FancyGetopt">
<em class="property">class </em><tt class="descclassname">distutils.fancy_getopt.</tt><tt class="descname">FancyGetopt</tt><big>(</big><span class="optional">[</span><em>option_table=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>option_table は 3つ組タプルのリストです。 <tt class="docutils literal"><span class="pre">(long_option,</span> <span class="pre">short_option,</span> <span class="pre">help_string)</span></tt></p>
<p>もしオプションが引数を持つなら、 <em>long_option</em> に <tt class="docutils literal"><span class="pre">'='</span></tt> を追加する必要があります。 <em>short_option</em> は一文字のみで、 <tt class="docutils literal"><span class="pre">':'</span></tt> はどの場合にも不要です。 <em>long_option</em>
に対応する <em>short_option</em> がない場合、 <em>short_option</em> は <tt class="docutils literal"><span class="pre">None</span></tt> にしてください。全てのオプションタプルは長い形式のオプションを持つ必要があります。</p>
</dd></dl>

<p><a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><tt class="xref py py-class docutils literal"><span class="pre">FancyGetopt</span></tt></a> クラスは以下のメソッドを提供します:</p>
<dl class="method">
<dt id="distutils.fancy_getopt.FancyGetopt.getopt">
<tt class="descclassname">FancyGetopt.</tt><tt class="descname">getopt</tt><big>(</big><span class="optional">[</span><em>args=None</em>, <em>object=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt.getopt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>argsのコマンドラインオプションを解析します。 <em>object</em> に属性として保存します。</p>
<p>もし <em>args</em> が <tt class="docutils literal"><span class="pre">None</span></tt> もしくは与えられない場合には、 <tt class="docutils literal"><span class="pre">sys.argv[1:]</span></tt> を使います。もし <em>object</em> が <tt class="docutils literal"><span class="pre">None</span></tt> もしくは与えられない場合には、新しく
<tt class="xref py py-class docutils literal"><span class="pre">OptionDummy</span></tt> インスタンスを作成し、オプションの値を保存したのち <tt class="docutils literal"><span class="pre">(args,</span> <span class="pre">object)</span></tt> のタプルを返します。もし <em>object</em> が提供されていれば、その場で変更され、 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: ポータブルなコマンドラインオプションのパーサ。 長短の両方の形式をサポートします。"><tt class="xref py py-func docutils literal"><span class="pre">getopt()</span></tt></a> は <em>args</em> のみを返します。どちらのケースでも、返された <em>args</em> は渡された <em>args</em> リスト(これは変更されません)の変更されたコピーです。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.fancy_getopt.FancyGetopt.get_option_order">
<tt class="descclassname">FancyGetopt.</tt><tt class="descname">get_option_order</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt.get_option_order" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>直前に実行された <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: ポータブルなコマンドラインオプションのパーサ。 長短の両方の形式をサポートします。"><tt class="xref py py-meth docutils literal"><span class="pre">getopt()</span></tt></a> が処理した <tt class="docutils literal"><span class="pre">(option,</span> <span class="pre">value)</span></tt> タプルのリストを返します。 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: ポータブルなコマンドラインオプションのパーサ。 長短の両方の形式をサポートします。"><tt class="xref py py-meth docutils literal"><span class="pre">getopt()</span></tt></a> がまだ呼ばれていない場合には <a class="reference internal" href="../library/exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> を起こします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.fancy_getopt.FancyGetopt.generate_help">
<tt class="descclassname">FancyGetopt.</tt><tt class="descname">generate_help</tt><big>(</big><span class="optional">[</span><em>header=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.fancy_getopt.FancyGetopt.generate_help" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この <a class="reference internal" href="#distutils.fancy_getopt.FancyGetopt" title="distutils.fancy_getopt.FancyGetopt"><tt class="xref py py-class docutils literal"><span class="pre">FancyGetopt</span></tt></a> オブジェクトのオプションテーブルからヘルプテキスト(出力の一行に対応する文字列のリスト)を生成します。</p>
<p>もし与えられていれば、 <em>header</em> をヘルプの先頭に出力します。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.filelist">
<span id="distutils-filelist-filelist"></span><h2><a class="reference internal" href="#module-distutils.filelist" title="distutils.filelist: ファイルシステムを見て、ファイルのリストを構築するために使われる FileList クラス"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.filelist</span></tt></a> &#8212;  FileList クラス<a class="headerlink" href="#module-distutils.filelist" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールはファイルシステムを見て、ファイルのリストを構築するために使われる <tt class="xref py py-class docutils literal"><span class="pre">FileList</span></tt> クラスを提供します。</p>
</div>
<div class="section" id="module-distutils.log">
<span id="distutils-log-pep-282"></span><h2><a class="reference internal" href="#module-distutils.log" title="distutils.log: シンプルな282スタイルのロギングメカニズム"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.log</span></tt></a> &#8212; シンプルな PEP 282 スタイルのロギング<a class="headerlink" href="#module-distutils.log" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.spawn">
<span id="distutils-spawn"></span><h2><a class="reference internal" href="#module-distutils.spawn" title="distutils.spawn: spawn() 関数を提供"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.spawn</span></tt></a> &#8212; サブプロセスの生成<a class="headerlink" href="#module-distutils.spawn" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <tt class="xref py py-func docutils literal"><span class="pre">spawn()</span></tt> 関数を提供します。これは様々なプラットフォーム依存の他プログラムをサブプロセスとして実行する関数に対するフロントエンドになっています。与えられた実行ファイルの名前からパスを探索する <tt class="xref py py-func docutils literal"><span class="pre">find_executable()</span></tt> 関数も提供しています。</p>
</div>
<div class="section" id="module-distutils.sysconfig">
<span id="distutils-sysconfig"></span><h2><a class="reference internal" href="#module-distutils.sysconfig" title="distutils.sysconfig: Python インタプリタの設定情報に対する低水準のアクセス手段。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.sysconfig</span></tt></a> &#8212; システム設定情報<a class="headerlink" href="#module-distutils.sysconfig" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-distutils.sysconfig" title="distutils.sysconfig: Python インタプリタの設定情報に対する低水準のアクセス手段。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.sysconfig</span></tt></a> モジュールでは、 Python の低水準の設定情報へのアクセス手段を提供しています。アクセスできる設定情報変数は、プラットフォームと設定自体に大きく左右されます。また、特定の変数は、使っているバージョンの Python のビルドプロセスに左右されます; こうした変数は、 Unix システムでは、 <tt class="file docutils literal"><span class="pre">Makefile</span></tt> や Python
と一緒にインストールされる設定ヘッダから探し出されます。設定ファイルのヘッダは、2.2 以降のバージョンでは <tt class="file docutils literal"><span class="pre">pyconfig.h</span></tt>
、それ以前のバージョンでは <tt class="file docutils literal"><span class="pre">config.h</span></tt>  です。</p>
<p>他にも、 <a class="reference internal" href="../library/distutils.html#module-distutils" title="distutils: 現在インストールされている Python に追加するためのモジュール構築、および実際のインストールを支援する。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils</span></tt></a> パッケージの別の部分を操作する上で便利な関数がいくつか提供されています。</p>
<dl class="data">
<dt id="distutils.sysconfig.PREFIX">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">PREFIX</tt><a class="headerlink" href="#distutils.sysconfig.PREFIX" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">os.path.normpath(sys.prefix)</span></tt> の結果です。</p>
</dd></dl>

<dl class="data">
<dt id="distutils.sysconfig.EXEC_PREFIX">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">EXEC_PREFIX</tt><a class="headerlink" href="#distutils.sysconfig.EXEC_PREFIX" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">os.path.normpath(sys.exec_prefix)</span></tt> の結果です。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_config_var">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">get_config_var</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#distutils.sysconfig.get_config_var" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ある一つの設定変数に対する値を返します。
<tt class="docutils literal"><span class="pre">get_config_vars().get(name)</span></tt> と同じです。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_config_vars">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">get_config_vars</tt><big>(</big><em>...</em><big>)</big><a class="headerlink" href="#distutils.sysconfig.get_config_vars" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>定義されている変数のセットを返します。引数を指定しなければ、設定変数名を変数の値に対応付けるマップ型を返します。引数を指定する場合、引数の各値は文字列でなければならず、戻り値は引数に関連付けられた各設定変数の値からなるシーケンスになります。引数に指定した名前の設定変数に値がない場合、その変数に対する戻り値には <tt class="docutils literal"><span class="pre">None</span></tt> が入ります。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_config_h_filename">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">get_config_h_filename</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.sysconfig.get_config_h_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>設定ヘッダのフルパス名を返します。 Unixの場合、このヘッダファイルは <strong class="program">configure</strong>
スクリプトによって生成されるヘッダファイル名です; 他のプラットフォームでは、ヘッダは Python ソース配布物中で直接与えられています。ファイルはプラットフォーム固有のテキストファイルです。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_makefile_filename">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">get_makefile_filename</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.sysconfig.get_makefile_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python をビルドする際に用いる <tt class="file docutils literal"><span class="pre">Makefile</span></tt> のフルパスを返します。 Unixの場合、このファイルは
<strong class="program">configure</strong> スクリプトによって生成されます; 他のプラットフォームでは、この関数の返す値の意味は様々です。有意なファイル名を返す場合、ファイルはプラットフォーム固有のテキストファイル形式です。この関数は POSIX
プラットフォームでのみ有用です。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_python_inc">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">get_python_inc</tt><big>(</big><span class="optional">[</span><em>plat_specific</em><span class="optional">[</span>, <em>prefix</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.sysconfig.get_python_inc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C インクルードファイルディレクトリについて、一般的なディレクトリ名か、プラットフォーム依存のディレクトリ名のいずれかを返します。
<em>plat_specific</em> が真であれば、プラットフォーム依存のインクルードディレクトリ名を返します; <em>plat_specific</em> が偽か、省略された場合には、プラットフォームに依存しないディレクトリを返します。 <em>prefix</em> が指定されていれば、 <a class="reference internal" href="#distutils.sysconfig.PREFIX" title="distutils.sysconfig.PREFIX"><tt class="xref py py-const docutils literal"><span class="pre">PREFIX</span></tt></a>
の代わりに用いられます。また、 <em>plat_specific</em> が真の場合、 <a class="reference internal" href="#distutils.sysconfig.EXEC_PREFIX" title="distutils.sysconfig.EXEC_PREFIX"><tt class="xref py py-const docutils literal"><span class="pre">EXEC_PREFIX</span></tt></a> の代わりに用いられます。</p>
</dd></dl>

<dl class="function">
<dt id="distutils.sysconfig.get_python_lib">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">get_python_lib</tt><big>(</big><span class="optional">[</span><em>plat_specific</em><span class="optional">[</span>, <em>standard_lib</em><span class="optional">[</span>, <em>prefix</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.sysconfig.get_python_lib" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリディレクトリについて、一般的なディレクトリ名か、プラットフォーム依存のディレクトリ名のいずれかを返します。 <em>plat_specific</em>
が真であれば、プラットフォーム依存のライブラリディレクトリ名を返します; <em>plat_specific</em> が偽か、省略された場合には、プラットフォームに依存しないディレクトリを返します。 <em>prefix</em> が指定されていれば、 <a class="reference internal" href="#distutils.sysconfig.PREFIX" title="distutils.sysconfig.PREFIX"><tt class="xref py py-const docutils literal"><span class="pre">PREFIX</span></tt></a>
の代わりに用いられます。また、 <em>plat_specific</em> が真の場合、 <a class="reference internal" href="#distutils.sysconfig.EXEC_PREFIX" title="distutils.sysconfig.EXEC_PREFIX"><tt class="xref py py-const docutils literal"><span class="pre">EXEC_PREFIX</span></tt></a> の代わりに用いられます。
<em>standard_lib</em> が真であれば、サードパーティ製の拡張モジュールをインストールするディレクトリの代わりに、標準ライブラリのディレクトリを返します。</p>
</dd></dl>

<p>以下の関数は、 <a class="reference internal" href="../library/distutils.html#module-distutils" title="distutils: 現在インストールされている Python に追加するためのモジュール構築、および実際のインストールを支援する。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils</span></tt></a> パッケージ内の使用だけを前提にしています。</p>
<dl class="function">
<dt id="distutils.sysconfig.customize_compiler">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">customize_compiler</tt><big>(</big><em>compiler</em><big>)</big><a class="headerlink" href="#distutils.sysconfig.customize_compiler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#distutils.ccompiler.CCompiler" title="distutils.ccompiler.CCompiler"><tt class="xref py py-class docutils literal"><span class="pre">distutils.ccompiler.CCompiler</span></tt></a> インスタンスに対して、プラットフォーム固有のカスタマイズを行います。</p>
<p>この関数は現在のところ、Unix だけで必要ですが、将来の互換性を考慮して一貫して常に呼び出されます。この関数は様々な Unix の変種ごとに異なる情報や、Python の <tt class="file docutils literal"><span class="pre">Makefile</span></tt> に書かれた情報をインスタンスに挿入します。この情報には、選択されたコンパイラやコンパイラ/リンカのオプション、そして共有オブジェクトを扱うためにリンカに指定する拡張子が含まれます。</p>
</dd></dl>

<p>この関数はもっと特殊用途向けで、Python 自体のビルドプロセスでのみ使われるべきです。</p>
<dl class="function">
<dt id="distutils.sysconfig.set_python_build">
<tt class="descclassname">distutils.sysconfig.</tt><tt class="descname">set_python_build</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.sysconfig.set_python_build" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#module-distutils.sysconfig" title="distutils.sysconfig: Python インタプリタの設定情報に対する低水準のアクセス手段。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.sysconfig</span></tt></a> モジュールに、モジュールが Python のビルドプロセスの一部として使われることを知らせます。これによって、ファイルコピー先を示す相対位置が大幅に変更され、インストール済みの Python
ではなく、ビルド作業領域にファイルが置かれるようになります。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.text_file">
<span id="distutils-text-file-textfile"></span><h2><a class="reference internal" href="#module-distutils.text_file" title="distutils.text_file: テキストファイルへのシンプルなインタフェース TextFile クラスを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.text_file</span></tt></a> &#8212; TextFile クラス<a class="headerlink" href="#module-distutils.text_file" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは <a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><tt class="xref py py-class docutils literal"><span class="pre">TextFile</span></tt></a> クラスを提供します。これはテキストファイルへのインタフェースを提供し、コメントの削除、空行の無視、バックスラッシュでの行の連結を任意に行えます。</p>
<dl class="class">
<dt id="distutils.text_file.TextFile">
<em class="property">class </em><tt class="descclassname">distutils.text_file.</tt><tt class="descname">TextFile</tt><big>(</big><span class="optional">[</span><em>filename=None</em>, <em>file=None</em>, <em>**options</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはファイルのようなオブジェクトを提供します。これは行指向のテキストファイルを処理する時に共通して必要となる処理を行います:
(<tt class="docutils literal"><span class="pre">#</span></tt> がコメント文字なら)コメントの削除、空行のスキップ、 (行末のバックスラッシュでの)改行のエスケープによる行の連結、先頭/末尾の空白文字の削除。これらは全て独立して任意に設定できます。</p>
<p>クラスは <a class="reference internal" href="#distutils.text_file.TextFile.warn" title="distutils.text_file.TextFile.warn"><tt class="xref py py-meth docutils literal"><span class="pre">warn()</span></tt></a> メソッドを提供しており、物理行つきの警告メッセージを生成することができます。この物理行は論理行が複数の物理行にまたがっていても大丈夫です。また <a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><tt class="xref py py-meth docutils literal"><span class="pre">unreadline()</span></tt></a> メソッドが一行先読みを実装するために提供されています。</p>
<p><a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><tt class="xref py py-class docutils literal"><span class="pre">TextFile</span></tt></a> のインスタンスは <em>filename</em>, <em>file</em>,またはその両方をとって作成されます。両方が <tt class="docutils literal"><span class="pre">None</span></tt> の場合
<a class="reference internal" href="../library/exceptions.html#exceptions.RuntimeError" title="exceptions.RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> が起きます。 <em>filename</em> は文字列、 <em>file</em> はファイルオブジェクト(または <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> と <a class="reference internal" href="#distutils.text_file.TextFile.close" title="distutils.text_file.TextFile.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> のメソッドを提供する何か) である必要があります。
<a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><tt class="xref py py-class docutils literal"><span class="pre">TextFile</span></tt></a> が生成する警告メッセージに含めることができるので、 <em>filename</em> を与えることが推奨されます、もし <em>file</em> が提供されなければ、 <a class="reference internal" href="#distutils.text_file.TextFile" title="distutils.text_file.TextFile"><tt class="xref py py-class docutils literal"><span class="pre">TextFile</span></tt></a> は組み込みの <a class="reference internal" href="../library/functions.html#open" title="open"><tt class="xref py py-func docutils literal"><span class="pre">open()</span></tt></a> を利用して自分で作成します。</p>
<p>オプションは全て真偽値で、 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> で返される値に影響します。</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="69%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">option name</th>
<th class="head">説明</th>
<th class="head">デフォルト値</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>strip_comments</em></td>
<td>バックスラッシュでエスケープされていない限り、 <tt class="docutils literal"><span class="pre">'#'</span></tt> から行末までと、 <tt class="docutils literal"><span class="pre">'#'</span></tt> の先にある空白文字の並びを削除します。</td>
<td>true</td>
</tr>
<tr class="row-odd"><td><em>lstrip_ws</em></td>
<td>行を返す前に先頭の空白文字の並びを削除します。</td>
<td>false</td>
</tr>
<tr class="row-even"><td><em>rstrip_ws</em></td>
<td>行を返す前に行末の空白文字(改行文字を含みます!)の並びを削除します。</td>
<td>true</td>
</tr>
<tr class="row-odd"><td><em>skip_blanks</em></td>
<td>コメントと空白を除いた*あとで*内容がない行をスキップします。
(もし lstrip_ws と rstrip_ws
がともに偽なら、空白文字だけの行があるかもしれません。これは <em>skip_blanks</em> が真でない限りスキップされません。)</td>
<td>true</td>
</tr>
<tr class="row-even"><td><em>join_lines</em></td>
<td>もしコメントと空白文字を削除したあとで、バックスラッシュが最後の改行文字でない文字なら、次の行を接続して一つの論理行とします:
N行の連続した行がバックスラッシュで終わる場合、N+1
行の物理行が1行の論理行として扱われます。</td>
<td>false</td>
</tr>
<tr class="row-odd"><td><em>collapse_join</em></td>
<td>前の行と接続するとき、行頭の空白文字を削除します。 <tt class="docutils literal"><span class="pre">(join_lines</span>
<span class="pre">and</span> <span class="pre">not</span> <span class="pre">lstrip_ws)</span></tt>
の時だけ意味をもちます。</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><em>rstrip_ws</em> は行末の改行を削除するので、 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> のセマンティクスが組み込みファイルオブジェクトの <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> メソッドとは変わってしまいます! 特に、 <em>rstrip_ws</em> が真で
<em>skip_blanks</em> が偽のとき、 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> はファイルの終端で <tt class="docutils literal"><span class="pre">None</span></tt> を返し、空文字列を返したときは空行(または全て空白文字の行)です。</p>
<dl class="method">
<dt id="distutils.text_file.TextFile.open">
<tt class="descname">open</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile.open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいファイル <em>filename</em> を開きます。これはコンストラクタ引数の <em>file</em> と <em>filename</em> を上書きします。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のファイルを閉じ、(ファイル名や現在の行番号を含め)現在のファイルについての情報を全て消します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.warn">
<tt class="descname">warn</tt><big>(</big><em>msg</em><span class="optional">[</span>, <em>line=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile.warn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準エラー出力に現在のファイルの論理行に結びついた警告メッセージを出力します。もし現在の論理行が複数の物理行に対応するなら、警告メッセージは以下のように全体を参照します: <tt class="docutils literal"><span class="pre">&quot;lines</span> <span class="pre">3-5&quot;</span></tt> 。もし <em>line</em> が与えられていれば、現在の行番号を上書きします;
物理行のレンジをあらわすリストまたはタプル、もしくはある物理行をあらわす整数のどれでも与えられます。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.readline">
<tt class="descname">readline</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile.readline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のファイル(または <a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><tt class="xref py py-meth docutils literal"><span class="pre">unreadline()</span></tt></a> で&#8221;unread&#8221;を直前に行っていればバッファ)から論理行を1行読み込んで返します。もし <em>join_lines</em> オプションが真なら、このメソッドは複数の物理行を読み込んで接続した文字列を返します。現在の行番号を更新します。そのため <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> のあとに <a class="reference internal" href="#distutils.text_file.TextFile.warn" title="distutils.text_file.TextFile.warn"><tt class="xref py py-meth docutils literal"><span class="pre">warn()</span></tt></a> を呼ぶと丁度読んだ行についての警告を出します。
<em>rstrip_ws</em> が真で、 <em>strip_blanks</em> が偽のとき空文字列が返るので、ファイルの終端では <tt class="docutils literal"><span class="pre">None</span></tt> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.readlines">
<tt class="descname">readlines</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile.readlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のファイルで残っている全ての論理行のリストを読み込んで返します。行番号を、ファイルの最後の行に更新します。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.text_file.TextFile.unreadline">
<tt class="descname">unreadline</tt><big>(</big><em>line</em><big>)</big><a class="headerlink" href="#distutils.text_file.TextFile.unreadline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>line</em> (文字列)を次の <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> 用に、内部バッファにpushします。行の先読みを必要とするパーサを実装する時に便利です。
<a class="reference internal" href="#distutils.text_file.TextFile.unreadline" title="distutils.text_file.TextFile.unreadline"><tt class="xref py py-meth docutils literal"><span class="pre">unreadline()</span></tt></a> で&#8221;unread&#8221;された行は <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> で読み込む際に再度処理(空白の除去など)されません。もし <tt class="xref py py-meth docutils literal"><span class="pre">unreadlinee()</span></tt> を、 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> を呼ぶ前に複数回実行すると、最後にunreadした行から返されます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-distutils.version">
<span id="distutils-version"></span><h2><a class="reference internal" href="#module-distutils.version" title="distutils.version: モジュールのバージョン番号を表すクラスの実装"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.version</span></tt></a> &#8212; バージョン番号クラス<a class="headerlink" href="#module-distutils.version" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.cmd">
<span id="distutils-cmd-distutils"></span><h2><a class="reference internal" href="#module-distutils.cmd" title="distutils.cmd: このモジュールは Command 抽象ベースクラスを提供します。このクラスは distutils.command サブパッケージ中のモジュールでサブクラスを作るために利用されます。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.cmd</span></tt></a> &#8212; Distutils コマンドの抽象クラス<a class="headerlink" href="#module-distutils.cmd" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは抽象ベースクラス <a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><tt class="xref py py-class docutils literal"><span class="pre">Command</span></tt></a> を提供します。</p>
<dl class="class">
<dt id="distutils.cmd.Command">
<em class="property">class </em><tt class="descclassname">distutils.cmd.</tt><tt class="descname">Command</tt><big>(</big><em>dist</em><big>)</big><a class="headerlink" href="#distutils.cmd.Command" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コマンドクラスを定義するための抽象ベースクラス &#8212; distutilsの「働きバチ」 &#8212; です。コマンドクラスは <em>options</em>
とよばれるローカル変数を持ったサブルーチンと考えることができます。オプションは <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><tt class="xref py py-meth docutils literal"><span class="pre">initialize_options()</span></tt></a> で宣言され、 <a class="reference internal" href="#distutils.cmd.Command.finalize_options" title="distutils.cmd.Command.finalize_options"><tt class="xref py py-meth docutils literal"><span class="pre">finalize_options()</span></tt></a> で定義さ(最終的な値を与えら)れます。どちらも全てのコマンドクラスで実装する必要があります。この2つの区別は必要です。なぜならオプションの値は外部(コマンドライン、設定ファイルなど)から来るかもしれず、他のオプションに依存しているオプションは外部の影響を処理した後で計算される必要があるからです。そのため
<a class="reference internal" href="#distutils.cmd.Command.finalize_options" title="distutils.cmd.Command.finalize_options"><tt class="xref py py-meth docutils literal"><span class="pre">finalize_options()</span></tt></a> が存在します。サブルーチンの本体は全ての処理をオプションの値にもとづいて行う
<a class="reference internal" href="#distutils.cmd.Command.run" title="distutils.cmd.Command.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> メソッドで、これも全てのコマンドクラスで実装される必要があります。</p>
<p>クラスのコンストラクタは <tt class="xref py py-class docutils literal"><span class="pre">Distribution</span></tt> のインスタンスである単一の引数 <em>dist</em> をとります。</p>
</dd></dl>

</div>
<div class="section" id="distutils">
<h2>新しいDistutilsコマンドの作成<a class="headerlink" href="#distutils" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションではDistutilsの新しいコマンドを作成する手順の概要をしめします。</p>
<p>新しいコマンドは <a class="reference internal" href="#module-distutils.command" title="distutils.command: このサブパッケージは標準のdistutilsコマンドを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command</span></tt></a> パッケージ中のモジュールに作られます。 <tt class="file docutils literal"><span class="pre">command_template</span></tt> というディレクトリにサンプルのテンプレートがあります。このファイルを実装しようとしているコマンドと同名の新しいモジュールにコピーしてください。このモジュールはモジュール(とコマンド)と同じ名前のクラスを実装する必要があります。そのため、 <tt class="docutils literal"><span class="pre">peel_banana</span></tt> コマンド(ユーザは
<tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">peel_banana</span></tt> と実行できます)を実装する際には、 <tt class="file docutils literal"><span class="pre">command_template</span></tt> を
<tt class="file docutils literal"><span class="pre">distutils/command/peel_banana.py</span></tt> にコピーし、
<a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><tt class="xref py py-class docutils literal"><span class="pre">distutils.cmd.Command</span></tt></a> のサブクラス <tt class="xref py py-class docutils literal"><span class="pre">peel_banana</span></tt>
クラスを実装するように編集してください。</p>
<p><a class="reference internal" href="#distutils.cmd.Command" title="distutils.cmd.Command"><tt class="xref py py-class docutils literal"><span class="pre">Command</span></tt></a> のサブクラスは以下のメソッドを実装する必要があります。</p>
<dl class="method">
<dt id="distutils.cmd.Command.initialize_options">
<tt class="descclassname">Command.</tt><tt class="descname">initialize_options</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.cmd.Command.initialize_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコマンドがサポートする全てのオプションのデフォルト値を設定します。これらのデフォルトは他のコマンドやセットアップスクリプト、設定ファイル、コマンドラインによって上書きされるかもしれません。そのためオプション間の依存関係を記述するには適切な場所ではありません。一般的に <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><tt class="xref py py-meth docutils literal"><span class="pre">initialize_options()</span></tt></a> は単に <tt class="docutils literal"><span class="pre">self.foo</span> <span class="pre">=</span> <span class="pre">None</span></tt> のような定義だけを行います。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.cmd.Command.finalize_options">
<tt class="descclassname">Command.</tt><tt class="descname">finalize_options</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.cmd.Command.finalize_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコマンドがサポートする全てのオプションの最終的な値を設定します。これは可能な限り遅く呼び出されます。つまりコマンドラインや他のコマンドによるオプションの代入のあとに呼び出されます。そのため、オプション間の依存関係を記述するのに適した場所です。もし <em>foo</em> が <em>bar</em>
に依存しており、かつまだ <em>foo</em> が <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><tt class="xref py py-meth docutils literal"><span class="pre">initialize_options()</span></tt></a> で定義された値のままなら、 <em>foo</em>
を <em>bar</em> から代入しても安全です。</p>
</dd></dl>

<dl class="method">
<dt id="distutils.cmd.Command.run">
<tt class="descclassname">Command.</tt><tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#distutils.cmd.Command.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コマンドの本体です。実行するべきアクションを実装しています。 <a class="reference internal" href="#distutils.cmd.Command.initialize_options" title="distutils.cmd.Command.initialize_options"><tt class="xref py py-meth docutils literal"><span class="pre">initialize_options()</span></tt></a> で初期化され、他のコマンドされ、セットアップスクリプト、コマンドライン、設定ファイルでカスタマイズされ、 <a class="reference internal" href="#distutils.cmd.Command.finalize_options" title="distutils.cmd.Command.finalize_options"><tt class="xref py py-meth docutils literal"><span class="pre">finalize_options()</span></tt></a> で設定されたオプションがアクションを制御します。端末への出力とファイルシステムとのやりとりは全て <a class="reference internal" href="#distutils.cmd.Command.run" title="distutils.cmd.Command.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> が行います。</p>
</dd></dl>

<dl class="attribute">
<dt id="distutils.cmd.Command.sub_commands">
<tt class="descclassname">Command.</tt><tt class="descname">sub_commands</tt><a class="headerlink" href="#distutils.cmd.Command.sub_commands" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sub_commands</em> はコマンドの&#8221;ファミリー&#8221;を定式化したものです。たとえば <tt class="docutils literal"><span class="pre">install</span></tt> はサブコマンド
<tt class="docutils literal"><span class="pre">install_lib</span></tt> <tt class="docutils literal"><span class="pre">install_headers</span></tt> などの親です。コマンドファミリーの親は
<em>sub_commands</em> をクラス属性として持ちます。
<em>sub_commands</em> は2要素のタプル <tt class="docutils literal"><span class="pre">(command_name,</span> <span class="pre">predicate)</span></tt> のリストで、
<em>command_name</em> は文字列、 <em>predicate</em> は関数か文字列か <tt class="docutils literal"><span class="pre">None</span></tt> です。
<em>predicate</em> はには親コマンドのメソッドで、現在の状況がコマンド実行にふさわしいかどうか判断するものを指定します。 (例えば <tt class="docutils literal"><span class="pre">install_headers</span></tt> はインストールするべき
Cヘッダファイルがある時だけ有効です。) もし <em>predicate</em> が None なら、そのコマンドは常に有効になります。</p>
<p><em>sub_commands</em> は通常クラスの <em>最後</em> で定義されます。  これは predicate は
bound されていないメソッドになるので、全て先に定義されている必要があるためです。標準的な例は <strong class="command">install</strong> コマンドです。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.command">
<span id="distutils-command-distutils"></span><h2><a class="reference internal" href="#module-distutils.command" title="distutils.command: このサブパッケージは標準のdistutilsコマンドを提供します。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command</span></tt></a> &#8212;  Distutils 各コマンド<a class="headerlink" href="#module-distutils.command" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist">
<span id="distutils-command-bdist"></span><h2><a class="reference internal" href="#module-distutils.command.bdist" title="distutils.command.bdist: パッケージのバイナリインストラーを構築します"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.bdist</span></tt></a> &#8212; バイナリインストーラの構築<a class="headerlink" href="#module-distutils.command.bdist" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_packager">
<span id="distutils-command-bdist-packager"></span><h2><a class="reference internal" href="#module-distutils.command.bdist_packager" title="distutils.command.bdist_packager: パッケージの抽象ベースクラス"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.bdist_packager</span></tt></a> &#8212; パッケージの抽象ベースクラス<a class="headerlink" href="#module-distutils.command.bdist_packager" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_dumb">
<span id="distutils-command-bdist-dumb"></span><h2><a class="reference internal" href="#module-distutils.command.bdist_dumb" title="distutils.command.bdist_dumb: &quot;ダム&quot;インストーラ(単純なファイルのアーカイブ)を構築します"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.bdist_dumb</span></tt></a> &#8212; &#8220;ダム&#8221;インストーラを構築<a class="headerlink" href="#module-distutils.command.bdist_dumb" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_msi">
<span id="distutils-command-bdist-msi-microsoft-installer"></span><h2><a class="reference internal" href="#module-distutils.command.bdist_msi" title="distutils.command.bdist_msi: Windows MSI ファイル形式のバイナリ配布物をビルドする。"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.bdist_msi</span></tt></a> &#8212; Microsoft Installer バイナリパッケージをビルドする<a class="headerlink" href="#module-distutils.command.bdist_msi" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="distutils.command.bdist_msi.bdist_msi">
<em class="property">class </em><tt class="descclassname">distutils.command.bdist_msi.</tt><tt class="descname">bdist_msi</tt><big>(</big><em>Command</em><big>)</big><a class="headerlink" href="#distutils.command.bdist_msi.bdist_msi" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference external" href="http://msdn.microsoft.com/en-us/library/cc185688(VS.85).aspx">Windows Installer</a> (.msi) バイナリパッケージをビルドします。</p>
<p>多くの場合、 <tt class="docutils literal"><span class="pre">bdist_msi</span></tt> インストーラは Win64 のサポートが優れていて、管理者が非インタラクティブインストールできたり、グループポリシーを利用したインストールができるので、 <tt class="docutils literal"><span class="pre">bdist_wininst</span></tt> インストーラよりも良い選択です。</p>
</dd></dl>

</div>
<div class="section" id="module-distutils.command.bdist_rpm">
<span id="distutils-command-bdist-rpm-redhat-rpmsrpm"></span><h2><a class="reference internal" href="#module-distutils.command.bdist_rpm" title="distutils.command.bdist_rpm: Redhat RPMとSRPM形式のバイナリディストリビューションを構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.bdist_rpm</span></tt></a> &#8212; Redhat RPMとSRPM形式のバイナリディストリビューションを構築<a class="headerlink" href="#module-distutils.command.bdist_rpm" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.bdist_wininst">
<span id="distutils-command-bdist-wininst-windows"></span><h2><a class="reference internal" href="#module-distutils.command.bdist_wininst" title="distutils.command.bdist_wininst: Windows インストーラの構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.bdist_wininst</span></tt></a> &#8212; Windowsインストーラの構築<a class="headerlink" href="#module-distutils.command.bdist_wininst" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.sdist">
<span id="distutils-command-sdist"></span><h2><a class="reference internal" href="#module-distutils.command.sdist" title="distutils.command.sdist: ソース配布物の構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.sdist</span></tt></a> &#8212; ソース配布物の構築<a class="headerlink" href="#module-distutils.command.sdist" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build">
<span id="distutils-command-build"></span><h2><a class="reference internal" href="#module-distutils.command.build" title="distutils.command.build: パッケージ中の全ファイルのビルド"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.build</span></tt></a> &#8212; パッケージ中の全ファイルを構築<a class="headerlink" href="#module-distutils.command.build" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_clib">
<span id="distutils-command-build-clib-c"></span><h2><a class="reference internal" href="#module-distutils.command.build_clib" title="distutils.command.build_clib: パッケージ中のCライブラリを構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.build_clib</span></tt></a> &#8212; パッケージ中のCライブラリを構築<a class="headerlink" href="#module-distutils.command.build_clib" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_ext">
<span id="distutils-command-build-ext"></span><h2><a class="reference internal" href="#module-distutils.command.build_ext" title="distutils.command.build_ext: パッケージ中の拡張を構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.build_ext</span></tt></a> &#8212; パッケージ中の拡張を構築<a class="headerlink" href="#module-distutils.command.build_ext" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_py">
<span id="distutils-command-build-py-py-pyc"></span><h2><a class="reference internal" href="#module-distutils.command.build_py" title="distutils.command.build_py: パッケージ中の.py/.pyc ファイルを構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.build_py</span></tt></a> &#8212; パッケージ中の.py/.pyc ファイルを構築<a class="headerlink" href="#module-distutils.command.build_py" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.build_scripts">
<span id="distutils-command-build-scripts"></span><h2><a class="reference internal" href="#module-distutils.command.build_scripts" title="distutils.command.build_scripts: パッケージ中のスクリプトを構築"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.build_scripts</span></tt></a> &#8212; パッケージ中のスクリプトを構築<a class="headerlink" href="#module-distutils.command.build_scripts" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.clean">
<span id="distutils-command-clean"></span><h2><a class="reference internal" href="#module-distutils.command.clean" title="distutils.command.clean: パッケージのビルドエリアを消去"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.clean</span></tt></a> &#8212; パッケージのビルドエリアを消去<a class="headerlink" href="#module-distutils.command.clean" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.config">
<span id="distutils-command-config"></span><h2><a class="reference internal" href="#module-distutils.command.config" title="distutils.command.config: パッケージの設定"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.config</span></tt></a> &#8212; パッケージの設定<a class="headerlink" href="#module-distutils.command.config" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install">
<span id="distutils-command-install"></span><h2><a class="reference internal" href="#module-distutils.command.install" title="distutils.command.install: パッケージのインストール"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.install</span></tt></a> &#8212; パッケージのインストール<a class="headerlink" href="#module-distutils.command.install" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_data">
<span id="distutils-command-install-data"></span><h2><a class="reference internal" href="#module-distutils.command.install_data" title="distutils.command.install_data: パッケージ中のデータファイルをインストール"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.install_data</span></tt></a> &#8212; パッケージ中のデータファイルをインストール<a class="headerlink" href="#module-distutils.command.install_data" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_headers">
<span id="distutils-command-install-headers-c-c"></span><h2><a class="reference internal" href="#module-distutils.command.install_headers" title="distutils.command.install_headers: パッケージから C/C++ ヘッダファイルをインストール"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.install_headers</span></tt></a> &#8212; パッケージから C/C++ ヘッダファイルをインストール<a class="headerlink" href="#module-distutils.command.install_headers" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_lib">
<span id="distutils-command-install-lib"></span><h2><a class="reference internal" href="#module-distutils.command.install_lib" title="distutils.command.install_lib: パッケージからライブラリファイルをインストール"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.install_lib</span></tt></a> &#8212; パッケージからライブラリファイルをインストール<a class="headerlink" href="#module-distutils.command.install_lib" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.install_scripts">
<span id="distutils-command-install-scripts"></span><h2><a class="reference internal" href="#module-distutils.command.install_scripts" title="distutils.command.install_scripts: パッケージからスクリプトファイルをインストール"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.install_scripts</span></tt></a> &#8212; パッケージからスクリプトファイルをインストール<a class="headerlink" href="#module-distutils.command.install_scripts" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="module-distutils.command.register">
<span id="distutils-command-register-python-package-index"></span><h2><a class="reference internal" href="#module-distutils.command.register" title="distutils.command.register: モジュールをPython Package Indexに登録する"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.register</span></tt></a> &#8212; モジュールをPython Package Indexに登録する<a class="headerlink" href="#module-distutils.command.register" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">register</span></tt> コマンドはパッケージをPython Package Index に登録します。この詳細は <span class="target" id="index-5"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0301"><strong>PEP 301</strong></a> に記述されています。</p>
</div>
<div class="section" id="module-distutils.command.check">
<span id="distutils-command-check"></span><h2><a class="reference internal" href="#module-distutils.command.check" title="distutils.command.check: パッケージのメタデータをチェックする"><tt class="xref py py-mod docutils literal"><span class="pre">distutils.command.check</span></tt></a> &#8212; パッケージのメタデータをチェックする<a class="headerlink" href="#module-distutils.command.check" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">check</span></tt> コマンドはパッケージのメタデータに対していくつかのテストをします。例えば、要求される全てのメタデータが <tt class="xref py py-func docutils literal"><span class="pre">setup()</span></tt> 関数の引数に渡されているかを検証します。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="jptranslation.html" title="このドキュメントについて"
             >次へ</a> |</li>
        <li class="right" >
          <a href="commandref.html" title="コマンドリファレンス"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python モジュールの配布</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>