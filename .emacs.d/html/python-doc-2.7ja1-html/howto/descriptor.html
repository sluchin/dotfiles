

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ディスクリプタ HowTo ガイド &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python HOWTO" href="index.html" />
    <link rel="next" title="Python 良い慣用句、悪い慣用句" href="doanddont.html" />
    <link rel="prev" title="Python で Curses プログラミング" href="curses.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="doanddont.html" title="Python 良い慣用句、悪い慣用句"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="curses.html" title="Python で Curses プログラミング"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python HOWTO</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">ディスクリプタ HowTo ガイド</a><ul>
<li><a class="reference internal" href="#id1">概要</a></li>
<li><a class="reference internal" href="#id2">定義と導入</a></li>
<li><a class="reference internal" href="#id3">ディスクリプタプロトコル</a></li>
<li><a class="reference internal" href="#id4">ディスクリプタの呼び出し</a></li>
<li><a class="reference internal" href="#id5">ディスクリプタの例</a></li>
<li><a class="reference internal" href="#id6">プロパティ</a></li>
<li><a class="reference internal" href="#id7">関数とメソッド</a></li>
<li><a class="reference internal" href="#id8">静的メソッドとクラスメソッド</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="curses.html"
                        title="前の章へ">Python で Curses プログラミング</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="doanddont.html"
                        title="次の章へ">Python 良い慣用句、悪い慣用句</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/howto/descriptor.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="howto">
<h1><a class="toc-backref" href="#id9">ディスクリプタ HowTo ガイド</a><a class="headerlink" href="#howto" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Raymond Hettinger</td>
</tr>
<tr class="field-even field"><th class="field-name">Contact:</th><td class="field-body">&lt;python at rcn dot com&gt;</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#howto" id="id9">ディスクリプタ HowTo ガイド</a><ul>
<li><a class="reference internal" href="#id1" id="id10">概要</a></li>
<li><a class="reference internal" href="#id2" id="id11">定義と導入</a></li>
<li><a class="reference internal" href="#id3" id="id12">ディスクリプタプロトコル</a></li>
<li><a class="reference internal" href="#id4" id="id13">ディスクリプタの呼び出し</a></li>
<li><a class="reference internal" href="#id5" id="id14">ディスクリプタの例</a></li>
<li><a class="reference internal" href="#id6" id="id15">プロパティ</a></li>
<li><a class="reference internal" href="#id7" id="id16">関数とメソッド</a></li>
<li><a class="reference internal" href="#id8" id="id17">静的メソッドとクラスメソッド</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id10">概要</a><a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ディスクリプタを定義し、プロトコルを要約し、ディスクリプタがどのように呼び出されるか示します。カスタムのディスクリプタや、関数、プロパティ、静的メソッド、クラスメソッドを含む、いくつかの組み込み Python
ディスクリプタを考察します。等価な pure Python やサンプルアプリケーションを与えることにより、それぞれがどのように働くかを示します。</p>
<p>ディスクリプタについて、大きなツールセットが使えるようにするだけでなく、
Python の仕組みや、洗練された設計のアプリケーションについて、深い理解を生み出します。</p>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id11">定義と導入</a><a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>一般に、ディスクリプタは &#8220;束縛動作 (binding behavior)&#8221; をもつオブジェクト属性で、その属性アクセスが、ディスクリプタプロトコルのメソッドによってオーバーライドされたものです。このメソッドは、
<a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a>, <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><tt class="xref py py-meth docutils literal"><span class="pre">__set__()</span></tt></a>, および <a class="reference internal" href="../reference/datamodel.html#object.__delete__" title="object.__delete__"><tt class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></tt></a> です。これらのメソッドのいずれかが、オブジェクトに定義されていれば、それはディスクリプタと呼ばれます。</p>
<p>属性アクセスのデフォルトの振る舞いは、オブジェクトの辞書の属性の取得、設定、削除です。例えば <tt class="docutils literal"><span class="pre">a.x</span></tt> は、まず <tt class="docutils literal"><span class="pre">a.__dict__['x']</span></tt> 、それから <tt class="docutils literal"><span class="pre">type(a).__dict__['x']</span></tt> 、さらに <tt class="docutils literal"><span class="pre">type(a)</span></tt> のメタクラスを除く基底クラスへと続くというように探索が連鎖します。見つかった値が、ディスクリプタメソッドのいずれかを定義しているオブジェクトなら、
Python はそのデフォルトの振る舞いをオーバーライドし、代わりにディスクリプタメソッドを呼び出します。これがどの連鎖順位で行われるかは、どのディスクリプタメソッドが定義されているかに依ります。なお、ディスクリプタは、新スタイルのオブジェクトまたはクラスにのみ呼び出されます (あるクラスは、それが <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> または <a class="reference internal" href="../library/functions.html#type" title="type"><tt class="xref py py-class docutils literal"><span class="pre">type</span></tt></a> を継承していれば、新スタイルです)。</p>
<p>ディスクリプタは、強力な、多目的のプロトコルです。これはプロパティ、メソッド、静的メソッド、クラスメソッド、そして <a class="reference internal" href="../library/functions.html#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> の背後にある機構です。これはバージョン 2.2 で導入された新スタイルクラスを実装するために、Python のいたるところで使わています。ディスクリプタは、基幹にある C コードを簡潔にし、毎日の Python プログラムに、柔軟な新しいツール群を提供します。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id12">ディスクリプタプロトコル</a><a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">descr.__get__(self,</span> <span class="pre">obj,</span> <span class="pre">type=None)</span> <span class="pre">--&gt;</span> <span class="pre">value</span></tt></p>
<p><tt class="docutils literal"><span class="pre">descr.__set__(self,</span> <span class="pre">obj,</span> <span class="pre">value)</span> <span class="pre">--&gt;</span> <span class="pre">None</span></tt></p>
<p><tt class="docutils literal"><span class="pre">descr.__delete__(self,</span> <span class="pre">obj)</span> <span class="pre">--&gt;</span> <span class="pre">None</span></tt></p>
<p>これで全てです。これらのメソッドのいずれかを定義すれば、オブジェクトはディスクリプタとみなされ、探索された際のデフォルトの振る舞いをオーバーライドできます。</p>
<p>あるオブジェクトが <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> と <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><tt class="xref py py-meth docutils literal"><span class="pre">__set__()</span></tt></a> の両方を定義していたら、それはデータディスクリプタとみなされます。 <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> だけを定義しているディスクリプタは、非データディスクリプタと呼ばれます (これらは典型的にはメソッドに使われますが、他の使い方も出来ます)。</p>
<p>データディスクリプタと非データディスクリプタでは、オーバーライドがインスタンスの辞書のエントリに関してどのように計算されるかが異なります。インスタンスの辞書に、データディスクリプタと同名の項目があれば、データディスクリプタの方が優先されます。インスタンスの辞書に、非データディスクリプタと同名の項目があれば、辞書の項目の方が優先されます。</p>
<p>読み込み専用のデータディスクリプタを作るには、 <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> と
<a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><tt class="xref py py-meth docutils literal"><span class="pre">__set__()</span></tt></a> の両方を定義し、 <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><tt class="xref py py-meth docutils literal"><span class="pre">__set__()</span></tt></a> が呼び出されたときに
<a class="reference internal" href="../library/exceptions.html#exceptions.AttributeError" title="exceptions.AttributeError"><tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt></a> が送出されるようにしてください。例外を送出する <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><tt class="xref py py-meth docutils literal"><span class="pre">__set__()</span></tt></a> メソッドをプレースホルダとして定義すれば、データディスクリプタにするのに十分です。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id13">ディスクリプタの呼び出し</a><a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ディスクリプタは、メソッド名で直接呼ぶことも出来ます。例えば、 <tt class="docutils literal"><span class="pre">d.__get__(obj)</span></tt> です。</p>
<p>または、一般的に、ディスクリプタは属性アクセスから自動的に呼び出されます。例えば、 <tt class="docutils literal"><span class="pre">obj.d</span></tt> は <tt class="docutils literal"><span class="pre">obj</span></tt> の辞書から <tt class="docutils literal"><span class="pre">d</span></tt> を探索します。 <tt class="docutils literal"><span class="pre">d</span></tt> がメソッド <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> を定義していたら、以下に列挙する優先順位に従って、
<tt class="docutils literal"><span class="pre">d.__get__(obj)</span></tt> が呼び出されます。</p>
<p>呼び出しの詳細は、 <tt class="docutils literal"><span class="pre">obj</span></tt> がオブジェクトかクラスかに依ります。どちらにしても、ディスクリプタは新スタイルのオブジェクトやクラスにのみ働きます。クラスは、それが <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> のサブクラスであるなら新スタイルです。</p>
<p>オブジェクトでは、その機構は <tt class="docutils literal"><span class="pre">b.x</span></tt> を
<tt class="docutils literal"><span class="pre">type(b).__dict__['x'].__get__(b,</span> <span class="pre">type(b))</span></tt> に変換する
<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">object.__getattribute__()</span></tt></a> にあります。データディスクリプタの優先度はインスタンス変数より高く、インスタンス変数の優先度は非データディスクリプタより高く、(提供されていれば)
<a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></tt></a> の優先度が最も低いように実装されています。完全な C 実装は、
<a class="reference external" href="http://svn.python.org/view/python/trunk/Objects/object.c?view=markup">Objects/object.c</a>
の <a class="reference internal" href="../c-api/object.html#PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GenericGetAttr()</span></tt></a> で見つかります。</p>
<p>クラスでは、その機構は <tt class="docutils literal"><span class="pre">B.x</span></tt> を <tt class="docutils literal"><span class="pre">B.__dict__['x'].__get__(None,</span> <span class="pre">B)</span></tt> に変換する <tt class="xref py py-meth docutils literal"><span class="pre">type.__getattribute__()</span></tt> にあります。
pure Python では、このようになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="s">&quot;Emulate type_getattro() in Objects/typeobject.c&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&#39;__get__&#39;</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>
</pre></div>
</div>
<p>憶えておくべき重要な点は:</p>
<ul class="simple">
<li>ディスクリプタは <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> メソッドに呼び出される</li>
<li><a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> をオーバーライドすると、自動的なディスクリプタの呼び出しが防がれる。</li>
<li><a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> は新スタイルのクラスとオブジェクトにのみ使える。</li>
<li><a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">object.__getattribute__()</span></tt></a> と <tt class="xref py py-meth docutils literal"><span class="pre">type.__getattribute__()</span></tt> では、
<a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> の呼び出しが異なる。</li>
<li>データディスクリプタは、必ずインスタンス辞書をオーバーライドする。</li>
<li>非データディスクリプタは、インスタンス辞書にオーバーライドされることがある。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">super()</span></tt> によって返されたオブジェクトもまた、ディスクリプタの呼び出しにカスタムの <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> メソッドを持ちます。
<tt class="docutils literal"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></tt> の呼び出しは、 <tt class="docutils literal"><span class="pre">obj.__class__.__mro__</span></tt> の中から、
<tt class="docutils literal"><span class="pre">B</span></tt> の直接の基底クラス <tt class="docutils literal"><span class="pre">A</span></tt> を探し、 <tt class="docutils literal"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">A)</span></tt>
を返します。ディスクリプタでなければ、 <tt class="docutils literal"><span class="pre">m</span></tt> はそのまま返されます。辞書になければ、 <tt class="docutils literal"><span class="pre">m</span></tt> は <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">object.__getattribute__()</span></tt></a> を使って、さかのぼって探索されます。</p>
<p>なお、Python 2.2 では、 <tt class="docutils literal"><span class="pre">m</span></tt> がデータディスクリプタなら、
<tt class="docutils literal"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></tt> は <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> を呼び出すだけです。
Python 2.3 では、旧スタイルクラスが呼び出されなければ、非データディスクリプタも呼び出されます。実装の詳細は、
<a class="reference external" href="http://svn.python.org/view/python/trunk/Objects/typeobject.c?view=markup">Objects/typeobject.c</a>
の <tt class="xref c c-func docutils literal"><span class="pre">super_getattro()</span></tt> と、 <a class="reference external" href="http://www.python.org/2.2.3/descrintro.html#cooperation">Guido&#8217;s Tutorial</a> にある等価な pure
Python を参照してください。</p>
<p>上述の詳細は、ディスクリプタの機構が、 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> メソッドに埋めこまれ、 <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a>, <a class="reference internal" href="../library/functions.html#type" title="type"><tt class="xref py py-class docutils literal"><span class="pre">type</span></tt></a>, そして <a class="reference internal" href="../library/functions.html#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a> に使われているということを表しています。クラスは、 <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> から導出されたとき、または、同じような機能を提供するメタクラスをもつとき、この機構を継承します。同様に、 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> をオーバーライドすることで、ディスクリプタの呼び出しを無効にできます。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id14">ディスクリプタの例</a><a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のコードは、オブジェクトが取得と設定のたびにメッセージを表示するデータディスクリプタであるようなクラスを生成します。代わりに <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><tt class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></tt></a> をオーバーライドすると、全ての属性に対してこれができます。しかし、このディスクリプタは、少数の選ばれた属性を監視するのに便利です:</p>
<div class="highlight-python"><pre>class RevealAccess(object):
    """A data descriptor that sets and returns values
       normally and prints a message logging their access.
    """

    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print 'Retrieving', self.name
        return self.val

    def __set__(self, obj, val):
        print 'Updating' , self.name
        self.val = val

&gt;&gt;&gt; class MyClass(object):
    x = RevealAccess(10, 'var "x"')
    y = 5

&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; m.x
Retrieving var "x"
10
&gt;&gt;&gt; m.x = 20
Updating var "x"
&gt;&gt;&gt; m.x
Retrieving var "x"
20
&gt;&gt;&gt; m.y
5</pre>
</div>
<p>このプロトコルは単純ですが、ワクワクする可能性も秘めています。ユースケースの中には、あまりに一般的なので個別の関数の呼び出しにまとめられたものもあります。プロパティ、束縛および非束縛のメソッド、静的メソッド、そしてクラスメソッドは、全てディスクリプタプロトコルに基づいています。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id15">プロパティ</a><a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a> を呼び出すことで、属性へアクセスすると関数の呼び出しを引き起こす、データディスクリプタを簡潔に組み立てられます。シグネチャはこうです:</p>
<div class="highlight-python"><pre>property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</pre>
</div>
<p>このドキュメントでは、管理された属性 <tt class="docutils literal"><span class="pre">x</span></tt> を定義する典型的な使用法を示します:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span>
    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>ディスクリプタの見地から <a class="reference internal" href="../library/functions.html#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a> がどのように実装されているかを見るために、等価な Python をここに挙げます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Property</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">&quot;Emulate PyProperty_Type() in Objects/descrobject.c&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="o">=</span> <span class="n">fget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="o">=</span> <span class="n">fset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="o">=</span> <span class="n">fdel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="s">&quot;unreadable attribute&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="s">&quot;can&#39;t set attribute&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="s">&quot;can&#39;t delete attribute&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fdel</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>組み込みの <a class="reference internal" href="../library/functions.html#property" title="property"><tt class="xref py py-func docutils literal"><span class="pre">property()</span></tt></a> 関数は、ユーザインタフェースへの属性アクセスが与えられ、続く変更がメソッドの介入を要求するときに役立ちます。</p>
<p>例えば、スプレッドシートクラスが、 <tt class="docutils literal"><span class="pre">Cell('b10').value</span></tt> でセルの値を取得できるとします。続く改良により、プログラムがアクセスの度にセルの再計算をすることを要求しました。しかしプログラマは、その属性に直接アクセスする既存のクライアントコードに影響を与えたくありません。この解決策は、property データディスクリプタ内に値属性へのアクセスをラップすることです:</p>
<div class="highlight-python"><pre>class Cell(object):
    . . .
    def getvalue(self, obj):
        "Recalculate cell before returning value"
        self.recalc()
        return obj._value
    value = property(getvalue)</pre>
</div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id16">関数とメソッド</a><a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のオブジェクト指向機能は、関数に基づく環境の上に構築されています。非データディスクリプタを使って、この 2 つはシームレスに組み合わされています。</p>
<p>クラス辞書は、メソッドを関数として保存します。クラス定義内で、メソッドは、関数を使うのに便利なツール、 <a class="reference internal" href="../reference/compound_stmts.html#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a> や <a class="reference internal" href="../reference/expressions.html#lambda"><tt class="xref std std-keyword docutils literal"><span class="pre">lambda</span></tt></a> を使って書かれます。標準の関数との唯一の違いは、第一引数がオブジェクトインスタンスのために予約されていることです。
Python の慣習では、このインスタンスの参照は <em>self</em> と呼ばれますが、
<em>this</em> その他の好きな変数名で呼び出せます。</p>
<p>メソッドの呼び出しをサポートするために、関数の <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> メソッドは属性アクセス時にメソッドを束縛します。これにより、すべての関数は、それが呼び出されたのがオブジェクトかクラスかによって、束縛か非束縛メソッドを返す非データディスクリプタになります。pure Python では、これはこのようにはたらきます:</p>
<div class="highlight-python"><pre>class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        return types.MethodType(self, obj, objtype)</pre>
</div>
<p>インタプリタを起動すると、この関数ディスクリプタが実際にどうはたらくかを見られます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">     def f(self, x):</span>
<span class="go">          return x</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">]</span> <span class="c"># 関数として内部に保存されている</span>
<span class="go">&lt;function f at 0x00C45070&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">f</span>             <span class="c"># クラスから取得すると非束縛メソッドになる</span>
<span class="go">&lt;unbound method D.f&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">f</span>             <span class="c"># クラスから取得すると束縛メソッドになる</span>
<span class="go">&lt;bound method D.f of &lt;__main__.D object at 0x00B18C90&gt;&gt;</span>
</pre></div>
</div>
<p>この出力が暗示するのは、束縛メソッドと非束縛メソッドは 2 つの異なる型であるということです。これらは、異なる型として実装することも出来ますが、
<a class="reference external" href="http://svn.python.org/view/python/trunk/Objects/classobject.c?view=markup">Objects/classobject.c</a>
における <a class="reference internal" href="../c-api/method.html#PyMethod_Type" title="PyMethod_Type"><tt class="xref c c-type docutils literal"><span class="pre">PyMethod_Type</span></tt></a> の実際の C 実装は、 <tt class="xref py py-attr docutils literal"><span class="pre">im_self</span></tt> が
<em>NULL</em> (<em>None</em> と等価な C) に設定されているかに依って 2 つの異なる表現を持つ、
1 つのオブジェクトです。</p>
<p>同様に、メソッドオブジェクトを呼び出すことの効果も、 <tt class="xref py py-attr docutils literal"><span class="pre">im_self</span></tt>
フィールドに依ります。設定されていれば (束縛を意味し)、期待通り
(<tt class="xref py py-attr docutils literal"><span class="pre">im_func</span></tt> フィールドに保存されている) 元の関数が、第一引数をインスタンスとして、呼び出されます。非束縛なら、すべての引数がそのまま元の関数に渡されます。
<tt class="xref py py-func docutils literal"><span class="pre">instancemethod_call()</span></tt> の実際の C 実装は、型チェックがあるため、もう少しだけ複雑です。</p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id17">静的メソッドとクラスメソッド</a><a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>非データディスクリプタは、関数をメソッドに束縛する、各種の一般的なパターンに、単純な機構を提供します。</p>
<p>まとめると、関数は <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><tt class="xref py py-meth docutils literal"><span class="pre">__get__()</span></tt></a> メソッドを持ち、属性としてアクセスされたとき、メソッドに変換されます。この非データディスクリプタは、
<tt class="docutils literal"><span class="pre">obj.f(*args)</span></tt> の呼び出しを <tt class="docutils literal"><span class="pre">f(obj,</span> <span class="pre">*args)</span></tt> に変換します。
<tt class="docutils literal"><span class="pre">klass.f(*args)</span></tt> を呼び出すと <tt class="docutils literal"><span class="pre">f(*args)</span></tt> になります。</p>
<p>このチャートは、束縛と、その 2 つの異なる便利な形をまとめています:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="39%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">変換</th>
<th class="head">オブジェクトから呼び出される</th>
<th class="head">クラスから呼び出される</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>関数</td>
<td>f(obj, *args)</td>
<td>f(*args)</td>
</tr>
<tr class="row-odd"><td>静的メソッド</td>
<td>f(*args)</td>
<td>f(*args)</td>
</tr>
<tr class="row-even"><td>クラスメソッド</td>
<td>f(type(obj), *args)</td>
<td>f(klass, *args)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>静的メソッドは、下にある関数をそのまま返します。
<tt class="docutils literal"><span class="pre">c.f</span></tt> や <tt class="docutils literal"><span class="pre">C.f</span></tt> は、 <tt class="docutils literal"><span class="pre">object.__getattribute__(c,</span> <span class="pre">&quot;f&quot;)</span></tt> や
<tt class="docutils literal"><span class="pre">object.__getattribute__(C,</span> <span class="pre">&quot;f&quot;)</span></tt> を直接探索するのと同じです。結果として、関数はオブジェクトとクラスから同じようにアクセスできます。</p>
<p>静的メソッドにすると良いのは、 <tt class="docutils literal"><span class="pre">self</span></tt> 変数への参照を持たないメソッドです。</p>
<p>例えば、統計パッケージに、実験データのコンテナがあるとします。そのクラスは、平均、メジアン、その他の、データに依る記述統計を計算する標準メソッドを提供します。しかし、概念上は関係があっても、データには依らないような便利な関数もあります。例えば、 <tt class="docutils literal"><span class="pre">erf(x)</span></tt> は統計上の便利な変換ルーチンですが、特定のデータセットに直接には依存しません。これは、オブジェクトからでもクラスからでも呼び出せます:
<tt class="docutils literal"><span class="pre">s.erf(1.5)</span> <span class="pre">--&gt;</span> <span class="pre">.9332</span></tt> または <tt class="docutils literal"><span class="pre">Sample.erf(1.5)</span> <span class="pre">--&gt;</span> <span class="pre">.9332</span></tt> 。</p>
<p>静的メソッドは下にある関数をそのまま返すので、呼び出しの例は面白くありません:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">     def f(x):</span>
<span class="go">          print x</span>
<span class="go">     f = staticmethod(f)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">E</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>非データディスクリプタプロトコルを使うと、pure Python 版の
<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><tt class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></tt></a> は以下のようになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">StaticMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
 <span class="s">&quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&quot;</span>

 <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

 <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
</pre></div>
</div>
<p>静的メソッドとは違って、クラスメソッドは関数を呼び出す前にクラス参照を引数リストの先頭に加えます。このフォーマットは、呼び出し元がオブジェクトでもクラスでも同じです:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">E</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">     def f(klass, x):</span>
<span class="go">          return klass.__name__, x</span>
<span class="go">     f = classmethod(f)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">E</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(&#39;E&#39;, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">E</span><span class="p">()</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(&#39;E&#39;, 3)</span>
</pre></div>
</div>
<p>この振る舞いは、関数がクラス参照のみを必要とし、下にあるデータを考慮しないときに便利です。クラスメソッドの使い方の一つは、代わりのクラスコンストラクタを作ることです。Python 2.3 では、クラスメソッド
<a class="reference internal" href="../library/stdtypes.html#dict.fromkeys" title="dict.fromkeys"><tt class="xref py py-func docutils literal"><span class="pre">dict.fromkeys()</span></tt></a> は新しい辞書をキーのリストから生成します。等価な pure Python は:</p>
<div class="highlight-python"><pre>class Dict:
    . . .
    def fromkeys(klass, iterable, value=None):
        "Emulate dict_fromkeys() in Objects/dictobject.c"
        d = klass()
        for key in iterable:
            d[key] = value
        return d
    fromkeys = classmethod(fromkeys)</pre>
</div>
<p>これで一意なキーを持つ新しい辞書が以下のように構成できます:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="s">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: None, &#39;r&#39;: None, &#39;b&#39;: None, &#39;c&#39;: None, &#39;d&#39;: None}</span>
</pre></div>
</div>
<p>非データディスクリプタプロトコルを使った、 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><tt class="xref py py-func docutils literal"><span class="pre">classmethod()</span></tt></a> の pure Python
版はこのようになります:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ClassMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
     <span class="s">&quot;Emulate PyClassMethod_Type() in Objects/funcobject.c&quot;</span>

     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

     <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">klass</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
               <span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
          <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
               <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">newfunc</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="doanddont.html" title="Python 良い慣用句、悪い慣用句"
             >次へ</a> |</li>
        <li class="right" >
          <a href="curses.html" title="Python で Curses プログラミング"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python HOWTO</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>