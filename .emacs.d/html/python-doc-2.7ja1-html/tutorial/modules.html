

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. モジュール &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python チュートリアル" href="index.html" />
    <link rel="next" title="7. 入力と出力" href="inputoutput.html" />
    <link rel="prev" title="5. データ構造" href="datastructures.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="inputoutput.html" title="7. 入力と出力"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="datastructures.html" title="5. データ構造"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python チュートリアル</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. モジュール</a><ul>
<li><a class="reference internal" href="#tut-moremodules">6.1. モジュールについてもうすこし</a></li>
<li><a class="reference internal" href="#tut-modulesasscripts">6.2. モジュールをスクリプトとして実行する</a><ul>
<li><a class="reference internal" href="#tut-searchpath">6.2.1. モジュール検索パス</a></li>
<li><a class="reference internal" href="#python">6.2.2. &#8220;コンパイル&#8221; された Python ファイル</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tut-standardmodules">6.3. 標準モジュール</a></li>
<li><a class="reference internal" href="#dir">6.4. <tt class="docutils literal"><span class="pre">dir()</span></tt> 関数</a></li>
<li><a class="reference internal" href="#tut-packages">6.5. パッケージ</a><ul>
<li><a class="reference internal" href="#import">6.5.1. パッケージから * を import する</a></li>
<li><a class="reference internal" href="#id8">6.5.2. パッケージ内での参照</a></li>
<li><a class="reference internal" href="#id9">6.5.3. 複数ディレクトリ中のパッケージ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="datastructures.html"
                        title="前の章へ">5. データ構造</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="inputoutput.html"
                        title="次の章へ">7. 入力と出力</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/tutorial/modules.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tut-modules">
<span id="id1"></span><h1>6. モジュール<a class="headerlink" href="#tut-modules" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Python インタプリタを終了させ、再び起動すると、これまでに行ってきた定義
(関数や変数) は失われています。ですから、より長いプログラムを書きたいなら、テキストエディタを使ってインタプリタへの入力を用意しておき、手作業の代わりにファイルを入力に使って動作させるとよいでしょう。この作業を <em>スクリプト (script)</em> の作成と言います。プログラムが長くなるにつれ、メンテナンスを楽にするために、スクリプトをいくつかのファイルに分割したくなるかもしれません。また、いくつかのプログラムで書いてきた便利な関数について、その定義をコピーすることなく個々のプログラムで使いたいと思うかもしれません。</p>
<p>こういった要求をサポートするために、Python では定義をファイルに書いておき、スクリプトの中やインタプリタの対話インスタンス上で使う方法があります。このファイルを <em>モジュール (module)</em> と呼びます。モジュールにある定義は、他のモジュールや <em>main</em> モジュール
(実行のトップレベルや電卓モードでアクセスできる変数の集まりを指します)
に <em>import</em> (取り込み) することができます。</p>
<p>モジュールは Python の定義や文が入ったファイルです。ファイル名はモジュール名に接尾語 <tt class="file docutils literal"><span class="pre">.py</span></tt> がついたものになります。モジュールの中では、(文字列の) モジュール名をグローバル変数 <tt class="docutils literal"><span class="pre">__name__</span></tt>
で取得できます。例えば、お気に入りのテキストエディタを使って、現在のディレクトリに以下の内容のファイル <tt class="file docutils literal"><span class="pre">fibo.py</span></tt> を作成してみましょう。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># フィボナッチ数列モジュール</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>    <span class="c"># nまでのフィボナッチ級数を出力</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">b</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>

<span class="k">def</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c"># nまでのフィボナッチ級数を返す</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>次に Python インタプリタに入り、モジュールを以下のコマンドで import しましょう。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
</pre></div>
</div>
<p>この操作では、 <tt class="docutils literal"><span class="pre">fibo</span></tt> で定義された関数の名前を直接現在のシンボルテーブルに入力することはありません。単にモジュール名 <tt class="docutils literal"><span class="pre">fibo</span></tt> だけをシンボルテーブルに入れます。関数にはモジュール名を使ってアクセスします。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">fib</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">fib2</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;fibo&#39;</span>
</pre></div>
</div>
<p>関数を度々使うのなら、ローカルな名前に代入できます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">.</span><span class="n">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<div class="section" id="tut-moremodules">
<span id="id2"></span><h2>6.1. モジュールについてもうすこし<a class="headerlink" href="#tut-moremodules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>モジュールには、関数定義に加えて実行文を入れることができます。これらの実行文はモジュールを初期化するためのものです。これらの実行文は、モジュールがどこかで <em>最初に</em> import された時にだけ実行されます。 <a class="footnote-reference" href="#id10" id="id3">[1]</a></p>
<p>各々のモジュールは、自分のプライベートなシンボルテーブルを持っていて、モジュールで定義されている関数はこのテーブルをグローバルなシンボルテーブルとして使います。したがって、モジュールの作者は、ユーザのグローバル変数と偶然的な衝突が起こる心配をせずに、グローバルな変数をモジュールで使うことができます。一方、自分が行っている操作をきちんと理解していれば、モジュール内の関数を参照するのと同じ表記法 <tt class="docutils literal"><span class="pre">modname.itemname</span></tt> で、モジュールのグローバル変数をいじることもできます。</p>
<p>モジュールが他のモジュールを import することもできます。
<a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文は全てモジュールの(さらに言えばスクリプトでも)先頭に置きますが、これは慣習であって必須ではありません。
import されたモジュール名は import を行っているモジュールのグローバルなシンボルテーブルに置かれます。</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文には、あるモジュール内の名前を、import を実行しているモジュールのシンボルテーブル内に直接取り込むという変型があります。例えば、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="n">fib</span><span class="p">,</span> <span class="n">fib2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<p>この操作は、import の対象となるモジュール名をローカルなシンボルテーブル内に取り入れることはありません (従って上の例では、 <tt class="docutils literal"><span class="pre">fibo</span></tt> は定義されません)。</p>
<p>モジュールで定義されている名前を全て import するという変型もあります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<p>上の操作は、アンダースコア (<tt class="docutils literal"><span class="pre">_</span></tt>) で開始する名前以外の全ての名前を import します。</p>
<p>一般的には、モジュールやパッケージから <tt class="docutils literal"><span class="pre">*</span></tt> を import するというやり方には賛同できません。というのは、この操作を行うとしばしば可読性に乏しいコードになるからです。しかし、対話セッションでキータイプの量を減らすために使うのは構わないでしょう。</p>
<div class="admonition note">
<p class="first admonition-title">ノート</p>
<p class="last">実行効率上の理由で、各モジュールはインタープリタの 1 セッションごとに 1 回だけ
import されます。従って、モジュールを修正した場合には、インタープリタを再起動させなければなりません &#8211; もしくは、その場で手直ししてテストしたいモジュールが 1 つだった場合には、例えば <tt class="docutils literal"><span class="pre">reload(modulename)</span></tt> のように <a class="reference internal" href="../library/functions.html#reload" title="reload"><tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt></a>
を使ってください。</p>
</div>
</div>
<div class="section" id="tut-modulesasscripts">
<span id="id4"></span><h2>6.2. モジュールをスクリプトとして実行する<a class="headerlink" href="#tut-modulesasscripts" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python モジュールを</p>
<div class="highlight-python"><pre>python fibo.py &lt;arguments&gt;</pre>
</div>
<p>と実行すると、 <tt class="docutils literal"><span class="pre">__name__</span></tt> に <tt class="docutils literal"><span class="pre">__main__</span></tt> が設定されている点を除いて import
したときと同じようにモジュール内のコードが実行されます。つまりモジュールの末尾に、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">fib</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>このコードを追加することで、このファイルが import できるモジュールであると同時にスクリプトとしても使えるようになります。なぜならモジュールが &#8220;main&#8221; ファイルとして起動されたときだけ、コマンドラインを解釈するコードが実行されるからです。</p>
<div class="highlight-python"><pre>$ python fibo.py 50
1 1 2 3 5 8 13 21 34</pre>
</div>
<p>モジュールが import された場合は、そのコードは実行されません。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>この方法はモジュールに便利なユーザインターフェースを提供したり、テストのために
(スクリプトをモジュールとして起動しテストスイートを実行して) 使われます。</p>
<div class="section" id="tut-searchpath">
<span id="id5"></span><h3>6.2.1. モジュール検索パス<a class="headerlink" href="#tut-searchpath" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-0"><tt class="xref py py-mod docutils literal"><span class="pre">spam</span></tt> という名前のモジュールが import されると、インタプリタは
<tt class="file docutils literal"><span class="pre">spam.py</span></tt> という名前のファイルを現在のディレクトリ内で探し、次に環境変数 <span class="target" id="index-1"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> に指定されているディレクトリのリストから探します。 <span class="target" id="index-2"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> はシェル変数 <span class="target" id="index-3"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt> と同じ構文、すなわちディレクトリ名を並べたものです。 <span class="target" id="index-4"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a>
が設定されていないか、探しているファイルが見つからなかった場合は、検索対象をインストール方法に依存するデフォルトのパスにして続けます。
Unixでは、このパスは通常 <tt class="file docutils literal"><span class="pre">.:/usr/locall/lib/python</span></tt> です。</p>
<p>実際には、モジュールは変数 <tt class="docutils literal"><span class="pre">sys.path</span></tt> で指定されたディレクトリのリストから検索されます。 <tt class="docutils literal"><span class="pre">sys.path</span></tt> は、入力とするスクリプトの入ったディレクトリ
(現在のディレクトリ)、 <span class="target" id="index-5"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> 、およびインストール方法依存のデフォルト値を使って初期化されます。
Python プログラマは、自分の行っている操作を理解しているなら、この変数を使ってモジュール検索パスを修正したり置き換えたりすることができます。起動しようとするスクリプトの入ったディレクトリが検索パス上にあるため、スクリプトが標準モジュールと同じ名前をもたないようにすることが重要です。さもなければ、Python が標準モジュールを import するときにスクリプトをモジュールとして import しようと試みてしまうので注意してください。このような誤りを犯すと、通常はエラーになります。詳しくは  <a class="reference internal" href="#tut-standardmodules"><em>標準モジュール</em></a> を参照してください。</p>
</div>
<div class="section" id="python">
<h3>6.2.2. &#8220;コンパイル&#8221; された Python ファイル<a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>たくさんの標準モジュールを使うような短いプログラムの起動時間を大きく高速化するために、 <tt class="file docutils literal"><span class="pre">spam.py</span></tt> が見つかったディレクトリに <tt class="file docutils literal"><span class="pre">spam.pyc</span></tt>
という名前のファイルがあった場合には、このファイルをモジュール <tt class="xref py py-mod docutils literal"><span class="pre">spam</span></tt>
の &#8220;バイトコンパイルされた&#8221; バージョンであると仮定します。
<tt class="file docutils literal"><span class="pre">spam.pyc</span></tt> を生成するのに使われたバージョンの <tt class="file docutils literal"><span class="pre">spam.py</span></tt> のファイル修正時刻が <tt class="file docutils literal"><span class="pre">spam.pyc</span></tt> に記録されており、この値が一致しなければ
<tt class="file docutils literal"><span class="pre">spam.pyc</span></tt> ファイルは無視されます。</p>
<p>通常、 <tt class="file docutils literal"><span class="pre">spam.pyc</span></tt> ファイルを生成するために何かをする必要はありません。
<tt class="file docutils literal"><span class="pre">spam.py</span></tt> が無事コンパイルされると、常にコンパイルされたバージョンを
<tt class="file docutils literal"><span class="pre">spam.pyc</span></tt> へ書き出すよう試みます。この試みが失敗してもエラーにはなりません。何らかの理由でファイルが完全に書き出されなかった場合、作成された
<tt class="file docutils literal"><span class="pre">smap.pyc</span></tt> は無効であるとみなされ、それ以後無視されます。
<tt class="file docutils literal"><span class="pre">spam.pyc</span></tt> ファイルの内容はプラットフォームに依存しないので、 Python
のモジュールのディレクトリは異なるアーキテクチャのマシン間で共有することができます。</p>
<p>エキスパート向けのTips:</p>
<ul>
<li><p class="first">Python インタプリタを <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a> フラグ付きで起動すると、最適化されたコードが生成されて <tt class="file docutils literal"><span class="pre">.pyo</span></tt> ファイルに保存されます。最適化機構は今のところあまり役に立っていません。最適化機構は <a class="reference internal" href="../reference/simple_stmts.html#assert"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> 文と <tt class="docutils literal"><span class="pre">SET_LINENO</span></tt> 命令を除去しているだけです。
<a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a> を使うと、 <em>すべての</em>  バイトコード (<a class="reference internal" href="../glossary.html#term-bytecode"><em class="xref std std-term">bytecode</em></a>)
が最適化されます。
<tt class="docutils literal"><span class="pre">.pyc</span></tt> ファイルは無視され、 <tt class="docutils literal"><span class="pre">.py</span></tt> ファイルは最適化されたバイトコードにコンパイルされます。</p>
</li>
<li><p class="first">二つの <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a> フラグ (<a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><em class="xref std std-option">-OO</em></a>) を Python インタプリタへ渡すと、バイトコードコンパイラは、まれにプログラムが正しく動作しなくなるかもしれないような最適化を実行します。現状では、ただ <tt class="docutils literal"><span class="pre">__doc__</span></tt> 文字列をバイトコードから除去して、よりコンパクトな <tt class="file docutils literal"><span class="pre">.pyo</span></tt> ファイルにするだけです。この文字列が利用できることをあてにしているプログラムがあるかもしれないので、自分の行っている操作が何かわかっているときにだけこのオプションを使うべきです。</p>
</li>
<li><p class="first"><tt class="file docutils literal"><span class="pre">.pyc</span></tt> ファイルや <tt class="file docutils literal"><span class="pre">.pyo</span></tt> ファイルから読み出されたとしても、プログラムは何ら高速に動作するわけではありません。
<tt class="file docutils literal"><span class="pre">.pyc</span></tt> ファイルや <tt class="file docutils literal"><span class="pre">.pyo</span></tt> ファイルで高速化されるのは、読み込まれるときの速度だけです。</p>
</li>
<li><p class="first">スクリプトの名前をコマンドラインで指定して実行した場合、そのスクリプトのバイトコードが <tt class="file docutils literal"><span class="pre">.pyc</span></tt> や <tt class="file docutils literal"><span class="pre">.pyo</span></tt> に書き出されることはありません。従って、スクリプトのほとんどのコードをモジュールに移し、そのモジュールを
import する小さなブートストラップスクリプトを作れば、スクリプトの起動時間を短縮できるときがあります。 <tt class="file docutils literal"><span class="pre">.pyc</span></tt> または <tt class="file docutils literal"><span class="pre">.pyo</span></tt>
ファイルの名前を直接コマンドラインに指定することもできます。</p>
</li>
<li><p class="first">一つのモジュールについて、ファイル <tt class="file docutils literal"><span class="pre">spam.py</span></tt> のない <tt class="file docutils literal"><span class="pre">spam.pyc</span></tt>
(<a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a> を使ったときは <tt class="file docutils literal"><span class="pre">spam.pyo</span></tt>) があってもかまいません。この仕様は、Python コードでできたライブラリをリバースエンジニアリングがやや困難な形式で配布するために使えます。</p>
</li>
<li id="index-6"><p class="first"><a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: ディレクトリに含まれる Python ソースファイルを、一括してバイトコンパイルします。"><tt class="xref py py-mod docutils literal"><span class="pre">compileall</span></tt></a> は、 <tt class="file docutils literal"><span class="pre">.pyc</span></tt> ファイル (または <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><em class="xref std std-option">-O</em></a>
を使ったときは <tt class="file docutils literal"><span class="pre">.pyo</span></tt> ファイル) をディレクトリ内の全てのモジュールに対して生成することができます。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="tut-standardmodules">
<span id="id6"></span><h2>6.3. 標準モジュール<a class="headerlink" href="#tut-standardmodules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-7">Python には標準モジュールのライブラリが付属しています。ライブラリは独立したドキュメント Python ライブラリリファレンス
(以降  &#8220;ライブラリリファレンス&#8221;)で記述されています。モジュールによってはインタプリタに組み込まれたものがあります。インタプリタに組み込まれているモジュールが提供しているのは、言語の中核の部分ではありませんが、効率化のためや、システムコールのようなオペレーティングシステムの根本機能へのアクセス手段を提供するための操作です。これらのモジュールのセットは設定時に選択可能で、またプラットフォームにも依存します。例えば、 <tt class="xref py py-mod docutils literal"><span class="pre">winreg</span></tt>  モジュールは、
Windows でのみ提供されます。とりわけ、注目に値するモジュールが一つあります。
<a class="reference internal" href="../library/sys.html#module-sys" title="sys: システムパラメータと関数へのアクセス"><tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt></a> はどの Python インタプリタにも組み込まれています。変数 <tt class="docutils literal"><span class="pre">sys.ps1</span></tt> と <tt class="docutils literal"><span class="pre">sys.ps2</span></tt> は、それぞれ一次プロンプトと二次プロンプトとして使われる文字列を定義しています。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps1</span>
<span class="go">&#39;&gt;&gt;&gt; &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps2</span>
<span class="go">&#39;... &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps1</span> <span class="o">=</span> <span class="s">&#39;C&gt; &#39;</span>
<span class="go">C&gt; print &#39;Yuck!&#39;</span>
<span class="go">Yuck!</span>
<span class="go">C&gt;</span>
</pre></div>
</div>
<p>これらの二つの変数は、インタプリタが対話モードにあるときだけ定義されています。</p>
<p>変数 <tt class="docutils literal"><span class="pre">sys.path</span></tt> は文字列からなるリストで、インタプリタがモジュールを検索するときのパスを決定します。 <tt class="docutils literal"><span class="pre">sys.path</span></tt> は環境変数
<span class="target" id="index-8"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a> から得たデフォルトパスに、 <span class="target" id="index-9"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a>
が設定されていなければ組み込みのデフォルト値に設定されます。標準的なリスト操作で変更することができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;/ufs/guido/lib/python&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dir">
<span id="tut-dir"></span><h2>6.4. <a class="reference internal" href="../library/functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> 関数<a class="headerlink" href="#dir" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>組込み関数 <a class="reference internal" href="../library/functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> は、あるモジュールがどんな名前を定義しているか調べるために使われます。
<a class="reference internal" href="../library/functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> はソートされた文字列のリストを返します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span><span class="o">,</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">fibo</span><span class="p">)</span>
<span class="go">[&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
<span class="go">[&#39;__displayhook__&#39;, &#39;__doc__&#39;, &#39;__excepthook__&#39;, &#39;__name__&#39;, &#39;__stderr__&#39;,</span>
<span class="go"> &#39;__stdin__&#39;, &#39;__stdout__&#39;, &#39;_getframe&#39;, &#39;api_version&#39;, &#39;argv&#39;,</span>
<span class="go"> &#39;builtin_module_names&#39;, &#39;byteorder&#39;, &#39;callstats&#39;, &#39;copyright&#39;,</span>
<span class="go"> &#39;displayhook&#39;, &#39;exc_clear&#39;, &#39;exc_info&#39;, &#39;exc_type&#39;, &#39;excepthook&#39;,</span>
<span class="go"> &#39;exec_prefix&#39;, &#39;executable&#39;, &#39;exit&#39;, &#39;getdefaultencoding&#39;, &#39;getdlopenflags&#39;,</span>
<span class="go"> &#39;getrecursionlimit&#39;, &#39;getrefcount&#39;, &#39;hexversion&#39;, &#39;maxint&#39;, &#39;maxunicode&#39;,</span>
<span class="go"> &#39;meta_path&#39;, &#39;modules&#39;, &#39;path&#39;, &#39;path_hooks&#39;, &#39;path_importer_cache&#39;,</span>
<span class="go"> &#39;platform&#39;, &#39;prefix&#39;, &#39;ps1&#39;, &#39;ps2&#39;, &#39;setcheckinterval&#39;, &#39;setdlopenflags&#39;,</span>
<span class="go"> &#39;setprofile&#39;, &#39;setrecursionlimit&#39;, &#39;settrace&#39;, &#39;stderr&#39;, &#39;stdin&#39;, &#39;stdout&#39;,</span>
<span class="go"> &#39;version&#39;, &#39;version_info&#39;, &#39;warnoptions&#39;]</span>
</pre></div>
</div>
<p>引数がなければ、 <a class="reference internal" href="../library/functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> は現在定義している名前を列挙します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">.</span><span class="n">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;a&#39;, &#39;fib&#39;, &#39;fibo&#39;, &#39;sys&#39;]</span>
</pre></div>
</div>
<p>変数、モジュール、関数、その他の、すべての種類の名前をリストすることに注意してください。</p>
<p id="index-10"><a class="reference internal" href="../library/functions.html#dir" title="dir"><tt class="xref py py-func docutils literal"><span class="pre">dir()</span></tt></a> は、組込みの関数や変数の名前はリストしません。これらの名前からなるリストが必要なら、標準モジュール <a class="reference internal" href="../library/__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a>
で定義されています。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__builtin__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">__builtin__</span><span class="p">)</span>
<span class="go">[&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;DeprecationWarning&#39;,</span>
<span class="go"> &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;,</span>
<span class="go"> &#39;FloatingPointError&#39;, &#39;FutureWarning&#39;, &#39;IOError&#39;, &#39;ImportError&#39;,</span>
<span class="go"> &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;,</span>
<span class="go"> &#39;LookupError&#39;, &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotImplemented&#39;,</span>
<span class="go"> &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;,</span>
<span class="go"> &#39;PendingDeprecationWarning&#39;, &#39;ReferenceError&#39;, &#39;RuntimeError&#39;,</span>
<span class="go"> &#39;RuntimeWarning&#39;, &#39;StandardError&#39;, &#39;StopIteration&#39;, &#39;SyntaxError&#39;,</span>
<span class="go"> &#39;SyntaxWarning&#39;, &#39;SystemError&#39;, &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;True&#39;,</span>
<span class="go"> &#39;TypeError&#39;, &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;,</span>
<span class="go"> &#39;UnicodeEncodeError&#39;, &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;,</span>
<span class="go"> &#39;UserWarning&#39;, &#39;ValueError&#39;, &#39;Warning&#39;, &#39;WindowsError&#39;,</span>
<span class="go"> &#39;ZeroDivisionError&#39;, &#39;_&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;,</span>
<span class="go"> &#39;__name__&#39;, &#39;abs&#39;, &#39;apply&#39;, &#39;basestring&#39;, &#39;bool&#39;, &#39;buffer&#39;,</span>
<span class="go"> &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;cmp&#39;, &#39;coerce&#39;, &#39;compile&#39;,</span>
<span class="go"> &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;,</span>
<span class="go"> &#39;enumerate&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;exit&#39;, &#39;file&#39;, &#39;filter&#39;, &#39;float&#39;,</span>
<span class="go"> &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;,</span>
<span class="go"> &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;intern&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;,</span>
<span class="go"> &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;long&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;,</span>
<span class="go"> &#39;min&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;property&#39;, &#39;quit&#39;, &#39;range&#39;,</span>
<span class="go"> &#39;raw_input&#39;, &#39;reduce&#39;, &#39;reload&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;,</span>
<span class="go"> &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;,</span>
<span class="go"> &#39;tuple&#39;, &#39;type&#39;, &#39;unichr&#39;, &#39;unicode&#39;, &#39;vars&#39;, &#39;xrange&#39;, &#39;zip&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="tut-packages">
<span id="id7"></span><h2>6.5. パッケージ<a class="headerlink" href="#tut-packages" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>パッケージ (package) は、Python のモジュール名前空間を &#8220;ドット付きモジュール名&#8221;
を使って構造化する手段です。例えば、モジュール名 <tt class="xref py py-mod docutils literal"><span class="pre">A.B</span></tt> は、 <tt class="docutils literal"><span class="pre">A</span></tt> というパッケージのサブモジュール
<tt class="docutils literal"><span class="pre">B</span></tt> を表します。ちょうど、モジュールを利用すると、別々のモジュールの著者が互いのグローバル変数名について心配しなくても済むようになるのと同じように、ドット付きモジュール名を利用すると、 NumPy や Python Imaging Library のように複数モジュールからなるパッケージの著者が、互いのモジュール名について心配しなくても済むようになります。</p>
<p>音声ファイルや音声データを一様に扱うためのモジュールのコレクション
(&#8220;パッケージ&#8221;) を設計したいと仮定しましょう。音声ファイルには多くの異なった形式がある (通常は拡張子、例えば <tt class="file docutils literal"><span class="pre">.wav</span></tt>,
<tt class="file docutils literal"><span class="pre">.aiff</span></tt>, <tt class="file docutils literal"><span class="pre">.au</span></tt> などで認識されます) ので、様々なファイル形式間で変換を行うためのモジュールからなる、次第に増えていくモジュールのコレクションを作成したりメンテナンスしたりする必要があるかもしれません。また、音声データに対して実行したい様々な独自の操作 (ミキシング、エコーの追加、イコライザ関数の適用、人工的なステレオ効果の作成など) があるかもしれません。そうなると、こうした操作を実行するモジュールを果てしなく書くことになるでしょう。以下に (階層的なファイルシステムで表現した)  パッケージの構造案を示します。</p>
<div class="highlight-python"><pre>sound/                          トップレベルのパッケージ
      __init__.py               サウンドパッケージを初期化する
      formats/                  ファイルフォーマット変換用の下位パッケージ
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  サウンド効果用の下位パッケージ
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  フィルタ用の下位パッケージ
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...</pre>
</div>
<p>パッケージを import する際、 Python は <tt class="docutils literal"><span class="pre">sys.path</span></tt> 上のディレクトリを検索して、トップレベルのパッケージの入ったサブディレクトリを探します。</p>
<p>あるディレクトリを、パッケージが入ったディレクトリとしてPython に扱わせるには、ファイル <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> が必要です。このファイルを置かなければならないのは、 <tt class="docutils literal"><span class="pre">string</span></tt> のようなよくある名前のディレクトリにより、モジュール検索パスの後の方で見つかる正しいモジュールが意図せず隠蔽されてしまうのを防ぐためです。最も簡単なケースでは <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> はただの空ファイルで構いませんが、
<tt class="file docutils literal"><span class="pre">__init__.py</span></tt> ではパッケージのための初期化コードを実行したり、後述の
<tt class="docutils literal"><span class="pre">__all__</span></tt> 変数を設定してもかまいません。</p>
<p>パッケージのユーザは、個々のモジュールをパッケージから import
することができます。例えば、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sound.effects.echo</span>
</pre></div>
</div>
<p>この操作はサブモジュール <tt class="xref py py-mod docutils literal"><span class="pre">sound.effects.echo</span></tt> をロードします。このモジュールは、以下のように完全な名前で参照しなければなりません。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sound</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">echo</span><span class="o">.</span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>サブモジュールを import するもう一つの方法を示します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
</pre></div>
</div>
<p>これもサブモジュール <tt class="xref py py-mod docutils literal"><span class="pre">echo</span></tt> をロードし、 <tt class="xref py py-mod docutils literal"><span class="pre">echo</span></tt> をパッケージ名を表す接頭辞なしで利用できるようにします。従って以下のように用いることができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">echo</span><span class="o">.</span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>さらにもう一つのバリエーションとして、必要な関数や変数を直接 import する方法があります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sound.effects.echo</span> <span class="kn">import</span> <span class="n">echofilter</span>
</pre></div>
</div>
<p>この操作も同様にサブモジュール <tt class="xref py py-mod docutils literal"><span class="pre">echo</span></tt> をロードしますが、 <tt class="xref py py-func docutils literal"><span class="pre">echofilter()</span></tt>
を直接利用できるようにします。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">item</span></tt> を使う場合、 <em>item</em> はパッケージ <em>package</em>
のサブモジュール (またはサブパッケージ) でもかまいませんし、関数やクラス、変数のような、 <em>package</em> で定義されている別の名前でもかまわないことに注意してください。
<tt class="docutils literal"><span class="pre">import</span></tt> 文はまず、 <em>item</em> がパッケージ内で定義されているかどうか調べます。定義されていなければ、 <em>item</em> はモジュール名であると仮定して、モジュールをロードしようと試みます。もしモジュールが見つからなければ、 <a class="reference internal" href="../library/exceptions.html#exceptions.ImportError" title="exceptions.ImportError"><tt class="xref py py-exc docutils literal"><span class="pre">ImportError</span></tt></a>
が送出されます。</p>
<p>反対に、 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">item.subitem.subsubitem</span></tt> のような構文を使った場合、最後の
<tt class="docutils literal"><span class="pre">subsubitem</span></tt> を除く各要素はパッケージでなければなりません。最後の要素はモジュールかパッケージにできますが、一つ前の要素で定義されているクラスや関数や変数にはできません。</p>
<div class="section" id="import">
<span id="tut-pkg-import-star"></span><h3>6.5.1. パッケージから * を import する<a class="headerlink" href="#import" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-11">それでは、ユーザが <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></tt> と書いたら、どうなるのでしょうか？理想的には、何らかの方法でファイルシステムが調べられ、そのパッケージにどんなサブモジュールがあるかを調べ上げ、全てを import する、という処理を望むことでしょう。これには長い時間がかかってしまうこともありますし、あるサブモジュールを import
することで、そのモジュールが明示的に import されたときのみ発生して欲しい副作用が起きてしまうかもしれません。</p>
<p>唯一の解決策は、パッケージの作者にパッケージの索引を明示的に提供させるというものです。
<a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文は次の規約を使います: パッケージの <tt class="file docutils literal"><span class="pre">__init__.py</span></tt>
コードに <tt class="docutils literal"><span class="pre">__all__</span></tt> という名前のリストが定義されていれば、
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">*</span></tt> が現れたときに import するリストとして使います。新たなパッケージがリリースされるときにリストを最新の状態に更新するのはパッケージの作者の責任となります。自分のパッケージから * を import するという使い方に同意できなければ、パッケージの作者はこの使い方をサポートしないことにしてもかまいません。例えば、ファイル <tt class="docutils literal"><span class="pre">sounds/effects/__init__.py</span></tt> には、次のようなコードを入れてもよいかもしれません。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;echo&quot;</span><span class="p">,</span> <span class="s">&quot;surround&quot;</span><span class="p">,</span> <span class="s">&quot;reverse&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>この例では、 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></tt> とすると、 <tt class="xref py py-mod docutils literal"><span class="pre">sound</span></tt>
パッケージから指定された 3つのサブモジュールが  import されることになっている、ということを意味します。</p>
<p>もしも <tt class="docutils literal"><span class="pre">__all__</span></tt> が定義されていなければ、実行文
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></tt> は、パッケージ <tt class="xref py py-mod docutils literal"><span class="pre">sound.effects</span></tt>
の全てのサブモジュールを現在の名前空間の中へ import <em>しません</em> 。この文は単に(場合によっては初期化コード <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> を実行して)
パッケージ <tt class="xref py py-mod docutils literal"><span class="pre">sound.effects</span></tt> が import されたということを確認し、そのパッケージで定義されている名前を全て import するだけです。 import
される名前には、 <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> で定義された名前 (と、明示的にロードされたサブモジュール) が含まれます。パッケージのサブモジュールで、以前の <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文で明示的にロードされたものも含みます。以下のコードを考えてください。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sound.effects.echo</span>
<span class="kn">import</span> <span class="nn">sound.effects.surround</span>
<span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>上の例では、 <tt class="xref py py-mod docutils literal"><span class="pre">echo</span></tt> と <tt class="xref py py-mod docutils literal"><span class="pre">surround</span></tt> モジュールが現在の名前空間に import
されます。これらのモジュールは <tt class="docutils literal"><span class="pre">from...import</span></tt> 文が実行された際に <tt class="xref py py-mod docutils literal"><span class="pre">sound.effects</span></tt>
内で定義されているからです (この機構は <tt class="docutils literal"><span class="pre">__all__</span></tt> が定義されているときにも働きます)。</p>
<p>特定のモジュールでは <tt class="docutils literal"><span class="pre">import</span> <span class="pre">*</span></tt> を使ったときに、特定のパターンに従った名前のみを公開 (export) するように設計されてはいますが、それでもやはり製品のコードでは良いことではないと考えます。</p>
<p><tt class="docutils literal"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">specific_submodule</span></tt> を使っても何も問題はないことに留意してください！実際この表記法は、import を行うモジュールが他のパッケージと同じ名前を持つサブモジュールを使わなければならない場合を除いて推奨される方式です。</p>
</div>
<div class="section" id="id8">
<h3>6.5.2. パッケージ内での参照<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サブモジュール同士で互いに参照を行う必要がしばしば起こります。例えば、 <tt class="xref py py-mod docutils literal"><span class="pre">surround</span></tt> モジュールは <tt class="xref py py-mod docutils literal"><span class="pre">echo</span></tt> モジュールを使うかもしれません。このような参照はよくあることなので、 <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a> 文を実行すると、まず最初に import 文の入っているパッケージを検索し、その後になって標準のモジュール検索パスを見に行きます。なので、 <tt class="xref py py-mod docutils literal"><span class="pre">surround</span></tt> モジュールは単に <tt class="docutils literal"><span class="pre">import</span> <span class="pre">echo</span></tt> や
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">echo</span> <span class="pre">import</span> <span class="pre">echofilter</span></tt> を使うことができます。
import されたモジュールが現在のパッケージ(現在のモジュールをサブモジュールにしているパッケージ) 内に見つからなかった場合、 <a class="reference internal" href="../reference/simple_stmts.html#import"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a>
文は指定した名前のトップレベルのモジュールを検索します。</p>
<p>パッケージが (前述の例の <tt class="xref py py-mod docutils literal"><span class="pre">sound</span></tt> パッケージのように) サブパッケージの集まりに構造化されている場合、絶対 import を使って兄弟関係にあるパッケージを参照できます。例えば、モジュール <tt class="xref py py-mod docutils literal"><span class="pre">sound.filters.vocoder</span></tt> で <tt class="xref py py-mod docutils literal"><span class="pre">sound.effects</span></tt>
パッケージの <tt class="xref py py-mod docutils literal"><span class="pre">echo</span></tt> モジュールを使いたいとすると、
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">echo</span></tt> を使うことができます。</p>
<p>Python 2.5 からは、上で説明した暗黙の相対importに加えて、明示的な相対importを
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span></tt> の形式の import 文で利用できます。この明示的な相対 import では、先頭のドットで現在および親パッケージを指定します。
<tt class="xref py py-mod docutils literal"><span class="pre">surround</span></tt> モジュールの例では、以下のように記述できます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">echo</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">formats</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="kn">import</span> <span class="n">equalizer</span>
</pre></div>
</div>
<p>明示的および暗黙的な相対 import のどちらも現在のモジュール名をベースにすることに注意してください。メインモジュールの名前は常に <tt class="docutils literal"><span class="pre">&quot;__main__&quot;</span></tt> なので、 Python アプリケーションのメインモジュールとして利用されることを意図しているモジュールでは絶対 import
を利用するべきです。</p>
</div>
<div class="section" id="id9">
<h3>6.5.3. 複数ディレクトリ中のパッケージ<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パッケージはもう一つ特別な属性として <tt class="xref py py-attr docutils literal"><span class="pre">__path__</span></tt> をサポートしています。この属性は、パッケージの <tt class="file docutils literal"><span class="pre">__init__.py</span></tt> 中のコードが実行されるよりも前に、
<tt class="file docutils literal"><span class="pre">__init__.py</span></tt> の収められているディレクトリ名の入ったリストになるよう初期化されます。この変数は変更することができます。変更を加えると、以降そのパッケージに入っているモジュールやサブパッケージの検索に影響します。</p>
<p>この機能はほとんど必要にはならないのですが、パッケージ内存在するモジュール群を拡張するために使うことができます。</p>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>実際には、関数定義も &#8216;実行&#8217; される &#8216;文&#8217; です。モジュールレベルの関数定義を実行すると、関数名はモジュールのグローバルなシンボルテーブルに入ります。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="inputoutput.html" title="7. 入力と出力"
             >次へ</a> |</li>
        <li class="right" >
          <a href="datastructures.html" title="5. データ構造"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python チュートリアル</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>