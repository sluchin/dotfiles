

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9. クラス &mdash; Python 2.7ja1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7ja1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 2.7ja1 documentation 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 2.7ja1 documentation" href="../index.html" />
    <link rel="up" title="Python チュートリアル" href="index.html" />
    <link rel="next" title="10. 標準ライブラリミニツアー" href="stdlib.html" />
    <link rel="prev" title="8. エラーと例外" href="errors.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/_jp.js"></script>
    
 

  </head>
  <body>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. 標準ライブラリミニツアー"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. エラーと例外"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python チュートリアル</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. クラス</a><ul>
<li><a class="reference internal" href="#tut-object">9.1. 名前とオブジェクトについて</a></li>
<li><a class="reference internal" href="#python">9.2. Python のスコープと名前空間</a></li>
<li><a class="reference internal" href="#tut-firstclasses">9.3. クラス初見</a><ul>
<li><a class="reference internal" href="#tut-classdefinition">9.3.1. クラス定義の構文</a></li>
<li><a class="reference internal" href="#tut-classobjects">9.3.2. クラスオブジェクト</a></li>
<li><a class="reference internal" href="#tut-instanceobjects">9.3.3. インスタンスオブジェクト</a></li>
<li><a class="reference internal" href="#tut-methodobjects">9.3.4. メソッドオブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tut-remarks">9.4. いろいろな注意点</a></li>
<li><a class="reference internal" href="#tut-inheritance">9.5. 継承</a><ul>
<li><a class="reference internal" href="#tut-multiple">9.5.1. 多重継承</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tut-private">9.6. プライベート変数</a></li>
<li><a class="reference internal" href="#tut-odds">9.7. 残りのはしばし</a><ul>
<li><a class="reference internal" href="#tut-exceptionclasses">9.7.1. 例外はクラスであってもよい</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator">9.8. イテレータ (iterator)</a></li>
<li><a class="reference internal" href="#generator">9.9. ジェネレータ (generator)</a></li>
<li><a class="reference internal" href="#tut-genexps">9.10. ジェネレータ式</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="errors.html"
                        title="前の章へ">8. エラーと例外</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="stdlib.html"
                        title="次の章へ">10. 標準ライブラリミニツアー</a></p>
  <h3>このページ</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/tutorial/classes.txt"
           rel="nofollow">ソースコードを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tut-classes">
<span id="id1"></span><h1>9. クラス<a class="headerlink" href="#tut-classes" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Python は、他のプログラミング言語と比て、最小限の構文と意味付けを使ってクラスを言語に追加しています。
Python のクラスは、 C++ と Modula-3 のクラスメカニズムを混ぜたものです。
Python のクラス機構はオブジェクト指向プログラミングの標準的な機能を全て提供しています。クラスの継承メカニズムは、複数の基底クラスを持つことができ、派生クラスで基底クラスの任意のメソッドをオーバライドすることができます。メソッドでは、基底クラスのメソッドを同じ名前で呼び出すことができます。オブジェクトには任意の種類と数のデータを格納することができます。モジュールと同じく、クラス機構も Python の動的な性質に従うように設計されています。クラスは実行時に生成され、生成後に変更することができます。</p>
<p>C++ の用語で言えば、通常のクラスメンバ (データメンバも含む) は
(<a class="reference internal" href="#tut-private"><em>プライベート変数</em></a> に書かれている例外を除いて) <em>public</em>
であり、メンバ関数はすべて <em>仮想関数(virtual)</em> です。
Module-3 にあるような、オブジェクトのメンバをメソッドから参照するための短縮した記法は使えません:
メソッド関数の宣言では、オブジェクト自体を表す第一引数を明示せねばなりません。第一引数のオブジェクトはメソッド呼び出しの際に暗黙の引数として渡されます。
Smalltalk に似て、クラスはそれ自体がオブジェクトです。そのため、 import や名前変更といった操作が可能です。
C++ や Modula-3 と違って、ユーザーは組込み型を基底クラスにして拡張を行えます。また、C++ とは同じで Modula-3 とは違う点として、特別な構文を伴うほとんどの組み込み演算子 (算術演算子 (arithmetic operator) や添字表記)
はクラスインスタンスで使うために再定義できます。</p>
<p>(クラスに関して普遍的な用語定義がないので、 Smalltalk と C++
の用語を場合に応じて使っていくことにします。
C++ よりも Modula-3 の方がオブジェクト指向の意味論が Python に近いので、
Modula-3 の用語を使いたいのですが、ほとんどの読者は Modula-3 についてしらないでしょうから。)</p>
<div class="section" id="tut-object">
<span id="id2"></span><h2>9.1. 名前とオブジェクトについて<a class="headerlink" href="#tut-object" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>オブジェクトには個体性があり、同一のオブジェクトに(複数のスコープから)
複数の名前を割り当てることができます。この機能は他の言語では 別名づけ(ailias) として知られています。
Python を一見しただけでは、別名づけの重要性は分からないことが多く、変更不能な基本型 (数値、文字列、タプル)を扱うときには無視して差し支えありません。しかしながら、別名付けは、リストや辞書や他の多くの型など、変更可能な型を扱う
Python コード上で驚くべき効果があります。別名付けはいくつかの点でポインタのように振舞い、このことは通常はプログラムに利するように使われます。例えば、オブジェクトの受け渡しは、実装上はポインタが渡されるだけなのでコストの低い操作になります。また、関数があるオブジェクトを引数として渡されたとき、関数の呼び出し側からオブジェクトに対する変更を見ることができます &#8212; これにより、 Pascal
にあるような二つの引数渡し機構をもつ必要をなくしています。</p>
</div>
<div class="section" id="python">
<span id="tut-scopes"></span><h2>9.2. Python のスコープと名前空間<a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>クラスを紹介する前に、Python のスコープのルールについてあることを話しておかなければなりません。クラス定義は巧みなトリックを名前空間に施すので、何が起こっているのかを完全に理解するには、スコープと名前空間がどのように動作するかを理解する必要があります。ちなみに、この問題に関する知識は全ての Python プログラマにとって有用です。</p>
<p>まず定義から始めましょう。</p>
<p><em>名前空間 (namespace)</em> とは、名前からオブジェクトへの対応付け (mapping) です。ほとんどの名前空間は、現状では Python の辞書として実装されていますが、そのことは通常は (パフォーマンス以外では) 目立つことはないし、将来は変更されるかもしれません。名前空間の例には、組込み名の集合 (<a class="reference internal" href="../library/functions.html#abs" title="abs"><tt class="xref py py-func docutils literal"><span class="pre">abs()</span></tt></a> 等の関数や組込み例外名)、モジュール内のグローバルな名前、関数を呼び出したときのローカルな名前があります。オブジェクトの属性からなる集合もまた、ある意味では名前空間です。名前空間について知っておくべき重要なことは、異なった名前空間にある名前の間には全く関係がないということです。例えば、二つの別々のモジュールの両方で関数 <tt class="docutils literal"><span class="pre">maximize</span></tt>
という関数を定義することができ、定義自体は混同されることはありません &#8212;
モジュールのユーザは名前の前にモジュール名をつけなければなりません。</p>
<p>ところで、 <em>属性</em> という言葉は、ドットに続く名前すべてに対して使っています &#8212;
例えば式 <tt class="docutils literal"><span class="pre">z.real</span></tt> で、 <tt class="docutils literal"><span class="pre">real</span></tt> はオブジェクト <tt class="docutils literal"><span class="pre">z</span></tt> の属性です。厳密にいえば、モジュール内の名前に対する参照は属性の参照です。式 <tt class="docutils literal"><span class="pre">modname.funcname</span></tt> では、 <tt class="docutils literal"><span class="pre">modname</span></tt> はあるモジュールオブジェクトで、
<tt class="docutils literal"><span class="pre">funcname</span></tt> はその属性です。この場合には、モジュールの属性とモジュールの中で定義されているグローバル名の間には、直接的な対応付けがされます。これらの名前は同じ名前空間を共有しているのです！  <a class="footnote-reference" href="#id16" id="id3">[1]</a></p>
<p>属性は読取り専用にも、書込み可能にもできます。書込み可能であれば、属性に代入することができます。モジュール属性は書込み可能で、
<tt class="docutils literal"><span class="pre">modname.the_answer</span> <span class="pre">=</span> <span class="pre">42</span></tt> と書くことができます。書込み可能な属性は、
<a class="reference internal" href="../reference/simple_stmts.html#del"><tt class="xref std std-keyword docutils literal"><span class="pre">del</span></tt></a> 文で削除することもできます。例えば、 <tt class="docutils literal"><span class="pre">del</span> <span class="pre">modname.the_answer</span></tt> は、 <tt class="docutils literal"><span class="pre">modname</span></tt>  で指定されたオブジェクトから属性 <tt class="xref py py-attr docutils literal"><span class="pre">the_answer</span></tt> を除去します。</p>
<p>名前空間は様々な時点で作成され、その寿命も様々です。組み込みの名前が入った名前空間は Python インタプリタが起動するときに作成され、決して削除されることはありません。モジュールのグローバルな名前空間は、モジュール定義が読み込まれたときに作成されます。通常、モジュールの名前空間は、インタプリタが終了するまで残ります。インタプリタのトップレベルで実行された文は、スクリプトファイルから読み出されたものでも対話的に読み出されたものでも、 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: トップレベルスクリプトが実行される環境。"><tt class="xref py py-mod docutils literal"><span class="pre">__main__</span></tt></a> という名前のモジュールの一部分であるとみなされるので、独自の名前空間を持つことになります。
(組み込みの名前は実際にはモジュール内に存在します。そのモジュールは
<a class="reference internal" href="../library/__builtin__.html#module-__builtin__" title="__builtin__: 組み込み名前空間を提供するモジュール"><tt class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></tt></a> と呼ばれています。)</p>
<p>関数のローカルな名前空間は、関数が呼び出されたときに作成され、関数から戻ったときや、関数内で例外が送出され、かつ関数内で処理されなかった場合に削除されます。
(実際には、忘れられる、と言ったほうが起きていることをよく表しています。)
もちろん、再帰呼出しのときには、各々の呼び出しで各自のローカルな名前空間があります。</p>
<p><em>スコープ (scope)</em> とは、ある名前空間が直接アクセスできるような、 Python
プログラムのテキスト上の領域です。
&#8220;直接アクセス可能&#8221; とは、修飾なしに (訳注: <tt class="docutils literal"><span class="pre">spam.egg</span></tt> ではなく単に <tt class="docutils literal"><span class="pre">egg</span></tt>
のように) 名前を参照した際に、その名前空間から名前を見つけようと試みることを意味します。</p>
<p>スコープは静的に決定されますが、動的に使用されます。実行中はいつでも、直接名前空間にアクセス可能な、少なくとも三つの入れ子になったスコープがあります。</p>
<ul class="simple">
<li>最初に探される、最も内側のスコープは、ローカルな名前を持っています。</li>
<li>外側の(enclosing)関数のスコープは、近いほうから順に探され、ローカルでもグローバルでもない名前を持っています。</li>
<li>次のスコープは、現在のモジュールのグローバルな名前を持っています。</li>
<li>一番外側の(最後に検索される)スコープはビルトイン名を持っています。</li>
</ul>
<p>名前が global と宣言されている場合、その名前に対する参照や代入は全て、モジュールのグローバルな名前の入った中間のスコープに対して直接行われます。そうでない場合、最も内側のスコープより外側にある変数は全て読み出し専用となります。
(そのような変数に対する書き込みは、単に <em>新しい</em> ローカル変数をもっとも内側のスコープで作成し、外部のスコープの値は変化しません)</p>
<p>通常、ローカルスコープは (プログラムテキスト上の) 現在の関数のローカルな名前を参照します。関数の外側では、ローカルスコープはグローバルな名前空間と同じ名前空間、モジュールの名前空間を参照します。クラス定義では、ローカルスコープの中にもう一つ名前空間が置かれます。</p>
<p>スコープはテキスト上で決定されていると理解することが重要です。モジュール内で定義される関数のグローバルなスコープは、関数がどこから呼び出されても、どんな別名をつけて呼び出されても、そのモジュールの名前空間になります。反対に、実際の名前の検索は実行時に動的に行われます
&#8212; とはいえ、言語の定義は、&#8221;コンパイル&#8221;  時の静的な名前解決の方向に進化しているので、動的な名前解決に頼ってはいけません！
(事実、ローカルな変数は既に静的に決定されています。)</p>
<p>Python 特有の癖として、代入を行うと &#8211; どの <a class="reference internal" href="../reference/simple_stmts.html#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文も有効でない場合は &#8211; 名前がいつも最も内側のスコープに入るというものがあります。代入はデータのコピーを行いません &#8212; 単に名前をオブジェクトに結びつける (bind)
だけです。オブジェクトの削除でも同じです: <tt class="docutils literal"><span class="pre">del</span> <span class="pre">x</span></tt> は、 <tt class="docutils literal"><span class="pre">x</span></tt> をローカルスコープが参照している名前空間から削除します。実際、新たな名前を導入する操作は全てローカルスコープを用います。とりわけ、 import 文や関数定義は、モジュールや関数の名前をローカルスコープに結び付けます。(<a class="reference internal" href="../reference/simple_stmts.html#global"><tt class="xref std std-keyword docutils literal"><span class="pre">global</span></tt></a> 文を使えば、特定の変数がグローバルスコープにあることを示せます。)</p>
</div>
<div class="section" id="tut-firstclasses">
<span id="id4"></span><h2>9.3. クラス初見<a class="headerlink" href="#tut-firstclasses" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>クラスでは、新しい構文を少しと、三つの新たなオブジェクト型、そして新たな意味付けをいくつか取り入れています。</p>
<div class="section" id="tut-classdefinition">
<span id="id5"></span><h3>9.3.1. クラス定義の構文<a class="headerlink" href="#tut-classdefinition" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラス定義の最も単純な形式は、次のようになります。</p>
<div class="highlight-python"><pre>class ClassName:
    &lt;文-1&gt;
    .
    .
    .
    &lt;文-N&gt;</pre>
</div>
<p>関数定義 (<a class="reference internal" href="../reference/compound_stmts.html#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a> 文) と同様、クラス定義が効果をもつにはまず実行しなければなりません。 (クラス定義を <a class="reference internal" href="../reference/compound_stmts.html#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>
文の分岐先や関数内部に置くことも、考え方としてはありえます。)</p>
<p>実際には、クラス定義の内側にある文は、通常は関数定義になりますが、他の文を書くこともでき、それが役に立つこともあります &#8212; これについては後で述べます。クラス内の関数定義は通常、メソッドの呼び出し規約で決められた独特の形式の引数リストを持ちます &#8212; これについても後で述べます。</p>
<p>クラス定義に入ると、新たな名前空間が作成され、ローカルな名前空間として使われます &#8212; 従って、ローカルな変数に対する全ての代入はこの新たな名前空間に入ります。特に、関数定義を行うと、新たな関数の名前はこの名前空間に結び付けられます。</p>
<p>クラス定義から普通に (定義の終端に到達して) 抜けると、
<em>クラスオブジェクト (class object)</em> が生成されます。クラスオブジェクトは、基本的にはクラス定義で作成された名前空間の内容をくるむラッパ (wrapper) です。クラスオブジェクトについては次の節で詳しく学ぶことにします。
(クラス定義に入る前に有効だった) 元のローカルスコープが復帰し、生成されたクラスオブジェクトは復帰したローカルスコープにクラス定義のヘッダで指定した名前
(上の例では <tt class="xref py py-class docutils literal"><span class="pre">ClassName</span></tt>) で結び付けられます。</p>
</div>
<div class="section" id="tut-classobjects">
<span id="id6"></span><h3>9.3.2. クラスオブジェクト<a class="headerlink" href="#tut-classobjects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラス・オブジェクトでは２種類の演算、属性参照とインスタンス生成をサポートしています。</p>
<p><em>属性参照 (attribute reference)</em> は、Python におけるすべての属性参照で使われている標準的な構文、 <tt class="docutils literal"><span class="pre">obj.name</span></tt> を使います。クラスオブジェクトが生成された際にクラスの名前空間にあった名前すべてが有効な属性名です。従って、以下のようなクラス定義では、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;hello world&#39;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">MyClass.i</span></tt> と <tt class="docutils literal"><span class="pre">MyClass.f</span></tt> は妥当な属性参照であり、それぞれ整数と関数オブジェクトを返します。クラス属性に代入を行うこともできます。従って、 <tt class="docutils literal"><span class="pre">MyClass.i</span></tt> の値を代入して変更できます。
<tt class="docutils literal"><span class="pre">__doc__</span></tt> も有効な属性で、そのクラスに属している docstring、この場合は <tt class="docutils literal"><span class="pre">&quot;A</span> <span class="pre">simple</span> <span class="pre">example</span> <span class="pre">class&quot;</span></tt> を返します。</p>
<p>クラスの <em>インスタンス生成 (instantiation)</em> には関数のような表記法を使います。クラスオブジェクトのことを、単にクラスの新しいインスタンスを返すパラメタを持たない関数かのように扱います。例えば (上記のクラスでいえば)、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>は、クラスの新しい <em>インスタンス (instance)</em> を生成し、そのオブジェクトをローカル変数 <tt class="docutils literal"><span class="pre">x</span></tt> へ代入します。</p>
<p>このクラスのインスタンス生成操作 (クラスオブジェクトの &#8220;呼出し&#8221;) を行うと、空のオブジェクトを生成します。多くのクラスは、オブジェクトを作成する際に、カスタマイズされた特定の初期状態になってほしいと望んでいます。そのために、クラスには <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a>
という名前の特別なメソッド定義することができます。例えば次のようにします。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>クラスが <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> メソッドを定義している場合、クラスのインスタンスを生成すると、新しく生成されたクラスインスタンスに対して自動的に <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a>
を呼び出します。従って、この例では、新たな初期済みのインスタンスを次のようにして得ることができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>もちろん、より大きな柔軟性を持たせるために、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a>  メソッドに複数の引数をもたせることができます。その場合、次の例のように、クラスのインスタンス生成操作に渡された引数は
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt></a> に渡されます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</div>
<div class="section" id="tut-instanceobjects">
<span id="id7"></span><h3>9.3.3. インスタンスオブジェクト<a class="headerlink" href="#tut-instanceobjects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ところで、インスタンスオブジェクトを使うと何ができるのでしょうか？インスタンスオブジェクトが理解できる唯一の操作は、属性の参照です。有効な属性の名前には二種類(データ属性およびメソッド)あります。</p>
<p><em>データ属性 (data attribute)</em> は、これは Smalltalk の &#8220;インスタンス変数&#8221; や
C++の &#8220;データメンバ&#8221; に相当します。データ属性を宣言する必要はありません。ローカルな変数と同様に、これらの属性は最初に代入された時点で湧き出てきます。例えば、上で生成した <tt class="xref py py-class docutils literal"><span class="pre">MyClass</span></tt> のインスタンス <tt class="docutils literal"><span class="pre">x</span></tt> に対して、次のコードを実行すると、値 <tt class="docutils literal"><span class="pre">16</span></tt> を印字し、 <tt class="docutils literal"><span class="pre">x</span></tt> の痕跡は残りません。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span>
<span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</div>
<p>もうひとつのインスタンス属性は <em>メソッド (method)</em> です。メソッドとは、オブジェクトに &#8220;属している&#8221;  関数のことです。(Python では、メソッドという用語はクラスインスタンスだけのものではありません。オブジェクト型にもメソッドを持つことができます。例えば、リストオブジェクトには、
append, insert, remove, sort などといったメソッドがあります。とはいえ、以下では特に明記しない限り、クラスのインスタンスオブジェクトのメソッドだけを意味するものとして使うことにします。)</p>
<p id="index-0">インスタンスオブジェクトで有効なメソッド名は、そのクラスによります。定義により、クラスの全てのo関数オブジェクトである属性がインスタンスオブジェクトの妥当なメソッド名に決まります。従って、例では、 <tt class="docutils literal"><span class="pre">MyClass.f</span></tt> は関数なので、 <tt class="docutils literal"><span class="pre">x.f</span></tt> はメソッドの参照として有効です。しかし、 <tt class="docutils literal"><span class="pre">MyClass.i</span></tt> は関数ではないので、 <tt class="docutils literal"><span class="pre">x.i</span></tt> はメソッドの参照として有効ではありません。
<tt class="docutils literal"><span class="pre">x.f</span></tt> は <tt class="docutils literal"><span class="pre">MyClass.f</span></tt> と同じものではありません &#8212; 関数オブジェクトではなく、
<em>メソッドオブジェクト (method object)</em> です。</p>
</div>
<div class="section" id="tut-methodobjects">
<span id="id8"></span><h3>9.3.4. メソッドオブジェクト<a class="headerlink" href="#tut-methodobjects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>普通、メソッドはバインドされた直後に呼び出されます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">MyClass</span></tt> の例では、上のコードは文字列 <tt class="docutils literal"><span class="pre">'hello</span> <span class="pre">world'</span></tt> を返すでしょう。しかしながら、必ずしもメソッドをその場で呼び出さなければならないわけではありません。 <tt class="docutils literal"><span class="pre">x.f</span></tt> はメソッドオブジェクトであり、どこかに記憶しておいて後で呼び出すことができます。例えば次のコードは、</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">xf</span><span class="p">()</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">hello</span> <span class="pre">world</span></tt> を時が終わるまで印字し続けるでしょう。</p>
<p>メソッドが呼び出されるときには実際には何が起きているのでしょうか？
<tt class="xref py py-meth docutils literal"><span class="pre">f()</span></tt> の関数定義では引数を一つ指定していたにもかかわらず、上の例では
<tt class="docutils literal"><span class="pre">x.f</span></tt> が引数なしで呼び出されています。引数はどうなったのでしょうか？たしか、引数が必要な関数を引数無しで呼び出すと、 Python が例外を送出するはずです &#8212; たとえその引数が実際には使われなくても…。</p>
<p>もう答は想像できているかもしれませんね。メソッドについて特別なこととして、オブジェクトが関数の第1引数として渡されます。例では、 <tt class="docutils literal"><span class="pre">x.f()</span></tt> という呼び出しは、 <tt class="docutils literal"><span class="pre">MyClass.f(x)</span></tt> と厳密に等価なものです。一般に、 <em>n</em> 個の引数リストもったメソッドの呼出しは、そのメソッドのオブジェクトを最初の引数の前に挿入した引数リストでメソッドに対応する関数を呼び出すことと等価です。</p>
<p>もしまだメソッドの動作を理解できなければ、一度実装を見てみると事情がよく分かるかもしれません。データ属性ではないインスタンス属性が参照された時は、そのクラスが検索されます。その名前が有効なクラス属性を表している関数オブジェクトなら、インスタンスオブジェクトと見つかった関数オブジェクト (へのポインタ) を抽象オブジェクト、すなわちメソッドオブジェクトにパックして作成します。メソッドオブジェクトが引数リストと共に呼び出されるとき、インスタンスオブジェクトと渡された引数リストから新しい引数リストを作成して、元の関数オブジェクトを新しい引数リストで呼び出します。</p>
</div>
</div>
<div class="section" id="tut-remarks">
<span id="id9"></span><h2>9.4. いろいろな注意点<a class="headerlink" href="#tut-remarks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>データ属性は同じ名前のメソッド属性を上書きしてしまいます。大規模なプログラムでみつけにくいバグを引き起こすことがあるこの偶然的な名前の衝突を避けるには、衝突の可能性を最小限にするような規約を使うのが賢明です。可能な規約としては、メソッド名を大文字で始める、データ属性名の先頭に短い一意な文字列 (あるいはただの下線) をつける、またメソッドには動詞、データ属性には名詞を用いる、などがあります。</p>
<p>データ属性は、メソッドから参照できると同時に、通常のオブジェクトのユーザ
(&#8220;クライアント&#8221;) からも参照できます。言い換えると、クラスは純粋な抽象データ型として使うことができません。実際、 Python では、データ隠蔽を補強するための機構はなにもありません &#8212;
データの隠蔽はすべて規約に基づいています。
(逆に、C 言語で書かれた Python の実装では実装の詳細を完全に隠蔽し、必要に応じてオブジェクトへのアクセスを制御できます。この機構は C 言語で書かれた Python 拡張で使うことができます。)</p>
<p>クライアントはデータ属性を注意深く扱うべきです &#8212; クライアントは、メソッドが維持しているデータ属性の不変式を踏みにじり、台無しにするかもしれません。クライアントは、名前の衝突が回避されている限り、メソッドの有効性に影響を及ぼすことなくインスタンスに独自の属性を追加することができる、ということに注意してください &#8212; ここでも、名前付けの規約は頭痛の種を無くしてくれます。</p>
<p>メソッドの中から、データ属性を (または別のメソッドも！) 参照するための短縮された記法はありません。私は、この仕様がメソッドの可読性を高めていると感じています。あるメソッドを眺めているときにローカルな変数とインスタンス変数をはっきり区別できるからです。</p>
<p>よく、メソッドの最初の引数を <tt class="docutils literal"><span class="pre">self</span></tt> と呼びます。この名前付けは単なる慣習でしかありません。 <tt class="docutils literal"><span class="pre">self</span></tt> という名前は、
Python では何ら特殊な意味を持ちません。とはいえ、この慣行に従わないと、コードは他の Python プログラマにとってやや読みにくいものとなります。また、 <em>クラスブラウザ (class browser)</em> プログラムがこの慣行をあてにして書かれているかもしれません。</p>
<p>クラス属性である関数オブジェクトはいずれも、そのクラスのインスタンスのためのメソッドを定義しています。関数定義は、テキスト上でクラス定義の中に入っている必要はありません。関数オブジェクトをクラスのローカルな変数の中に代入するのも OK です。例えば以下のコードのようにします。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># クラスの外側で定義された関数</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;hello world&#39;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>これで、 <tt class="docutils literal"><span class="pre">f</span></tt> 、 <tt class="docutils literal"><span class="pre">g</span></tt> 、および <tt class="docutils literal"><span class="pre">h</span></tt> は、すべて <tt class="xref py py-class docutils literal"><span class="pre">C</span></tt> の属性であり関数オブジェクトを参照しています。従って、これら全ては、 <tt class="xref py py-class docutils literal"><span class="pre">C</span></tt> のインスタンスのメソッドとなります &#8212;
<tt class="docutils literal"><span class="pre">h</span></tt> は <tt class="docutils literal"><span class="pre">g</span></tt> と全く等価です。これを実践しても、大抵は単にプログラムの読者に混乱をもたらすだけなので注意してください。</p>
<p>メソッドは、 <tt class="docutils literal"><span class="pre">self</span></tt> 引数のメソッド属性を使って、他のメソッドを呼び出すことができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Bag</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">addtwice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>メソッドは、通常の関数と同じようにしてグローバルな名前を参照します。
(クラス自体はグローバルなスコープとして用いられることはありません。)
メソッドでグローバルなデータを使う良い理由はほとんどありませんが、グローバルなスコープを使うべき場面は多々あります。一つ挙げると、メソッド内から、グローバルなスコープに import された関数やモジュールや、そのモジュール中で定義された関数やクラスを使うことができます。通常、メソッドの入っているクラス自体はグローバルなスコープ内で定義されています。次の節では、メソッドが自分のクラスを参照する理由として正当なものを見てみましょう。</p>
<p>個々の値はオブジェクトなので、 <em>クラス</em> (<em>型</em> とも言います) を持っています。それは <tt class="docutils literal"><span class="pre">object.__class__</span></tt> に保持されています。</p>
</div>
<div class="section" id="tut-inheritance">
<span id="id10"></span><h2>9.5. 継承<a class="headerlink" href="#tut-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>言うまでもなく、継承の概念をサポートしない言語機能は &#8220;クラス&#8221; と呼ぶに値しません。派生クラス (derived class) を定義する構文は次のようになります。</p>
<div class="highlight-python"><pre>class DerivedClassName(BaseClassName):
    &lt;文-1&gt;
    .
    .
    .
    &lt;文-N&gt;</pre>
</div>
<p>基底クラス (base class) の名前 <tt class="xref py py-class docutils literal"><span class="pre">BaseClassName</span></tt> は、派生クラス定義の入っているスコープで定義されていなければなりません。基底クラス名のかわりに任意の式を入れることもできます。これは次の例のように、基底クラスが別モジュールで定義されているときに便利なことがあります。</p>
<div class="highlight-python"><pre>class DerivedClassName(modname.BaseClassName):</pre>
</div>
<p>派生クラス定義の実行は、基底クラスの場合と同じように進められます。クラスオブジェクトが構築される時、基底クラスが記憶されます。記憶された基底クラスは、属性参照を解決するために使われます。要求された属性がクラスに見つからなかった場合、基底クラスに検索が進みます。この規則は、基底クラスが他の何らかのクラスから派生したものであった場合、再帰的に適用されます。</p>
<p>派生クラスのインスタンス化では、特別なことは何もありません。
<tt class="docutils literal"><span class="pre">DerivedClassName()</span></tt> はクラスの新たなインスタンスを生成します。メソッドの参照は次のようにしてい解決されます。まず対応するクラス属性が検索されます。検索は、必要に応じ、基底クラス連鎖を下って行われ、検索の結果として何らかの関数オブジェクトがもたらされた場合、メソッド参照は有効なものとなります。</p>
<p>派生クラスは基底クラスのメソッドを上書き (override) することができます。メソッドは同じオブジェクトの別のメソッドを呼び出す際に何ら特殊な権限を持ちません。このため、ある基底クラスのメソッドが、同じ基底クラスで定義されているもう一つのメソッド呼び出しを行っている場合、派生クラスで上書きされた何らかのメソッドが呼び出されることになるかもしれません。
(C++ プログラマへ:  Python では、すべてのメソッドは事実上 <tt class="docutils literal"><span class="pre">virtual</span></tt> です。)</p>
<p>派生クラスで上書きしているメソッドでは、基底クラスの同名のメソッドを置き換えるのではなく、拡張したいのかもしれません。基底クラスのメソッドを直接呼び出す簡単な方法があります。単に <tt class="docutils literal"><span class="pre">BaseClassName.methodname(self,</span> <span class="pre">arguments)</span></tt> を呼び出すだけです。この仕様は、場合によってはクライアントでも役に立ちます。
(この呼び出し方が動作するのは、基底クラスがグローバルスコープの <tt class="docutils literal"><span class="pre">BaseClassName</span></tt>
という名前でアクセスできるときだけです。)</p>
<p>Python には継承に関係する 2 つの組み込み関数があります。</p>
<ul class="simple">
<li><a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><tt class="xref py py-func docutils literal"><span class="pre">isinstance()</span></tt></a> を使うとインスタンスの型が調べられます。
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></tt> は <tt class="docutils literal"><span class="pre">obj.__class__</span></tt> が <a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a> や
<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a> の派生クラスの場合に限り <tt class="docutils literal"><span class="pre">True</span></tt> になります。</li>
<li><a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><tt class="xref py py-func docutils literal"><span class="pre">issubclass()</span></tt></a> を使うとクラスの継承関係が調べられます。
<a class="reference internal" href="../library/functions.html#bool" title="bool"><tt class="xref py py-class docutils literal"><span class="pre">bool</span></tt></a> は <a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a> のサブクラスなので <tt class="docutils literal"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></tt>
は <tt class="docutils literal"><span class="pre">True</span></tt> です。しかし、 <a class="reference internal" href="../library/functions.html#unicode" title="unicode"><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></a> は <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>
のサブクラスではない (単に共通の祖先 <a class="reference internal" href="../library/functions.html#basestring" title="basestring"><tt class="xref py py-class docutils literal"><span class="pre">basestring</span></tt></a>
を共有している) ので <tt class="docutils literal"><span class="pre">issubclass(unicode,</span> <span class="pre">str)</span></tt> は <tt class="docutils literal"><span class="pre">False</span></tt> です。</li>
</ul>
<div class="section" id="tut-multiple">
<span id="id11"></span><h3>9.5.1. 多重継承<a class="headerlink" href="#tut-multiple" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python では、限られた形式の多重継承 (multiple inheritance) もサポートしています。複数の基底クラスをもつクラス定義は次のようになります。</p>
<div class="highlight-python"><pre>class DerivedClassName(Base1, Base2, Base3):
    &lt;文-1&gt;
    .
    .
    .
    &lt;文-N&gt;</pre>
</div>
<p>旧形式のクラスでは、名前解決規則は単に、深さ優先、左から右へ、だけです。従って、ある属性が <tt class="xref py py-class docutils literal"><span class="pre">DerivedClassName</span></tt> で見つからなければ
<tt class="xref py py-class docutils literal"><span class="pre">Base1</span></tt> で検索され、次に <tt class="xref py py-class docutils literal"><span class="pre">Base1</span></tt> の基底クラスで (再帰的に)
検索されます。それでも見つからなければはじめて <tt class="xref py py-class docutils literal"><span class="pre">Base2</span></tt> で検索される、といった具合です。</p>
<p>(人によっては、幅優先 (breadth first) &#8212; <tt class="xref py py-class docutils literal"><span class="pre">Base2</span></tt> と  <tt class="xref py py-class docutils literal"><span class="pre">Base3</span></tt>
を検索してから <tt class="xref py py-class docutils literal"><span class="pre">Base1</span></tt> の基底クラスで検索する &#8212;  のほうが自然に思うかもしれません。しかしながら、幅優先の検索では、 <tt class="xref py py-class docutils literal"><span class="pre">Base1</span></tt> の特定の属性のうち、実際に定義されているのが <tt class="xref py py-class docutils literal"><span class="pre">Base1</span></tt> なのか、その基底クラスなのかを知らなければ、 <tt class="xref py py-class docutils literal"><span class="pre">Base2</span></tt> の属性との名前衝突がどんな結果をもたらすのか分からないことになります。深さ優先規則では、 <tt class="xref py py-class docutils literal"><span class="pre">Base1</span></tt> の直接の属性と継承された属性とを区別しません。)</p>
<p>新スタイルクラス(<a class="reference internal" href="../glossary.html#term-new-style-class"><em class="xref std std-term">new-style class</em></a>) では、協調的な <a class="reference internal" href="../library/functions.html#super" title="super"><tt class="xref py py-func docutils literal"><span class="pre">super()</span></tt></a>
の呼び出しのためにメソッドの解決順序は動的に変更されます。このアプローチは他の多重継承のある言語で call-next-method として知られており、単一継承しかない言語の super 呼び出しよりも強力です。</p>
<p>新スタイルクラスについて、多重継承の全ての場合に 1 つかそれ以上のダイヤモンド継承
(少なくとも 1 つの祖先クラスに対し最も下のクラスから到達する経路が複数ある状態)
があるので、動的順序付けが必要です。例えば、全ての新形式のクラスは <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> を継承しているので、どの多重継承でも <a class="reference internal" href="../library/functions.html#object" title="object"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a> へ到達するための道は複数存在します。基底クラスが複数回アクセスされないようにするために、動的アルゴリズムで検索順序を直列化し、各クラスで指定されている祖先クラスどうしの左から右への順序は崩さず、各祖先クラスを一度だけ呼び出し、かつ一様になる (つまり祖先クラスの順序に影響を与えずにサブクラス化できる) ようにします。まとめると、これらの特徴のおかげで信頼性と拡張性のある多重継承したクラスを設計することができるのです。さらに詳細を知りたければ、 <a class="reference external" href="http://www.python.org/download/releases/2.3/mro/">http://www.python.org/download/releases/2.3/mro/</a>
を見てください。</p>
</div>
</div>
<div class="section" id="tut-private">
<span id="id12"></span><h2>9.6. プライベート変数<a class="headerlink" href="#tut-private" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>オブジェクトの中からしかアクセス出来ない &#8220;プライベート&#8221; インスタンス変数は、
Python にはありません。しかし、ほとんどの Python コードが従っている慣習があります。アンダースコアで始まる名前 (例えば <tt class="docutils literal"><span class="pre">_spam</span></tt>) は、 (関数であれメソッドであれデータメンバであれ) 非 public なAPIとして扱います。これらは、予告なく変更されるかもしれない実装の詳細として扱われるべきです。</p>
<p>クラスのプライベートメンバについて適切なユースケース(特にサブクラスで定義された名前との衝突を避ける場合)があるので、 マングリング(<em class="dfn">name mangling</em>) と呼ばれる、限定されたサポート機構があります。
<tt class="docutils literal"><span class="pre">__spam</span></tt> (先頭に二個以上の下線文字、末尾に一個以下の下線文字) という形式の識別子は、
<tt class="docutils literal"><span class="pre">_classname__spam</span></tt> へとテキスト置換されるようになりました。ここで
<tt class="docutils literal"><span class="pre">classname</span></tt> は、現在のクラス名から先頭の下線文字をはぎとった名前になります。このような難号化 (mangle) は、識別子の文法的な位置にかかわらず行われるので、クラス定義内に現れた識別子全てに対して実行されます。</p>
<p>難号化の規則は主に不慮の事故を防ぐためのものだということに注意してください;
確信犯的な方法で、プライベートとされている変数にアクセスしたり変更することは依然として可能なのです。デバッガのような特殊な状況では、この仕様は便利ですらあります。</p>
<p><tt class="docutils literal"><span class="pre">exec</span></tt> や <tt class="docutils literal"><span class="pre">eval()</span></tt> や <tt class="docutils literal"><span class="pre">execfile()</span></tt> へ渡されたコードでは、呼出し元のクラス名を現在のクラスと見なさないことに注意してください。この仕様は <tt class="docutils literal"><span class="pre">global</span></tt> 文の効果と似ており、その効果もまた同様に、バイトコンパイルされたコードに制限されています。同じ制約が <tt class="docutils literal"><span class="pre">getattr()</span></tt> と
<tt class="docutils literal"><span class="pre">setattr()</span></tt> と <tt class="docutils literal"><span class="pre">delattr()</span></tt> にも適用されます。また、 <tt class="docutils literal"><span class="pre">__dict__</span></tt> を直接参照するときにも適用されます。</p>
</div>
<div class="section" id="tut-odds">
<span id="id13"></span><h2>9.7. 残りのはしばし<a class="headerlink" href="#tut-odds" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Pascal の &#8220;レコード (record)&#8221; や、C 言語の &#8220;構造体 (struct)&#8221; のような、名前つきのデータ要素を一まとめにするデータ型があると便利なことがあります。空のクラス定義を使うとうまくできます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">()</span> <span class="c"># 空の従業員レコードを造る</span>

<span class="c"># レコードのフィールドを設定する</span>
<span class="n">john</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;John Doe&#39;</span>
<span class="n">john</span><span class="o">.</span><span class="n">dept</span> <span class="o">=</span> <span class="s">&#39;computer lab&#39;</span>
<span class="n">john</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>ある特定の抽象データ型を要求する Python コードの断片に、そのデータ型のメソッドをエミュレーションするクラスを代わりに渡すことができます。例えば、ファイルオブジェクトから何らかのデータを構築する関数がある場合、
<tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt> と <a class="reference internal" href="../library/readline.html#module-readline" title="readline: Python のための GNU readline サポート。 (Unix)"><tt class="xref py py-meth docutils literal"><span class="pre">readline()</span></tt></a> を持つクラスを定義して、ファイルではなく文字列バッファからデータを取得するようにしておき、引数として渡すことができます。</p>
<p>インスタンスメソッドオブジェクトにも属性があります。
<tt class="docutils literal"><span class="pre">m.im_self</span></tt> はメソッド <tt class="xref py py-meth docutils literal"><span class="pre">m()</span></tt> の属しているインスタンスオブジェクトで、
<tt class="docutils literal"><span class="pre">m.im_func</span></tt> はメソッドに対応する関数オブジェクトです。</p>
<div class="section" id="tut-exceptionclasses">
<span id="id14"></span><h3>9.7.1. 例外はクラスであってもよい<a class="headerlink" href="#tut-exceptionclasses" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユーザ定義の例外をクラスとして識別することもできます。このメカニズムを使って、拡張可能な階層化された例外を作成することができます。</p>
<p>新しい二つの (意味付け的な) 形式の <a class="reference internal" href="../reference/simple_stmts.html#raise"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> 文があります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">raise</span> <span class="n">Class</span><span class="p">,</span> <span class="n">instance</span>

<span class="k">raise</span> <span class="n">instance</span>
</pre></div>
</div>
<p>第一の形式では、 <tt class="docutils literal"><span class="pre">instance</span></tt> は <tt class="xref py py-class docutils literal"><span class="pre">Class</span></tt> またはその派生クラスのインスタンスでなければなりません。第二の形式は以下の表記の短縮された記法です。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">raise</span> <span class="n">instance</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">instance</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/compound_stmts.html#except"><tt class="xref std std-keyword docutils literal"><span class="pre">except</span></tt></a> 節のクラスは、例外と同じクラスか基底クラスのときに互換
(compatible)となります。
(逆方向では成り立ちません &#8212; 派生クラスの例外がリストされている  except
節は基底クラスの例外と互換ではありません)。例えば、次のコードは、 B, C, D を順序通りに出力します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">cls</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">D</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;D&quot;</span>
    <span class="k">except</span> <span class="n">C</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;C&quot;</span>
    <span class="k">except</span> <span class="n">B</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
<p>except 節が逆に並んでいた場合 (<tt class="docutils literal"><span class="pre">except</span> <span class="pre">B</span></tt> が最初にくる場合)、 B, B, B
と出力されるはずだったことに注意してください &#8212;
最初に一致した except 節が駆動されるのです。</p>
<p>処理されないクラスの例外に対してエラーメッセージが出力されるとき、まずクラス名が出力され、続いてコロン、スペース、最後に組み込み関数 <a class="reference internal" href="../library/functions.html#str" title="str"><tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt></a>
を使って文字列に変換したインスタンスが出力されます。</p>
</div>
</div>
<div class="section" id="iterator">
<span id="tut-iterators"></span><h2>9.8. イテレータ (iterator)<a class="headerlink" href="#iterator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>すでに気づいているでしょうが、 <tt class="docutils literal"><span class="pre">for</span></tt> 文を使うとほとんどのコンテナオブジェクトにわたってループを行うことができます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">element</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">element</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;two&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="k">print</span> <span class="n">key</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s">&quot;123&quot;</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">char</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">line</span>
</pre></div>
</div>
<p>こうしたアクセス方法は明確で、簡潔で、かつ便利なものです。イテレータの使用は Python
全体に普及していて、統一性をもたらしています。背後では、 <tt class="docutils literal"><span class="pre">for</span></tt> 文はコンテナオブジェクトの <a class="reference internal" href="../library/functions.html#iter" title="iter"><tt class="xref py py-func docutils literal"><span class="pre">iter()</span></tt></a> を呼び出しています。この関数は <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドの定義されたイテレータオブジェクトを返します。
<a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドは一度コンテナ内の要素に一度に一つづつアクセスします。コンテナ内にアクセスすべき要素がなくなると、 <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> は
<a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> 例外を送出し、 <tt class="docutils literal"><span class="pre">for</span></tt> ループを終了させます。実際にどのように動作するかを以下の例に示します。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;iterator object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
    <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="nc">StopIteration</span>
</pre></div>
</div>
<p>イテレータプロトコルの背後にあるメカニズムを一度目にすれば、自作のクラスにイテレータとしての振る舞いを追加するのは簡単です。
<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> メソッドを定義して、 <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドを持つオブジェクトを返すようにしてください。クラス自体で <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a>
を定義している場合、 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> では単に <tt class="docutils literal"><span class="pre">self</span></tt> を返すようにできます。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Reverse</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rev</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">(</span><span class="s">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">iter</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
<span class="go">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">char</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</div>
<div class="section" id="generator">
<span id="tut-generators"></span><h2>9.9. ジェネレータ (generator)<a class="headerlink" href="#generator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ジェネレータ(<a class="reference internal" href="../glossary.html#term-generator"><em class="xref std std-term">generator</em></a>)は、イテレータを作成するための簡潔で強力なツールです。ジェネレータは通常の関数のように書かれますが、何らかのデータを返すときには
<a class="reference internal" href="../reference/simple_stmts.html#yield"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> 文を使います。
<a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> が呼び出されるたびに、ジェネレータは以前に中断した処理を再開します
(ジェネレータは、全てのデータ値と最後にどの文が実行されたかを記憶しています)。以下の例を見れば、ジェネレータがとても簡単に作成できることがわかります。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">(</span><span class="s">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">char</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>ジェネレータを使ってできることは、前節で記述したクラスベースのイテレータを使ってもできます。ジェネレータを使うとコンパクトに記述できるのは、
<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a> と <a class="reference internal" href="../library/functions.html#next" title="next"><tt class="xref py py-meth docutils literal"><span class="pre">next()</span></tt></a> メソッドが自動的に作成されるからです。</p>
<p>ジェネレータのもう一つの重要な機能は、呼び出しごとにローカル変数と実行状態が自動的に保存されるということです。これにより、 <tt class="docutils literal"><span class="pre">self.index</span></tt> や
<tt class="docutils literal"><span class="pre">self.data</span></tt> といったインスタンス変数を使ったアプローチよりも簡単に関数を書くことができるようになります。</p>
<p>メソッドを自動生成したりプログラムの実行状態を自動保存するほかに、ジェネレータは終了時に自動的に <a class="reference internal" href="../library/exceptions.html#exceptions.StopIteration" title="exceptions.StopIteration"><tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt></a> を送出します。これらの機能を組み合わせると、通常の関数を書くのと同じ労力で、簡単にイテレータを生成できます。</p>
</div>
<div class="section" id="tut-genexps">
<span id="id15"></span><h2>9.10. ジェネレータ式<a class="headerlink" href="#tut-genexps" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>単純なジェネレータなら、式を使って簡潔にコードする方法があります。リスト内包に似た構文の式ですが、各括弧ではなく丸括弧を使います。ジェネレータ式は、関数の中でジェネレータをすぐに使いたいような状況のために用意されています。ジェネレータ式はコンパクトですが、完全なジェネレータに比べてちょっと融通の効かないところがありますが、同じ内容を返すリスト内包よりはメモリに優しいことが多いという利点があります。</p>
<p>例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c"># 平方和を求める</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c"># 内積を求める</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sine_table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">91</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span>  <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">valedictorian</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">student</span><span class="o">.</span><span class="n">gpa</span><span class="p">,</span> <span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">graduates</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">注記</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>例外が一つあります。モジュールオブジェクトには、秘密の読取り専用の属性
<tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> があり、モジュールの名前空間を実装するために使われている辞書を返します; <tt class="xref py py-attr docutils literal"><span class="pre">__dict__</span></tt> という名前は属性ですが、グローバルな名前ではありません。この属性を利用すると名前空間の実装に対する抽象化を侵すことになるので、プログラムを検死するデバッガのような用途に限るべきです。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. 標準ライブラリミニツアー"
             >次へ</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. エラーと例外"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="../index.html">Python 2.7ja1 documentation</a> &raquo;</li>

          <li><a href="index.html" >Python チュートリアル</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="../copyright.html">Copyright</a> 1990-2011, Python Software Foundation.
      最終更新: 2011-12-26
      このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/02cb752c6a9e で生成しました。
    </div>
  </body>
</html>