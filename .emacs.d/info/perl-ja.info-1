Info file: perl-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `perl-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.






File: perl-ja.info, Node: Top, Next: 概要, Prev: (dir), Up: (dir)

PERL5
*****

This is Edition 0.1, last updated Dec 30, 1998, of `The Perl5 Manual',
for Perl, Version 5.00.

参照しやすいように Perl のマニュアルは、いくつかの節に分割しました。

* Menu:

* Copying::
* 概要::
* データ構造::
* 構文::
* 演算子と優先順位::
* 正規表現::
* 実行とオプション::
* 組み込み関数::
* 定義済み変数::
* サブルーティン::
* モジュールについて::
* リファレンスとデータ構造のネスト::
* オブジェクト::
* オブジェクト指向の仕組みと例::
* デバッグ::
* 診断メッセージ::
* フォーマット文::
* プロセス間通信::
* セキュリティ::
* 不注意によるわな::
* スタイルガイド::
* 応用プログラムインタフェース::
* 拡張を行なうための内部関数::
* C からの呼び出し法::
* 多重定義::
* 書籍の情報::
* Function Index::              関数索引
* Variable Index::              変数索引
* Concept Index::               概念索引

(初めて、1通り読もうと考えているならば、ここに並べた順番で読めば、おそ
らく前方参照を減らすようになっていると思います。)

プログラムの実行時に何か変なことが起こって、どこを参照したらよいかわか
らない場合には、取り敢えず `-w' スイッチを試してみてください。これで、
問題か所を特定できる場合も、多々あります。





File: perl-ja.info, Node: Copying, Next: 概要, Prev: Top, Up: Top

Copying
*******

この Texinfo 形式の Perl5 の日本語マニュアルは、

     吉村寿人さん( UXM54026@pcvan.or.jp,
                   JAE00534@niftyserve.or.jp,
                   ideal@mix.or.jp,
                   net49602@asciinet.or.jp )

によって翻訳された Perl5 日本語マニュアルを、以下の両名が Texinfo 形式
に変換したものです。

   * 土屋雅稔 <tsuchiya@pine.kuee.kyoto-u.ac.jp>
   * 大城尚紀 <oshiro@tec.u-ryukyu.ac.jp>

このマニュアルの著作権は、翻訳者である吉村さんに帰属します。配布及び再
利用については、GPL または Artistic License に従います。ただし、現在は、
まだ校正作業中ですので、再配布は御遠慮下さい。

なお、Texinfo に変換する際に、文書の大意を変えない範囲で多少の編集を行
ないました。そのため、文書の順が元のマニュアルと一致しない部分や、抜け
落ちている文があります。






File: perl-ja.info, Node: 概要, Next: データ構造, Prev: Copying, Up: Top

概要
****

Perl は、テキストファイルを読み取り、そこから情報を引き出し、その情報を
元に様々な報告を行なうように設計された、インタプリタ言語です。また、多
くのシステムマネジメントの作業を行なうのに適した言語でもあります。この
言語は、綺麗さ (小規模、エレガント、最少) ではなく、実用性(使い易さ、効
率、完全性)を目指しています。

この言語は、(少なくとも作者の意見では) C, sed, sh の良い部分を組み合わ
せているので、これらの言語に馴染みのある方には、それほど難しいものでは
ないでしょう。(言語歴史学者はまた、csh, Pascal あるいは BASIC-PLUS の痕
跡にも気付くかもしれません。) 式の構文はかなりの部分で、C の式の構文に
対応したものとなっています。多くの UNIX のユーティリティとは違って、
Perl はデータの大きさに恣意的な制限を設けません。つまり Perl では、メモ
リさえ十分にあれば、ファイルを丸ごと1つの文字列に入れてしまうこともでき
ます。再帰の深さにも制限がありません。また、連想配列が使用するハッシュ
テーブルは、パフォーマンスを損なわないように、必要に応じて、自動的に大
きくなります。Perl では、大量のデータをすばやく走査できるように、工夫を
凝らしたパターンマッチの技術を使っています。テキストの走査のために設計
されてはいますが、Perl では、バイナリデータを扱うこともできますし、
(dbm が使えるところでは) dbm ファイルを連想配列のようにして扱うこともで
きるようになっています。データフロートレース機構を使って、単純ミスによ
るセキュリティホールを塞ぐようにしているため、多くの場合、setuid Perl
スクリプトは C のプログラムよりも安全です。

普通は sed や awk や sh で書くような問題でも、少し荷が重すぎるようなと
き、多少でも実行速度を速くしなければならないときや、C で書く程でもない
ときには、Perl が最適でしょう。また、sed や awk のスクリプトを Perl の
スクリプトに変換するトランスレータも用意されています。

ちょっと待ってください、まだあります...

Perl version 5 は、ほとんど全て書き直しており、以下のようなことが追加さ
れています:

多くの利便性に関する拡張
     より読みやすい Perl コードが書けるようになりました(たとえ正規表現
     の中でも)。以前の暗号的な変数名は覚えやすい識別子で置き換えること
     ができます。エラーメッセージの情報量が多くなり、オプションの警告に
     よって、初心者が犯すような過ちを見つけやすくなっています。これは、
     あまり強要してはいません。何かおかしな動作を見つけたら、`-w' スイッ
     チを使ってみてください!!! 変な動作が見つからない場合にも `-w' スイッ
     チを使ってください。

単純化された文法
     新しい `yacc' 文法は以前に比べて、半分の大きさになりました。任意文
     法規則の多くが正規化されました。予約語の数は 2/3 ほどに切り詰めて
     います。それにもかかわらず、ほとんどすべての古い Perl のスクリプト
     を変更なしに使うことができます。

文面に従ったスコープ
     Perl の変数を、C の "auto" 変数のように、字句スコープで宣言するこ
     とができます。これは効率的であるばかりでなく、「大規模プログラミン
     グ」におけるプライバシーの保護にも役立ちます。

任意の多重データ構造
     任意のスカラ変数 (配列の要素でもよい) が、他の変数やサブルーティン
     へのリファレンスを持つことができます。名前のない変数やサブルーティ
     ンを作ることが簡単にできます。また、Perl がリファレンスの参照数を
     管理してくれます。

モジュール性と再利用性
     Perl ライブラリは、様々なパッケージで簡単に共有できるモジュールと
     いう形で定義されるようになりました。パッケージは、モジュールが公開
     しているインタフェースのすべて、あるいは一部をインポートすることを
     選択できます。プラグマ (コンパイラディレクティブのこと) は同じ機構
     によって定義され、使用されます。

オブジェクト指向プログラミング
     パッケージはクラスとして機能します。少しばかり新しい文法を導入して、
     動的多重継承や仮想メソッドを、明快な方法でサポートしています。ファ
     イルハンドルをオブジェクトとして扱うことができるようになりました。

組み込み容易性と拡張性
     Perl は簡単に C や C++ のアプリケーションに組み込めるようになり、
     文書化されているインタフェースを使って、それらのルーティンとの間で、
     相互に呼び出しを行なったりすることができます。プリプロセッサ `XS'
     は、C や C++ のルーティンを Perl に張り付けるのを手伝ってくれます。
     動的なモジュールのロードがサポートされています。

POSIX 親和性
     主な新規モジュールとして POSIX モジュールがあり、適切なところでオ
     ブジェクトクラスを介するようにして、利用可能な POSIX のルーティン
     や定義をアクセスすることができます。

パッケージコンストラクタとデストラクタ
     新しい `BEGIN' と `END' ブロックは、パッケージがコンパイルされ
     るときと、プログラムが終了した後に制御を受け取るために使われます。縮退し
     た形として、`-p' や `-n' スイッチを用いたときには awk の
     `BEGIN' と `END' のように動作します。

複数の同時 DBM インプリメンテーション
     一つのスクリプトから、Perl プログラムが DBM、NDBM、SDBM、GDBM、バー
     クレイ DB のファイルを、同時にアクセスできるようになりました。実際
     には、旧 `dbmopen' インタフェースは、任意の変数をアクセスメソッド
     を定義しているオブジェクトクラスに `tie' する形式に一般化されまし
     た。

サブルーティン定義の自動ロード
     実際には、AUTOLOAD 機構では、未定義のサブルーティンコールのために、
     任意の内容を定義することができるようにしています。自動ロードのため
     だけではありません。

正規表現の拡張
     最長一致ではない数量子を指定することができます。後方参照とならない
     グループ化が可能になりました。正規表現の中に空白やコメントを書くこ
     とができ、読みやすさが向上します。すべての古い正規表現にアッパーコ
     ンパチな一貫した拡張性機構が組み込まれました。


さあ、誇大広告にはこれくらいにしましょう。

* Menu:

* 環境変数::
* ファイル::
* 診断::
* バグ::
* 注釈::




File: perl-ja.info, Node: 環境変数, Next: ファイル, Prev: 概要, Up: 概要

環境変数
========

HOME
     `chdir' が引数なしで使われたときに参照されます。

LOGDIR
     `chdir' が引数なしで使われたときに、HOME が設定されていないと参照
     されます。

PATH
     サブプロセスを実行するときと、`-S' を使ったときにスクリプトを探す
     ために参照されます。

PERL5LIB
     Perl のライブラリファイルを探すときに、標準のライブラリディレクト
     リとカレントディレクトリよりも前に探しにいくディレクトリを、コンマ
     で区切って並べたリストです。PERL5LIB が定義されていないときには、
     PERLLIB が使われます。

PERL5DB
     デバッグのコードを持ってくるためのコマンドを指定します。設定されて
     いないときには

          BEGIN { require 'perl5db.pl' }

     がデフォルトとして使用されます。

PERLLIB
     Perl のライブラリファイルを探すときに、標準のライブラリディレクト
     リとカレントディレクトリよりも前に探しにいくディレクトリを、コンマ
     で区切って並べたリストです。PERL5LIB が定義されているときには、
     PERLLIB は使われません。

これら以外は、実行されるスクリプトとチャイルドプロセスから環境変数が使
えるようにするのを除いて Perl は環境変数を使用しません。しかし、setuid
で実行するスクリプトは何よりもまず以下を行なうようにしてください:

     $ENV{'PATH'}  = '/bin:/usr/bin';    # 必要なものを
     $ENV{'SHELL'} = '/bin/sh' if defined $ENV{'SHELL'};
     $ENV{'IFS'}   = '' if defined $ENV{'IFS'};





File: perl-ja.info, Node: ファイル, Next: 診断, Prev: 環境変数, Up: 概要

ファイル
========

"/tmp/perl-e$$"
     `-e' commands によるテンポラリファイル

"@INC"
     Perl 5 ライブラリの位置





File: perl-ja.info, Node: 診断, Next: バグ, Prev: ファイル, Up: 概要

診断
====

`-w' スイッチは、幾分わかりやすい診断メッセージを出します。

すべての Perl の診断メッセージについては、*Note 診断メッセージ::, を参
照してください。

コンパイル時のエラーでは、エラーの起こった行番号に、次に調べられるはず
だったトークンかトークンの型を示します。(スクリプトが `-e' スイッチで
Perl に渡される場合には、`-e' スイッチ1が1行とカウントされます。)

setuid スクリプトでは、制限事項が増えるため、"Insecure dependency" といっ
たエラーメッセージが表示されることがあります。*Note セキュリティ::, を
参照してください。

絶対に `-w' スイッチを使った方が良いっていうのは、もう書きましたっけ?





File: perl-ja.info, Node: バグ, Next: 注釈, Prev: 診断, Up: 概要

バグ
====

`-w' スイッチが必須になっていません。

Perl は型のキャストや `atof()' や `sprintf()' のような様々な操作のマシ
ンごとの定義に依存します。

使用している標準入出力ライブラリが、`read' と `write' の間に `seek' や
`eof' が必要なものであれば、Perl でも同様となります。(ただし、
`sysread()' や `syswrite()' には適用されません。)

組み込みのデータ型には (メモリサイズからくるものを除いて) 恣意的なサイ
ズの制限はありませんが、それでもいくつかの恣意的制限は存在します: どの
識別子も 255 文字より長くてはなりませんし、`-S' を使った時、どの PATH
も 255 文字より長くてはいけません。正規表現は、内部的にコンパイルされた
時、32767 バイトを越えることができません。

Perl は本当は「病的折衷主義ガラクタ出力機」(Pathologically Eclectic
Rubbish Lister) を意味していますが、私がそういった事をばらしてはいけま
せん。





File: perl-ja.info, Node: 注釈, Prev: バグ, Up: 概要

注釈
====

Perl のモットーは「やり方は 1 通りではない。」ということです。このマニュ
アルを、後いくつに分割できるかは、宿題とします。

プログラマの3つの美徳は、無精、短気、傲慢です。理由は、キャメルブックを
参照してください。




File: perl-ja.info, Node: データ構造, Next: 構文, Prev: 概要, Up: Top

データ構造
**********

Perl には、スカラ、スカラの配列、「ハッシュ」とも呼ばれるスカラの連想配
列という 3 つのデータ構造があります。通常の配列は 0 を基点とする数値で
インデクスされます。(負の添字は、配列の終わりからインデクスします。)ハッ
シュ配列は、文字列でインデクスされます。

* Menu:

* 変数名::
* コンテキスト::
* スカラ値::
* スカラ値の構成::
* リスト値の構成::





File: perl-ja.info, Node: 変数名, Next: コンテキスト, Prev: データ構造, Up: データ構造

変数名
======

Perl には、スカラ、スカラの配列、「ハッシュ」とも呼ばれるスカラの連想配
列という 3 つのデータ構造があります。通常の配列は 0 を基点とする数値で
インデクスされます。(負の添字は、配列の終わりからインデクスします。)ハッ
シュ配列は、文字列でインデクスされます。

スカラ値の参照は、配列の一要素であるスカラを参照する場合でも、常に名前に
`$' を付けます。以下のようなものが使えます:

     $days               # 単純なスカラ変数 "days" の値
     $days[28]           # 配列 @days の 29 番目の要素の値
     $days{'Feb'}        # ハッシュ %days の 'Feb' の値
     $#days              # 配列 @days の最後のインデクス値

ただし、配列全体や配列のスライスは `@' で示します:

     @days               # ($days[0], $days[1],..., $days[n])
     @days[3,4,5]        # @days[3..5] と同じ
     @days{'a','c'}      # ($days{'a'},$days{'c'}) と同じ

ハッシュ全体は `%' で示します:

     %days               # (key1, val1, key2, val2,...)

さらに、サブルーティンは名前の前に `&' を付けて示しますが、曖昧にならな
ければ、(英語でもほとんど使われなくなった "do" のように)省略することが
できます。シンボルテーブルのエントリは、名前に `*' を付けて示すことがで
きますが、使用に際しては十分に注意する必要があります。

変数のすべての型には、それぞれの名前空間があります。衝突を心配せずに、
スカラ変数、配列、ハッシュ (ついでにファイルハンドルやサブルーティン名、
ラベル) に、同じ名前を付けることができます。つまり、`$foo' と `@foo' は
2つの異なる変数であるということです。また、`$foo[1]' は `@foo' の一部で
あって、`$foo' の一部ではありません。奇妙に思えるかもしれませんが、それ
で良いのです。奇妙なのですから。

変数と配列の参照は、いつも `$'、`@'、`%' で始まりますから、「予約」語は、
変数名としては、本当の意味で予約されているわけではありません。(しかしな
がら、先頭に特別な文字を付けない、ラベルやファイルハンドルとしては、予
約されていることになります。たとえば、`log' といった名前のファイルハン
ドルを使うことはできません。ヒント: `open(log,'logfile')' などではなく、
`open(LOG,'logfile')' としてください。大文字のファイルハンドルを使えば、
読みやすくもなりますし、将来に渡る予約語との衝突も避けられます。大文字
と小文字は区別されますから、`FOO'、`Foo'、`foo' は、すべて違う名前です。
英字と下線で始まる名前は、名前の一部に数字や下線を含むことができます。

そのような英数字の名前を、その型のオブジェクトへのリファレンスを返す式
で置き換えることも可能です。詳しくは、*Note リファレンスとデータ構造の
ネスト::,を参照してください。

数字で始まる名前には、数字しか含めることができません。英字、下線、数字
以外の文字で始まる名前は、`$%' や `$$' のように 1 文字に限定されます。
(これら 1 文字の名前の多くは、Perl があらかじめ意味を定めています。たと
えば、`$$' はカレントプロセスのプロセス id を示します。) (訳注: `$^A'
など 2 文字が続く変数が Version 3 の終わり頃から、いくつかできています。
ただし、^A の 2 文字を control-A の1 文字 (16 進数の 0x01) で置き換える
ことも可能です。)





File: perl-ja.info, Node: コンテキスト, Next: スカラ値, Prev: 変数名, Up: データ構造

コンテキスト
============

Perl における演算や値の解釈は、その演算や値の置かれたコンテキストからの
要求に依存する場合があります。このコンテキストというものには大きく2つあ
り、スカラコンテキストとリストコンテキストと呼ばれます。リストが要求さ
れるコンテキストではリスト値を返し、そうでなければスカラ値を返すような
演算も存在します。(そのような演算については、ドキュメントでその演算に触
れるときに付記しています。)言い方を変えると、Perl では、ある種の演算が
1つの値を返して欲しいか、複数の値を返して欲しいかによって多重定義されて
いるということです。("fish" や "sheep" といった、単複同形の英単語と似て
いるかもしれません。) 逆に、演算子は自分の引数が、スカラコンテキストと
リストコンテキストのどちらで解釈されるかを決めてしまいます。たとえば、

     int( <STDIN> )

と書くと、int 演算子は、自分の引数である <STDIN> 演算子がスカラコンテキ
ストで評価されることを期待するため、<STDIN> は、STDIN から1行を読み出し
int 演算子に渡します。int 演算子は、その行から整数値を取り出して返すこ
とになります。これに比べて、もし、

     sort( <STDIN> )

と書いたなら、sort 演算子は、<STDIN> 演算子がリストコンテキストで評価さ
れるようにするため、<STDIN> は STDIN から読める限り最後の行まで読み出し、
その行のリストを sort のルーティンに返します。sort ルーティンは受け取っ
た行のリストをソートして、ソートした結果のリストが値となります。

代入演算は少し特殊です。代入では、右引数のコンテキストを決めるために左
引数が使われます。スカラへの代入では、右側をスカラコンテキストで評価し
ますが、配列や配列のスライスに対する代入では、右側をリストコンテキスト
で評価することになります。リストへの代入も右側をリストコンテキストで評
価することになります。

ユーザが定義するサブルーティンは、自分がスカラコンテキストで呼ばれたか、
リストコンテキストで呼ばれたかを意識することができますが、多くのサブルー
ティンでは意識する必要もないでしょう。スカラ値は自動的にリストの要素に
なることができるからです。*Note 組み込み関数::,の wantarray の項を参照
してください。





File: perl-ja.info, Node: スカラ値, Next: スカラ値の構成, Prev: コンテキスト, Up: データ構造

スカラ値
========

スカラ変数には、数値、文字列、リファレンスのような、さまざまな種類の単
独データを保持することができます。一般に、1つの形式から他への変換は透過
的です。(スカラに複数の値を保持することはできませんが、複数の値を持って
いる配列やハッシュへのリファレンスを保持することができます。)スカラの値
どうしは、自動的に変換されるので、スカラを返す演算や関数では、コンテキ
ストが文字列を要求しているのか、数値を要求しているのかを意識する必要が
ないのです (実際は意識することができないのですが)。

スカラ値は、その値が空文字列か数値の 0 (あるいは同値な文字列 '') 以外の
場合には、ブール値の真として扱われます。ブール値が必要となるコンテキス
トは、単に特別なスカラコンテキストとして扱われます。スカラのヌルには、
実は defined と undefined の 2 種類があります。undefined のヌルは、エラー
があったときや、ファイルの終わりに達したとき、初期化していない変数や配
列要素を参照したときなど、何かに対する実際の値が存在しないときに返され
ます。undefined のヌルは、最初に defined であるかのように使ったときに
defined となり得ますが、それに先立って値が defined かどうかを調べるため
に defined() 演算子を使うことができます。

配列の大きさはスカラ値です。配列 `@days' の大きさは、csh のように
`$#days' を評価するとわかります。(実際は、これは大きさではなく、最後の
要素に対する添え字になります。(通常は) 0 番目の要素があるからです。)
`$#days' に代入を行なうと、配列の大きさも変化します。この方法で配列を小
さくすると、見えなくなった部分の値は破壊されます。小さくした配列を再び
大きくしても、以前存在した要素に対する前の値が回復することはありません。
(Perl 4 では回復可能でしたが、デストラクタが期待どうりの時点で呼ばれる
ことを保証するために、これを止めました。)大きくなるであろう配列を、あら
かじめ大きくしておくことで、ある程度の効率を得ることもできます。(最後の
要素よりも後ろに離れた位置に代入を行なうことでも、配列を大きくすること
ができます。)配列に空リスト () を代入すると何も無い状態にまで、切り詰め
ることができます。以下の 2 つは等価です:

     @whatever = ();
     $#whatever = $[ - 1;

名前のある配列をスカラコンテキストで評価すると、配列の大きさが返されま
す。(これは、リストに対しては成り立ちません。この場合には、C のコンマ演
算子と同じく最後の値が返されます。)以下は常に真となります:

     scalar(@whatever) == $#whatever - $[ + 1;

Perl version 5 では `$[' の意味を変更し、`$[' を設定していないファイル
で、他のファイルがこの変数を変更しているかどうかを、気にする必要がなく
なりました。(言い換えると、`$[' は使わないほうが良いと言うことです。)で
すから、普通は以下のようになります。

     scalar(@whatever) == $#whatever + 1;

ハッシュをスカラコンテキストで評価した場合、ハッシュの中に1つでも
key/value のペアが登録されているときにだけ、真となる値が返されます。
(key/value のペアが登録されていれば、返される値は、使用しているエントリ
の数と、割り付けられているエントリの数を、スラッシュで区切った文字列で
す。これは、与えたデータに対して、Perl の (コンパイルされた) ハッシュの
アルゴリズムが、うまく動作しないかを確認するときくらいにしか使えません
が。たとえば、ハッシュに 10,000 のものを入れ、`%HASH' をスカラコンテキ
ストで評価したときに "1/16" が得られれば、16 のうち 1 つのエントリだけ
が使われ、おそらくそこに 10,000 すべてが入っていることを意味します。ほ
とんど起こりそうもないことですが。)





File: perl-ja.info, Node: スカラ値の構成, Next: リスト値の構成, Prev: スカラ値, Up: データ構造

スカラ値の構成
==============

数値リテラルは、慣習的な浮動小数点数と整数の形式で示されます:

     12345
     12345.67
     .23E-10
     0xffff              # 16 進数
     0377                # 8 進数
     4_294_967_296       # 下線は読みやすさのため

文字列リテラルは、シングルクォートかダブルクォートで区切られます。これ
らは、シェルのクォートと同じように扱われ、ダブルクォートの文字列リテラ
ルでは、バックスラッシュの置換と変数の置換が行なわれ、シングルクォート
の文字列では、("\'" と "\\"を除いて)これらの置換は行なわれません。普通
の UNIX でのバックスラッシュの置換規則は、改行やタブを始め、ある種の変
わった形式のためにも使われます。一覧は perlop manpage の qq のところを
ご覧ください。

また、文字列に直接、改行を埋め込むこともできます。つまり、文字列は、開
始した行で終了する必要はないと言うことです。これは素晴らしいのですが、
終了のクォートを付け忘れた場合には、次にクォート文字が見つかるまでの間、
Perl はエラーを見つけることができなくなります。それは、スクリプト上でずっ
と先になるかもしれません。文字列中での変数の置換は、スカラ変数と配列と
配列のスライスに限定されています。(言い換えれば、$ や@ で始まる識別子か、
それに大括弧で括った添え字をつけたものです。)次のプログラムは "The
price is $100." と印字します。

     $Price = '$100';                    # 置換されない
     print "The price is $Price.\n";     # 置換される

いくつかのシェルと同じように、識別子の前後に中括弧を入れて、つながって
いる英数字から切り離すことができます。また、シングルクォート文字列は、
その前の単語とスペースで区切らなければならないことに注意してください。
シングルクォートが (使わないように言われていますが) 識別子を構成する文
字として有効なものだからです (perlmod manpage のパッケージのところを参
照してください)。

`__LINE__' と `__FILE__' という 2 つの特別なリテラルがあって、プログラ
ムのその時点での行番号とファイル名を示します。これらは、独立したトーク
ンとしてだけ使用することができ、文字列の中に展開することはできません。
さらに、トークン `__END__' は、スクリプトを納めたファイルの実際の最後よ
りも前で、論理的にスクリプトが終わるとき、その位置を示すのに使うことが
できます。それ以降のテキストは無視されますが、DATA というファイルハンド
ルを通して読むことができます。(ファイルハンドル DATA は、main のスクリ
プトからだけ読むことができ、require されたファイルや eval された文字列
からは読めません。)コントロール文字 ^D と ^Z を `__END__' の同義語とし
て使うことができます。

文法的に別の解釈ができない単語は、クォート文字列であるかのように扱われ
ます。これは「裸の単語」と言われます。ファイルハンドルやラベルと同様に、
小文字だけからなる裸の単語は、将来的に予約後とぶつかる危険がありますか
ら、そのような単語があった場合、`-w' スイッチをつけることで、Perl がそ
の単語を指摘してくれます。裸の単語をなくして欲しいという方もいらっしゃ
います。もし、

     use strict 'subs';

と書いておけば、サブルーティンコールと解釈できない裸の単語がコンパイル
時にエラーとなります。この制約は囲っているブロックの終わりまで有効です。
内側のブロックで `no strict 'subs'' と書くことで、この機能を撤回するこ
ともできます。

配列変数は、ダブルクォート文字列中で、配列のすべての要素を変数 `$"' 中
に示す区切文字 (デフォルトはスペース) でつなげて展開されます。以下は同
値です:

     $temp = join($",@ARGV);
     system "echo $temp";

     system "echo @ARGV";

検索パターン (ここでも、ダブルクォートのような置換が行なわれます) の中
では、解釈する上で曖昧となる場合ができてきます。`/$foo[bar]/' は、
`/${foo}[bar]/' と解釈される (この場合 `[bar]' は、正規表現の文字クラス)
のでしょうか、`/${foo[bar]}/' と解釈される (この場合 `[bar]' は、配列
`@foo' の添え字) のでしょうか。`@foo' が他に存在しない場合には、明らか
に文字クラスとなります。@foo が存在すれば、Perl が `[bar]' の意味に見当
をつけますが、たいてい正しい解釈をします。もし、見当があたっていないと
きや、偏執的にこだわりたい時には、上に書いたように中括弧を付けて、強制
的に解釈のしかたを決めることができます。

行指向形式のクォートは、シェルの「ヒアドキュメント」構文をもとにしてい
ます。<< の後にクォートされるものを終了する文字列を示し、現在行の次の行
からその終了文字列に一致する行の前の行までが、その項目の値となります。
終了文字列には、識別子(単語) かクォートされたテキストが許されます。クォー
トされている場合には、そのクォート文字の種類によって、実際にクォートさ
れるテキストの扱いが、通常のクォートと同様にして決められます。クォート
されていない識別子とした場合には、ダブルクォートのように扱われます。<<
と識別子の間にスペースを入れてはいけません。(もしスペースを入れると、空
識別子として扱われ、最初の空行にマッチするようになります。下記の Merry
Christmas の例を参照してください。)終了文字列は、その終了を示す行に単独
で (クォートもしないで、前後に空白を入れることも無く) 置かなければなり
ません。

         print <<EOF;    # 上記と同じ
     The price is $Price.
     EOF

         print <<"EOF";  # これも同じ
     The price is $Price.
     EOF

         print << x 10;  # 正しいが、使わないように。<<"" を使う。
     Merry Christmas!

         print <<`EOC`;  # 実際にクォートされたコマンドを実行
     echo hi there
     echo lo there
     EOC

         print <<"foo", <<"bar"; # スタックすることも可能
     I said foo.
     foo
     I said bar.
     bar

         myfunc(<<"THIS", 23, <<'THAT");
     Here's a line
     or two.
     THIS
     and here another.
     THAT

文を終了するためのセミコロンを付けなければいけないことは、忘れないでく
ださい。以下のようにしたいのではないと言うことを Perl が知ることはでき
ないのですから:

         print <<ABC
     179231
     ABC
         + 20;





File: perl-ja.info, Node: リスト値の構成, Prev: スカラ値の構成, Up: データ構造

リスト値の構成
==============

リスト値は、個々の値をコンマで区切って (必要に応じて括弧で括って) 示さ
れます:

     (LIST)

リスト値が要求されていないコンテキストでは、リストリテラルの値としては、
C のコンマ演算子の場合のように、最後の要素の値が使われます。たとえば、

     @foo = ('cc', '-E', $bar);

は、リスト値全体を配列 `@foo' に代入しますが、

     $foo = ('cc', '-E', $bar);

は、変数 `$bar' の値を変数 `$foo' に代入します。本物の配列がスカラコン
テキストで評価されたときの値は、その配列の大きさとなります。以下の例で
は、`$foo' に 3 という値が代入されます:

     @foo = ('cc', '-E', $bar);
     $foo = @foo;                # $foo は 3 となる

リストリテラルの閉じ括弧の前には余分にコンマを置いてかまいませんので、

     @foo = (
         1,
         2,
         3,
     );

と書くことができます。

リストの中にリストがある場合には、自動的に展開されてしまいます。これは、
外側のリストが評価されると、リストの個々の要素がリストコンテキストで評
価され、その結果のリスト値の個々の値が、元のリストの要素であるかのよう
に展開されるのです。つまり、リストの中では配列も、その性質が現れてきま
せん。

     (@foo,@bar,&SomeSub)

というリストは、`@foo' のすべての要素の後に `@bar' のすべての要素を続け、
その後に SomeSub というサブルーティンが返すすべての要素を続けたものを要
素として持ちます。展開されないリストのリファレンスを作るためには、
perlref manpage を参照してください。

空リストは () で表わされます。リスト中で空リストを展開しても何も起こり
ません。つまり、 ((),(),()) は () と等価です。同様に、要素のない配列を
展開することは、その場所に何も展開しなかったのと同じことになります。

リスト値にも通常の配列と同じように、添え字をつけることができます。リス
トには、曖昧さをなくすために、括弧を付けなくてはなりません。例:

     # stat はリスト値を返す
     $time = (stat($file))[8];

     # 16 進の数字を探す
     $hexdigit = ('a','b','c','d','e','f')[$digit-10];

     # 「逆コンマ演算子」
     return (pop(@foo),pop(@foo))[0];

リストを構成する個々の要素すべてに代入が許される場合には、全体のリスト
に代入を行なうことができます:

     ($a, $b, $c) = (1, 2, 3);

     ($map{'red'}, $map{'blue'}, $map{'green'})
                                     = (0x00f, 0x0f0, 0xf00);

リストの最後の要素は、配列やハッシュでもかまいません:

     ($a, $b, @rest) = split;
     local($a, $b, %rest) = @_;

実際は、リストの任意の要素として配列を使うことができますが、リスト中の
最初の配列が、右辺の値をすべて取り込んでしまうため、それ以降のものはヌ
ルしか受け取ることができません。これは、local() や my() では有用かもし
れません。

ハッシュリテラルは key と value と解釈される値のペアで構成されます:

     # 上記の map の代入と同じ
     %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);

key と value のペアの間には `=>' 演算子を使うと読みやすくなります (実際
のところ `=>' 演算子は、見た目に目立つコンマの同義語でしかありません):

     %map = (
              'red'   => 0x00f,
              'blue'  => 0x0f0,
              'green' => 0xf00,
            );

スカラコンテキストにおける配列代入は、代入の右辺の式で作られる要素の数
を返します:

     $x = (($foo,$bar) = (3,2,1));       # $x は 2 ではなく 3

これは、ブールコンテキストでリストの代入を行ないたい時に、とても便利で
す。多くのリスト関数は最終的に空リストを返し、それが代入されると 0 とな
り、偽として解釈されるからです。




File: perl-ja.info, Node: 構文, Next: 演算子と優先順位, Prev: データ構造, Up: Top

構文
****

Perl のスクリプトは宣言と実行文の列で構成されます。Perl で宣言の必要が
あるのは、レポートフォーマットとサブルーティンだけです。これらの宣言に
ついては、後ほど詳しく述べます。ユーザが造った初期化していないすべての
オブジェクトは、代入などの明示的な操作で定義されない限り、ヌルもしくは
0 の値を持っているとものとして扱われます。(しかし、未定義の値を使った場
合に警告を出すようにすることもできます。) sed や awk のスクリプトでは、
実行文の列は入力行ごとに繰り返して実行されますが、Perl では、実行文の列
は 1 度実行されるだけです。これは、入力ファイルに対して明示的に自分でルー
プを行なわなければならないことを意味していますが、どのファイルのどの行
に注目するかを自由に制御できることも意味しています。(本当は、私はウソを
付いています。`-n' か `-p' スイッチを使えば、暗黙にループを行なうことが
できます。sed や awk のように必須のデフォルトになっていないだけのことで
す。)

Perl は、ほとんどすべての部分で、自由形式の言語です。(理由は自明である
と思われますが、フォーマット宣言が唯一の例外となっています。)コメントは、
文字 "#" によって示され、行末までとなります。C のスタイルの /* */ を使
おうとした場合には、文脈によって、割り算かパターンマッチかのいずれかに
解釈され、C++ の // コメントは、空の正規表現に見えます。使わないように
しましょう。

宣言は実行文が置けるところであれば、どこにでも置けますが、実行文の列を
実行するのに影響を与えません。宣言はコンパイル時にのみ意味を持ちます。
普通は、すべての宣言をスクリプトの最初か、最後にまとめておきます。

Perl 5 から、サブルーティンを宣言することで、宣言した場所以降では、サブ
ルーティン名をリスト演算子のようにして使うことができるようになりました。
サブルーティンは以下のように、定義しないで宣言することができます:

     sub myname;
     $me = myname $0 or die "can't get myname";

リスト演算子として働きはしますが、単項演算子ではありませんので、
`||' ではなく `or' を使うことに注意してください。

サブルーティンの宣言は、`use' 文を使ってインポートすることもできます。

Perl 5 からはまた、実行文の列に字句スコープの変数宣言を、含めることがで
きるようになりましたが、変数名を宣言することを除けば、宣言文は通常の実
行文と同様に働き、通常の実行文であるかのように他の文の中に埋め込まれる
のです。

* Menu:

* 単純実行文::
* 複合実行文::





File: perl-ja.info, Node: 単純実行文, Next: 複合実行文, Prev: 構文, Up: 構文

単純実行文
==========

唯一の単純実行文は、副作用を目的として評価される式です。個々の単純実行
文は、それがブロックの最後の文でなければ、お尻にセミコロンを付けなくて
はなりません。ブロックの最後の文では、セミコロンが省略可能です。(ブロッ
クが複数の行から成るのであれば、やはりセミコロンは付けた方が良いでしょ
う。あとで、行を増やすこともあるでしょうから。) eval {} や do {} のよう
に複合文に見える演算子もありますが、これは複合文ではありません (式の中
の「項」でしかありません) し、実行文の最後の項となった場合には、明示的
にセミコロンが必要です。

どんな単純実行文にも、最後のセミコロン (もしくは、ブロックの終わり) の
直前に 1 つだけ修飾子を付けることができます。修飾子としては:

     if EXPR
     unless EXPR
     while EXPR
     until EXPR

が使えます。

if 修飾子と unless 修飾子は、英語ができる方なら、期待通りの意味となりま
す。while 修飾子と until 修飾子も通常の "while loop" の意味 (条件が先に
評価される) となりますが、do-BLOCK (と現在は使わないようにしている
do-SUBROUTINE 文) に対して使用すると、条件が評価される前に 1 度だけブロッ
クが実行されます。これは:

     do {
         $_ = <STDIN>;
         ...
     } until $_ eq ".\n";

のようなループが書けるようにするためです。perlfunc manpage を参照してく
ださい。後述するループ制御文は、この構文では使用できないことにも注意し
てください。修飾子にはループラベルを付けることができないからです。ごめ
んなさい。そういったことがしたい場合には、別のブロックを被せてしまうと
よいでしょう。)





File: perl-ja.info, Node: 複合実行文, Prev: 単純実行文, Up: 構文

複合実行文
==========

Perl では、スコープが定義される実行文の列をブロックと呼んでいます。とき
にはブロックは、そのブロックを含むファイルの単位で区切られ (この場合
require で読み込まれるか、プログラム全体ということになります)、また文字
列として区切られる場合もあります (eval される場合です)。

しかし、一般にはブロックは中括弧 (`{}') で区切られるのが普通です。この
構文上の構造を BLOCK と呼ぶことにします。

以下の複合実行文を、流れの制御のために使うことができます:

     if (EXPR) BLOCK
     if (EXPR) BLOCK else BLOCK
     if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
     LABEL while (EXPR) BLOCK
     LABEL while (EXPR) BLOCK continue BLOCK
     LABEL for (EXPR; EXPR; EXPR) BLOCK
     LABEL foreach VAR (ARRAY) BLOCK
     LABEL BLOCK continue BLOCK

C や Pascal と違って、文ではなく、BLOCK を使って定義されていることに注
意してください。これは中括弧が必須ということで、中ぶらりんの実行文が許
されないということです。中括弧を使わないで条件を書きたい場合には、方法
がいくつかあります:

     if (!open(FOO)) { die "Can't open $FOO: $!"; }
     die "Can't open $FOO: $!" unless open(FOO);
     open(FOO) or die "Can't open $FOO: $!";     # FOO or bust!
     open(FOO) ? 'hi mom' : die "Can't open $FOO: $!";
                         # a bit exotic, that last one

はすべて同じことをします。

if 文は見た通りです。BLOCK は必ず中括弧で括られますから、if と else の
対応が曖昧になることはありません。if の代わりに unless を使えば、テスト
の意味が逆になります。

while 文は、式が真である間 (評価結果が、空文字列、0、"0" のいずれかでな
い間) ブロックを実行します。LABEL はあっても無くてもよく、もし存在する
時には、識別子にコロンを続けたものです。LABEL は、next、last、redo とい
うループ制御文が、ループを識別できるようにするものです (以下を参照)。
continue BLOCK があれば、C の for ループの 3 番目の部分のように、次に条
件が評価される直前に実行されます。ですから、(C の continue 文と同様に)
たとえ next 文でループを進めるときにも、ループ変数のインクリメントが行
なうことができます。

while を until で置き換えると、テストの意味が逆になりますが、繰り返しの
前に、条件が評価されることは変わりません。

if 文または while 文において、"(EXPR)" を BLOCK で置き換えることができ、
ブロックの最後に実行した文が真であれば、条件も真となります。(この機能は
Perl 5 でも機能しますが、使わないようにしてください。"if BLOCK" の代わ
りに "if (do BLOCK)" とすればよいでしょう。)

C スタイルの for ループは、完全に対応する while ループと同じように動作
します:

     for ($i = 1; $i < 10; $i++) {
         ...
     }

は、

     $i = 1;
     while ($i < 10) {
         ...
     } continue {
         $i++;
     }

と同じことです。

foreach ループは通常のリスト値で繰り返しを行ない、変数 VAR にそのリスト
の値を順番に設定します。その変数は、(前もって my で宣言したのでなければ)
暗黙のうちにループ内にローカルとなり、ループを抜けると以前の値に戻りま
す。キーワードの foreach は、実際にはキーワード for の同義語であり、読
みやすさのために foreach を、簡潔さのために for を使い分けることが可能
です。VAR を省略すると、`$_' に個々の値が順に設定されます。もし、ARRAY
が (リスト値を返す式ではなく) 本物の配列の時には、ループの中で VAR を修
正することによって、その時に対応している配列の要素自身を修正することが
できます。例:

     for (@ary) { s/foo/bar/; }

     foreach $elem (@elements) {
         $elem *= 2;
     }

     for ((10,9,8,7,6,5,4,3,2,1,'BOOM')) {
         print $_, "\n"; sleep(1);
     }

     for (1..15) { print "Merry Christmas\n"; }

     foreach $item (split(/:[\\\n:]*/, $ENV{'TERMCAP'})) {
         print "Item: $item\n";
     }

BLOCK 自身は (ラベルが付いていても、いなくても) 意味的には、1度だけ実行
されるループと同じです。つまり、ブロックを抜けたり、再度実行したりする
のに、ループ制御文が使えるということです。continue BLOCK はあっても無く
てもかまいません。この構成は、case 構文を組み立てるのに便利です。

     SWITCH: {
         if (/^abc/) { $abc = 1; last SWITCH; }
         if (/^def/) { $def = 1; last SWITCH; }
         if (/^xyz/) { $xyz = 1; last SWITCH; }
         $nothing = 1;
     }

Perl には、公に switch 文は存在しません。同値なものが既にいくつもあるか
らです。上にあげたものの他に、

     SWITCH: {
         $abc = 1, last SWITCH  if /^abc/;
         $def = 1, last SWITCH  if /^def/;
         $xyz = 1, last SWITCH  if /^xyz/;
         $nothing = 1;
     }

とも書けます。(これは、ループ制御「演算子」を式の中で使えることに気が付
けば、見た目ほど奇妙なものではありません。普通の C のコンマ演算子です。)

また、

     SWITCH: {
         /^abc/ && do { $abc = 1; last SWITCH; };
         /^def/ && do { $def = 1; last SWITCH; };
         /^xyz/ && do { $xyz = 1; last SWITCH; };
         $nothing = 1;
     }

とも書けますし、もう少し「正当な」switch 文のように整形すると:

     SWITCH: {
         /^abc/      && do {
                             $abc = 1;
                             last SWITCH;
                        };

         /^def/      && do {
                             $def = 1;
                             last SWITCH;
                        };

         /^xyz/      && do {
                             $xyz = 1;
                             last SWITCH;
                         };
         $nothing = 1;
     }

となりますし、

     SWITCH: {
         /^abc/ and $abc = 1, last SWITCH;
         /^def/ and $def = 1, last SWITCH;
         /^xyz/ and $xyz = 1, last SWITCH;
         $nothing = 1;
     }

や、醜くも

     if (/^abc/)
         { $abc = 1 }
     elsif (/^def/)
         { $def = 1 }
     elsif (/^xyz/)
         { $xyz = 1 }
     else
         { $nothing = 1 }

としてもよいでしょう。




File: perl-ja.info, Node: 演算子と優先順位, Next: 正規表現, Prev: 構文, Up: Top

演算子と優先順位
****************

* Menu:

* 優先順位::
* 項とリスト演算子 (左方向)::
* アロー演算子::
* インクリメントとデクリメント::
* 指数演算子::
* 単項演算子::
* 拘束演算子::
* 乗法演算子::
* 加法演算子::
* シフト演算子::
* 名前付き単項演算子::
* 比較演算子::
* 等価演算子::
* ビットごとの AND::
* ビットごとの OR と XOR::
* C スタイルの論理積::
* C スタイルの論理和::
* 範囲演算子::
* 条件演算子::
* 代入演算子::
* コンマ演算子::
* リスト演算子 (右方向)::
* 論理否定::
* 論理積::
* 論理和と排他論理和::
* Perl にない C の演算子::
* クォートとクォートのような演算子::
* I/O 演算子::
* 定数の畳み込み::
* 整数演算::





File: perl-ja.info, Node: 優先順位, Next: 項とリスト演算子 (左方向), Prev: 演算子と優先順位, Up: 演算子と優先順位

優先順位
========

Perl の演算子には、以下のような結合性と優先順位 (高い優先順位から低いも
のへ並べている) があります。C から持ってきた演算子の優先順位は、C での
優先順位が多少おかしくても、そのままにしてあることに注意してください。
(これによって、C を使っている方が Perl に移りやすくなっています。)

     左結合      項 リスト演算子 (左方向に対して)
     左結合      ->
     非結合      ++ --
     右結合      **
     右結合      ! ~ \ 単項の+ 単項の-
     左結合      =~ !~
     左結合      * / % x
     左結合      + - .
     左結合      << >>
     非結合      名前付き単項演算子
     非結合      < > <= >= lt gt le ge
     非結合      == != <=> eq ne cmp
     左結合      &
     左結合      | ^
     左結合      &&
     左結合      ||
     非結合      ..
     右結合      ?:
     右結合      = += -= *= などの代入演算子
     左結合      , =>
     非結合      リスト演算子 (右方向に対して)
     左結合      not
     左結合      and
     左結合      or xor





File: perl-ja.info, Node: 項とリスト演算子 (左方向), Next: アロー演算子, Prev: 優先順位, Up: 演算子と優先順位

項とリスト演算子 (左方向)
=========================

「項」は Perl でもっとも優先順位が高いものです。これには、変数、クォー
トとクォート的な演算子、括弧で括った任意の式、引数を括弧で括った任意の
関数が含まれます。実際には、この意味では本当の関数はなく、リスト演算子
と関数のように働く単項演算子が、引数を括弧で括るためそのように見えます。
これらはすべて perlfunc manpage に記述しています。

もし、リスト演算子 (`print()' など) や単項演算子 (`chdir()' など) の名
前の後に開き括弧が続く場合には、その演算子と括弧内の引数は、通常の関数
呼び出しのように、もっとも高い優先順位で処理されます。

括弧が無い場合には、`print', `sort', `chmod' のようなリスト演算子の優先
順位は、演算子の左側をからすると非常に高く、右側からすると非常に低く見
えます。たとえば、

     @ary = (1, 3, sort 4, 2);
     print @ary;         # 1324 と印字

では、`sort' の右のコンマは `sort' よりも前に評価されます (右側から見る
と `sort' の優先順位が低い) が、左側のコンマは `sort' のあとに評価され
ます (左側から見ると `sort' の方が優先順位が高くなっている)。言い方を変
えると、リスト演算子は自分の後にある引数をすべて使って処理を行ない、そ
の結果を自分の前の式に対する「項」であるかのように見せるということです。
ただし、括弧には気を付けないといけません:

     # 以下は print を行なう前に exit を評価します:
     print($foo, exit);  # 明らかにやりたいことではないでしょう。
     print $foo, exit;   # これでもない。

     # 以下は exit を評価する前に print を行ないます:
     (print $foo), exit; # これがしたかった。
     print($foo), exit;  # これでもいい。
     print ($foo), exit; # これも OK。

また、

     print ($foo & 255) + 1, "\n";

の動作を一目見ただけで判断するのは、難しいでしょう。詳しくは、
*Note 名前付き単項演算子::,の節を参照してください。

この他に「項」として解析されるものには、do {} や eval {} の構成、サブルー
ティンやメソッドの呼び出し、無名のコンストラクタ [] と {} があります。

後の方の*Note クォートとクォートのような演算子::,の節や*Note I/O 演算
子::,の節も参照してください。





File: perl-ja.info, Node: アロー演算子, Next: インクリメントとデクリメント, Prev: 項とリスト演算子 (左方向), Up: 演算子と優先順位

アロー演算子
============

C や C++ と同じように "->" は中置の被参照演算子です。右側が [...] か
{...} の形の添字であれば、左側は配列かハッシュへのハードリファレンスかシ
ンボリックリファレンス (あるいは、左辺値 (代入可能) であればハードリファ
レンスを保持できる場所)でなければなりません。
*Note リファレンスとデータ構造のネスト::,を参照してください。

そうでなければ、右側はメソッド名かメソッド名を持った単純スカラ変数で、
左側はオブジェクト (bless されたリファレンス) かクラス名でなければなり
ません。perlobj manpage を参照してください。





File: perl-ja.info, Node: インクリメントとデクリメント, Next: 指数演算子, Prev: アロー演算子, Up: 演算子と優先順位

インクリメントとデクリメント
============================

"++" と "--" は、C の場合と同じように動作します。つまり、変数の前に置か
れれば、値を返す前に変数をインクリメントまたはデクリメントし、後に置か
れれば、値を返した後で変数をインクリメントまたはデクリメントします。

インクリメント演算子には、ちょっと風変わりな機能が組み込まれています。
数値が入った変数や、数値の文脈で使われてきた変数をインクリメントする場
合には、通常のインクリメントとして動作します。しかし、その変数が設定さ
れてからずっと文字列の文脈でしか使われていなくて、空でない
/^[a-zA-Z]*[0-9]*$/ にマッチする値を持っているときには、個々の文字の範
囲を保ちながら桁あげを行なって、文字列としてインクリメントが行なわれま
す (マジカルインクリメントと呼ばれます):

     print ++($foo = '99');      # '100' と印字
     print ++($foo = 'a0');      # 'a1' と印字
     print ++($foo = 'Az');      # 'Ba' と印字
     print ++($foo = 'zz');      # 'aaa' と印字

デクリメント演算子には、マジカルなものはありません。





File: perl-ja.info, Node: 指数演算子, Next: 単項演算子, Prev: インクリメントとデクリメント, Up: 演算子と優先順位

指数演算子
==========

二項演算子の "**" は指数演算子です。この演算子は、単項のマイナスよりも
結合が強い演算子で、-2**4 は (-2)**4 ではなく、-(2**4) と解釈されます。





File: perl-ja.info, Node: 単項演算子, Next: 拘束演算子, Prev: 指数演算子, Up: 演算子と優先順位

単項演算子
==========

単項演算子の "!" は論理否定を行ないます。つまり not ということです。こ
の演算子の優先順位を低くしたものとして、"not" が用意されています。

単項演算子の "-" は被演算子が数値であれば、算術否定を行ないます。被演算
子が識別子ならば、マイナス記号にその識別子をつなげた文字列が返されます。
これ以外で被演算子の最初の文字がプラスかマイナスのときには、その記号を
逆のものに置き換えた文字列を返します。この規則の結果、-bareword が
-bareword" に等価となります。

単項演算子の "~" はビットごとの否定を行ないます。つまり、1 の補数を返し
ます。

単項演算子の "+" は、たとえ文字列に対して用いられた場合にも、何もしませ
ん。関数名に続けて括弧付きの式を書く場合に、関数の引数リストと解釈され
ないようにするために用いることができます。(下記「名前付き単項演算子」の
節の例を参照してください。)

単項演算子の "\" はその後に続くものへのリファレンスを生成します。*Note
リファレンスとデータ構造のネスト::,を参照してください。この用法も文字列
中のバックスラッシュも、後に続くものが解釈されるのを防ぐことになります
が、動作を混同しないでください。





File: perl-ja.info, Node: 拘束演算子, Next: 乗法演算子, Prev: 単項演算子, Up: 演算子と優先順位

拘束演算子
==========

二項演算子の "=~" は、式をパターンマッチに拘束します。デフォルトで $_
の文字列を検索したり、変更したりする演算があります。この演算子は、その
ような演算を他の文字列に対して行なわせるようにするものです。右引数は、
検索パターン、置換、変換のいずれかです。左引数は、デフォルトの $_ の代
わりに検索、置換、変換の対象となる対象となります。返却値は演算の結果が
成功したか否かです。(右引数が検索パターン、置換、変換ではなく、式であれ
ば、それは実行時に決まる検索パターンと解釈されます。これは /o を使わな
い限り、明示的な検索に比べて効率が落ちます。式が評価されるたびにパター
ンをコンパイルする必要があるからです。)

二項演算子の "!~" は、返される値が論理否定されることを除いて"=~" と同じ
です。





File: perl-ja.info, Node: 乗法演算子, Next: 加法演算子, Prev: 拘束演算子, Up: 演算子と優先順位

乗法演算子
==========

二項演算子の "*" は 2 つの数値の積を返します。

二項演算子の "/" は 2 つの数値の商を返します。

二項演算子の "%" は 2 つの数値の剰余を返します。

二項演算子の "x" は繰り返し演算子です。スカラコンテキストでは、左被演算
子を右被演算子に示す数だけ繰り返したもので構成される文字列を返します。
リストコンテキストでは、左被演算子が括弧で括られたリストであれば、リス
トを繰り返します。

     print '-' x 80;               # 1 列のダッシュを印字

     print "\t" x ($tab/8), ' ' x ($tab%8); # タブに畳み込み

     @ones = (1) x 80;            # 80 個の 1 を含むリスト
     @ones = (5) x @ones;        # すべての要素を 5 にする





File: perl-ja.info, Node: 加法演算子, Next: シフト演算子, Prev: 乗法演算子, Up: 演算子と優先順位

加法演算子
==========

二項演算子の "+" は 2 つの数値の和を返します。

二項演算子の "-" は 2 つの数値の差を返します。

二項演算子の "." は 2 つの文字列を連結します。





File: perl-ja.info, Node: シフト演算子, Next: 名前付き単項演算子, Prev: 加法演算子, Up: 演算子と優先順位

シフト演算子
============

二項演算子の "<<" は左引数の値を、右引数で示すビット数だけ、左にシフト
した値を返します。引数は整数でなければなりません。

二項演算子の ">>" は左引数の値を、右引数で示すビット数だけ、右にシフト
した値を返します。引数は整数でなければなりません。





File: perl-ja.info, Node: 名前付き単項演算子, Next: 比較演算子, Prev: シフト演算子, Up: 演算子と優先順位

名前付き単項演算子
==================

さまざまな名前付き単項演算子が、引数を 1 つ持ち、括弧が省略可能な、関数
として扱われます。これには -f や -M のようなファイルテスト演算子も含ま
れます。*Note 組み込み関数::,を参照してください。

リスト演算子 (print() など) や単項演算子 (chdir() など) は、すべて次の
トークンとして開き括弧が続くと、その演算子と括弧内の引数は、通常の関数
呼び出しのようにもっとも高い優先順位として扱われます。たとえば、|| は
chdir より優先順位が低いので、

     chdir $foo    || die;       # (chdir $foo) || die
     chdir($foo)   || die;       # (chdir $foo) || die
     chdir ($foo)  || die;       # (chdir $foo) || die
     chdir +($foo) || die;       # (chdir $foo) || die

ですが、* は chdir や rand よりも高い優先順位となっているので:

     chdir $foo * 20;    # chdir ($foo * 20)
     chdir($foo) * 20;   # (chdir $foo) * 20
     chdir ($foo) * 20;  # (chdir $foo) * 20
     chdir +($foo) * 20; # chdir ($foo * 20)

     rand 10 * 20;       # rand (10 * 20)
     rand(10) * 20;      # (rand 10) * 20
     rand (10) * 20;     # (rand 10) * 20
     rand +(10) * 20;    # rand (10 * 20)

となります。*Note 項とリスト演算子 (左方向)::,の節を参照してください。





File: perl-ja.info, Node: 比較演算子, Next: 等価演算子, Prev: 名前付き単項演算子, Up: 演算子と優先順位

比較演算子
==========

二項演算子の "<" は左引数が数値的に右引数よりも小さければ、真を返します。

二項演算子の ">" は左引数が数値的に右引数よりも大きければ、真を返します。

二項演算子の "<=" は左引数が数値的に右引数よりも小さいか等しければ、真
を返します。

二項演算子の ">=" は左引数が数値的に右引数よりも大きいか等しければ、真
を返します。

二項演算子の "lt" は左引数が文字列的に右引数よりも小さければ、真を返し
ます。

二項演算子の "gt" は左引数が文字列的に右引数よりも大きければ、真を返し
ます。

二項演算子の "le" は左引数が文字列的に右引数よりも小さいか等しければ、
真を返します。

二項演算子の "ge" は左引数が文字列的に右引数よりも大きいか等しければ、
真を返します。





File: perl-ja.info, Node: 等価演算子, Next: ビットごとの AND, Prev: 比較演算子, Up: 演算子と優先順位

等価演算子
==========

二項演算子の "==" は左引数が数値的に右引数と等しければ、真を返します。

二項演算子の "!=" は左引数が数値的に右引数と等しくなければ、真を返しま
す。

二項演算子の "<=>" は左引数が数値的に右引数より小さいか、等しいか、大き
いかに従って、-1, 0, 1 を返します。

二項演算子の "eq" は左引数が文字列的に右引数と等しければ、真を返します。

二項演算子の "ne" は左引数が文字列的に右引数と等しくなければ、真を返し
ます。

二項演算子の "cmp" は左引数が文字列的に右引数より小さいか、等しいか、大
きいかに従って、-1, 0, 1 を返します。





File: perl-ja.info, Node: ビットごとの AND, Next: ビットごとの OR と XOR, Prev: 等価演算子, Up: 演算子と優先順位

ビットごとの AND
================

二項演算子の "&" は、両被演算子のビットごとに論理積をとって、その結果を
返します。





File: perl-ja.info, Node: ビットごとの OR と XOR, Next: C スタイルの論理積, Prev: ビットごとの AND, Up: 演算子と優先順位

ビットごとの OR と XOR
======================

二項演算子の "|" は、両被演算子のビットごとに論理和をとって、その結果を
返します。

二項演算子の "^" は、両被演算子のビットごとに排他論理和をとって、その結
果を返します。





File: perl-ja.info, Node: C スタイルの論理積, Next: C スタイルの論理和, Prev: ビットごとの OR と XOR, Up: 演算子と優先順位

C スタイルの論理積
==================

二項演算子の "&&" は、短絡の論理積演算を行ないます。つまり、左被演算子
が偽であれば、右被演算子は評価さえ行なわれないということです。評価され
る場合には、スカラかリストかというコンテキストは、右被演算子にも及びま
す。





File: perl-ja.info, Node: C スタイルの論理和, Next: 範囲演算子, Prev: C スタイルの論理積, Up: 演算子と優先順位

C スタイルの論理和
==================

二項演算子の "||" は、短絡の論理和演算を行ないます。つまり、左被演算子
が真であれば、右被演算子は評価さえ行なわれないということです。評価され
る場合には、スカラかリストかというコンテキストは、右被演算子にも及びま
す。

|| 演算子と && 演算子は、単に 0 や 1 を返すのではなく、最後に評価された
値を返すという点において、C と違っています。これにより、かなり一般的に
使えるホームディレクトリ ("0" でないとして) を探す方法は:

     $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
         (getpwuid($<))[7] || die "You're homeless!\n";

のようにすることができます。

Perl では、多少読みやすい && と || の同義語として、"and" 演算子と "or"
演算子が用意されています (下記参照)。短絡の動作は全く同じです。しかし、
and" と "or" の優先順位はかなり低くしてあるので、引数に括弧を使っていな
いリスト演算子のあとに続けて使う場合にも、安心して使うことができます:

     unlink "alpha", "beta", "gamma"
             or gripe(), next LINE;

C スタイルの演算子では:

     unlink("alpha", "beta", "gamma")
             || (gripe(), next LINE);

のように書く必要があります。





File: perl-ja.info, Node: 範囲演算子, Next: 条件演算子, Prev: C スタイルの論理和, Up: 演算子と優先順位

範囲演算子
==========

二項演算子の ".." は範囲演算子で、使われるコンテキストによって異なる動
作をする 2 つの演算子を合わせたものです。リストコンテキストでは、左の値
から右の値まで (1 づつ) 数えあげた値からなる配列を返します。これは、
for (1..10) のようなループを書くときや、配列のスライス演算を行なうとき
に便利です。現状のインプリメントでは、テンポラリの配列が作られるので:

     for (1 .. 1_000_000) {
         # プログラム
     }

のようなことを書くと、メモリを使い果たして、悲惨な結果になりかねません
ので注意してください。

スカラコンテキストで使われたときには、".." はブール値を返します。この演
算子は、フリップフロップのように 2 値安定で、sed や awk や多くのエディ
タでの行範囲 (コンマ) 演算子をエミュレートするものとなります。各々の
.." 演算子がそれぞれに独立して自分のブール状態を管理します。はじめは、
左被演算子が偽である間、演算全体も偽となっています。範囲演算子は、いっ
たん左被演算子が真になると、右被演算子が真である間、真を返すようになり
ます。右被演算子が偽になると、演算子も偽を返すようになります。(次に範囲
演算子が評価されるまでは、偽とはなりません。(awk でのように) 真となった、
その評価の中で右被演算子をテストし、偽とすることができますが、1 度は真
を返すことになります。(sed でのように) 次に評価されるまで、右被演算子を
テストしたくなければ、2 個のドットの代わりに 3 つのドット ("...") を使っ
てください。右被演算子は、演算子の状態が「偽」である間は評価されること
がなく、左被演算子は、演算子の状態が「真」である間は評価されることがあ
りません。優先順位は、|| と && の少し下です。偽としては空文字列が返され、
真としては (1 から始まる) 順に並んだ数値が返されます。この通し番号は、
新たに範囲が始まるごとにリセットされます。範囲の最後の数字には、文字列
E0" がお尻につけられます。これは、数値としては何の影響もありませんが、
範囲の終わりで何か特別なことをしたい場合に、目印として使うことができま
す。範囲の始まりで何かしたい場合には、通し番号が 1 よりも大きくなるのを
待っていればよいでしょう。スカラの ".." の被演算子が数値リテラルである
ときは、その被演算子は暗黙に、変数 $. (現行番号)と比較されることになり
ます。例:

スカラ演算子として:

     if (101 .. 200) { print; }  # 101 行目から 200 行目を印字
     next line if (1 .. /^$/);   # ヘッダをスキップし、
     s/^/> / if (/^$/ .. eof()); # 本文を引用する。

リスト演算子として:

     for (101 .. 200) { print; } # $_ を 100 回、印字する
     @foo = @foo[$[ .. $#foo];   # コストがかかるが何もしない
     @foo = @foo[$#foo-4 .. $#foo]; # 最後の 5 要素のスライス

(リストコンテキストでの) 範囲演算子は、被演算子が文字列であるときには、
マジカルインクリメントの機能を使います。大文字すべての配列を得るのに

     @alphabet = ('A' .. 'Z');

と書けますし、

     $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];

と書けば、16 進の数字が得られますし、

     @z2 = ('01' .. '31');  print $z2[$mday];

とすれば、0 付きの日付が得られます。マジカルインクリメントによって得ら
れる値の中に指定した最終値にちょうど一致するものが見つからないような場
合には、マジカルインクリメントによって得られる次の値の文字列長が、最終
値として指定した値のものより長くなるまでインクリメントが続けられます。





File: perl-ja.info, Node: 条件演算子, Next: 代入演算子, Prev: 範囲演算子, Up: 演算子と優先順位

条件演算子
==========

三項演算子の "?:" は、C の場合と同じ条件演算子です。これは、
if-then-else のように働きます。"?" の前の引数が真であれば、":" の前の引
数が返されますが、真でなければ、":" の後の引数が返されます。スカラコン
テキストかリストコンテキストかという状況は、選択された 2 番目もしくは
3 番目の引数にまで伝わります。2 番目と 3 番目の引数双方が左辺値 (代入可
能ということ)であれば、この演算子に代入を行なうこともできます:

     ($a_or_b ? $a : $b) = $c;

このことがプログラムの読みやすさにつながるかどうかは、別問題なので注意
してください。





File: perl-ja.info, Node: 代入演算子, Next: コンマ演算子, Prev: 条件演算子, Up: 演算子と優先順位

代入演算子
==========

"=" は通常の代入演算子です。

代入演算子は C の場合と同様の働きをします。つまり、

     $a += 2;

は、

     $a = $a + 2;

と等価ですが、tie() のようなもので起こる左辺値の被参照による副作用が 2
回起こることはありません。他の代入演算も同様に働きます。以下のものが認
識されます:

              **=    +=    *=    &=    <<=    &&=
                     -=    /=    |=    >>=    ||=
                     .=    %=    ^=
                           x=

グループ分けしてありますが、これらはいずれも代入演算子として同じ優先順
位となっています。

C と違って、代入演算子は有効な左辺値を作り出します。代入を修正すること
は、代入を行なってから、その代入された変数を修正するのと同じことになり
ます。これは:

     ($tmp = $global) =~ tr [A-Z] [a-z];

ように何かのコピーを変更したいときに便利です。同じように、

     ($a += 2) *= 3;

は、

     $a += 2;
     $a *= 3;

と等価となります。





File: perl-ja.info, Node: コンマ演算子, Next: リスト演算子 (右方向), Prev: 代入演算子, Up: 演算子と優先順位

コンマ演算子
============
二項演算子の "," はコンマ演算子です。スカラコンテキストでは、その左引数
を評価し、その値を捨てて、それから右引数を評価し、その値を返します。こ
れはちょうど、C のコンマ演算子と同じです。

リストコンテキストでは、これは単にリスト引数の区切り文字で、双方の引数
をそのリストに挿入する働きがあります。





File: perl-ja.info, Node: リスト演算子 (右方向), Next: 論理否定, Prev: コンマ演算子, Up: 演算子と優先順位

リスト演算子 (右方向)
=====================

リスト演算子の右側のものにとって、リスト演算子はとても低い優先順位にな
ります。これによってコンマで区切った式をリスト演算子の引数として、置く
ことができます。これよりも優先順位が低いものは、論理演算子の "and",
or", "not" のみで、余分な括弧を付けないリスト演算子の呼び出しを評価する
ために使うことができます:

     open HANDLE, "filename"
         or die "Can't open: $!\n";

「*Note 項とリスト演算子 (左方向)::,」の節の記述も参照してください。





File: perl-ja.info, Node: 論理否定, Next: 論理積, Prev: リスト演算子 (右方向), Up: 演算子と優先順位

論理否定
========

単項演算子の "not" は右側に来る式の否定を返します。これは、優先順位がずっ
と低いことを除いては "!" と等価です。




File: perl-ja.info, Node: 論理積, Next: 論理和と排他論理和, Prev: 論理否定, Up: 演算子と優先順位

論理積
======

二項演算子の "and" は両側の式の論理積を返します。これは、優先順位がずっ
と低いことを除けば && と等価です。つまり、これも短絡演算を行ない、右側
の式は左側の式が「真」であった場合にのみ評価されます。




File: perl-ja.info, Node: 論理和と排他論理和, Next: Perl にない C の演算子, Prev: 論理積, Up: 演算子と優先順位

論理和と排他論理和
==================

二項演算子の "or" は両側の式の論理和を返します。これは、優先順位がずっ
と低いことを除いて || と等価です。つまり、これも短絡演算を行ない、右側
の式は左側の式が「偽」であった場合にのみ評価されます。

二項演算子の "xor" は両側の式の排他論理和を返します。これはもちろん、短
絡ではありません。





File: perl-ja.info, Node: Perl にない C の演算子, Next: クォートとクォートのような演算子, Prev: 論理和と排他論理和, Up: 演算子と優先順位

Perl にない C の演算子
======================

C にあって Perl に無いものは以下の通りです:

単項 &
     アドレス演算子。("\" 演算子がリファレンスのために用いられます。)

単項 *
     被アドレス参照演算子。 (Perl の被参照プリフィクス演算子が型づけを
     行なう: $, @, %, &。)

(型)
     型のキャスト演算子。





File: perl-ja.info, Node: クォートとクォートのような演算子, Next: I/O 演算子, Prev: Perl にない C の演算子, Up: 演算子と優先順位

クォートとクォートのような演算子
================================

クォートはリテラル値であると考えるのが普通ですが、Perl において、クォー
トは演算子として働き、さまざまな展開やパターンマッチの機能を持っていま
す。そのような動作をさせるのに、Perl は慣習的にクォート文字を使っていま
すが、どの種類のクォートも、自分でクォート文字を選べるようになっていま
す。以下の表では、{} がその選んだ区切文字のペアを示しています。選んだ区
切文字が括弧の類でない場合には、前後の文字として同一のものを使いますが、
4 つの括弧 ((), <>, [], {}) の場合にはネストできます。

     通常記法  汎用記法      意味         展開
     ==========================================
        ''       q{}       リテラル       不可
        ""      qq{}       リテラル        可
        ``      qx{}       コマンド        可
                qw{}      単語リスト      不可
        //       m{}    パターンマッチ     可
                 s{}{}       置換          可
                tr{}{}       変換         不可

展開が行なわれる構文では、"$" や "@" で始まる変数が、以下のシーケンスと
同時に展開されます:

     \t          タブ
     \n          改行
     \r          復帰
     \f          改ページ
     \v          垂直タブ (それが何であっても)
                 (訳注: これは使えないように見える)
     \b          バックスペース
     \a          アラーム (ベル)
     \e          エスケープ
     \033        8 進数で表した文字
     \x1b        16 進数で表した文字
     \c[         コントロール文字
     \l          次の文字を小文字にする
     \u          次の文字を大文字にする
     \L          \E まで小文字にする
     \U          \E まで大文字にする
     \E          変更の終わり
     \Q          \E まで正規表現のメタ文字をクォートする

パターンはさらに、正規表現として展開が行なわれます。これは、変数が展開
された後の 2 回目のパスで行なわれるので、変数に正規表現を含めておき、パ
ターンの中へ展開することができます。もし、そうしたくないのであれば、\Q
を使うと変数の内容を文字どおりに展開することができます。

上記のものを除けば、複数の段階を踏んで展開が行なわれることはありません。
特に、シェルのプログラマの期待とは裏腹に、バッククォートはダブルクォー
トの中では展開されませんし、シングルクォートがダブルクォートの中で使わ
れても、変数の展開を妨げることはありません。

?PATTERN?
     これは、reset() 演算子を呼び出すごとに 1 度だけしかマッチしないこ
     とを除いては /pattern/ による検索と全く同じです。たとえば、ファイ
     ルの集まりの中で個々のファイルについて、あるものを探すとき、最初の
     1 つだけの存在がわかれば良いのであれば、この機能を使って最適化をは
     かることができます。現在のパッケージにローカルとなっている
     ?PATTERN? のパターンだけが reset されます。

     この方法は、あまりお勧めしません。Perl の将来のバージョンでは削除
     されるかもしれません。

m/PATTERN/gimosx
/PATTERN/gimosx
     パターンマッチで文字列検索を行ない、スカラコンテキストでは真 (1)
     または偽 (") を返す。=~ 演算子か !~ 演算子で検索対象の文字列を示さ
     なかったときには、$_の文字列が検索対象となります。(=~ で指定される
     文字列は、左辺値である必要はありません。式を評価した結果でもかまい
     ませんが、=~ の優先順位がいくぶん高いことに注意してくださ
     い。)perlre manpage を参照してください。

     オプションには、

        g   グローバルにマッチ、つまり、すべてを探し出す
        i   大文字、小文字を区別しない
        m   文字列を複数行として扱う
        o   パターンのコンパイルを 1 度だけにする
        s   文字列を単一行として扱う
        x   拡張正規表現を使用する

     があります。

     区切文字が "/" のときには、最初の m は付けても付けなくてもかまいま
     せん。m を付けるときには、英数字でも空白でもない、任意の任意の文字
     のペアを、区切文字として使うことができます。これは "/" を含む
     UNIX のパス名にパターンパッチを行なうときに便利でしょう。\/ といっ
     た LTS (楊枝偏執症候群) を避けるためにも。

     PATTERN には、変数が含まれていてもよく、パターンが評価されるごとに、
     変数は展開され (パターンが再コンパイルされ) ます。(2 つの変数 $)
     と $| は文字列の終わりを調べるパターンであると解釈されるので、展開
     されません。)パターンがコンパイルされるのを 1 度だけにしたい場合に
     は、終わりの区切文字の後に /o 修飾子を付けます。これにより、実行時
     に再コンパイルが頻繁に起こることが避けられ、展開する値がスクリプト
     の実行中に変化しない場合に有効なものとなります。しかし、/o を付け
     ることは、パターンの中の変数を変更しないことを約束するものです。変
     更したとしても、Perl がそれに気付くことはありません。

     PATTERN を評価した結果が空文字列となった場合には、最後に実行され
     (コンパイルに成功し) た正規表現が、代わりに使われます。

     パターンマッチが、リスト値が要求されるコンテキストで使われると、パ
     ターンの中の括弧で括られた部分列にマッチしたもので構成されるリスト
     を返します。これは、($1, $2, $3, ...) ということです。(この場合、
     $1 なども設定されます。この点で Perl 4 の動作と違っています。)マッ
     チが失敗した場合には、空配列が返されます。マッチが成功した場合で、
     括弧が無い場合には、リスト値 (1) が返されます。

     例:
          open(TTY, '/dev/tty');
          <TTY> =~ /^y/i && foo();    # 要望により foo を実行

          if (/Version: *([0-9.]*)/) { $version = $1; }

          next if m#^/usr/spool/uucp#;

          # 安上がりな grep
          $arg = shift;
          while (<>) {
              print if /$arg/o;       # 1 度だけコンパイル
          }

          if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

     最後の例は、$foo を最初の 2 つの単語と行の残りに分解し、$F1 と
     $F2 と $Etc に代入しています。変数に代入されれば、すなわちパターン
     がマッチすれば、if の条件が真となります。

     /g 修飾子は、グローバルなパターンマッチを指定するもので、文字列の
     中で可能な限りたくさんマッチを行ないます。この動作は、コンテキスト
     に依存します。リストコンテキストでは、正規表現内のすべての括弧付け
     されたものにマッチした部分文字列全部のリストが返されます。括弧がな
     ければ、パターン全体を括弧で括っていたかのように、すべてのマッチし
     た文字列のリストが返されます。

     スカラコンテキストでは、m//g は文字列内で繰り返しを行ない、マッチ
     するごとに「真」を返し、最終的にマッチしなくなったときに「偽」を返
     します。(言い換えると、前回止まった場所を覚えていて、その場所から
     検索を再開するということです。文字列の現在の検索位置は、関数
     pos() を使って知ることができます。*Note 組み込み関数::,を参照して
     ください。)いかなる方法でも、対象の文字列を変更すると、検索位置は
     先頭にリセットされます。

     例:
          # リストコンテキスト
          ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

          # スカラコンテキスト
          $/ = ""; $* = 1;  # Perl 5 では、$* は使わないほうがよい
          while ($paragraph = <>) {
              while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
                  $sentences++;
              }
          }
          print "$sentences\n";

q/STRING/
'STRING'
     シングルクォートされた、リテラル文字列です。バックスラッシュは、後
     ろに続くものが区切文字か、別のバックスラッシュである場合を除いて無
     視されます。区切文字やバックスラッシュが続く場合には、その区切文字
     自身もしくはバックスラッシュそのものが展開されます。

          $foo = q!I said, "You said, 'She said it.'"!;
          $bar = q('This is it.');

qq/STRING/
"STRING"
     ダブルクォートされた、リテラル文字列です。

          $_ .= qq
           (*** The previous line contains the naughty word "$1".\n)
                      if /(tcl|rexx|python)/;      # :-)


qx/STRING/
`STRING`
     展開され、システムのコマンドとして実行される文字列です。そのコマン
     ドの、標準出力を集めたものが返されます。スカラコンテキストでは、
     (複数行を含むかもしれない) 1 つの文字列が戻ってきます。リストコン
     テキストでは、($/ もしくは $INPUT_RECORD_SEPARATOR をどのように設
     定していても) 行のリストを返します。

          $today = qx{ date };

     詳しくは「*Note I/O 演算子::,」の節を参照してください。

qw/STRING/
     埋め込まれた空白を区切文字として、STRING から抜き出した単語のリス
     トを返します。これは、

          split(' ', q/STRING/);

     と完全に同じになります。

     よく行なわれる例としては:

          use POSIX qw( setlocale localeconv );
          @EXPORT = qw( foo bar baz );

     というものがあります。

s/PATTERN/REPLACEMENT/egimosx
     文字列中でパターンを検索し、もし見つかれば、置換テキストで置き換え、
     置換した数を返します。見つからなければ、偽 (0) を返します。

     =~ 演算子や !~ 演算子によって文字列が指定されていなければ、変数 $_ が検
     索され、修正されます。(=~ で指定される文字列は、スカラ変数、配列要
     素、ハッシュ要素、あるいは、これらへの代入式といった左辺値でなけれ
     ばなりません。)

     あとで述べますが、区切り文字はスラッシュとは限りません。シングル
     クォートを区切り文字として使った場合には、PATTERN にも
     REPLACEMENT にも変数の展開を行ないません。 それ以外の場合、文字列
     の最後を表わすものには見えない $ が PATTERN に含まれると、実行時に
     変数がパターン内に展開されます。最初に変数が展開されるときにだけパ
     ターンのコンパイルを行ないたいときには、/oオプションを使ってくださ
     い。パターンの評価結果が空文字列になった場合には、最後に実行され
     (コンパイルに成功し) た正規表現が代わりに使われます。これについて
     さらに詳しくは、*Note 正規表現::,を参照してください。

     オプションには、

        e   式の右側の評価を行なう
        g   グローバルな置換、つまり見つかったものすべて
        i   大文字、小文字を区別しないで検索
        m   文字列を複数行として扱う
        o   パターンのコンパイルを 1 度だけにする
        s   文字列を単一行として扱う
        x   拡張正規表現を使用する

     があります。

     英数字、空白ではない任意の区切り文字で、スラッシュを置き換えること
     ができます。先に述べたように、シングルクォートを使うと置換文字列で
     の展開はされません (/e 修飾子を使えば可能です)。バッククォートを用
     いると、置換文字列をコマンドとして実行して、その出力が実際の置換文
     字列に使われます。PATTERN を括弧類で括った場合には、REPLACEMENT 用
     にもう一組の区切り文字を用意します。これは、括弧類であっても、なく
     てもかまいません。例: s(foo)(bar) や s<foo>/bar/。/e は置換文字列
     を完全な Perl の式として解釈し、その場所で直ちにeval() します。し
     かし、これはコンパイル時に構文チェックされます。

     例:
          s/\bgreen\b/mauve/g;  # wintergreen は変更しない

          $path =~ s|/usr/bin|/usr/local/bin|;

          s/Login: $foo/Login: $bar/; # 実行時パターン

          ($foo = $bar) =~ s/this/that/;

          $count = ($paragraph =~ s/Mister\b/Mr./g);

          $_ = 'abc123xyz';
          s/\d+/$&*2/e;               # 'abc246xyz' となる
          s/\d+/sprintf("%5d",$&)/e;  # 'abc  246xyz'
          s/\w/$& x 2/eg;             # 'aabbcc  224466xxyyzz'

          s/%(.)/$percent{$1}/g;      # パーセントエスケー
                                                       # プを変更; /e なし
          s/%(.)/$percent{$1} || $&/ge;  # 式となるので /e
          s/^=(\w+)/&pod($1)/ge;      # 関数呼び出しを使う

          # /e はネスト可能;
          # $_ に単純に埋め込まれた変数を展開する
          s/(\$\w+)/$1/eeg;

          # C コメントの削除
          $program =~ s {
              /\*     (?# 開始区切り文字にマッチ)
              .*?     (?# 最短一致でマッチ)
              \*/     (?# 終了区切り文字にマッチ)
          } []gsx;

          s/^\s*(.*?)\s*$/$1/;        # 空白の切り詰め

          s/([^ ]*) *([^ ]*)/$2 $1/;  # 最初の 2 語の入れ替え

     最後の例で \ の代わりに $ を使っているのに注意してください。sed と
     違って、\<数字> の形式はパターンの方でのみ使用できます。その他の場
     所では、$<数字> を使います。

     ときには、/g を付けるだけでは、すべてを変更することができないこと
     があります。2 つ例を示します:

          # 整数の適切な位置にコンマを入れる
          1 while s/(.*\d)(\d\d\d)/$1,$2/g;      # perl4
          1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;  # perl5

          # タブを 8 カラムのスペースに展開
          1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

tr/SEARCHLIST/REPLACEMENTLIST/cds
y/SEARCHLIST/REPLACEMENTLIST/cds
     検索リスト (SEARCHLIST) に含まれる文字を、対応する置換リスト
     (REPLACEMENTLIST) の文字に変換します。置換または削除が行なわれた、
     文字数を返します。=~ 演算子や =! 演算子で文字列が指定されていなけ
     れば、$_の文字列が変換されます。(=~ で指定される文字列は、スカラ変
     数、配列要素、ハッシュ要素、あるいは、これらへの代入式といった左辺
     値でなければなりません。) sed の信仰者のために y が tr の同義語と
     して提供されています。SEARCHLIST を括弧類で括った場合には、
     REPLACEMENTLIST 用に、もう一組の区切り文字を用意します。これは、括
     弧類であっても、なくてもかまいません。

          例: tr[A-Z][a-z] や tr(+-*/)/ABCD/。

     オプションには、

        c   SEARCHLIST を補集合にする
        d   見つかったが置換されなかった文字を削除する
        s   置換された文字が重なったときに圧縮する

     があります。

     /c 修飾子が指定されると、SEARCHLIST には補集合が指定されたものと解
     釈されます。/d 修飾子が指定されると、SEARCHLIST に指定されて、
     REPLACEMENTLIST に対応するものがない文字が削除されます。(これは、
     SEARCHLIST で見つかったものを削除する、ただそれだけの、ある種の
     tr プログラムの動作よりと比べれば、いく分柔軟なものになっていま
     す。)/s 修飾子が指定されると、同じ文字に置き換えられた文字の並びを、
     その文字 1 文字だけに圧縮します。

     /d 修飾子が使われると、REPLACEMENTLIST は、常に指定された通りに解
     釈されます。/d が指定されない場合で、REPLACEMENTLIST が
     SEARCHLIST よりも短いと、同じ長さになるまで、REPLACEMENTLIST の最
     後の文字が繰り返されているものとして扱われます。REPLACEMENTLIST が
     空文字列でのときには、SEARCHLIST と同じになります。後者は、ある文
     字クラスに含まれる文字数を数えるときや、ある文字クラスの文字の並び
     を圧縮するようなときに便利です。

     例:
          $ARGV[1] =~ tr/A-Z/a-z/;    # 小文字に統一

          $cnt = tr/*/*/;             # $_ 内の * を数える

          $cnt = $sky =~ tr/*/*/;     # $sky 内の * を数える

          $cnt = tr/0-9//;            # $_ 内の数字を数える

          tr/a-zA-Z//s;               # bookkeeper -> bokeper

          ($HOST = $host) =~ tr/a-z/A-Z/;

          tr/a-zA-Z/ /cs;             # 英字以外を 1 つの
                                      # スペースに変換する

          tr [\200-\377]
             [\000-\177];             # 8th bit 目を削除

     変換テーブルはコンパイル時に作られるので、SEARCHLIST も
     REPLACEMENTLIST もダブルクォート展開の対象とはなりません。変数を使
     いたい場合には、eval() を使わなければならないということです:

          eval "tr/$oldlist/$newlist/";
          die $@ if $@;

          eval "tr/$oldlist/$newlist/, 1" or die $@;





File: perl-ja.info, Node: I/O 演算子, Next: 定数の畳み込み, Prev: クォートとクォートのような演算子, Up: 演算子と優先順位

I/O 演算子
==========

知っておいた方がよい I/O 演算子もいくつかあります。バッククォートで括ら
れた文字列は、まず、ダブルクォート文字列のように、変数の展開が行なわれ
ます。その後、シェルでの場合と同じように、コマンドとして解釈され、その
コマンドの出力がこの擬似リテラルの値となります。スカラコンテキストでは、
出力すべてを含む一個の文字列が返されます。リストコンテキストでは、出力
の 1 行 1 行が個々の要素となるリストが返されます。($/ を設定すれば、行
の終わりを示す文字を変えることができます。)コマンドは、この擬似リテラル
が評価されるごとに実行されます。コマンドのステータス値は $? に返されま
す ($? の解釈については、*Note 定義済み変数::,を参照してください)。csh
での場合とは違って、結果のデータに対する変換は行なわれず、改行は改行の
ままです。どのシェルとも違って、シングルクォートがコマンド中の変数名を
解釈させないようにすることはありません。シェルに$ を渡すには、バックス
ラッシュでエスケープしなければなりません。バッククォートの一般形は、
qx// です。

山括弧の中のファイルハンドルを評価すると、そのファイルから、次の行を読
み込むことになります (改行も含まれるので、未定義値が返される EOF に達す
るまでは、偽と評価される値が返ることはありません)。通常は、その値を変数
に代入しなければなりませんが、自動的に代入される場合が 1 つだけあります。
この入力シンボルが、while ループの条件式中に単独で現れた場合だけは、そ
の値が自動的に変数 $_ に代入されます。(これは、奇妙に思えるかもしれませ
んが、ほとんどすべての Perl スクリプトでこれが必要になることでしょう。)い
ずれにせよ、以下のものは、お互いに同値なものです:

     while ($_ = <STDIN>) { print; }
     while (<STDIN>) { print; }
     for (;<STDIN>;) { print; }
     print while $_ = <STDIN>;
     print while <STDIN>;

STDIN、STDOUT、STDERR というファイルハンドルは、あらかじめ定義されてい
ます。(stdin、stdout、stderr というファイルハンドルも、ローカルな名前で
これらのグローバルな名前が見えなくなっているパッケージを除けば、使用す
ることができます。)その他のファイルハンドルは、open() 関数で作ることが
できます。

<FILEHANDLE> がリストを必要とするコンテキストで用いられると、1 要素に
1 行の入力行すべてからなるリストが返されます。これを使うと簡単に巨大な
データが作られてしまいますので、注意を要します。

ヌルファイルハンドル <> は特別で、sed や awk の動作をエミュレートするた
めに使われます。<> からの入力は、標準入力からか、コマンドライン上に並べ
られた個々のファイルから行なわれます。動作の概要は、以下のようになりま
す。最初に <> が評価されると、配列 @ARGV が調べられ、空であれば、
$ARGV[0] に "-"を設定します。これは、open されるとき標準入力となります。
その後、配列 @ARGV がファイル名のリストとして処理されます。

     while (<>) {
         ...                     # 行ごとの処理
     }

というループは、

     unshift(@ARGV, '-') if $#ARGV < $[;
     while ($ARGV = shift) {
         open(ARGV, $ARGV);
         while (<ARGV>) {
             ...         # 行ごとの処理
         }
     }

のような Perl の擬似コードと等価です。わずらわしく書かなくても、動作し
ます。実際に @ARGV を shift しますし、その時点のファイル名を変数 $ARGV
に入れています。また、内部的にファイルハンドル ARGV を使っていて、<> は
不思議な <ARGV> の同義語となっています。(上記の擬似コードは、<ARGV> を
通常のものとして扱っているので、うまく動作しません。)

終的に、@ARGV に扱いたいと思っているファイル名が含まれるのであれば、最
初に <> を評価する前に @ARGV を変更することも可能です。行番号 ($.) は、
入力ファイルがあたかも 1 つの大きなファイルであるかのように、続けてカウ
ントされます。(個々のファイルごとにリセットする方法は、perlfunc
manpage の eof() の例を参照してください。)

最初から @ARGV に自分でファイルのリストを設定してもかまいません。スクリ
プトにスイッチを渡したいのであれば、Getopts モジュールを使うこともでき
ますし、実際の処理の前に

     while ($_ = $ARGV[0], /^-/) {
         shift;
         last if /^--$/;
         if (/^-D(.*)/) { $debug = $1 }
         if (/^-v/)     { $verbose++  }
         ...             # その他のスイッチ
     }
     while (<>) {
         ...             # 個々のファイルに対するコード
     }

のようなループを置くこともできます。

シンボル <> が「偽」を返すのは一度きりです。偽となったあとで、もう一度
呼び出すと、新たに別の @ARGV を処理するものとみなされ、その時に @ARGV
を設定しなおしていないと、STDIN から読み込むことになります。

山括弧の中の文字列が (<$foo> のような) スカラ変数の参照となっていれば、
その変数が入力を行なうファイルハンドルの名前を示しているとみなされます。

山括弧の中の文字列がファイルハンドルでなければ、グロブを行なうファイル
名のパターンと解釈され、コンテキストによって、ファイル名のリストか、そ
のリストの次のファイル名が返されます。まず、1 段階だけ $ の展開が行なわ
れますが、前の段落に書いた間接ファイルハンドルと同じになる、<$foo> のよ
うには書けません。ファイル名グロブと解釈させるには <${foo}> のように中
括弧を入れる必要があります。(別の方法として、glob($foo) と内部関数を呼
ぶこともできます。おそらく、まず、こちらの方で試すのが正解でしょう。)例:

     while (<*.c>) {
         chmod 0644, $_;
     }

は、

     open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
     while (<FOO>) {
         chop;
         chmod 0644, $_;
     }

と等価です。実際、現在はそのようにインプリメントされています。(つまり、
マシン上に csh(1) がないと、スペースを含むファイル名は、うまく扱えない
ということです。)もちろん、もっと簡単に

     chmod 0644, <*.c>;

と書けます。

グロブはシェルを呼び出しますから、自分で readdir() を呼んで、得られたファ
イル名に grep() した方が速い場合もあります。さらに、現在のインプリメン
トがシェルを使うために、(/bin/csh として tcsh(1L) をインストールしてい
ない限り) glob() ルーティンで "Arg list too long" エラーが発生する場合
があります。





File: perl-ja.info, Node: 定数の畳み込み, Next: 整数演算, Prev: I/O 演算子, Up: 演算子と優先順位

定数の畳み込み
==============

C と同じように Perl でも、演算子に対するすべての引数がスタティックで、
副作用がないと判断できれば、コンパイル時に式の評価を行なってしまいます。
特に、変数置換の無いリテラルどうしの文字列連結はコンパイル時に行なわれ
ます。バックスラッシュの解釈もコンパイル時に行なわれます。

     'Now is the time for all' . "\n" .
         'good men to come to.'

と書いても、内部的に 1 つの文字列になります。同様に

     foreach $file (@filenames) {
         if (-s $file > 5 + 100 * 2**16) { ... }
     }

と書くとコンパイラは、式が表わす数値をあらかじめ計算しますので、インタ
プリタで計算する必要がなくなっています。





File: perl-ja.info, Node: 整数演算, Prev: 定数の畳み込み, Up: 演算子と優先順位

整数演算
========

デフォルトでは、Perl は演算を浮動小数で行なわなければならないものとして
いますが、

         use integer;

と書けば、その場所から現在の BLOCK の終わりまでは、整数演算を行なってよ
いと、コンパイラに指示することができます。内部の BLOCK で、

         no integer;

と書けば、その BLOCK の終わりまでは、指示を取り消すことになります。




File: perl-ja.info, Node: 正規表現, Next: 実行とオプション, Prev: 演算子と優先順位, Up: Top

正規表現
********

マッチ演算子においてどのように正規表現を使うかについての説明は、*Note
演算子と優先順位::,の m// や s/// を参照してください。マッチ演算子は、
いくつかの修飾子をとり、中の正規表現の解釈の仕方を変更することができま
す。修飾子には、

   i   大文字小文字の区別をしないパターンマッチを行なう。
   m   文字列を複数行として扱う。
   s   文字列を単一行として扱う。
   x   拡張正規表現を使用する。

があります。これらは通常、使用する区切り文字にスラッシュ以外のものを使
うときでも、「/x 修飾子」のように書かれます。実際には、これらの修飾子は、
(?...) という新しい形式で正規表現の中に埋め込んでしまうこともできます。
これについては、あとで述べます。

/x 修飾子について、もう少し説明しておきましょう。これは、正規表現のパー
ザに、バックスラッシュでエスケープされている空白、文字クラス内で使われ
ている空白以外の空白を無視するように指示するものです。これを使えば、正
規表現を (少しは) 読みやすい単位に分割して使うことができるでしょう。あ
とで述べる、埋め込みコメントの機能とともに、Perl 5 を読みやすい言語にす
ることに貢献しています。*Note 演算子と優先順位::,にあげた C のコメント
を削除する例を参照してください。

* Menu:

* 正規表現の書き方::
* Version 8 正規表現::





File: perl-ja.info, Node: 正規表現の書き方, Next: Version 8 正規表現, Prev: 正規表現, Up: 正規表現

正規表現の書き方
================

パターンマッチで用いるパターンは、Version 8 regexp ルーティンで提供され
ているような正規表現です。(実際、使用しているルーティンは、Henry
Spencer が書き直した再配布可能な V8 のルーティンを元にしています。)詳し
くは、「*Note Version 8 正規表現::,」の節を参照してください。

特に、以下のメタ文字は、標準的な egrep(1) と同様の意味を表わします:

   \   次のメタ文字をクォートする
   ^   行の最初にマッチする
   .   (改行以外の) すべての文字にマッチする
   $   行の終わりにマッチする
   |   選択
   ()  グループ化
   []  文字クラス

デフォルトでは、文字 "^" は文字列の最初にだけ、文字 "$" は最後 (もしく
は、最後の改行の前) にだけマッチすることが保証されており、Perl は文字列
には 1 行だけが含まれていると仮定して、最適化を行ないます。文字列の中に
埋め込まれた改行は、"^" や"$" はマッチしません。しかし、文字列を複数行
のバッファとして扱い、"^" はすべての改行のあとにマッチし、"$" はすべて
の改行の前にマッチするようにしたい場合もあるでしょう。少しばかり負荷が
かかりますが、パターンマッチ演算子に /m 修飾子を付けると、そのようにす
ることができるようになります。(昔のプログラムでは $* を設定することでこ
れを行なっていましたが、Perl 5 でこれを行なうことは芳しくありません。)

複数行の置換を容易にするため、/s 修飾子を使わない限り、文字 "." は改行
文字にマッチしません。この /s 修飾子は、文字列がたとえ複数行であっても
単一行であるかのように扱うよう Perl に指示するものです。/s 修飾子は、他
のモジュールで $* を設定するような (よくない) 過去のコードを持ってきた
ような場合にも、その $* の設定を無効にします。

次のような標準の数量子が認識されます:

   *      0 回以上にマッチ
   +      1 回以上にマッチ
   ?      1 回または 0 回にマッチ
   {n}    ちょうど n 回にマッチ
   {n,}   n 回以上にマッチ
   {n,m}  n 回以上 m 回以下にマッチ

(中括弧が他の文脈であらわれた場合には、通常の文字として扱われます。)
*" 修飾子は {0,}、"+" は {1,}、"?" は {0,1} と等価なものとして扱われま
す。n や m の大きさに制限はありませんが、大きな数はそれだけメモリを消費
します。

デフォルトでは、数量子を付けたサブパターンは、「最長一致」となり、残り
のパターンがマッチしなくならない範囲で、できる限り多くのものにマッチす
るようになっています。つまり、標準の数量子は、すべて「最長一致」で、(適
切な開始位置を与えると) パターンが失敗しない範囲で可能な限り長い範囲に
マッチします。もし、最短の範囲でマッチさせたいのであれば、数量子の後に
?" を付けて指定します。この場合、「最短一致」となるだけで、意味するとこ
ろは変わりありません:

   *?     0 回以上にマッチ
   +?     1 回以上にマッチ
   ??     1 回または 0 回にマッチ
   {n}?   ちょうど n 回にマッチ
   {n,}?  n 回以上にマッチ
   {n,m}? n 回以上 m 回以下にマッチ

パターンはダブルクォート文字列として処理されますから、

     \t          タブ
     \n          改行
     \r          復帰
     \f          改ページ
     \v          垂直タブ (それが何であっても)
                 (訳注: これは使えないように見える)
     \a          アラーム (ベル)
     \e          エスケープ
     \033        8 進数で表した文字
     \x1b        16 進数で表した文字
     \c[         コントロール文字
     \l          次の文字を小文字にする
     \u          次の文字を大文字にする
     \L          \E まで小文字にする
     \U          \E まで大文字にする
     \E          変更の終わり
     \Q          \E まで正規表現のメタ文字をクォートする

も使用できます。さらに、Perl では以下のものが定義されています:

     \w  「単語」の構成文字 (英数字と "_") にマッチ
     \W  単語の構成文字以外にマッチ
     \s  空白文字にマッチ
     \S  空白文字以外にマッチ
     \d  数字にマッチ
     \D  数字以外にマッチ

\w は 1 字の英数字にマッチするのであって、単語全体にマッチするのではな
いことに注意してください。単語全体にマッチさせるためには \w+ とする必要
があります。\w, \W, \s, \S, \d, \Dは文字クラス内 (で範囲を指定する両端
の文字以外の場所) でも使うことができます。

Perl では以下の長さのない、位置指定子を定義しています:

     \b  単語の境界にマッチ
     \B  単語の境界以外にマッチ
     \A  文字列の最初にのみマッチ
     \Z  文字列の最後にのみマッチ
     \G  前回の m//g が終わったところにのみマッチ

単語の境界 (\b) は \w で定義される文字と \W で定義される文字の間という
ように定義されます (順番はどちらが先でもよい)。文字列の最初と最後には
W に含まれる仮想的な文字があるものとして扱われます。(文字クラスの中では
b は単語境界ではなく、バックスペースを表わします。)\A と \Z は /m 修飾
子が用いられた場合にも 1 か所でしかマッチしないことを除いて "^" と "$"
と同じ事になります。"^" と "$" は内部的な行の境界にもマッチします。

括弧括り ( ... ) の形式を用いている場合には、\<数字> がその括られている
「数字」番目の部分文字列にマッチします。(パターンの外では、数字の前の
の代わりに "$" を使います。) $<数字> (と $`, $&, $') のスコープは、
BLOCK や eval 文字列の終わりや、次の部分式を使ったパターンマッチまでと
なります。サブパターンとして記録せずに、括弧で括ってサブパターンを区切
りたい (たとえば、選択肢をまとめる) 場合、"(" の後に "?" を続けます。
<数字> の記法は、そのパターンの外で使える場合もあるかもしれませんが、こ
れに頼ってはなりません。括弧は、好きなだけ使ってかまいません。10 個以上
の部分文字列は、$10,$11 などで参照することができます。そのパターンの中
では、後方参照の前に最低限、参照している番号の数だけの開き括弧があれば、
10, \11 などで参照できます。その番号の数だけの開き括弧が無い場合には、
(以前のバージョンとの互換性のために) \10 は、\010 (バックスペース)、
11 は \011 (タブ) といった意味になります。(\1 から \9 は、常に後方参照
を意味します。)

$+ は、最後の括弧対にマッチしたものを返します。$& は、マッチした文字列
全体を返します。(以前は、$0 がこの意味に使われましたが、現在は使えませ
ん。) $` は、マッチした文字列の前にあったものを返します。$' は、マッチ
した文字列の後にあったものを返します。例:

     s/^([^ ]*) *([^ ]*)/$2 $1/;     # 最初の 2 語を入替える

     if (/Time: (..):(..):(..)/) {
         $hours = $1;
         $minutes = $2;
         $seconds = $3;
     }

Perl におけるすべてのバックスラッシュ付きのメタ文字が、\b,\w, \n といっ
た英数字であることにお気付きかもしれません。他のいくつかの正規表現言語
とは違って、英数字以外にバックスラッシュ付きの記号はありません。つまり、
, \(, \), \<, \>,\{, \} といったものはすべて、メタ文字ではなく、リテラ
ル文字として解釈されます。このことによって、パターンとして使いたい文字
列に、メタ文字と解釈される文字が含まれている可能性があるときに、たやす
くクォートすることができるようになっています。単に英数字以外の文字を、
すべてクォートすればよいのです:

     $pattern =~ s/(\W)/\\$1/g;

同じことを行なうために、組み込みの関数 quotemeta() を使うこともできます。
マッチ演算子の中でより簡単にメタ文字をクォートするには、

     /$unquoted\Q$quoted\E$unquoted/

とすればよいでしょう。

Perl 5 では、正規表現に一貫した拡張構文を定義しています。構文は、括弧の
ペアの中に、最初の文字としてクエスチョンマークを置いたものとなっていま
す (これは、Perl 4 では構文エラーです)。クエスチョンマークに続く文字で、
拡張の機能のどれを使うのかを示します。いくつかの拡張が、既にサポートさ
れています:

(?#text)
     コメント。Text は無視されます。

(?:regexp)
     これは、"()" と同じようにグループ化を行ないますが、"()" のように後
     方参照を生成しません。つまり

          split(/\b(?:a|b|c)\b/)

     は、

          split(/\b(a|b|c)\b/)

     と似ていますが、余分なフィールドを作りません。

(?=regexp)
     長さの無い、前方参照位置指定子。たとえば、/\w+(?=\t)/ は、後ろにタ
     ブが続く単語にマッチしますが、そのタブは $& には含まれません。

(?!regexp)
     長さの無い、前方参照否定位置指定子。たとえば、/foo(?!bar)/ は、後
     ろに "bar" が続かない "foo" にマッチします。前方参照と後方参照は、
     同じではないことに注意してください。この構文を後方を参照するために
     使うことはできません。/(?!foo)bar/ では、"foo" 以外のものに続く
     bar" を見つけるものではありません。(?!foo) は次にくるものが "foo"
     でないとだけ言っているからで、次が "bar" であれば、当然"foo" では
     ありませんから、"foobar" がマッチします。先の目的のためには、
     /(?!foo)...bar/ のように書かなくてはならないでしょう。「ように」と
     いったのは、"bar" の前に 3 文字無い場合もあるだろうからです。これ
     もカバーするには、/(?:(?!foo)...|^..?)bar/ というように書けるでしょ
     う。単に:

          if (/foo/ && $` =~ /bar$/)

     と書いた方が簡単なこともあります。(訳注: これは if(/bar(?=foo)/)
     かな。($' を除く))

(?imsx)
     パターンマッチ修飾子の埋め込み。これは、パターンが、どこかの表に示
     され、そのうちのいくつかは大文字小文字を区別せず、いくつかは区別す
     るといった場合に便利です。区別するものでは、単にパターンの先頭に
     (?i) を付け加えればよいのです。たとえば:

          $pattern = "foobar";
          if ( /$pattern/i )

          # パターンに埋め込めば、より柔軟:

          $pattern = "(?i)foobar";
          if ( /$pattern/ )

この構文や新しい最短一致の構文にクエスチョンマークを選らんだのは、1) 以
前の正規表現においてクエスチョンマークが使われることが少なかったこと、
2) これを見つけた人は「疑問」に思ってなにが起こるのかを考えるべきだとい
うことによります。これこそ、心理学 ...





File: perl-ja.info, Node: Version 8 正規表現, Prev: 正規表現の書き方, Up: 正規表現

Version 8 正規表現
==================

万が一、みなさんが「正規の」Version 8 正規表現ルーティンを知らなかった
場合のために、これまでに書いていないパターンマッチの規則を示します。

ある 1 文字は、その文字がこの節かこれまでに示した「メタ文字」でない場合
には、その文字自身にマッチします。通常はメタ文字として働く文字も、前に
を付けることで、文字通りに解釈されるようにすることができます。(たとえば、
." は任意の 1 文字ではなく、"." という文字にマッチします。)文字の並びは、
対象の文字列の中の同じ文字の並びにマッチしますから、blurfl というパター
ンは、対象となる文字列の "blurfl" にマッチします。

文字のリストを [] で囲って、そのリストのいずれかの文字にマッチする、文
字クラスを指定することができます。"[" に続く最初の文字が "^" であれば、
その文字クラスは、リストに無い文字にマッチするようになります。リストの
中では、"-" が範囲を示すのに使われ、a-z は "a" から "z" までのすべての
文字を表わします。

C で使われているのと非常によく似たメタ文字構文を使って、文字を指定する
ことができます。"\n" が改行、"\t" がタブ、"\r"が復帰、"\f" が改ページと
いった具合です。さらに一般的には、nnn を 8 進数の数字として、\nnn は
ASCII 値が nnn の文字にマッチします。同様に、nn を 16 進数の数字として、
xnn はASCII 値が nn の文字にマッチします。\cx という式は、ASCII 文字
control-x にマッチします。最後に、メタ文字 "." は (/s を使っているとき
を除いて) "\n" を除くどんな文字にもマッチします。

"|" で区切ることで、パターンの選択肢を示すことができますから、
fee|fie|foe は、対象の文字列の "fee" か "fie" か "foe" のいずれかにマッ
チします (f(e|i|o)e と同じ)。最初の選択肢には、最後の区切文字 ("(" か
[" かパターンの始め) の後から最初の"|" の前までが含まれ、最後の選択肢に
は、最後の "|" の後から次のパターンの区切文字の前までが含まれます。この
事から、最初と最後をはっきりさせるために、選択肢を括弧に入れることがよ
く行なわれます。(fee|fie|foe) というパターンは、[fee|fie|foe] というパ
ターンとは違うことに注意してください。前者が対象文字列の "fee" か
fie" か "foe" にマッチするのに対して、後者は [fee] か [fie] か [foe] の
いずれかの文字クラスにマッチするものにマッチします (つまり、文字クラス
[feio] です)。

パターンではあとで参照するために、括弧で括ってサブパターンを指定でき、
そのパターンの中で n 番目のサブパターンを \n というメタ文字で参照するこ
とができます。サブパターンは、左から右に向かって、開き括弧に対して番号
がつけられます。後方参照は、サブパターンが調べられる文字列中で、実際に
マッチしたものにマッチするのであって、そのサブパターン規則そのものにマッ
チするのではありません。ですから、([0|0x])\d*\s\1\d* というパターンは、
0x1234 0x4321" にマッチしますが、"0x1234 01234" にはマッチしません。た
とえ [0|0x] という規則が 2 番目の数字の前の 0 にマッチすることができる
としても、サブパターン 1 は、"0x" にマッチしたものだからです。




File: perl-ja.info, Node: 実行とオプション, Next: 組み込み関数, Prev: 正規表現, Up: Top

実行とオプション
****************

実行にあたって、Perl は指定されたスクリプトを以下に示す場所で探します:

  1. コマンドライン上で `-e' スイッチで指定された行。

  2. コマンドライン上で最初のファイル名として示されたファイルの中。(#!
     記法をサポートしているシステムでは、このようにしてインタプリタを呼
     び出します。)

  3. 標準入力から非明示に渡される。ファイル名を示す引数が無い場合にのみ
     うまくいきます。STDIN からのスクリプトに引数を渡すには、スクリプト
     名として明示的に "-" を指定しなくてはなりません、

2 番目、3 番目の方法では、`-x' スイッチを指定した場合を除いて、Perl
は入力ファイルを最初から解析し始めます。`-x' スイッチを指定した場合
には、まず、最初に #! と "perl" という文字列を含む行を探し、そこから解析
を始めます。これは、大きなテキストにスクリプトを埋め込んで、実行するよう
なときに便利です。(この場合、スクリプトの終わりは、トークン
`__END__' を使って示すとよいでしょう。)

Perl 5 からは、#! を含む行のスイッチが必ず解析されるようになりました。
つまり、#! の行で引数が一つしか許されない、あるいはもっと悪く、#! の行
が認識されないといったシステムで運用している場合にも、`-x' でスクリプト
の開始位置を見つけた場合を含め、どのように Perl が起動されたかによらず、
一貫したスイッチの動作を期待できるようになっています。

多くの OS で、カーネルによる #! 行の解釈が、エラーなしに 32文字で打ち切
られてしまいますので、あるスイッチはコマンドラインに渡され、あるスイッチ
は渡されないといったことが起こります。注意しないと、文字が続かない "-"
だけが渡されるといったことも起こり得ます。すべてのスイッチが、32 文字境
界の前か後ろかを確かめたいことでしょう。多くのスイッチは、余分に処理され
ても問題ありませんが、完全なスイッチの代わりに - が入っていた場合には、
スクリプトの代わりに、標準入力を Perl に実行させることになってしまいます。
`-I' スイッチが中途半端になった場合にもおかしな結果となり得ます。

#! スイッチの解析は、行内で "perl" が示された位置から始まります。とりわ
け "-*" と "- " という文字の並びは無視されますので、

     #!/bin/sh -- # -*- perl -*- -p
     eval 'exec perl $0 -S ${1+"$@"}'
         if 0;

のように書けば、Perl に `-p' スイッチを渡すことができます。

#! 行に "perl" という語が含まれていなければ、#! の後に指定されたプログ
ラムが Perl インタプリタの代わりに実行されます。これは少し変わっていま
すが、#! が行なえないマシンを使っている方には有効でしょう。プログラムに
対して使っている SHELL が /usr/bin/perl だと言っておけば、Perl が正しい
インタプリタを起動してくれるからです。

スクリプトの場所が特定できたなら、Perl はスクリプト全体を内部形式にコン
パイルし始めます。コンパイルエラーが見つかった時には、スクリプトの実行
は行なわれません。(これは、構文エラーがある場合にも、途中まで実行される
可能性のある、典型的なシェルのスクリプトと異なる点です。)

スクリプトが構文的に正しければ、実行されることになります。スクリプトが、
exit() 演算子にも die() 演算子にも当たらないで最後まで到達すると、正常
に完了したことを示すために、暗黙の exit(0) が行なわれます。

1 文字のスイッチは、次に続くスイッチがあれば、それとつなげることができ
ます。

     #!/usr/bin/perl -spi.bak    # -s -p -i.bak と同じ

* Menu:

* スイッチ一覧::




File: perl-ja.info, Node: スイッチ一覧, Prev: 実行とオプション, Up: 実行とオプション

スイッチ一覧
============

-0digits
     レコードセパレータ ($/) を 8 進数で示します。digitsを指定しないと、
     ヌル文字がセパレータになります。他のスイッチを前に置いてもかまいま
     せんし、digits のあとにつなげてもかまいません。たとえば、ファイル
     名をヌル文字で区切って表示できる find があれば:

          find . -name '*.bak' -print0 | perl -n0e unlink

     のようにできます。

     00 という特別な値は、Perl にパラグラフモードで、ファイルを読ませま
     す。0777 という値は、該当する文字がないため、Perl にファイル全体を
     読ませることになります。

-a
     `-n' や `-p' といっしょに用いると、自動 split モードになります。
     `-n' や `-p' で作られる暗黙のループ内の最初の文として、配列
      @F への暗黙の split コマンドが実行されます。

          perl -ane 'print pop(@F), "\n";'

     は、

          while (<>) {
              @F = split(' ');
              print pop(@F), "\n";
          }

     と等価です。`-F' を使って区切文字を変更することができます。

-c
     Perl にスクリプトの構文のチェックを行なわせ、実行せずに抜けるよう
     にします。

-d
     Perl デバッガの下でスクリプトを実行します。*Note デバッグ::,を参照
     してください。

-Dnumber
-Dlist
     デバッグフラグを設定します。スクリプトがどのように実行されるかを見るには、
     `-D14' を使ってください。(これは、`-DDEBUGGING' を指定して
     Perl にデバッグ機能を盛り込んでコンパイルしたときにだけ働きます。)この他
     に役に立つ値としては、コンパイルされた構文トリーを表示する、
     `-D1024' があげられます。`-D512' は、コンパイルした正規表現を
     表示します。数字の代わりに文字のリストを指定することもできます (たとえば、
     `-D14' は `-Dtls' と等価です):

              1  p  トークン化と構文解析
              2  s  スタックの表示
              4  l  ラベルスタックの処理
              8  t  実行のトレース
             16  o  演算子ノードの構造
             32  c  文字列/数値変換
             64  P  -P のためのプリプロセッサコマンドの表示
            128  m  メモリ配置
            256  f  フォーマットの処理
            512  r  正規表現の解析
           1024  x  構文トリーのダンプ
           2048  u  汚染チェック
           4096  L  メモリリーク (既にサポートされていない)
           8192  H  ハッシュのダンプ -- values() の横取り
          16384  X  スクラッチパッドの配置
          32768  D  全消去

-e commandline
     1 行のスクリプトを指定するのに使用します。`-e' が指定されると
     Perl は引数のリストからはスクリプトのファイル名を探しません。複数
     の `-e' コマンドで、複数行のスクリプトを構成することができます。通
     常のプログラムでセミコロンを置くところには、セミコロンを使うことに
     気を付けてください。

-Fregexp
     `-a' が有効なときに、split を行なう正規表現を指定します。正規表現
     の前後に // があっても、そのスラッシュは無視されます。

-iextension
     <> の構文で処理されたファイルを置き換えるための拡張子を指定します。
     これは、入力ファイルをリネームし、元の名前で出力ファイルを open し、
     print() 文のデフォルトとしてその出力ファイルを select することで行
     ないます。extension が指定されると、昔の内容のバックアップを行なう
     ファイル名の拡張子として、元のファイル名に付け加えられます。
     extension が指定されないと、バックアップを作りません。シェルからは

          $ perl -p -i.bak -e "s/foo/bar/; ... "

     とすれば、

          #!/usr/bin/perl -pi.bak
          s/foo/bar/;

     とスクリプトで書くのと同じで、これは、

          #!/usr/bin/perl
          while (<>) {
              if ($ARGV ne $oldargv) {
                  rename($ARGV, $ARGV . '.bak');
                  open(ARGVOUT, ">$ARGV");
                  select(ARGVOUT);
                  $oldargv = $ARGV;
              }
              s/foo/bar/;
          }
          continue {
              print;  # 元のファイル名に出力する
          }
          select(STDOUT);

     と書くのと、`-i' の形式が、いつファイル名が変わったかを知るために、
     $ARGV と $oldargv を比較する必要がないのを除いて、同値です。しかし
     ながら、選択するファイルハンドルとして ARGVOUT は使用します。ルー
     プのあとは、STDOUTがデフォルトのファイルハンドルとして再設定されま
     す。

     個々のファイルの終わりに何かを付け加えたいときや、行番号をリセット
     したいような場合に、個々の入力ファイルの終わりを知るために、括弧の
     無い eof を使うことができます。

     (*Note 組み込み関数::,の eof の項の例を参照してください。)

-Idirectory
     `-P' といっしょに使って、C プリプロセッサにインクルードファイルを
     探す場所を示します。デフォルトでは、/usr/include と /usr/lib/perl
     が検索されます。

-loctnum
     自動の行末処理を行なうようにします。これには、2 つの機能があります。
     1 つには、`-n' や `-p' を使ったときに、自動的に行末文字を chomp し
     ます。2 つめに octnum を"$\" に代入し、print 文で行末文字を追加で
     きるようにします。octnum を指定しなかった場合には、その時点の
     $/" の値を "$\" に設定します。たとえば、行を 80 カラムに切り詰める
     には:

          perl -lpe 'substr($_, 80) = ""'

     とします。

     $\ = $/ という代入は、`-l' スイッチが処理されるときに実行されると
     きに行なわれますので、`-l' スイッチの後に `-0' スイッチを置くよう
     にすれば、入力レコードセパレータを、出力レコードセパレータと違うよ
     うにもできます:

          gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

     これはまず、$\ に改行 ($/ のデフォルト値) を設定し、それから $/ に
     ヌル文字を設定します。

-n
     以下のようなループが、実際のスクリプトの回りにあるかのように Perl
     に指示します。sed -n や awk のようにファイル名引数上で繰り返しを行
     なうことになります:

          while (<>) {
              ...             # ここでスクリプトが実行される
          }

     デフォルトでは、各行が印字されることはありません。各行の印字を行な
     うには `-p' を参照してください。以下にあげるのは、1 週間以上たった
     ファイルを効率的に削除するものです:

          find . -mtime +7 -print | perl -nle 'unlink;'

     これは、ファイル名が見つかるごとにプロセスを起動しなくて済みますの
     で、find の -exec スイッチを使うよりも速くなります。

     awk と同じように、暗黙に実行されるループの前後に実行されるコードを
     指定するために、BEGIN ブロックと END ブロックを使うことができます。

-p
     以下のようなループが、実際のスクリプトの回りにあるかのように Perl
     に指示します。sed のようにファイル名引数上で繰り返しを行なうことに
     なります:

          while (<>) {
              ...             # ここでスクリプトが実行される
          } continue {
              print;
          }

     各行は、自動的に印字されることになります。印字を抑制するには、
     `-n' スイッチを使ってください。`-p' は `-n' スイッチを無効にします。

     awk と同じように、暗黙に実行されるループの前後に実行されるコードを
     指定するために、BEGIN ブロックと END ブロックを使うことができます。

-P
     Perl によるコンパイルを行なう前に、スクリプトを C プリプロセッサに
     かけるようにします。(コメントも CPP のディレクティブも # で始まり
     ますから、コメントの最初を Cプリプロセッサが認識してしまう "if",
     else", "define"といった単語で始めるべきではありません。)

-s
     コマンドライン上のスクリプト名の後から、ファイル名引数(または --)
     の前までのスイッチのための、原始的な解析を行なえるようにします。こ
     こで見つかったスイッチは、@ARGV から取り除かれ、対応する Perl スク
     リプトの変数に設定されます。以下のスクリプトは、`-xyz' というスイッ
     チを付けて実行された時にだけ、"ture" と表示するものです。

          #!/usr/bin/perl -s
          if ($xyz) { print "true\n"; }

-S
     Perl がスクリプトを探すときに環境変数 PATH を参照するようにします
     (スクリプト名がスラッシュで始めるときを除きます)。これは、#! をサ
     ポートしていないマシンで、#! による実行をエミュレートするために、
     以下のようにして使います:

          #!/usr/bin/perl
          eval "exec /usr/bin/perl -S $0 $*"
                  if $running_under_some_shell;

     システムは、最初の行を無視し、スクリプトを /bin/sh に渡し、
     /bin/sh は Perl スクリプトをシェルスクリプトとして実行しようとしま
     す。シェルは 2 行目を通常のシェルコマンドとして実行し、Perl インタ
     プリタを起動することになります。$0 にフルパス名が入っているとは限
     らないシステムもありますので、`-S' が Perl に必要に応じてスクリプ
     トを探すように指示します。Perl がスクリプトを見つけると、これらの
     行の解析を始めますが、$running_under_some_shell が真になることがな
     いため、無視することになります。$* を使うよりもファイル名内に埋め
     込まれたスペースなどを扱うことのできる ${1+"$@"} の方がよいのです
     が、スクリプトがcsh で解釈される場合には、うまくいきません。csh で
     はなく、sh を起動するように、いくつかのシステムでは、#!  の行を
     Perl も無視することになっている、コロンだけの行で置き換える必要が
     あるかもしれません。そういった制御が効かないシステムでは、csh でも
     sh でも Perl でも使える、回りくどい方法を使うことが必要です:

          eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
          & eval 'exec /usr/bin/perl -S $0 $argv:q'
                  if 0;

-T
     「汚染」チェックをオンにします。通常、このチェックはsetuid や
     setgid のスクリプトを実行するときにだけ、行なわれます。*Note セキュ
     リティ::,を参照してください。

-u
     スクリプトのコンパイル後、コアダンプを行なうようにします。このコア
     ダンプを持ってきて、(Perl の配布では提供されていませんが) undump
     プログラムを使って、実行ファイルに変換することができます。これは多
     少ディスク容量を食いますが (実行ファイルを sprit することで少しは
     減ります)、実行開始を速くすることができます。(減らしても、"hello
     world" の実行ファイルは、私のマシンで 200K 程になります。)ダンプす
     る前に部分的にスクリプトを実行しておきたい場合には、このスイッチの
     代わりに dump() 演算子を使ってください。undump が実行できるのは特
     定の環境下ですし、これが使えない移植バージョンの Perl もあるでしょ
     う。

-U
     Perl に安全でない演算を許可します。現在のところ、「安全でない」演
     算には、スーパーユーザとして実行中にディレクトリを削除することと、
     致命的な汚染チェックを警告に替えて、setuid プログラムを実行するこ
     とが含まれます。

-v
     Perl 実行ファイルのバージョンとパッチレベルを表示します。

-w
     1 度しか使われない識別子、設定される前に使われている変数に警告を出します。
     サブルーティンの再定義、未定義のファイルハンドルの参照や、read-only でオー
     プンしたファイルハンドルへの書き込みにも警告を出します。また、数値に見え
     ない値を数値として使った場合、配列をスカラであるかのように使った場合、
     100 段階以上のサブルーティンの再帰、その他たくさんの事に警告を出します。
     *Note デバッグ::,と*Note 不注意によるわな::,を参照してください。

-x directory
     テキスト中にスクリプトが埋め込まれている事を Perl につたえます。最
     初の #! で始まり、"perl" という文字列を含む行までの、先行するゴミ
     は捨てられます。その行にある意味を持つスイッチは、(通常の #! 処理
     と同じく 1 つのまとまりだけですが) 適用されます。directory が指定
     されると、Perl はスクリプトの実行前に、そのディレクトリに移ります。
     `-x' スイッチは先行するゴミの処分を制御するだけです。スクリプトの
     後に無視すべきゴミがある場合には、__ END__ でスクリプトを終了する
     必要があります (その、後に続くゴミの一部または全部は、必要に応じて
     DATA ファイルハンドルを通して、そのスクリプトで処理する事ができま
     す)。




File: perl-ja.info, Node: 組み込み関数, Next: 定義済み変数, Prev: 実行とオプション, Up: Top

組み込み関数
************

この節の関数は、式の中で項として使うことができます。これらは、大きく 2
つに分けられます: リスト演算子と名前付き単項演算子です。これらの違いは、
その後に出て来るコンマとの優先順位の関係にあります。( *Note 演算子と優
先順位::,の優先順位の表を参照してください。)リスト演算子は 2 個以上の引
数をとるのに対して、単項演算子が複数の引数をとることはありません。つま
り、コンマは単項演算子の引数の終わりとなりますが、リスト演算子の場合に
は、引数の区切りでしかありません。単項演算子は一般に、引数に対してスカ
ラコンテキストを与えるのに対して、スカラ演算子の場合には、引数に対して
スカラコンテキストを与える場合も、リストコンテキストを与える場合もあり
ます。1 つのリスト演算子が両方のコンテキストを与える場合には、スカラ引
数がいくつか並び、最後にリスト引数が 1 つ続きます。(リスト引数は 1 つだ
けです。)たとえば、splice() は 3 つのスカラ引数に 1 つのリスト引数が続
きます。

後に載せる構文記述では、リストをとり (そのリストの要素にリストコンテキ
ストを与える) リスト演算子は、引数として LIST をとるように書いています。
そのようなリストには、任意のスカラ引数の組み合わせやリスト値を含めるこ
とができ、リスト値はリストの中に、個々の要素が展開されたように埋め込ま
れます。1 次元の長いリスト値が形成されることになります。LIST の要素は、
コンマで区切られている必要がありあます。

下のリストの関数はすべて、引数の前後の括弧は省略可能となっています。(構
文記述では省略しています。)括弧を使うときには、単純な (しかし、ときには
驚く結果となる) 規則が適用できます: 関数に見えるならば、それは関数で、
優先順位は関係ない。そう見えなければ、それはリスト演算子か単項演算子で、
優先順位が関係する。また、関数と開き括弧の間の空白は関係ありませんので、
ときに気を付けなければなりません:

     print 1+2+3;        # 6 と出力
     print(1+2) + 3;     # 3 と出力
     print (1+2)+3;      # これも 3!
     print +(1+2)+3;     # 6 と出力
     print ((1+2)+3);    # 6 と出力

Perl に `-w' スイッチを付けて実行すれば、こういったものには警告を出して
くれます。たとえば、上記の 3 つめは:

     print (...) interpreted as function at - line 1.
     Useless use of integer addition in void context at - line 1.

となります。スカラコンテキストでも、リストコンテキストでも使える関数は、
致命的でないエラーを示すために、スカラコンテキストでは未定義値を返し、
リストコンテキストでは空リストを返します。

以下の規則を覚えておいてください:

   * 「リストをスカラに変換するための、一般的な規則はない」

それぞれの演算子や関数について、スカラコンテキストにおいて、どんな値を
返すのが望ましいかを吟味しています。ある種の演算子では、リストコンテキ
ストであったなら、返すはずのリストの長さを返すようにしています。いくつ
の演算子は、リストの最初の値を返します。また、別の演算子は、演算がうま
くいった数を返すようにしています。一般に、一貫性さえ望まなければ、やり
たいことが、できるようになっています。

* Menu:

* 流れ制御::
* サブルーティン、パッケージ、モジュール::
* 数学関数::
* 変換関数::
* 文字列関数::
* 検索・置換関数::
* 配列関数とリスト関数::
* ファイル操作関数::
* 入出力関数::
* ディレクトリ読み出し関数::
* システム操作関数::
* ネットワーク操作関数::
* SystemV IPC 関数::
* その他の関数::







File: perl-ja.info, Node: 流れ制御, Next: サブルーティン、パッケージ、モジュール, Prev: 組み込み関数, Up: 組み込み関数

流れ制御
========


 -- Function: goto LABEL
 -- Function: goto &NAME
     `goto LABEL' の形式は、LABEL というラベルの付いた文を探して、そこ
     へ実行を移すものです。サブルーティンや`foreach' ループなど、何らか
     の初期化が必要な構造の中に入り込むことは許されません。最適化によっ
     てなくなってしまう構造の中にも `goto' することはできません。これ以
     外は、サブルーティンの外を含む、動的スコープ内のほとんどすべての場
     所へ行くために使用できますが、普通は、`last' や `die' といった別の
     構造を使った方が良いでしょう。Perl の作者はこの形式の `goto' を使
     う必要を感じたことは、1 度もありません (Perl では。C は別のお話で
     す)。

     `goto &NAME' の形式は、かなりマジカルなもので、現在実行中のサブルー
     ティンを、NAME で指定されたサブルーティンの呼び出しで置き換えます。
     これは、AUTOLOAD サブルーティンが別のサブルーティンをロードして、
     その別のサブルーティンが最初に呼ばれたようにするために使われます
     (ただし、現在のサブルーティンで @_ を修正した場合には、そのその別
     のサブルーティンに伝えられます)。`goto' のあとは、`caller()' でさ
     えも、現在のサブルーティンが最初に呼び出されたと言うことができませ
     ん。


 -- Function: last LABEL
 -- Function: last
     `last' コマンドは、(ループ内で使った) C の break 文と同じようなも
     ので、LABEL で指定されるループを即座に抜けます。LABEL が省略される
     と、一番内側のループが対象となります。`continue' ブロックがあって
     も実行されません:

          LINE: while (<STDIN>) {
              last LINE if /^$/;      # ヘッダが終わったら抜ける
              ...
          }


 -- Function: next LABEL
 -- Function: next
     `next' コマンドは、C での continue 文のようなもので、ループの次の
     繰り返しを開始します:

          LINE: while (<STDIN>) {
              next LINE if /^#/;      # コメントを捨てる
              ...
          }

     `continue' ブロックが存在すれば、たとえ捨てられる行にあっても、そ
     れが実行されます。LABEL が省略されると、このコマンドは、もっとも内
     側のループを参照します。


 -- Function: redo LABEL
 -- Function: redo
     `redo' は、条件を再評価しないで、ループブロックの始めからもう一度
     実行を開始します。`continue' ブロックがあっても、実行されません。
     LABEL が省略されると、このコマンドは、もっとも内側のループを参照し
     ます。このコマンドは通常、自分への入力を欺くために使用します:

          # 単純な Pascal のコメント除去プログラム
          # (警告: 文字列中には { や } がないと仮定)
          LINE: while (<STDIN>) {
              while (s|({.*}.*){.*}|$1 |) {}
              s|{.*}| |;
              if (s|{.*| |) {
                  $front = $_;
                  while (<STDIN>) {
                      if (/}/) {      # コメントの終わり
                          s|^|$front{|;
                          redo LINE;
                      }
                  }
              }
              print;
          }







File: perl-ja.info, Node: サブルーティン、パッケージ、モジュール, Next: 数学関数, Prev: 流れ制御, Up: 組み込み関数

サブルーティン、パッケージ、モジュール
======================================


 -- Function: bless REF,PACKAGE
 -- Function: bless REF
     この関数は、(REF で渡された) 参照されるオブジェクトに対し、PACKAGE 内の
     オブジェクトとなったことを伝えます。通常は PACKAGE が省略され、その場合
     には、その時点のパッケージとなります。`bless()' は通常、コンストラ
     クタの最後に置かれますので、簡便のためにそのリファレンスを返します。オブ
     ジェクトの `bless' (や再`bless') について、詳しくは
     *Note オブジェクト::,を参照してください。


 -- Function: caller EXPR
 -- Function: caller
     その時点のサブルーティン呼び出しのコンテキストを返します。スカラコ
     ンテキストでは、呼び元がある場合 (サブルーティン、`eval()'、
     `require()' の中にいるとき) には真を返し、その他のときには偽を返し
     ます。リストコンテキストでは、

          ($package,$filename,$line) = caller;

     を返します。

     EXPR を付けると、デバッガがスタックトレースを表示するために使う情
     報を返します。EXPR の値は、現状から数えて、いくつ前のコールフレー
     ムまで戻るかを示します。


 -- Function: do SUBROUTINE(LIST)
     望ましくないサブルーティン呼び出しの形式。
     *Note サブルーティン::,を参照してください。


 -- Function: do BLOCK
     実際は関数ではありません。$var{block} で示されるコマンド列の最後の
     値を返します。ループ修飾子で修飾すると、ループ条件を調べる前に 1
     度、$var{block} を実行します。(これ以外の実行文は、ループ修飾子に
     より、条件が最初に調べられます。)


 -- Function: do EXPR
     EXPR の値をファイル名として用い、そのファイルの中身を Perl のスク
     リプトとして実行します。主に、Perlのサブルーティンライブラリからサ
     ブルーティンをインクルードするために用います。

          do 'stat.pl';

     は、

          eval `cat stat.pl`;

     と同じようなものですが、より効率的で、簡潔であり、エラーメッセージ
     でファイル名がわかる、カレントディレクトリでファイルが見つからなかっ
     たときに、`-I' に指定された全てのディレクトリを探す、といったこと
     があります(*Note 定義済み変数::,の「定義済み名」にある @INC 配列も
     参照してください)。しかし、呼び出すたびにファイルを解析し直すとい
     う点では同じですから、ループ内でこれを使おうなどとは、間違っても思っ
     たりしないように。

     ライブラリモジュールのインクルードには、`use()' 演算子や
     `require()' 演算子を使った方が良いでしょう。


 -- Function: import
     組み込みの `import()' 関数というものはありません。これは単に、別の
     モジュールに名前をエクスポートしたいモジュールが定義した、通常のメ
     ソッドサブルーティンです。`use()' 関数は、使用されるパッケージのた
     めに、`import()' メソッドを呼び出します。このドキュメントの `use'
     の項と*Note モジュール::,を参照してください。


 -- Function: no MODULE LIST
     `use' 関数を参照してください。 `no' は、その逆を行なうものです。


 -- Function: require EXPR
 -- Function: require
     指定する EXPR か、EXPR 省略時には $_ によって、いくつかの意味を使
     い分けます。EXPR が数値のときには、実行中の Perl のバージョン ($]
     か $PERL_VERSION) がEXPR 以上であることが必要となります。

     数値でない場合には、既に読み込まれていないときに、読み込むライブラ
     リファイルを要求するものとなります。そのファイルは、基本的には
     `eval()' の一種である、do-FILE によって読み込まれます。意味的には、
     次のようなサブルーティンと同じようなものです:

          sub require {
              local($filename) = @_;
              return 1 if $INC{$filename};
              local($realfilename,$result);
              ITER: {
                  foreach $prefix (@INC) {
                      $realfilename = "$prefix/$filename";
                      if (-f $realfilename) {
                          $result = do $realfilename;
                          last ITER;
                      }
                  }
                  die "Can't find $filename in \@INC";
              }
              die $@ if $@;
              die "$filename did not return true value" unless $result;
              $INC{$filename} = $realfilename;
              $result;
          }

     ファイルは、同じ名前で 2 回読み込まれることはありません。初期化コー
     ドの実行がうまくいったことを示すために、ファイルは真を返さなければ
     なりませんから、真を返すようになっている自信がある場合を除いては、
     ファイルの最後に "1;" と書くのが習慣です。実行文を追加するような場
     合に備えて、"1;" と書いておいた方が良いでしょう。

     EXPR が裸の単語であるときには、標準モジュールのロードを簡単にする
     ように、`require' は拡張子が `.pm' であると仮定します。この形式の
     モジュールロードは、名前空間を変更してしまう危険はありません。

     より強力な import 機能については、このドキュメントの `use()' の項と、
     *Note モジュール::,を参照してください。


 -- Function: return LIST
     サブルーティンや `eval' から指定した値をもって、リターンします。
     (サブルーティンや `eval' に `return' がなければ、最後に評価された
     値で、自動的にリターンします。)


 -- Function: tie VARIABLE,PACKAGENAME,LIST
     この関数は、変数を、その変数のインプリメンテーションを行なうパッケー
     ジと結び付けます。VARIABLE は、魔法をかける変数の名前です。
     PACKAGENAME は、正しい型のオブジェクトをインプリメントする、パッケー
     ジの名前です。他に引数があれば、そのパッケージの `new' メソッドに
     渡されます。通常、これらは、C の dbm_open()などの関数に渡す引数と
     なります。

     大きな DBM ファイルでは、`keys()' や `values()' のような関数は、
     大きな配列値を返す可能性があります。大きなDBM ファイルでは、
     `each()' 関数を使って繰り返しを行なった方が、よいかもしれません。例:

          # print out history file offsets
          tie(%HIST, NDBM_File, '/usr/lib/news/history', 1, 0);
          while (($key,$val) = each %HIST) {
              print $key, ' = ', unpack('L',$val), "\n";
          }
          untie(%HIST);

     連想配列をインプリメントするパッケージでは、次のようなメソッドを用
     意します:

        TIEHASH objectname, LIST
        DESTROY this
        FETCH this, key
        STORE this, key, value
        DELETE this, key
        EXISTS this, key
        FIRSTKEY this
        NEXTKEY this, lastkey

     通常の配列をインプリメントするパッケージでは、次のようなメソッドを
     用意します:

        TIEARRAY objectname, LIST
        DESTROY this
        FETCH this, key
        STORE this, key, value
        [others TBD]

     スカラ変数をインプリメントするパッケージでは、次のようなメソッドを
     用意します:

        * TIESCALAR objectname, LIST
        * DESTROY this
        * FETCH this,
        * STORE this, value


 -- Function: untie VARIABLE
     変数とパッケージの間の結合を解きます。(`tie()' を参照してください。)


 -- Function: use MODULE LIST
 -- Function: use MODULE
     指定したモジュールから、現在のパッケージにさまざまな内容をインポー
     トします。多くは、パッケージのサブルーティン名や、変数名に別名を付
     けることで、実現されています。これは、

          BEGIN { require Module; import Module LIST; }

     というのと、全く同値です。名前空間を変更したくない場合には、代わりに
     `require' を使ってください。

     BEGIN によって、`require' や `import' は、コンパイル時に実行される
     ことになります。`require' は、モジュールがまだ、メモリーにロードさ
     れていなければ、ロードします。`import' は、組込みの関数ではなく、
     さまざまな機能を現在のパッケージにインポートするように、`Module'
     パッケージに伝えるために呼ばれる、通常の静的メソッドです。モジュー
     ル側では、`import' メソッドをどのようにでもインプリメントすること
     ができますが、多くのモジュールでは、`Exporter' モジュールで定義さ
     れた、`Exporter' クラスからの継承によって、`import' メソッドを行な
     うようにしています。

     これは、広く公開されているインタフェースですので、プラグマ (コンパ
     イラディレクティブ) は、この方法でインプリメントされています。現在
     インプリメントされているプラグマには、以下のものがあります:

          use integer;
          use sigtrap qw(SEGV BUS);
          use strict  qw(subs vars refs);
          use subs    qw(afunc blurfl);

     通常のモジュールが、現在のパッケージにシンボルをインポートする (こ
     れは、ファイルの終わりまで有効です) のに対して、これらの擬似モジュー
     ルは、現在のブロックスコープにインポートを行ないます。

     これに対して、`no' コマンドという、`use' によってインポートされた
     ものを、インポートされていないことにするものがあります。

          no integer;
          no strict 'refs';

     標準モジュールやプラグマの一覧は、*Note モジュール::,を参照してく
     ださい。







File: perl-ja.info, Node: 数学関数, Next: 変換関数, Prev: サブルーティン、パッケージ、モジュール, Up: 組み込み関数

数学関数
========


 -- Function: abs VALUE
     引数の絶対値を返す。


 -- Function: atan2 Y,X
     -πからπの範囲で Y/X の逆正接を返す。


 -- Function: cos EXPR
     (ラジアンで示した) EXPR の余弦を返します。EXPR が省略されたときに
     は、$_ の余弦を取ります。


 -- Function: exp EXPR
     e (自然対数の底) の EXPR 乗を返す。EXPR を省略した場合には、
     `exp($_)' を返す。


 -- Function: int EXPR
     EXPR の整数部を返します。EXPR を省略すると、$_ を使います。


 -- Function: log EXPR
     EXPR の (e を底とする) 対数を返します。EXPR が省略されると、$_ の
     対数を返します。


 -- Function: rand EXPR
 -- Function: rand
     0 から EXPR の値までの小数の乱数値を返します。(EXPR は正の数である
     必要があります。) EXPR を省略すると、0 から 1 までの値を返します。
     この関数は、`srand()' を呼ばなければ、数列を繰り返して生成するかも
     しれません。`srand()' も参照してください。

     (注: もし、rand 関数が、常に大きい値ばかりや、小さい数ばかりを返す
     ようなら、お使いになっている Perl が、良くない RANDBITS を使ってコ
     ンパイルされている可能性があります。取り敢えず、EXPR に適切な範囲
     に収まるように 2 のべき乗をかけることで凌ぐ事ができます。ただし、
     このようにした場合には、移植性に欠けたものになります。できれば、再
     コンパイルした方が、良いでしょう。)


 -- Function: sin EXPR
     (ラジアンで示した) EXPR の正弦を返します。EXPR が省略されたときに
     は、$_ の正弦を取ります。


 -- Function: sqrt EXPR
     EXPR の平方根を返します。EXPR を省略すると、$_ の平方根を返します。


 -- Function: srand EXPR
     `rand' 演算子のためのシード値を設定します。EXPR を省略すると、
     `srand(time)' を実行します。もちろん、現在時間を想像するのは容易い
     ことですから、暗号処理には、もっとランダムな値を使う必要があるがあ
     ります。急激に変化する OS のステータス値プログラムの出力を圧縮して、
     チェックサムをとる、というようなことが普通、行なわれます。例は、定
     期定期に comp.security.unix に投稿されます。


 -- Function: time
     UTC で 1970 年 1 月 1 日 00:00:00 からの連続秒数を返します。
     `gmtime()' や `localtime()' への入力形式にあっています。







File: perl-ja.info, Node: 変換関数, Next: 文字列関数, Prev: 数学関数, Up: 組み込み関数

変換関数
========


 -- Function: chr NUMBER
     特定の文字セットでの NUMBER で表わされる文字を返す。たとえば、
     `chr(65)' は ASCII では "A" となります。


 -- Function: gmtime EXPR
     `time' 関数が返す時刻を、グリニッジタイムゾーンで測った時刻として、
     9 要素の配列に変換します。通常は、

          ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime(time);

     のようにして使用します。

     すべての配列要素は数値で、tm 構造体から直接持ってきます。これは特に、
     $mon が 0..11 の範囲で、$wday が 0..6 の範囲となるということです。
     EXPR が省略されると、gmtime(time()) を行ないます。


 -- Function: hex EXPR
     EXPR を 16 進数の文字列と解釈して、10 進数の値を返します。(0 や
     0x で始まる文字列の解釈には、`oct()' を参照してください。) EXPR が
     省略されると、$_ を使用します。


 -- Function: localtime EXPR
     `time' 関数が返す時刻を、ローカルなタイムゾーンで測った時刻として、
     9 要素の配列に変換します。通常は、

          ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);

     のようにして使用します。

     すべての配列要素は数値で、tm 構造体から直接持ってきます。これは特に、
     $mon が 0..11 の範囲で、$wday が0..6 の範囲となるということです。
     EXPR が省略されると、`localtime(time())' を行ないます。

     スカラコンテキストでは、ctime(3) の値を返します:

          $now_string = localtime;  # 例 "Thu Oct 13 04:54:34 1994"

     *Note モジュール::,の `timelocal' の項や POSIX モジュールによって使用
     できる strftime(3) 関数も参照してください。(訳注: と書いてあるが、
     *Note モジュール::,に `timelocal' はない。)


 -- Function: oct EXPR
     EXPR を 8 進数文字列と解釈して、10 進数の値を返します。(EXPR が
     0x で始まるときには、16 進数文字列と解釈します。)以下の例は、標準
     的な Perl や C の記法での 10 進数、8 進数、16 進数を扱います:

          $val = oct($val) if $val =~ /^0/;

     EXPR を省略すると、$_ を使用します。


 -- Function: ord EXPR
     EXPR の最初の文字の ASCII 値を返します。EXPR を省略した場合には、
     $_ を使用します。


 -- Function: pack TEMPLATE,LIST
     配列か値のリストをとり、バイナリの構造体に入れ、その構造体を含む文
     字列を返します。TEMPLATE は、以下のような値の型と順番を指定する文
     字を並べたものです:

        a   ASCII 文字列、ヌル文字で埋める
        A   ASCII 文字列、スペース文字で埋める
        b   ビット列 (昇ビット順、vec() と同じ)
        B   ビット列 (降ビット順)
        h   16 進数文字列 (低位ニブルが先)
        H   16 進数文字列 (高位ニブルが先)

        c   signed char 値
        C   unsigned char 値
        s   signed short 値
        S   unsigned short 値
        i   signed int 値
        I   unsigned int 値
        l   signed long 値
        L   unsigned long 値

        n   "network" 順序 (ビッグエンディアン) の short
        N   "network" 順序 (ビッグエンディアン) の long
        v   "VAX" 順序 (リトルエンディアン) の short
        V   "VAX" 順序 (リトルエンディアン) の long

        f   機種依存の単精度浮動小数点数
        d   機種依存の倍精度浮動小数点数

        p   ヌル文字で終端する文字列へのポインタ
        P   構造体 (固定長文字列) へのポインタ

        u   uuencode 文字列

        x   ヌル文字
        X   1 文字後退
        @   絶対位置までヌル文字で埋める

     これらの文字の後には、繰り返し数を示す数字を付けることができます。
     a"、"A"、"b"、"B"、"h"、"H" を以外の型を使うとき、`pack' 関数は、
     LIST からその数の値を取り出して使います。くり返し数に * を指定する
     と、その時点で残っているすべての要素を意味します。"a" や"A" という
     型を使うと、値を一つだけ取り出して使いますが、繰り返し数で示す長さ
     の文字列となるように、必要に応じてヌル文字かスペース文字を付け足し
     ます。(unpackするとき、"A" は後続のスペース文字やヌル文字を取り除
     きますが、"a" はそのままにします。)同様に、"b" や"B" は、繰り返し
     数で示すビット長のビット列に `pack' します。(訳注: LIST から要素を
     1 つだけ取り出し、その要素を文字列と見て、各文字の下位 1 ビットづ
     つを取り出して `pack' します。最終的に半端なビットは 0 で埋められ
     ます。) "h" や "H" は、そのニブル長のニブル列に `pack' します。
     P" は、指定した長さの構造体へのポインタを pcide{pack} します。実数
     (float と double) は、機種依存のフォーマットしかありません。いろん
     な浮動小数点数のフォーマットが在り、標準的な "network" 表現といっ
     たものがないため、データ交換のための機能は用意してありません。つま
     り、あるマシンで `pack' した浮動小数点数は、別のマシンでは読めない
     かもしれないということです。たとえ双方で IEEE フォーマットの浮動小
     数点数演算を行なっていてもです (IEEE の仕様では、メモリ表現上のバ
     イト順序までは、規定されていないからです)。Perl では、(訳注: 特に
     指定しない限り) すべての数値演算のために、内部的に double を使用し
     ています。double から float へ変換し、それから再び double に戻すと
     精度が落ちることになります (つまり、`unpack("f", pack("f",
     $foo))' は、一般には $foo と同じではないということです)。

     例:
          $foo = pack("cccc",65,66,67,68);
          # $foo eq "ABCD"
          $foo = pack("c4",65,66,67,68);
          # 同じ

          $foo = pack("ccxxcc",65,66,67,68);
          # $foo eq "AB\0\0CD"

          $foo = pack("s2",1,2);
          # リトルエンディアンでは、"\1\0\2\0"
          # ビッグエンディアンでは、"\0\1\0\2"

          $foo = pack("a4","abcd","x","y","z");
          # "abcd"

          $foo = pack("aaaa","abcd","x","y","z");
          # "axyz"

          $foo = pack("a14","abcdefg");
          # "abcdefg\0\0\0\0\0\0\0"

          $foo = pack("i9pl", gmtime);
          # 実際の struct tm (とにかく私のシステムでは)

          sub bintodec {
              unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
          }

     一般には、`pack' で使用したものと同じテンプレートが、`unpack' 関数
     でも使用できます。


 -- Function: unpack TEMPLATE,EXPR
     `unpack' は `pack' の逆を行ないます: 構造体を表わす文字列をとり、
     リスト値に展開し、その配列値を返します。(スカラコンテキストでは、
     単に最初の値を返します。) TEMPLATE は、`pack' 関数と同じフォーマッ
     トを使います。部分文字列を取り出すうサブルーティンの例を示します:

          sub substr {
              local($what,$where,$howmuch) = @_;
              unpack("x$where a$howmuch", $what);
          }

     そして、

          sub ordinal { unpack("c",$_[0]); } # ord() と同じ

     ということもできます。

     さらに、フィールドの前に %<数値> というものを付けて、項目自身の代
     わりに、その項目の <数値>-ビットのチェックサムを計算させることがで
     きます。デフォルトは、16-ビットチェックサムです。たとえば、

          while (<>) {
              $checksum += unpack("%16C*", $_);
          }
          $checksum %= 65536;

     は、System V の sum プログラムと同じ値を計算します。

     また、

          $setbits = unpack("%32b*", $selectmask);

     は、効率的に、ビットベクターの設定されているビットを数えるものです。


 -- Function: vec EXPR,OFFSET,BITS
     文字列 EXPR を unsigned int のベクターとして扱い、OFFSET と BITS
     で指定されるビットフィールドの値を返します。左辺値として、代入の対
     象にすることもできます。BIT は、1 から 32 までの 2 のべきを値とし
     て使うことができます (1, 2, 4, 8, 16, 32)。

     `vec()' で作られたベクターは、論理演算子 |、&、^ で扱うこともでき
     ます。これらの演算子は、両方の被演算子に文字列を使うと、ビットベク
     ター演算を行ないます。

     ビットベクターを、0 と 1 の文字列や配列に変換するには、

          $bits = unpack("b*", $vector);
          @bits = split(//, unpack("b*", $vector));

     のようにします。ビット長が分かっていれば、* の代わりにその長さを使
     うことができます。







File: perl-ja.info, Node: 文字列関数, Next: 検索・置換関数, Prev: 変換関数, Up: 組み込み関数

文字列関数
==========


 -- Function: chomp VARIABLE
 -- Function: chomp LIST
 -- Function: chomp
     少しばかり安全な `chop' (以下を参照してください) です。$/
     (English モジュールでは、$INPUT_RECORD_SEPARATORとも言う) のその時
     点の値に対応する行末文字を削除します。削除した文字数を返します。入
     力レコードから、改行を削除したいのだけれど、最後のレコードには改行
     が入っているのかわからないような場合に、使用することができます。段
     落モード ($/ = "") では、レコードの最後の改行をすべて取り除きます。
     VARIABLE が省略されると、$_ を対象として `chomp' します。例:

          while (<>) {
              chomp;  # 最後のフィールドの \n を避ける
              @array = split(/:/);
              ...
          }

     左辺値であれば、代入を含めて、任意のものを `chomp' できます:

          chomp($cwd = `pwd`);
          chomp($answer = <STDIN>);

     リストを `chomp' すると、個々の要素が `chomp' され、削除された文字
     数の合計が返されます。


 -- Function: chop VARIABLE
 -- Function: chop LIST
 -- Function: chop
     文字列の最後の文字を切り捨てて、その切り取った文字を返します。主に、
     入力レコード末の改行を削除するために使われますが、文字列の検索もコ
     ピーも行ないませんので s/\n// よりも、ずっと効率的です。VARIABLE
     が省略されると、$_ を対象として `chop' します。例:

          while (<>) {
              chop;   # 最後のフィールドの \n を避ける
              @array = split(/:/);
              ...
          }

     左辺値であれば、代入を含めて、任意のものを `chop' できます:

          chop($cwd = `pwd`);
          chop($answer = <STDIN>);

     リストを `chop' すると、個々の要素が `chop' されます。最後の
     `chop' の値だけが返されます。


 -- Function: crypt PLAINTEXT,SALT
     C ライブラリの crypt(3) 関数と全く同じように、文字列を暗号化します。
     パスワードファイルの中で、あまり良くないものをチェックするために使
     うことができます。公正な人だけが、これを行なうべきです。

     プログラムを実行する人が、自分のパスワードを知っていることを確認す
     る例です:

          $pwd = (getpwuid($<))[1];
          $salt = substr($pwd, 0, 2);

          system "stty -echo";
          print "Password: ";
          chop($word = <STDIN>);
          print "\n";
          system "stty echo";

          if (crypt($word, $salt) ne $pwd) {
              die "Sorry...\n";
          } else {
              print "ok\n";
          }

     もちろん、聞かれれば、誰にでもパスワードを打ってあげるなんてのは、
     もってのほかです。


 -- Function: eval EXPR
 -- Function: eval BLOCK
     EXPR が Perl のプログラムであるかのように、解析し、実行します。そ
     の時点の Perl プログラムの脈絡の中で実行されますので、変数の設定、
     サブルーティンやフォーマットの定義は、その後も残っています。返され
     る値は、サブルーティン同様に、最後に評価した式の値か、return 文の
     値です。

     構文エラーや実行エラーが発生するか、`die()' 文が実行されると、
     `eval()' の値として未定義値が返され、$@ にエラーメッセージが設定さ
     れます。エラーがなければ、$@は、空文字列であることが保証されます。
     EXPR を省略すると、$_ を評価します。最後のセミコロンは、式から省く
     ことができます。

     `eval()' は、致命的エラーとなるようなものをトラップすることができ
     ますから、(`dbmopen()' や `symlink()' といった) 特定の機能がインプ
     リメントされているかを、調べるために使うことができます。die 演算子
     が例外を発生させるものとすれば、これはまた、Perl の例外捕捉機能と
     捉えることもできます。

     実行するコードが変わらないのであれば、毎回多量の再コンパイルするこ
     となしに、実行時エラーのトラップを行なうために、eval-BLOCK 形式を
     使うことができます。エラーがあれば、やはり $@ に返されます。例:

          # 0 除算を致命的でなくす
          eval { $answer = $a / $b; }; warn $@ if $@;

          # 効率的ではないが、同じ
          eval '$answer = $a / $b'; warn $@ if $@;

          # コンパイル時エラー
          eval { $answer = };

          # 実行時エラー
          eval '$answer =';   # $@ を設定

     eval() では、何が調べられるかに、特に注意しておくことが必要です:

          eval $x;            # CASE 1
          eval "$x";          # CASE 2

          eval '$x';          # CASE 3
          eval { $x };        # CASE 4

          eval "\$$x++"       # CASE 5
          $$x++;              # CASE 6

     上記の CASE 1 と CASE 2 の動作は同一で、変数 $x 内のコードを実行し
     ます。(ただし、CASE 2 では、必要のないダブルクォートによって、読む
     人が何が起こるか混乱することでしょう (何も起こりませんが)。)同様に
     CASE 3 と CASE 4 の動作も等しく、何もしない「$x」というコードを実
     行します。(純粋に見た目の問題で、CASE 4 が好まれます。)CASE 5 の場
     合は、通常ダブルクォートを使用します。この状況を除けば、CASE 6 の
     ように、単にシンボリックリファレンスを使えば良いでしょう。


 -- Function: lc EXPR
     EXPR を小文字に変換したものを返します。これは、ダブルクォート文字
     列における、\L エスケープをインプリメントする内部関数です。


 -- Function: lcfirst EXPR
     最初の文字だけを小文字にした、EXPR を返します。これは、ダブルクォー
     ト文字列における、\l エスケープをインプリメントする内部関数です。


 -- Function: length EXPR
     EXPR の値の文字列長を返します。EXPR が省略されたときには、$_ の長
     さを返します。


 -- Function: q/STRING/
 -- Function: qq/STRING/
 -- Function: qx/STRING/
 -- Function: qw/STRING/
     汎用のクォート。*Note 演算子と優先順位::,を参照。


 -- Function: quotemeta EXPR
     EXPR の中のすべての正規表現のメタ文字をバックスラッシュでエスケー
     プしたものを返します。これは、ダブルクォート文字列での \Q エスケー
     プをインプリメントするための内部関数です。


 -- Function: substr EXPR,OFFSET,LEN
 -- Function: substr EXPR,OFFSET
     EXPR から、部分文字列を取り出して返します。最初の文字がオフセット
     0 もしくは、$[ に設定した値となります。OFFSET に負の値を設定すると、
     EXPR の終わりからのオフセットとなります。LEN を省略すると、EXPR の
     最後まですべてが返されます。`substr()' を左辺値として使用すること
     も可能で、その場合には、EXPR が左辺値でなければなりません。LEN よ
     り短いものを代入したときには、EXPR は短くなり、LEN より長いものを
     代入したときには、EXPR はそれに合わせて伸びることになります。EXPR
     の長さを一定に保つためには、`sprintf()' を使って、代入する値の長さ
     を調整することが、必要になるかもしれません。


 -- Function: uc EXPR
     EXPR を大文字に変換したものを返します。これは、ダブルクォート文字
     列における、\U エスケープをインプリメントする内部関数です。


 -- Function: ucfirst EXPR
     最初の文字だけを大文字にした、EXPR を返します。これは、ダブルクォー
     ト文字列における、\u エスケープをインプリメントする内部関数です。







File: perl-ja.info, Node: 検索・置換関数, Next: 配列関数とリスト関数, Prev: 文字列関数, Up: 組み込み関数

検索・置換関数
==============


 -- Function: index STR,SUBSTR,POSITION
 -- Function: index STR,SUBSTR
     STR の中の POSITION の位置以降で、最初に SUBSTR が見つかった位置を
     返します。POSITION が省略された場合には、STR の最初から探し始めま
     す。返却値のベースは、0 もしくは、変数 $[ に設定した値です。
     SURSTR が見つからなかった場合には、ベースよりも 1 小さい値、通常
     は -1 が返されます。


 -- Function: m//
     マッチ演算子。*Note 演算子と優先順位::,を参照してください。


 -- Function: pos SCALAR
     対象の変数に対して、前回の `m//g' が終了した場所のオフセットを返し
     ます。そのオフセットを変えるために、変更することができます。


 -- Function: reset EXPR
 -- Function: reset
     通常、ループの最後に、変数をクリアし、?? 検索を再び動作するように
     リセットするため、`continue' ブロックで使われます。EXPR は、文字を
     並べたもの (範囲を指定するのに、ハイフンが使えます) と解釈されます。
     名前がその文字のいずれかで始まる変数や配列は、最初の状態にリセット
     されます。EXPR を省略すると、1回検索(`?PATTERN?') を再びマッチする
     ようにリセットできます。カレントパッケージの変数もしくは検索だけが
     リセットされます。常に 1 を返します。例:

          reset 'X';          # すべての X 変数をリセット
          reset 'a-z';        # 小文字変数をリセット
          reset;              # ?? 検索だけをリセット

     `reset "A-Z"' とすると、ARGV や ENV といった配列もなくなってしまい
     ますから、止めた方が良いでしょう。パッケージ変数だけがリセットされ
     ます。字句変数は、影響を受けませんが、スコープから外れれば、自動的
     に綺麗になりますので、これからは、こちらを使うようにした方がよいで
     しょう。このドキュメントの `my' の項を参照してください。


 -- Function: rindex STR,SUBSTR,POSITION
 -- Function: rindex STR,SUBSTR
     STR 中で最後に見つかった SUBSTR の位置を返すことを除いて、`index'
     と同じように動作します。POSITION を指定すると、その位置より前の、
     最後の位置を返します。


 -- Function: s///
     置換演算子。*Note クォートとクォートのような演算子::,を参照してく
     ださい。


 -- Function: study SCALAR
 -- Function: study
     次に変更される前に、何回も文字列に対するパターンマッチを行なうアプ
     リケーションで、そのような文字列 SCALAR (省略時には $_) を予め学習
     しておきます。これは、検索のために、どのようなパターンを何回使うか
     によって、また、検索される文字列内の文字頻度の分布によって、時間を
     節約することになるかもしれませんし、逆に浪費することになるかもしれ
     ません。予習をした場合と、しない場合の実行時間を比較して、どちらが
     速いか調べることが、必要でしょう。短い固定文字列 (複雑なパターンの
     固定部分を含みます) をたくさん検索するループで、もっとも効果がある
     でしょう。一つの時点では、一つの `study' だけが有効です。別のスカ
     ラを `study' した場合には、以前に学習した内容は「忘却」されてしま
     います。(この `study' の仕組みは、まず、検索される文字列内のすべて
     の文字のリンクされたリストが作られ、たとえば、すべての 'k' がどこ
     にあるかがわかるようになります。各おのの検索文字列から、C プログラ
     ムや英語のテキストから作られた、頻度の統計情報に基づいて、もっとも
     めずらしい文字が選ばれます。この「めずらしい」文字を含む場所だけが
     調べられるのです。)

     たとえば、特定のパターンを含む行の前にインデクスを付けるエントリを
     入れる例を示します。

          while (<>) {
              study;
              print ".IX foo\n" if /\bfoo\b/;
              print ".IX bar\n" if /\bbar\b/;
              print ".IX blurfl\n" if /\bblurfl\b/;
              ...
              print;
          }

     "f" は "o" よりもめずらしいので、`/\bfoo\b/' を探すとき、$_ で
     f" を含む場所だけが探されます。一般に、病的な場合を除いて、かなり
     の結果が得られます。唯一の問題は、節約できる時間が、最初にリンクリ
     ストを作る時間よりも多いかどうかです、

     実行時まで、探そうとする文字列がわからないときには、ループ全体を文
     字列として組み立てて、`eval' すれば、いつも、ずべてのパターンを再
     コンパイルするという事態は避けられます。ファイル全体を一つのレコー
     ドとして入力するために、$/ を未定義にすれば、かなり速くなり、多く
     の場合 fgrep(1) のような専用のプログラムより速くなります。以下の例
     は、ファイルのリスト (@files) から単語のリスト (@words) を探して、
     マッチするものがあったファイル名を出力します。

          $search = 'while (<>) { study;';
          foreach $word (@words) {
              $search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";
          }
          $search .= "}";
          @ARGV = @files;
          undef $/;
          eval $search;               # ぶっ飛ばす
          $/ = "\n";          # 入力のデリミタをもとに戻す
          foreach $file (sort keys(%seen)) {
              print $file, "\n";
          }


 -- Function: tr///
     変換演算子。*Note 演算子と優先順位::,を参照してください。


 -- Function: y///
     変換演算子。*Note 演算子と優先順位::,の `tr///' の節を参照してくだ
     さい。







File: perl-ja.info, Node: 配列関数とリスト関数, Next: ファイル操作関数, Prev: 検索・置換関数, Up: 組み込み関数

配列関数とリスト関数
====================


 -- Function: delete EXPR
     ハッシュ配列から指定された value を削除します。削除された値か、(何も削除
     されなかった場合には) 未定義値が返されます。`$ENV{}' から削除を行な
     うと、実際に環境変数を変更します。DBM ファイルに `tie' された配列か
     らの削除は、その DBM ファイルからエントリを削除します。(しかし、
     `tie' されたハッシュからの削除が、値を返すとは限りません。)

     以下は、連想配列のすべての value を削除します:

          foreach $key (keys %ARRAY) {
              delete $ARRAY{$key};
          }

     (ただし、`undef()' コマンドを使った方が速いでしょう。)最終的な操作
     がハッシュの key による検索である限りは、$var{expr} には任意の複雑
     な式を置くことができます:

          delete $ref->[$x][$y]{$key};


 -- Function: each ASSOC_ARRAY
     連想配列の次の value に対する、key と value からなる 2 要素の配列
     を返しますので、連想配列上での繰り返しを行なうことができます。エン
     トリは見かけ上、ランダムな順序で返されます。配列をすべて読み込んで
     しまうと、空配列が返されます (これは代入されると、偽 (0) となりま
     す)。そのあと、もう一度 `each()' を呼び出すと、再び繰り返しを始め
     ます。反復子は、配列の要素をすべて読むことによってのみリセットする
     ことができます。繰り返しを行なっている間に、配列に要素を追加しては
     なりません。連想配列ごとに反復子が 1 つあり、プログラム中のすべて
     の `each()' 関数、`keys()' 関数、`values()' 関数で共用されます。以
     下のプログラムは、順番が異なるものの、printenv(1) プログラムのよう
     に環境変数を表示します:

          while (($key,$value) = each %ENV) {
              print "$key=$value\n";
          }

     `keys()' や `values()' も参照してください。


 -- Function: exists EXPR
     指定されたハッシュ key が、ハッシュ配列に存在すれば、たとえ対応す
     る value が未定義でも「真」を返します。

          print "Exists\n" if exists $array{$key};
          print "Defined\n" if defined $array{$key};
          print "True\n" if $array{$key};

     ハッシュ要素は、定義されているときにのみ真となり、存在しているとき
     にのみ定義されますが、逆は必ずしも真ではありません。

     最終的な操作がハッシュの key による検索である限りは、$var{expr} に
     は任意の複雑な式を置くことができます:

          if (exists $ref->[$x][$y]{$key}) { ... }


 -- Function: grep BLOCK LIST
 -- Function: grep EXPR,LIST
     LIST の個々の要素に対して、BLOCK か EXPR を評価し($_ は、ローカル
     に個々の要素が設定されます) 、その要素のうち、評価した式が真となっ
     たものからなるリスト値が返されます。スカラコンテキストでは、式が真
     となった回数を返します。例:

          @foo = grep(!/^#/, @bar);    # コメント行の除去

     は

          @foo = grep {!/^#/} @bar;    # コメント行の除去

     は、同じことをします。

     $_ は、LIST の値へのリファレンスですので、配列の要素を変更するため
     に使うことができます。これは、便利でサポートされていますが、LIST
     が名前の付いた配列でないと、悲惨な結果になります。


 -- Function: join EXPR,LIST
     LIST の個別の文字列を、EXPR の値で区切って1 つの文字列につなげ、そ
     の文字列を返します。例:

          $_ = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

     この*Note 組み込み関数::,の `split' の項も参照してください。


 -- Function: keys ASSOC_ARRAY
     指定した連想配列のすべての key からなる、通常配列を返します。(スカ
     ラコンテキストでは、key の数を返します。)返される key の順序は、見
     た目にばらばらなものですが (連想配列に変更がなければ)、`values()'
     関数や `each()' 関数で返されるものと同じ順序です。環境変数を表示す
     る別の例です:

          @keys = keys %ENV;
          @values = values %ENV;
          while ($#keys >= 0) {
              print pop(@keys), '=', pop(@values), "\n";
          }

     key をソートしてもいいでしょう:

          foreach $key (sort(keys %ENV)) {
              print $key, '=', $ENV{$key}, "\n";
          }


 -- Function: map BLOCK LIST
 -- Function: map EXPR,LIST
     LIST の個々の要素に対して、BLOCK か EXPR を評価し($_ は、ローカル
     に個々の要素が設定されます) 、それぞれの評価結果からなるリスト値が
     返されます。BLOCK やEXPR をリストコンテキストで評価しますので、
     LIST の個々の要素によって作られる、返却値であるリストの要素数は、
     0 個の場合もあれば、複数の場合もあります。

          @chars = map(chr, @nums);

     は、数のリストを対応する文字に変換します。また、

          %hash = map {&key($_), $_} @array;

     は、

          %hash = ();
          foreach $_ (@array) {
              $hash{&key($_)} = $_;
          }

     をちょっと変わった書き方で書いたものです。


 -- Function: pop ARRAY
     配列の最後の値をポップして返し、配列の大きさを 1 だけ小さくします。
     これは、

          $tmp = $ARRAY[$#ARRAY--];

     と同じ効果があります。指定された配列に要素がなければ、未定義値が返
     されます。


 -- Function: push ARRAY,LIST
     ARRAY をスタックとして扱い、LIST 内の値を ARRAY の終わりにプッシュ
     します。ARRAY の大きさは、LIST の長さ分だけ大きくなります。これは、

          for $value (LIST) {
              $ARRAY[++$#ARRAY] = $value;
          }

     とするのと同じ効果がありますが、より効率的です。変更後の配列の要素
     数を返します。


 -- Function: reverse LIST
     リストコンテキストでは、LIST を構成するよ要素を逆順に並べた、リス
     ト値を返します。スカラコンテキストでは、LIST の最初の要素のバイト
     順序を逆順にした文字列を返します。(訳注: 4.036 では、スカラコンテ
     キストで最初の要素ではなく、最後の要素の逆順にします。5.0000 では、
     スカラコンテキストでリストをつなげた文字列を反転しているようです。)


 -- Function: scalar EXPR
     EXPR を強制的にスカラコンテキストで解釈されるようにして、
     EXPR の値を返します。


 -- Function: shift ARRAY
 -- Function: shift
     配列の最初の値を取り出して、その値を返し、配列を一つ短くして、すべ
     ての要素を前へずらします。配列に要素がなければ、未定義値を返します。
     ARRAY を省略すると、メインプログラムでは、@ARGV 配列を `shift' し、
     サブルーティンでは、@_ 配列を `shift' します。(これは、文面上で決
     まります。) `unshift()'、`push()'、`pop()' も参照してください。
     `shift()' と `unshift()' は、`push()' と `pop()' が配列の右端で行
     なうことを、左端で行ないます。


 -- Function: sort SUBNAME LIST
 -- Function: sort BLOCK LIST
 -- Function: sort LIST
     LIST をソートし、ソートされたリスト値を返します。配列内の存在しな
     い値は、なくなります。SUBNAME やBLOCK を省略すると、標準の文字列比
     較の順番でソートが行なわれます。SUBNAME を指定すると、それは、配列
     の要素をどのような順番に並べるかに応じて、負、ゼロ、正の整数を返す
     サブルーティンの名前であると解釈されます。(このようなルーティンに
     は、`<=>' 演算子や `cmp' 演算子が、たいへん便利です。) SUBNAME は、
     スカラ変数でもよく、その場合には、その値が使用するサブルーティンの
     名前と解釈されます。SUBNAME の代わりに、無名のインラインソートルー
     ティンとして、BLOCK を書くことができます。

     効率化のために、このサブルーティンでは、通常の呼び出し処理は行なわ
     れず、以下のような制約があります。このサブルーティンは、再帰サブルー
     ティンであってはなりません。比較のためサブルーティンに渡される 2
     つの要素は、@_ ではなく、$a と $b で渡されます (次の例を参照してく
     ださい)。これらはリファレンスによって渡されるので、$a や $b を変更
     しないでください。

     例:
          # 文字の順でソート
          @articles = sort @files;

          # 同じことを明示的にソートルーティンを指定して
          @articles = sort {$a cmp $b} @files;

          # 同じことを逆順に
          @articles = sort {$b cmp $a} @files;

          # 数値の昇順にソート
          @articles = sort {$a <=> $b} @files;

          # 数値の降順にソート
          @articles = sort {$b <=> $a} @files;

          # サブルーティン名を指定してソート
          sub byage {
              $age{$a} <=> $age{$b};  # 整数を仮定
          }
          @sortedclass = sort byage @class;

          sub backwards { $b cmp $a; }
          @harry = ('dog','cat','x','Cain','Abel');
          @george = ('gone','chased','yz','Punished','Axed');
          print sort @harry;
                  # AbelCaincatdogx と出力
          print sort backwards @harry;
                  # xdogcatCainAbel と出力
          print sort @george, 'to', @harry;
                  # AbelAxedCainPunishedcatchaseddoggonetoxyz と出力


 -- Function: splice ARRAY,OFFSET,LENGTH,LIST
 -- Function: splice ARRAY,OFFSET,LENGTH
 -- Function: splice ARRAY,OFFSET
     ARRAY から OFFSET、LENGTH で指定される要素を取り除き、LIST があれ
     ば、それを代わりに挿入します。配列から取り除かれた要素を返します。
     配列は、必要に応じて、大きくなったり、小さくなったりします。
     LENGTH が省略されると、OFFSET 以降のすべての要素を取り除きます。以
     下は、($[ == 0 と仮定すると) それぞれ、等価です。

          push(@a,$x,$y)      splice(@a,$#a+1,0,$x,$y)
          pop(@a)             splice(@a,-1)
          shift(@a)           splice(@a,0,1)
          unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
          $a[$x] = $y         splice(@a,$x,1,$y);

     次の例では、配列の前に、それぞれの配列の大きさが渡されるものとして
     います:

          sub aeq {   # 2 つのリスト値を比較する
              local(@a) = splice(@_,0,shift);
              local(@b) = splice(@_,0,shift);
              return 0 unless @a == @b;    # 長さは等しいか
              while (@a) {
                  return 0 if pop(@a) ne pop(@b);
              }
              return 1;
          }
          if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }


 -- Function: split /PATTERN/,EXPR,LIMIT
 -- Function: split /PATTERN/,EXPR
 -- Function: split /PATTERN/
 -- Function: split
     文字列を文字列の配列に分割して、それを返します。

     リストコンテキストでない場合には、見つかったフィールドの数を返し、
     配列 @_ に分割結果を設定します。(リストコンテキストでは、パターン
     の区切り文字に ?? を使うことで、強制的に @_ に分割結果を残すことが
     できますが、返却値は配列値のままです。)しかし、暗黙の @_への
     `split' は使わないようにしてください。

     EXPR を省略すると、文字列 $_ を `split' します。もし、PATTERN も省
     略すると、空白 (/[ \t\n]+/) で `split' します。PATTERN にマッチす
     るものは、フィールドを分割するデリミタとして扱われます。(デリミタ
     は、1 文字とは限りません。)負でない LIMIT を指定した場合には、最大
     その数までのフィールドに `split' します (しかし、それより少ないこ
     とはあります)。LIMIT を指定しないと、末尾の空フィールドを捨ててし
     まいます (`pop()' を行なうときには気を付けないといけません)。
     LIMIT が負ならば、LIMIT に任意の大きな数を指定したのと同じことにな
     ります。

     空文字列にマッチするパターン (ヌルパターン // と混同しないでくださ
     い。これは、空文字列にマッチするパターンの一つでしかありません) は、
     どの場所にもマッチし、EXPR の値を1 文字ずつに分割します。たとえば、

          print join(':', split(/ */, 'hi there'));

     は、'h:i:t:h:e:r:e' という出力になります。

     LIMIT を使うと、行を部分的に `split' することができます。

          ($login, $passwd, $remainder) = split(/:/, $_, 3);

     リストへ代入するとき、LIMIT を省略すると、Perl は、無駄な仕事を避
     けるため、そのリストの変数の数より、1つだけ大きい LIMIT が与えられ
     たものとして処理を行ないます。上のリストの場合には、LIMIT はデフォ
     ルトで 4 になります。時間が問題となるアプリケーションでは、必要以
     上のフィールドに分けないようにする必要があります。

     PATTERN に括弧が含まれていると、デリミタ内の部分文字列にマッチする
     ものも、配列要素に含まれるようになります。

          split(/([,-])/, "1-10,20");

     は、リスト値

          (1, '-', 10, ',', 20)

     を生成します。

     `/PATTERN/' は、実行時に変わるパターンを指定する式で置き換えること
     ができます。(実行時のコンパイルを 1 度にするために、`/$variable/o'
     を使ってください。) 特別な場合として、スペース (' ') を指定すると、引数
     なしの `split' のように空白で `split' を行ないますが、先頭の空
     白で、最初に空のフィールドができません。つまり、`split(' ')' は、
     awk のデフォルトの動作をエミュレートするために使うことができ、
     `split(/ /)' は行頭のスペースの数に応じた空フィールドができます。

     例:
          open(passwd, '/etc/passwd');
          while (<passwd>) {
              ($login, $passwd, $uid, $gid,
                       $gcos, $home, $shell) = split(/:/);
              ...
          }

     (上記の $shell には、まだ改行がついたままです。このドキュメントの
     `chop'、`chomp'、`join' の項を参照してください。)


 -- Function: unshift ARRAY,LIST
     `shift' の逆操作を行ないます。見方を変えれば、`push' の逆操作とも
     考えられます。LIST を ARRAY の先頭に入れて、新しくできた配列の要素
     の数を返します。

          unshift(ARGV, '-e') unless $ARGV[0] =~ /^-/;

     LIST は、はらばらにではなく、一度に登録されるので、順番はそのまま
     です。逆順に登録するには、`reverse' を使ってください。


 -- Function: values ASSOC_ARRAY
     指定した連想配列のすべての value からなる通常配列を返します。(スカラコン
     テキストでは、value の数を返します。) 返される value の順序は、見た目に
     ばらばらなものですが、同じ配列に対して、`keys()' 関数や
     `each()' 関数が返すものと同じ順序です。`keys()' と
     `each()' も参照してください。







File: perl-ja.info, Node: ファイル操作関数, Next: 入出力関数, Prev: 配列関数とリスト関数, Up: 組み込み関数

ファイル操作関数
================


 -- Function: -X FILEHANDLE
 -- Function: -X EXPR
 -- Function: -X
     X は以下にあげる文字で、ファイルテストを行なう。この単項演算子は、
     ファイル名かファイルハンドルを唯一の引数として動作し、「あること」
     について真であるか否かを判定した結果を返します。引数が省略されると、
     `-t' では STDIN を調べますが、その他は $_ を調べます。特に記述され
     ていなければ、真として 1 を返し、偽として '' を返し、ファイルが存
     在しなければ、未定義値を返します。みかけは変わっていますが、優先順
     位は名前付き単項演算子と同じで、他の単項演算子と同じく、引数を括弧
     で括ることもできます。演算子には:

        -r  ファイルが実効 uid/gid で読み出し可
        -w  ファイルが実効 uid/gid で書き込み可
        -x  ファイルが実効 uid/gid で実行可
        -o  ファイルが実効 uid の所有物

        -R  ファイルが実 uid/gid で読み出し可
        -W  ファイルが実 uid/gid で書き込み可
        -X  ファイルが実 uid/gid で実行可
        -O  ファイルが実 uid の所有物

        -e  ファイルが存在する
        -z  ファイルの大きさがゼロ
        -s  ファイルの大きさがゼロ以外 (大きさを返す)

        -f  ファイルは通常ファイル
        -d  ファイルはディレクトリ
        -l  ファイルはシンボリックリンク
        -p  ファイルは名前付きパイプ (FIFO)
        -S  ファイルはソケット
        -b  ファイルはブロック特殊ファイル
        -c  ファイルはキャラクタ特殊ファイル
        -t  ファイルハンドルは tty にオープンされている

        -u  ファイルの setuid ビットがセットされている
        -g  ファイルの setgid ビットがセットされている
        -k  ファイルの sticky ビットがセットされている

        -T  ファイルはテキストファイル
        -B  ファイルはバイナリファイル (-T の反対)

        -M  スクリプト実行開始時のファイル修正からの日数
        -A  同様にアクセスがあってからの日数
        -C  同様に inode が変更されてからの日数

     があります。

     ファイルのパーミッション演算子 `-r', `-R', `-w', `-W', `-x', `-X'
     の解釈は、ファイルのモードとユーザの実効／実 uidと実効／実 gid の
     みから判断されます。実際にファイルが読めたり、書けたり、実行できた
     りするためには、別の条件が必要かもしれません。スーパーユーザには、
     `-r', `-R', `-w', `-W' に対して、常に 1 が返り、モード中のいずれか
     の実行許可ビットが立っていれば、`-x', `-X' にも 1 が返ることにも注
     意してください。スーパーユーザが実行するスクリプトでは、ファイルの
     モードを調べるためには、stat() を行なうか、uid を一時的に別のもの
     にする必要があるでしょう。

     例:
          while (<>) {
              chop;
              next unless -f $_;  # 通常ファイル以外はスキップ
              ...
          }

     -s/a/b は、置換演算 (s///) の符号反転ではありません。しかし、-exp($foo)
     は期待どおりに動作します。マイナス記号の後に英字が 1 字続くときに
     のみ、ファイルテストと解釈されます。

     ファイルテスト `-T' と `-B' の動作原理は、次のようになっています。
     ファイルの最初の数ブロックを調べて、変わった制御コードや上位ビット
     がセットされているような、通常のテキストには現れない文字を探します。
     そのような文字が、たくさん (>30%) 見つかるようであれば、そのファイ
     ルは `-B' ファイルであると判断され、それほど見つからなければ、
     `-T' ファイルとなります。最初のブロックにヌル文字が含まれるファイ
     ルも、バイナリファイルとみなされます。`-T' や `-B' をファイルハン
     ドルに対して用いると、最初のブロックを調べる代わりに、標準入出力バッ
     ファを調べます。調べたファイルの中身が何もないときや、ファイルハン
     ドルを調べたときに EOF に達していたときには、`-T' も `-B' も「真」
     を返します。

     どのファイルテスト (あるいは、stat() や lstat()) 演算子にも、下線
     だけから成る特別なファイルハンドルを与えると、前回のファイルテスト
     (や stat) の stat 構造体が使われ、システムコールを省きます。(`-t'
     には使えませんし、lstat() や `-l' は実ファイルではなく、シンボリッ
     クリンクの情報を stat 構造体に残すことを覚えておく必要があります。)
     例:

          print "Can do.\n" if -r $a || -w _ || -x _;

          stat($filename);
          print "Readable\n" if -r _;
          print "Writable\n" if -w _;
          print "Executable\n" if -x _;
          print "Setuid\n" if -u _;
          print "Setgid\n" if -g _;
          print "Sticky\n" if -k _;
          print "Text\n" if -T _;
          print "Binary\n" if -B _;


 -- Function: chmod LIST
     LIST に含まれるファイルの、パーミッションを変更します。LIST の最初
     の要素は、数値表現のモードでなければなりません。変更に成功したファ
     イルの数を返します。

          $cnt = chmod 0755, 'foo', 'bar';
          chmod 0755, @executables;


 -- Function: chown LIST
     LIST に含まれるファイルの所有者 (とグループ) を変更します。LIST の
     最初の 2 つの要素には、「数値表現」の uid と gid をこの順序で与え
     なければなりません。変更に成功したファイルの数が返されます。

          $cnt = chown $uid, $gid, 'foo', 'bar';
          chown $uid, $gid, @filenames;

     passwd ファイルから数値表現でない uid を検索する例を示します:

          print "User: ";
          chop($user = <STDIN>);
          print "Files: "
          chop($pattern = <STDIN>);

          ($login,$pass,$uid,$gid) = getpwnam($user)
              or die "$user not in passwd file";

          @ary = <${pattern}>;        # ファイル名の展開
          chown $uid, $gid, @ary;


 -- Function: link OLDFILE,NEWFILE
     OLDFILE にリンクされた、新しいファイル NEWFILE を作ります。成功時
     には 1 を、失敗時には 0 を返します。


 -- Function: lstat FILEHANDLE
 -- Function: lstat EXPR
     `stat()' 関数と同じことをするが、シンボリックリンクが指しているファ
     イルではなく、シンボリック自体の `stat'をとります。シンボリックリ
     ンクがシステムにインプリメントされていないと、通常の `stat()' が行
     なわれます。


 -- Function: mkdir FILENAME,MODE
     FILENAME で指定したディレクトリを、MODE で指定した許可モード (を
     `umask' で修正したもの) で作成します。成功時には 1 を返し、失敗時
     には 0 を返して $! (errno)を設定します。


 -- Function: readlink EXPR
     シンボリックリンクがインプリメントされていれば、シンボリックリンク
     の値を返します。インプリメントされていないときには、致命的エラーと
     なります。何らかのシステムエラーが検出されると、未定義値を返し、
     $! (errno)を設定します。EXPR を省略すると、$_ を使用します。


 -- Function: rename OLDNAME,NEWNAME
     ファイルの名前を変更します。成功時には 1、失敗時には 0 を返します。
     ファイルシステムにまたがって、パス名を付け替えることはできません。


 -- Function: rmdir FILENAME
     FILENAME で指定したディレクトリが空であれば、そのディレクトリを削
     除します。成功時には 1 を返し、失敗時には 0 を返し、$! (errno) を
     設定します。FILENAME を省略した場合には、$_ を使用します。


 -- Function: stat FILEHANDLE
 -- Function: stat EXPR
     FILEHANDLE を通じてオープンされているファイルか、EXPR で指定される
     ファイルの情報を与える、13 要素の配列を返します。`stat' に失敗した
     場合には、空リストを返します。普通は、

          ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
             $atime,$mtime,$ctime,$blksize,$blocks)
                 = stat($filename);

     のようにして使います。

     下線だけの _ という、特別なファイルハンドルを、`stat' に渡すと、実
     際には `stat' を行なわず、stat 構造体に残っている、前回の
     `stat' やファイルテストの情報が返されます。例:

          if (-x $file && (($d) = stat(_)) && $d < 0) {
              print "$file is executable NFS file\n";
          }

     (これは、NFS のもとでデバイス番号が負になるマシンでのみ動作します。)


 -- Function: symlink OLDFILE,NEWFILE
     NEWFILE として、OLDFILE へのシンボリックリンクを生成します。成功時
     には 1 を返し、失敗時には 0 を返します。シンボリックリンクをサポー
     トしていないシステムでは、実行時に致命的エラーが発生します。これを
     チェックするには、`eval' を使用します:

          $symlink_exists = (eval 'symlink("","");', $@ eq ");


 -- Function: truncate FILEHANDLE,LENGTH
 -- Function: truncate EXPR,LENGTH
     FILEHANDLE 上にオープンされたファイルか、EXPR で名前を表わしたファ
     イルを、指定した長さに切り詰めます。システム上に `truncate' がイン
     プリメントされていなければ、致命的エラーとなります。


 -- Function: unlink LIST
     LIST に含まれるファイルを削除します。削除に成功したファイルの数を
     返します。

          $cnt = unlink 'a', 'b', 'c';
          unlink @goners;
          unlink <*.bak>;

     注: スーパーユーザ権限で、Perl に `-U' を付けて実行した場合でなけ
     れば、`unlink' でディレクトリを削除することはありません。この条件
     にあう場合にも、ディレクトリの削除は、ファイルシステムに多大な損害
     を与える可能性がありますので、特に注意が必要です。`rmdir' を代わり
     に使ってください。


 -- Function: utime LIST
     ファイルのアクセス時刻と修正時刻を変更します。LIST の最初の 2 つの
     要素に、数値で表わしたアクセス時刻と修正時刻を順に指定します。
     LIST の残りの要素が、変更の対象となるファイルです。変更に成功した
     ファイルの数を返します。各ファイルの inode 修正時刻には、その時点
     の時刻が設定されます。`touch' コマンドの例です:

          #!/usr/bin/perl
          $now = time;
          utime $now, $now, @ARGV;







File: perl-ja.info, Node: 入出力関数, Next: ディレクトリ読み出し関数, Prev: ファイル操作関数, Up: 組み込み関数

入出力関数
==========


 -- Function: binmode FILEHANDLE
     バイナリファイルとテキストファイルを区別する OS において、指定ファ
     イルを「バイナリ」で読み書きするように指定します。バイナリモードで
     はないファイルは、入力時に CR LF の連続が LF に置き換えられ、出力
     時に LF が CR LF の列に置き換えられます。`binmode' は、UNIX では何
     の影響もなく、DOS では必須かもしれません。FILEHANDLE が式である場
     合には、その式の値がファイルハンドルの名前として使われます。


 -- Function: close FILEHANDLE
     FILEHANDLE に対応したファイルまたはパイプをクローズし、標準入出力
     が正常にバッファのフラッシュを行なって、ファイル記述子のクローズし
     たときにのみ「真」を返します。クローズしてすぐにまた、同じファイル
     ハンドルに対してオープンを行なう場合には、`open' が自動的に
     `close' を行ないますので、`close FILEHANDLE' する必要はありません。
     (`open()' 参照。)ただし、明示的にクローズを行なったときにのみ入力
     ファイルの行番号 ($.) のリセットが行なわれ、`open()' によって行な
     われる暗黙の `close' では行なわれません。また、後でパイプの出力を
     見たい場合のために、パイプのクローズでは、パイプ上で実行されている
     プロセスの完了を待ちます。明示的なパイプのクローズはまた、コマンド
     のステータス値を $? に設定します。例:

          open(OUTPUT, '|sort >foo'); # sort へのパイプ
          ...                         # 出力
          close OUTPUT;               # sort の完了を待つ
          open(INPUT, 'foo');         # 結果を入力

     FILEHANDLE は、実際のファイルハンドル名を値とする式でもかまいません。


 -- Function: dbmclose ASSOC_ARRAY
     [この関数は、`untie()' 関数にとって代わられました。]

     DBM ファイルと連想配列の連結をはずします。


 -- Function: dbmopen ASSOC,DBNAME,MODE
     [この関数は、tie() 関数にとって代わられました。]

     dbm(3) ファイルまたは ndbm(3) ファイルを連想配列に結び付けます。
     ASSOC は、その連想配列の名前です。(普通の `open' とは違って、
     最初の引数はファイルハンドルではありません。まあ、似たようなものですが。)
     DBNAME は、データベースの名前です (拡張子の .dir や .pag はつけま
     せん)。データベースが存在しなければ、MODE (を `umask()' で修
     正したもの) で指定されたモードで作られます。古い DBM 関数のみをサポート
     しているシステムでは、プログラム中で 1 度だけ `dbmopen()' を実行す
     ることができます。DBM も ndbm も持っていないシステムでは、
     `dbmopen()' を呼び出すと致命的エラーになります。

     DBM ファイルに対して、書き込み権が無いときには、連想配列を読みだす
     ことだけができ、設定することはできません。書けるか否かを調べたい場
     合には、ファイルテスト演算子を使うか、エラーをトラップしてくれる、
     `eval()' の中で、ダミーのエントリを設定してみることになります。

     大きな DBM ファイルを扱うときには、`keys()' や `values()' のような
     関数は、巨大は配列を返します。大きな DBM ファイルでは、`each()' 関
     数を使って繰り返しを行なった方が良いかもしれません。例:

          # history ファイルのオフセットを印字
          dbmopen(%HIST,'/usr/lib/news/history',0666);
          while (($key,$val) = each %HIST) {
              print $key, ' = ', unpack('L',$val), "\n";
          }
          dbmclose(%HIST);


 -- Function: eof FILEHANDLE
 -- Function: eof
     次に FILEHANDLE 上で読み込みを行なったときに、 EOF が返されるとき
     か、FILEHANDLE がオープンされていないと、1 を返します。
     FILEHANDLE は、値が実際のファイルハンドル名を示す式であってもかま
     いません。(この関数は、実際に文字を読み、`ungetc()' を行ないますの
     で、対話型の場合には、それ程有用ではありません。)引数を省略した
     `eof' は、最後に読み込みを行なったファイルの EOF 状態を返します。空
     の括弧 () は、コマンドラインのファイルリストで構成される、擬似ファイルを
     示すために用いられます。つまり `eof()' は、`while (<>)' ループ
     の中で、最終ファイルの最後を検出するために使えます。`while (<>)' ルー
     プの個々のファイルを調べるには、`eof(ARGV)' か、括弧なしの
     `eof' を用います。例:

          # 最後のファイルの最終行の前にダッシュを入れる
          while (<>) {
              if (eof()) {
                  print "--------------\n";
              }
              print;
          }

          # ファイルごとに行番号をリセットする
          while (<>) {
              print "$.\t$_";
              if (eof) {      # eof() ではない
                  close(ARGV);
              }
          }

     現実的なヒント: Perl で `eof' が必要となることは、ほとんどありませ
     ん。データがなくなったときに、入力演算子が未定義値を返してくれるか
     らです。


 -- Function: fcntl FILEHANDLE,FUNCTION,SCALAR
     fcntl(2) 関数をインプリメントします。正しい関数定義を得るために、
     まず、

          use Fcntl;

     と書くことが必要でしょう。引数の処理と返却値については、下記の
     ioctl() と同様に動作します。fcntl(2)がインプリメントされていないマ
     シンでは、fcntl() は致命的エラーを引き起こします。使用例:

          use Fcntl;
          fcntl($filehandle, F_GETLK, $packed_return_buffer);


 -- Function: fileno FILEHANDLE
     ファイルハンドルに対するファイル記述子を返します。`select()' に対
     する、ビットマップを構成するときに便利です。FILEHANDLE が式であれ
     ば、その値がファイルハンドルの名前として使われます。


 -- Function: flock FILEHANDLE,OPERATION
     FILEHANDLE に対して flock(2) を呼び出します。OPERATION の記述につ
     いては、flock(2) manpage を参照してください。成功時には真を、失敗
     時には偽を返します。flock(2) がインプリメントされていないマシンで
     の実行は、致命的エラーとなります。BSD システムでのメールボックスへ
     の追加処理の例を示します。

          $LOCK_SH = 1;
          $LOCK_EX = 2;
          $LOCK_NB = 4;
          $LOCK_UN = 8;

          sub lock {
              flock(MBOX,$LOCK_EX);
              # さらに、待っている間に書き足した
              # 人がいるといけないので ...
              seek(MBOX, 0, 2);
          }

          sub unlock {
              flock(MBOX,$LOCK_UN);
          }

          open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
                  or die "Can't open mailbox: $!";

          lock();
          print MBOX $msg,"\n\n";
          unlock();

     `flock()' ではネットワークをまたがって、ロックは行なえません。この
     ためには、`fcntl()' を使ってロックしなくてはなりません。


 -- Function: formline PICTURE, LIST
     これは、`format' が使用する内部関数ですが、直接呼び出すこともでき
     ます。これは、PICTURE の内容にしたがって、LIST の値を整形し
     (*Note フォーマット文::,を参照してください)、結果をフォーマット出
     力アキュムレータ $^A に納めます。最終的に、WRITE() がなされると、
     $^A の中身が、何らかのファイルハンドルに書き出されますが、自分で
     $^A を読んで、$^A の内容を "" に戻してもかまいません。`format' は
     通常、1 行ごとに `formline()' を行ないますが、`formline()' 関数自
     身は、PICTURE の中にいくつの改行が入っているかは、関係がありません。
     ダブルクォートで PICTURE を囲む場合には、"@" という文字が配列名の
     始まりと解釈されますので、注意してください。

     `formline()' は常に「真」を返します。


 -- Function: getc FILEHANDLE
 -- Function: getc
     FILEHANDLE につながれている入力ファイルから、次の一文字を返します。
     EOF では、空文字列を返します。FILEHANDLE が省略された場合には、
     STDIN から読み込みを行ないます。


 -- Function: ioctl FILEHANDLE,FUNCTION,SCALAR
     ioctl(2) 関数をインプリメントします。正しい関数の定義を得るために、
     おそらく最初に

          require "ioctl.ph"; # たぶん /usr/local/lib/perl/ioctl.ph

     としなくてはならないでしょう。ioctl.h がないか、間違った定義をして
     いる場合には、<sys/ioctl.ph> のような C のヘッダファイルをもとに、
     自分で作らなければなりません。(これを手助けしてくれる、h2ph という
     Perl スクリプトが Perl の配布キットに入っています。) FUNCTION に応
     じて SCALAR が読み書きされます。SCALAR の文字列値へのポインタが、
     実際の ioctl コールの 3 番目の引数として渡されます。(SCALAR が文字
     列値を持っておらず、数値を持っている場合には、文字列値へのポインタ
     の代わりに、その値が渡されます。このことを保証するためには、使用す
     る前に SCALAR に 0 を足してください。) `ioctl()' で使われる構造体
     の値を操作するには、`pack()' 関数と `unpack()' 関数が便利です。以
     下の例は、1 文字削除の文字として DEL を指定します。

          require 'ioctl.ph';
          $sgttyb_t = "ccccs";   # 4 つの char と 1 つの short
          if (ioctl(STDIN,$TIOCGETP,$sgttyb)) {
              @ary = unpack($sgttyb_t,$sgttyb);
              $ary[2] = 127;
              $sgttyb = pack($sgttyb_t,@ary);
              ioctl(STDIN,$TIOCSETP,$sgttyb)
                  || die "Can't ioctl: $!";
          }

     ioctl (と fcntl) の返却値は、

            OS からの返却値  |  Perl の返却値
          -------------------+-----------------------------
                  -1         |  未定義値
                   0         |  "0 but true" という文字列
                その他       |  OS からの返却値

     のようになっています。

     つまり Perl は、成功時に「真」、失敗時に「偽」を返すことになり、
     OS が実際に返した値も、

          ($retval = ioctl(...)) || ($retval = -1);
          printf "System returned %d\n", $retval;

     のように簡単に知ることができます。


 -- Function: open FILEHANDLE,EXPR
 -- Function: open FILEHANDLE
     EXPR でファイル名を指定するファイルをオープンして、FILEHANDLE に対
     応させます。FILEHANDLE が式のときには、その値が実際に使用するファ
     イルハンドルの名前として使われます。EXPR を省略すると、FILEHANDLE
     と同じ名前のスカラ変数に、ファイル名が入れられているものとして処理
     されます。ファイル名の先頭に "<" を付けるか、何も付けなかった場合
     には、入力用としてオープンされることになります。先頭に ">" を付け
     ると、ファイルは出力用にオープンされます。同じように ">>" を付ける
     とアペンド用にオープンされます。(">" や "<" の前に "+" を置くこと
     で、ファイルを読み書き両用にすることもできます。)ファイル名の先頭
     に "|" を付けると、そのファイル名をコマンドとして解釈し、ファイル
     ハンドルへの出力がパイプを通じて、そのコマンドへ入力されます。逆に
     ファイル名の最後に "|" を付けた場合には、同様にファイル名をコマン
     ドと解釈し、そのコマンドの出力がパイプを通じて、ファイルハンドルか
     ら入力として読み込むことができるようになります。(入出力両用にパイ
     プするコマンドは使えません。訳注: ただし、Perl モジュール
     `IPC::Open2' や `IPC::Open3' が使えます。) "-"を `open' すると
     STDIN がオープンされ、">-" を `open' すると STDOUT がオープンされ
     ます。`open' は、成功時には、ゼロ以外を返し、失敗時には未定義値を
     返します。パイプに関る `open' のときには、返却値はサブプロセスの
     pid となります。例:

          $ARTICLE = 100;
          open ARTICLE or die "Can't find article $ARTICLE: $!\n";
          while (<ARTICLE>) {...

          open(LOG, '>>/usr/spool/news/twitlog'); # (log は予約語)

          open(article, "caesar <$article |");    # 記事の復号

          open(extract, "|sort >/tmp/Tmp$$");     # $$ は現 pid

          # include を使っているファイルのリストを処理する

          foreach $file (@ARGV) {
              process($file, 'fh00');
          }

          sub process {
              local($filename, $input) = @_;
              $input++;               # マジカルインクリメント
              unless (open($input, $filename)) {
                  print STDERR "Can't open $filename: $!\n";
                  return;
              }
              while (<$input>) {        # 間接ファイルハンドル
                  if (/^#include "(.*)"/) {
                      process($1, $input);
                      next;
                  }
                  ...         # 好きな処理
              }
          }

     Bourne シェルの慣例にしたがって、EXPR の先頭に ">&"を付けると、
     EXPR の残りの文字列をファイルハンドル名(数字であれば、ファイル記述
     子) と解釈して、それを dupしてオープンします。"&" は、">"、">>"、
     <"、"+>"、"+>>"、"+<" というモード指定に付けることができます。指定
     するモード指定は、もとのファイルハンドルのモードと合っていないとい
     けません。STDOUT と STDERR をいったん保存し、リダイレクトし、元に
     戻すスクリプトを示します。

          #!/usr/bin/perl
          open(SAVEOUT, ">&STDOUT");
          open(SAVEERR, ">&STDERR");

          open(STDOUT, ">foo.out") || die "Can't redirect stdout";
          open(STDERR, ">&STDOUT") || die "Can't dup stdout";

          select(STDERR); $| = 1;     # バッファリングしない
          select(STDOUT); $| = 1;     # バッファリングしない

          print STDOUT "stdout 1\n";  # これはサブプロセス
          print STDERR "stderr 1\n";  # でも働きます

          close(STDOUT);
          close(STDERR);

          open(STDOUT, ">&SAVEOUT");
          open(STDERR, ">&SAVEERR");

          print STDOUT "stdout 2\n";
          print STDERR "stderr 2\n";

     N を数値として、"<&=N" と指定すると、Perl は、そのファイル記述子に
     対する C の fdopen() と同じことを行ないます。たとえば:

          open(FILEHANDLE, "<&=$fd")

     "-|" や "|-" というふうに、"-" というコマンドにパイプをオープンす
     ると、`fork' が行なわれ、`open' の返却値として、親プロセスにはチャ
     イルドプロセスの pid が、チャイルドプロセスには 0 が返されます。
     (open が成功したかどうかは、`defined($pid)' のようにして調べること
     ができます。)親プロセスでは、このファイルハンドルは通常通りに動作
     しますが、行なわれる入出力は、チャイルドプロセスの STDIN/STDOUT に
     パイプされます。チャイルドプロセス側では、そのファイルハンドルはオー
     プンされず、入出力は新しい STDOUT か STDIN に対して行なわれます。
     これは、setuid で実行して、シェルコマンドのメタ文字を検索させたく
     ないような場合に、パイプコマンドの起動の仕方を制御したいとき、普通
     のパイプの `open' と同じように使います。以下の組み合わせは、だいた
     い同じものです:

          open(FOO, "|tr '[a-z]' '[A-Z]'");
          open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';

          open(FOO, "cat -n '$file'|");
          open(FOO, "-|") || exec 'cat', '-n', $file;

     パイプのファイルハンドルを明示的に `close' することで、親プロセス
     は、チャイルドプロセスの終了を待ち、$? にステータス値を返します。
     注: `fork' を行なう操作では、フラッシュされていないバッファがある
     と、`fork' 後には、そのバッファの内容が両方のプロセスで残ったまま
     になってしまいますから、出力がダブらないように $| を設定する必要が
     あるかもしれません。

     オープンするために渡されたファイル名は、はじめと終わりの空白が取り
     除かれます。妙な文字が含まれているようなファイル名をオープンするに
     は、次のようにして、最初と最後の空白を保護します:

          $file =~ s#^(\s)#./$1#;
          open(FOO, "< $file\0");


 -- Function: pipe READHANDLE,WRITEHANDLE
     対応するシステムコールと同じように、接続されたパイプのペアをオープ
     ンします。パイプでプロセスをループにするときには、よほど気を付けな
     いと、デッドロックは起こります。さらに、Perl のパイプでは、stdio
     のバッファリングを使いますから、アプリケーションによっては、コマン
     ドごとに WRITEHANDLE をフラッシュするように、$| を設定することが必
     要になるかもしれません。


 -- Function: print FILEHANDLE LIST
 -- Function: print LIST
 -- Function: print
     文字列かコンマで区切った文字列のリストを出力します。成功時には、ゼ
     ロ以外を返します。FAILEHANDLE は、スカラ変数名でもよく、その場合に
     は、その変数にファイルハンドル名が入っているものとして扱われますか
     ら、一段階の間接指定が行なえます。(注: FILEHANDLE に変数を使い、次
     のトークンが「項」のときには、間に + を置くか、引数の前後を括弧で
     括らなければ、誤って解釈されることがあります。) FILEHANDLE を省略
     した場合には、標準出力 (か、最後に選択された出力チャネル --
     `select()' を参照) に出力します。LIST も省略すると、$_ を STDOUT
     に出力することになります。デフォルトの出力チャネルを STDOUT 以外に
     したければ、`select' 演算子を使ってください。`print' の引数は
     LIST です。LIST の中のものは、すべてリストコンテキストで評価されま
     す。サブルーティンの呼び出しがあれば、リストコンテキストでは、複数
     の値を返すかもしれません。また、すべての引数を括弧で括るのでなけれ
     ば、`print' というキーワードの次に開き括弧を書いてはいけません。
     `print' と引数の間に "+" を書くか、すべての引数を括弧で括ってくだ
     さい。


 -- Function: printf FILEHANDLE LIST
 -- Function: printf LIST
     `print FILEHANDLE sprintf(LIST)' と等価です。LIST の最初の要素は、
     `printf' フォーマットと解釈されます。


 -- Function: read FILEHANDLE,SCALAR,LENGTH,OFFSET
 -- Function: read FILEHANDLE,SCALAR,LENGTH
     指定した FILEHANDLE から、変数 SCALAR に LENGTH バイトのデータを読
     み込みます。実際に読み込まれたバイト数か、エラー時には `undef' を
     返します。SCALAR は、実際に読み込んだ長さに応じて、伸び縮みします。
     OFFSETを指定すると、SCALAR の先頭以外の場所から、読み込みを行ない
     うことができます。この関数は、stdio ライブラリの fread() 関数を使っ
     てインプリメントしています。実際のシステムコールを利用するには、
     `sysread()' を参照してください。


 -- Function: seek FILEHANDLE,POSITION,WHENCE
     stdio ライブラリの fseek() 関数のように、FILEHANDLE のファイルポイ
     ンタを任意の位置に設定します。FILEHANDLE は、実際のファイルハンド
     ル名を与える式でもかまいません。WHENCE の値が、0 ならば、ファイル
     ポインタを POSITION の位置へ、1 ならば、現在位置からPOSITION 離れ
     た位置へ、2 ならば、EOF から POSITION だけ離れた位置へ、ファイルポ
     インタを設定します。この値には、POSIX モジュールで使われている
     SEEK_SET、SEEK_CUR、SEEK_END を使うこともできます。成功時には、1
     を、失敗時には 0 を返します。


 -- Function: select FILEHANDLE
 -- Function: select
     その時点で、選択されていたファイルハンドルを返します。FILEHANDLE
     を指定した場合には、その値を出力のデフォルトファイルハンドルに設定
     します。これには、2 つの効果があります。まず、ファイルハンドルを指
     定しないで `write' や `print' を行なった場合のデフォルトが、この
     FILEHANDLE になります。もう一つは、出力関連の変数への参照は、この
     出力チャネルを参照するようになります。たとえば、複数の出力チャネル
     に対して、ページ先頭フォーマットを設定しなければならないのであれば、

          select(REPORT1);
          $^ = 'report1_top';
          select(REPORT2);
          $^ = 'report2_top';

     のようにしなければならないでしょう。

     FILEHANDLE は、実際のファイルハンドルの名前を示す、式でもかまいま
     せん。つまり、

          $oldfh = select(STDERR); $| = 1; select($oldfh);

     のようなものです。

     Perl 5 では、ファイルハンドルはメソッドを持ったオブジェクトですか
     ら、最後の例は

          use FileHandle;
          STDERR->autoflush(1);

     のように書くと良いでしょう。


 -- Function: select RBITS,WBITS,EBITS,TIMEOUT
     これは、select(2) システムコールを、指定したビットマスクで呼び出し
     ます。ビットマスクは、`fileno()' と `vec()' を使って、

          $rin = $win = $ein = ";
          vec($rin,fileno(STDIN),1) = 1;
          vec($win,fileno(STDOUT),1) = 1;
          $ein = $rin | $win;

     のようにして作成することができます。

     複数のファイルハンドルに `select' を行ないたいのであれば、

          sub fhbits {
              local(@fhlist) = split(' ',$_[0]);
              local($bits);
              for (@fhlist) {
                  vec($bits,fileno($_),1) = 1;
              }
              $bits;
          }
          $rin = &fhbits('STDIN TTY SOCK');

     のようなサブルーティンを書くとよいでしょう。

     通常は、

          ($nfound,$timeleft) =
            select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

     のように使い、いずれかの準備が整うまでブロックするには、

          $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);

     のようにします。どのビットマスクにも `undef' を設定することができ
     ます。TIMEOUT を指定するときは、秒数で指定し、少数でかまいません。
     注: すべてのインプリメンテーションで、$timeleft が返せるものではあ
     りません。その場合、$timeleft には、常に指定した TIMEOUT と同じ値
     が返されます。

     250 ミリ秒の `sleep' と同じ効果が、

          select(undef, undef, undef, 0.25);

     のようにして得られます。(マイクロ秒じゃないよ :-))


 -- Function: sprintf FORMAT,LIST
     普通の C 言語の printf 記法のフォーマットで、整形された文字列を返
     します。(長さの間接指定のための * 文字はサポートされていませんが、
     変数をパターン内で展開すれば、同じ結果となります。)


 -- Function: sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
 -- Function: sysread FILEHANDLE,SCALAR,LENGTH
     システムコール read(2) を用いて、指定した FILEHANDLE から、変数
     SCALAR へ、LENGTH バイトのデータの読み込みを試みます。これは、
     stdio ルーティンを通りませんから、他の入力関数と混ぜて使うと、入力
     がおかしくなるかもしれません。実際に読み込まれたデータの長さか、エ
     ラー時には `undef' が返されます。SCALAR は、実際に読み込んだ長さに
     応じて、伸び縮みします。OFFSET を指定すると、SCALAR の先頭以外の場
     所から、読み込みを行ないうことができます。


 -- Function: syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
 -- Function: syswrite FILEHANDLE,SCALAR,LENGTH
     write(2) システムコールを使って、指定した FILEHANDLE へ、変数
     SCALAR から、LENGTH バイトのデータの書き込みを試みます。これは、
     stdio ルーティンを通りませんから、他の出力関数と混ぜて使うと、出力
     がおかしくなるかもしれません。実際に読み込まれたデータの長さか、エ
     ラー時には `undef' が返されます。OFFSET を指定すると、SCALAR の先
     頭以外の場所から、データを取り出して、書き込みを行ないうことができ
     ます。


 -- Function: tell FILEHANDLE
 -- Function: tell
     FILEHANDLE の現在のファイル位置を返します。FILEHANDLE は、実際のファ
     イルハンドル名を示す式でもかまいません。FILEHANDLE が省略された場
     合には、最後に読み込みを行なったファイルについて調べます。


 -- Function: write FILEHANDLE
 -- Function: write EXPR
 -- Function: write
     指定されたファイルに対して、そのファイルに対応させたフォーマットを
     使って、(複数行の場合もある) 整形されたレコードを書き出します。デ
     フォルトでは、ファイルに対応するフォーマットは、ファイルハンドルと
     同じ名前のものですが、その時点の出力チャネル (`select()' 関数の項
     を参照) のフォーマットは、その名前を明示的に、変数 $~ に代入するこ
     とで、変更が可能です。

     ページの先頭の処理は、自動的に行なわれます。現在のページに整形され
     たレコードを出力するだけのスペースがない場合には、改ページを行なっ
     てページを進め、新しいページヘッダを整形するため、ページ先頭フォー
     マットが使われ、その後でレコードが書かれます。デフォルトでは、ペー
     ジ先頭フォーマットは、ファイルハンドルの名前に "_TOP" をつなげたも
     のですが、ファイルハンドルが選択されている間に、変数 $^ に名前を設
     定すれば、動的にフォーマットを変更することができます。そのページの
     残り行数は、変数 $- に入っており、この変数を 0 に設定することで、
     強制的に改ページを行なうことができます。

     FILEHANDLE を指定しないと、出力はその時点のデフォルト出力チャネル
     に対して行なわれます。これは、スクリプトの開始時点では STDOUT ですが、
     `select()' 演算子で変更することができます。FILEHANDLE が
     EXPR ならば、式が評価され、その結果の文字列が実行時に
     FILEHANDLE の名前として見られます。フォーマットについて、さらには、
     *Note フォーマット文::,を参照してください。

     残念ながら、`write' は `read' の反対のことをするものではありません。







File: perl-ja.info, Node: ディレクトリ読み出し関数, Next: システム操作関数, Prev: 入出力関数, Up: 組み込み関数

ディレクトリ読み出し関数
========================


 -- Function: closedir DIRHANDLE
     `opendir()' でオープンしたディレクトリをクローズします。


 -- Function: opendir DIRHANDLE,EXPR
     `readdir()', `telldir()', `seekdir()',
     `rewinddir()', `closedir()' で処理するために、EXPR で指
     定された名前のディレクトリをオープンします。成功時には真を返します。
     DIRHANDLE は、FILEHANDLE とは別に名前空間を持っています。


 -- Function: readdir DIRHANDLE
     `opendir()' でオープンしたディレクトリで、次のディレクトリエントリ
     を返します。リストコンテキストで用いると、そのディレクトリの残りの
     エントリを、すべて返します。エントリが残っていない場合には、スカラ
     コンテキストでは未定義値を、リストコンテキストでは空リストを返しま
     す。


 -- Function: rewinddir DIRHANDLE
     DIRHANDLE に対する `readdir()' ルーティンの現在位置をディレクトリ
     の最初に設定します。


 -- Function: seekdir DIRHANDLE,POS
     DIRHANDLE での `readdir()' ルーティンの現在位置を設定します。POS
     は、`telldir()' が返す値でなければなりません。同名のシステムライブ
     ラリルーティンと同じく、ディレクトリ縮小時の問題が考えられます。


 -- Function: telldir DIRHANDLE
     DIRHANDLE 上の `readdir()' ルーティンに対する現在位置を返します。
     値は、そのディレクトリで特定の位置をアクセスするため、`seekdir()'
     に渡すことができます。同名のシステムライブラリルーティンと同じく、
     ディレクトリ縮小時の問題が考えられます。







File: perl-ja.info, Node: システム操作関数, Next: ネットワーク操作関数, Prev: ディレクトリ読み出し関数, Up: 組み込み関数

システム操作関数
================


 -- Function: alarm SECONDS
     指定した秒数が経過した後に、自プロセスに SIGALRM が送られてくるよ
     うにします。(マシンによっては、秒の数え方が異なるため、指定した秒
     数よりも最大で 1 秒少ない経過時間となります。)一度には 1 つのタイ
     マだけが設定可能です。呼び出しを行なう度に、以前のタイマを無効にし
     ますし、新しくタイマを起動しないで以前のタイマをキャンセルするため
     に引数に 0 を指定して呼び出すことができます。以前のタイマの残り時
     間が、返却値となります。

     1 秒より精度の高いスリープを行なうには、setitimer(2) をサポートし
     ているシステムでは、Perl の syscall() インタフェースを使ってアクセ
     スすることができますし、サポートしていなければ、このドキュメントの
     どこかにある select() の項を参照してください。


 -- Function: chdir EXPR
     (可能であれば、) カレントディレクトリを EXPR に移します。EXPR を指
     定しないと、ホームディレクトリに移ります。成功時には真を返し、そう
     でなければ偽を返します。`die()' の項の例を参照してください。


 -- Function: chroot FILENAME
     同じ名前のシステムコールと同じことをします。それが何をするものかを、知ら
     なくても気にしないでください。FILENAME を省略すると、$_ へ
     `chroot' します。


 -- Function: die LIST
     `eval()' の外では、LIST の値を STDERR に出力し、その時点の $!
     (errno) の値で exit します。$! の値が 0 ならば、($? >> 8)
     (`command` のステータス) の値で exitします。($? >> 8) も 0 であれ
     ば、255 で exit することになります。`eval()' の中で使用すると、エ
     ラーメッセージが、$@ に入れられます。`eval()' は中断され、未定義値
     を返します。

     同値な例:
          die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
          chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

     $var{list} の評価結果が改行で終わっていなければ、その時点のスクリ
     プト名とスクリプトの行番号、(もしあれば) 入力ファイルの行番号と改
     行文字が、続けて表示されます。ヒント: メッセージの最後を ",
     stopped" のようなもので終わるようにしておけば、"at foo line 123"
     のように追加されて、わかりやすくなります。"canasta" というスクリプ
     トを実行しているとすると、

          die "/etc/games is no good";
          die "/etc/games is no good, stopped";

     は、それぞれ

          /etc/games is no good at canasta line 123.
          /etc/games is no good, stopped at canasta line 123.

     と表示することになります。`exit()' と `warn()' も参照してください。


 -- Function: exec LIST
     `exec()' 関数は、システムのコマンドを実行し、戻ってはきません。戻っ
     て欲しい場合には、`system()' 関数を使ってください。

     LIST に複数の引数がある場合か、LIST が複数の値を持つ配列の場合には、
     LIST の引数を使って、execvp(3) を呼び出します。1 つのスカラ引数の
     みの場合には、その引数からシェルのメタ文字をチェックします。もし、
     メタ文字があれば、引数全体を `/bin/sh -c' に渡して解析させます。も
     し、なければ、その引数を単語に分け、より効率的な execvp() に直接、
     渡します。注: `exec()' (と `system()')は出力バッファをフラッシュし
     ませんので、出力をなくしたくなければ、$| を設定する必要があるかも
     しれません。例:

          exec '/bin/echo', 'Your arguments are: ', @ARGV;
          exec "sort $outfile | uniq";

     第一引数に指定するものを本当に実行したいが、実行するプログラムに対
     して別の名前を教えたい場合には、LIST の前に、「間接オブジェクト」
     (コンマなし) として、実際に実行したいプログラムを指定することがで
     きます。(これによって、LIST に単一のスカラしかなくても、複数値のリ
     ストであるように、LIST の解釈を行ないます。)例:

          $shell = '/bin/csh';
          exec $shell '-sh';          # login シェルの振りをする

     あるいは、より直接的に、

          exec {'/bin/csh'} '-sh';    # login シェルの振りをする


 -- Function: exit EXPR
     EXPR を評価し、即座にその値を持って終了します。(実際には、まず、定
     義されている END ルーティンを呼び出しますが、END ルーティンは
     exit を止められません。同様に、呼び出す必要のあるオブジェクトデス
     トラクタはすべて、exit の前に呼び出されます。)例:

          $ans = <STDIN>;
          exit 0 if $ans =~ /^[Xx]/;

     `die()' も参照してください。EXPR が省略された場合には、ステータス
     を 0 として終了します。


 -- Function: fork
     システムコール fork(2) を行ないます。親プロセスには、チャイルドプ
     ロセスの pid を、チャイルドプロセスに 0 を返しますが、fork に失敗
     したときには、未定義値を返します。注: フラッシュされていないバッファ
     は、どちらのプロセスに対しても、フラッシュされていないままとなって
     います。これは、出力がダブルのを避けるためには、$| (English では
     $AUTOFLUSH) を設定するか、ファイルハンドルメソッド autoflush() を
     呼ぶ必要があるかもしれないということです。

     チャイルドプロセスの終了を待たずに、fork() を繰り返せば、ゾンビを
     ため込むことになります:

          $SIG{'CHLD'} = sub { wait };

     ダブル `fork' という仕掛けも使えます (`fork' の返却値のエラーチェッ
     クは省いています);

          unless ($pid = fork) {
              unless (fork) {
                  exec "what you really wanna do";
                  die "no exec";
                  # ... または ...
                  some_perl_code_here;
                  exit 0;
              }
              exit 0;
          }
          waitpid($pid,0);


 -- Function: getlogin
     もしあれば、/etc/utmp から現在のログイン名を返します。ヌルであれば、
     `getpwuid()' を使ってください。

          $login = getlogin || (getpwuid($<))[0] || "Kilroy";


 -- Function: getpgrp PID
 -- Function: getpgrp
     指定された PID の現在のプロセスグループを返します。PID に 0 を与え
     るとカレントプロセスの指定となります。getpgrp(2) をインプリメント
     していないマシンで実行した場合には、致命的エラーとなります。PID を
     省略するとカレントプロセスのプロセスグループを返します。


 -- Function: getppid
     親プロセスのプロセス id を返します。


 -- Function: getpriority WHICH,WHO
     プロセス、プロセスグループ、ユーザに対する現在の優先度を返します。
     (getpriority(2) manpage を参照してください。)getpriority(2) をイン
     プリメントしていないマシンで実行した場合には、致命的エラーとなりま
     す。


 -- Function: getpwnam NAME
 -- Function: getgrnam NAME
 -- Function: gethostbyname NAME
 -- Function: getnetbyname NAME
 -- Function: getprotobyname NAME
 -- Function: getpwuid UID
 -- Function: getgrgid GID
 -- Function: getservbyname NAME,PROTO
 -- Function: gethostbyaddr ADDR,ADDRTYPE
 -- Function: getnetbyaddr ADDR,ADDRTYPE
 -- Function: getprotobynumber NUMBER
 -- Function: getservbyport PORT,PROTO
 -- Function: getpwent
 -- Function: getgrent
 -- Function: gethostent
 -- Function: getnetent
 -- Function: getprotoent
 -- Function: getservent
 -- Function: setpwent
 -- Function: setgrent
 -- Function: sethostent STAYOPEN
 -- Function: setnetent STAYOPEN
 -- Function: setprotoent STAYOPEN
 -- Function: setservent STAYOPEN
 -- Function: endpwent
 -- Function: endgrent
 -- Function: endhostent
 -- Function: endnetent
 -- Function: endprotoent
 -- Function: endservent
     これらのルーティンは、システムライブラリの同名の関数を実行します。
     リストコンテキストでは、さまざまな get ルーティンからの返却値は、
     次のようになります:

          ($name,$passwd,$uid,$gid,
             $quota,$comment,$gcos,$dir,$shell) = getpw*
          ($name,$passwd,$gid,$members) = getgr*
          ($name,$aliases,$addrtype,$length,@addrs) = gethost*
          ($name,$aliases,$addrtype,$net) = getnet*
          ($name,$aliases,$proto) = getproto*
          ($name,$aliases,$port,$proto) = getserv*

     (エントリが存在しなければ、空リストが返されます。)

     スカラコンテキストでは、*nam、*byname といった NAME で検索するもの
     以外は、name を返し、NAME で検索するものは、何か別のものを返します。
     (エントリが存在しなければ、未定義値が返ります。)たとえば:

          $uid = getpwnam
          $name = getpwuid
          $name = getpwent
          $gid = getgrnam
          $name = getgrgid
          $name = getgrent
          etc.

     getgr*() によって返る値 $members は、グループのメンバのログイン名
     をスペースで区切ったものです。

     gethost*() 関数では、C で h_errno 変数がサポートされていれば、関数呼出が
     失敗したときに、$? を通して、その値が返されます。成功時に返される
     @addrs 値は、対応するシステムコールが返す、生のアドレスのリストです。イ
     ンターネットドメインでは、個々のアドレスは、4 バイト長で、

          ($a,$b,$c,$d) = unpack('C4',$addr[0]);

     のようにして、`unpack' することができます。


 -- Function: glob EXPR
     EXPR の値を、シェルが行なうように、ファイル名の展開を行なって返し
     ます。これは、<*.*> 演算子をインプリメントする内部関数です。


 -- Function: kill LIST
     プロセスのリストにシグナルを送ります。LIST の最初の要素は、送信す
     るシグナルでなくてはなりません。シグナル送信に成功したプロセスの数
     を返します。

          $cnt = kill 1, $child1, $child2;
          kill 9, @goners;

     シェルとは異なり、Perl では、シグナルに負の数を与えると、プロセス
     ではなく、プロセスグループに対して、kill を行ないます。(Syetem V
     では、プロセス番号として負の値を与えても、プロセスグループの kill
     を行ないますが、移植性がありません。)すなわち、通常は、負のシグナ
     ルは用いず、正のシグナルを使うことになります。シグナル名をクォート
     して使うこともできます。


 -- Function: setpgrp PID,PGRP
     指定した PID (0 を指定するとカレントプロセス) に対するプロセスグルー
     プを設定します。setpgrp(2) がインプリメントされていないマシンでは、
     致命的エラーが発生します。


 -- Function: setpriority WHICH,WHO,PRIORITY
     プロセス、プロセスグループ、ユーザに対する優先順位を設定します。
     (setpriority(2) を参照してください。) setpriority(2) がインプリメ
     ントされていないマシンでは、致命的エラーが発生します。


 -- Function: sleep EXPR
 -- Function: sleep
     スクリプトを EXPR で指定した秒数 (省略時には、永久に)スリープさせ
     ます。そのプロセスには、`SIGALRM' を送ることで、割り込みを掛けるこ
     とができます。実際にスリープした秒数を返します。`sleep()' は、
     `alarm()' を使ってインプリメントされることが多いので、`alarm()' と
     `sleep()' は、おそらく混ぜて使用することはできません。

     古いシステムでは、どのように秒を数えるかによって、要求した秒数に完
     全に満たないうちに、スリープから抜ける場合があります。最近のシステ
     ムでは、常に完全にスリープします。


 -- Function: syscall LIST
     LIST の最初の要素で指定するシステムコールを、残りの要素をそのシス
     テムコールの引数として呼び出します。インプリメントされていないとき
     には、致命的エラーとなります。引数は、以下のように解釈されます: 引
     数が数字であれば、int として引数を渡します。そうでなければ、文字列
     値へのポインタが渡されます。文字列に結果を受け取るときには、その結
     果を受け取るのに十分なくらいに、文字列を予め伸ばしておく必要があり
     ます。整数引数が、リテラルでなく、数値コンテキストで評価されたこと
     のないものであれば、数値として解釈されるように、0 を足しておく必要
     があるかもしれません。

          require 'syscall.ph'; # h2ph を実行する必要があるかも
          syscall(&SYS_write, fileno(STDOUT), "hi there\n", 9);

     Perl は、システムコールに最大 14 個の引数しか渡せませんが、実用上
     問題はないでしょう。


 -- Function: system LIST
     `exec LIST' とほとんど同じですが、まず `fork' を行ない、親プロセス
     ではチャイルドプロセスが終了するのを `wait' します。`exec' の項で
     述べたように、引数の処理は、引数の数によって異なることに注意してく
     ださい。返却値は、`wait()' が返すプログラムの exit 状態です。実際
     の exit 値を得るには 256 で割ってください。このドキュメントの
     `exec' の項も参照してください。


 -- Function: times
     現プロセスと、そのチャイルドプロセスに対する、ユーザ時間とシステム
     時間を秒で示した、4 要素のリスト値を返します。

          ($user,$system,$cuser,$csystem) = times;


 -- Function: umask EXPR
 -- Function: umask
     現在のプロセスの umask を設定し、以前の値を返します。EXPR が省略さ
     れると、単にその時点の umask の値を返します。


 -- Function: wait
     チャイルドプロセスが終了するのを待ち、消滅したプロセスの pid を返
     します。チャイルドプロセスが存在しないときには、-1 を返します。ス
     テータスは $? に返されます。


 -- Function: waitpid PID,FLAGS
     特定のチャイルドプロセスが終了するのを待ち、消滅したプロセスの
     pid を返します。指定したチャイルドプロセスが存在しないときには、-1
     を返します。ステータスは $? に返されます。

          use POSIX "wait_h";
          ...
          waitpid(-1,&WNOHANG);

     とすると、ブロックが起こらないようにして、任意のプロセスを `wait'
     します。ブロックなしの `wait' は、システムコール waitpid(2) か、シ
     ステムコール wait4(2) をサポートしているマシンでのみ利用可能です。
     しかしながら、特定の pid を 0 の FLAGS での `wait' はどこでもイン
     プリメントされています。(exit したプロセスのステータス値を覚えてお
     いて、Perl がシステムコールをエミュレートしますが、Perl スクリプト
     には取り入れられていません。)


 -- Function: warn LIST
     `die()' と同じように STDERR にメッセージを出力しますが、exit した
     り、例外を発生させたりしません。







File: perl-ja.info, Node: ネットワーク操作関数, Next: SystemV IPC 関数, Prev: システム操作関数, Up: 組み込み関数

ネットワーク操作関数
====================


 -- Function: accept NEWSOCKET,GENERICSOCKET
     accept(2) システムコールと同様に、着信するソケットの接続を受け付けます。
     成功時にはパックされたアドレスを返し、失敗すれば偽を返します。
     *Note プロセス間通信::,の例を参照してください。


 -- Function: bind SOCKET,NAME
     bind(2) システムコールと同様に、ネットワークアドレスをソケットに結び付け
     ます。成功時には真を返し、失敗時には偽を返します。NAME は、ソケッ
     トに対する、適切な型のパックされたアドレスでなければなりません。
     *Note プロセス間通信::,の例を参照してください。


 -- Function: connect SOCKET,NAME
     connect(2) システムコールと同様に、リモートソケットへの接続を試みます。
     成功時には真を返し、失敗時には偽を返します。NAME は、ソケットに対
     する、適切な型のパックされたアドレスでなければなりません。
     *Note プロセス間通信::,の例を参照してください。


 -- Function: getpeername SOCKET
     SOCKET コネクションの向こう側のパックされた aockaddr アドレスを返
     します。

          # インターネットの sockaddr
          $sockaddr = 'S n a4 x8';
          $hersockaddr = getpeername(S);
          ($family, $port, $heraddr) = unpack($sockaddr,$hersockaddr);


 -- Function: getsockname SOCKET
     SOCKET コネクションのこちら側のパックされた aockaddr アドレスを返
     します。

          # インターネット sockaddr
          $sockaddr = 'S n a4 x8';
          $mysockaddr = getsockname(S);
          ($family, $port, $myaddr) = unpack($sockaddr,$mysockaddr);


 -- Function: getsockopt SOCKET,LEVEL,OPTNAME
     要求されたソケットオプションを返します。エラーの場合には、未定義値
     を返します。


 -- Function: listen SOCKET,QUEUESIZE
     listen(2) システムコールと同じことをします。成功時には真を返し、失
     敗時には偽を返します。*Note プロセス間通信::,の例を参照してくださ
     い。


 -- Function: recv SOCKET,SCALAR,LEN,FLAGS
     ソケット上のメッセージを受信します。指定されたファイルハンドル
     SOCKET から、変数 SCALAR に LENGTH バイトのデータを読み込もうとし
     ます。実際には、C の recvfrom() を呼びますので、送信側のアドレスを
     返すことができます。エラー発生時には、未定義値を返します。SCALAR
     は、実際に読まれた長さによって、大きくなったり、小さくなったりしま
     す。同名のシステムコールと同じ FLAGS を使います。


 -- Function: send SOCKET,MSG,FLAGS,TO
 -- Function: send SOCKET,MSG,FLAGS
     SOCKET に MSG を送ります。FLAGS には、同名のシステムコールと同じフ
     ラグを指定します。接続していないソケットには、送信先 TO を指定しな
     ければならず、この場合、C の sendto() を実行します。送信した文字数
     か、エラー時には、未定義値を返します。


 -- Function: setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
     要求したソケットオプションを設定します。エラー時には、未定義値が返
     されます。引数を渡したくない場合には、OPTVAL に `undef' を指定しま
     す。


 -- Function: shutdown SOCKET,HOW
     同名のシステムコールと同じように解釈される HOW によって、指定され
     た方法でソケット接続のシャットダウンを行ないます。


 -- Function: socket SOCKET,DOMAIN,TYPE,PROTOCOL
     指定した種類のソケットをオープンし、ファイルハンドルSOCKET にアタッ
     チします。DOMAIN、TYPE、PROTOCOL は、同名のシステムコールと同じよ
     うに指定します。適切な定義を `import' するために、まず、`use
     Socket;' とするとよいでしょう。*Note プロセス間通信::,の例を参照し
     てください。


 -- Function: socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
     指定した DOMAIN に、指定した TYPE で名前の無いソケットのペアを生成
     します。DOMAIN、TYPE、PROTOCOL は、同名のシステムコールと同じよう
     に指定します。インプリメントされていない場合には、致命的エラーとな
     ります。成功時には真を返します。







File: perl-ja.info, Node: SystemV IPC 関数, Next: その他の関数, Prev: ネットワーク操作関数, Up: 組み込み関数

SystemV IPC 関数
================


 -- Function: msgctl ID,CMD,ARG
     System V IPC 関数 msgctl を呼び出します。CMD が`&IPC_STAT' であれ
     ば、ARG は返される msqid_ds 構造体を納める変数でなければなりません。
     `ioctl' と同じように、エラー時には未定義値、ゼロのときは "0 but
     true"、それ以外なら、その値そのものを返します。


 -- Function: msgget KEY,FLAGS
     System V IPC 関数 msgget を呼び出します。メッセージキューの ID か、
     エラー時には未定義値を返します。


 -- Function: msgrcv ID,VAR,SIZE,TYPE,FLAGS
     System V IPC 関数 msgrcv を呼び出し、メッセージキュー ID から、変
     数 VAR に最大メッセージ長 SIZE のメッセージを受信します。メッセー
     ジが受信されたならば、VAR の先頭がメッセージタイプとなり、VAR の最
     大長は、SIZE にこのメッセージタイプの長さを加えたものになります。
     成功時には真を返し、エラー時には偽を返します。


 -- Function: msgsnd ID,MSG,FLAGS
     System V IPC 関数 msgsnd を呼び出し、メッセージキュー ID にメッセー
     ジ MSG を送信します。MSG の先頭は、long 整数のメッセージタイプでな
     ければならず、これは、`pack("L", $type)' として生成できます。成功
     時には真を、エラー時には偽を返します。


 -- Function: semctl ID,SEMNUM,CMD,ARG
     System V IPC 関数 semctl を呼び出します。CMD が、`&IPC_STAT' か
     `&GETALL' のときには、ARG は、返されるsemid_ds 構造体か、セマフォ
     値の配列を納める変数でなければなりません。`ioctl' と同じように、エ
     ラー時には未定義値、ゼロのときは "0 but true"、それ以外なら、その
     値そのものを返します。


 -- Function: semget KEY,NSEMS,FLAGS
     System V IPC 関数 semget を呼び出します。セマフォ ID か、エラー時
     には未定義値を返します。


 -- Function: semop KEY,OPSTRING
     シグナルを送信や、待ち合わせなどのセマフォ操作を行なうために、
     System V IPC 関数 semop を呼び出します。OPSTRING は、semop 構造体
     の `pack' された配列でなければなりません。semop 構造体は、それぞれ、
     `pack("sss", $semnum, $semop, $semflag)' のように作ることができま
     す。セマフォ操作の数は、OPSTRING の長さからわかります。成功時には
     真を、エラー時には偽を返します。例として、

          $semop = pack("sss", $semnum, -1, 0);
          die "Semaphore trouble: $!\n" unless semop($semid, $semop);

     は、セマフォ ID $semid のセマフォ $semnum で待ち合わせを行ないます。
     セマフォにシグナルを送るには、"-1"を "1" に変更してください。


 -- Function: shmctl ID,CMD,ARG
     System V IPC 関数 shmctl を呼び出します。CMD が、`&IPC_STAT' なら
     ば、ARG は、返される shmid 構造体を納める変数でなければなりません。
     ioctl と同じように、エラー時には未定義値、ゼロのときは "0 but
     true"、それ以外なら、その値そのものを返します。


 -- Function: shmget KEY,SIZE,FLAGS
     System V IPC 関数 shmget を呼び出します。共有メモリのセグメント
     ID か、エラー時には未定義値を返します。


 -- Function: shmread ID,VAR,POS,SIZE
 -- Function: shmwrite ID,STRING,POS,SIZE
     System V 共有メモリセグメント ID に対し、アタッチして、コピーを行
     ない、デタッチするという形で、位置 POS から、サイズ SIZE だけ、読
     み込みか書き込みを行ないます。読み込み時には、VAR は読み込んだデー
     タを納める変数でなければなりません。書き込み時には、STRING が長す
     ぎても、SIZE バイトだけが使われます。STRING が短すぎる場合には、
     SIZE バイトを埋めるために、ヌル文字が書き込まれます。成功時には真
     を、エラー時には偽を返します。







File: perl-ja.info, Node: その他の関数, Prev: SystemV IPC 関数, Up: 組み込み関数

その他の関数
============


 -- Function: defined EXPR
     左辺値 EXPR が実際に値を持つか否かを示す、ブール値を返します。多く
     の演算子が、EOF や未初期化変数、システムエラーといった、例外的な条
     件で未定義値を返すようになっています。この関数は、配列の要素の参照
     のように、実際にヌル文字列を返す演算について、未定義のヌルスカラと、
     定義済みのヌルスカラを区別するときに使います。配列やサブルーティン
     の存在を、確かめることもできます。あらかじめ定義された予約変数に対
     して用いても、直感的に想像できるような値を返すことは保証されていま
     せん。

     ハッシュの要素に対して用いると、value が定義されているか否かを返すもので
     あって、ハッシュに key が存在するか否かを返すのではありません。これには、
     `exits()'を使ってください。

     例:

          print if defined $switch{'D'};
          print "$val\n" while defined($val = pop(@ary));
          die "Can't readlink $sym: $!"
              unless defined($value = readlink $sym);
          eval '@foo = ()' if defined(@foo);
          die "No XYZ package defined" unless defined %_XYZ;
          sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }

     `undef()' も参照してください。


 -- Function: dump LABEL
     即座にコアダンプを行ないます。プログラムの先頭で、すべての変数を初期化し
     たあとのコアダンプを `undump' プログラムを使って実行ファイルに返る
     ことができます。この新しいバイナリが実行されると、`goto LABEL' から
     始めます (`goto' に関する制限はすべて適用されます)。コアダンプをは
     さんで再生する `goto' と考えてください。$var{label} が省略されると、
     プログラムを先頭から再開します。警告: `dump' 時点でオープンされてい
     たファイルは、プログラムが再生されたときには、もはやオープンされていませ
     ん。Perl を部分的に混乱させる可能性があります。$xref{実行とオプション}の
     `-u' オプションも参照してください。

     例:
          #!/usr/bin/perl
          require 'getopt.pl';
          require 'stat.pl';
          %days = (
              'Sun' => 1,
              'Mon' => 2,
              'Tue' => 3,
              'Wed' => 4,
              'Thu' => 5,
              'Fri' => 6,
              'Sat' => 7,
          );
          dump QUICKSTART if $ARGV[0] eq '-d';
          QUICKSTART:
          Getopt('f');


 -- Function: local EXPR
     一般には、`local' よりも `my' を使うべきでしょう。速く、安全だ
     からです。しかし、`format' 文の変数には、`local' やローカルな
     値が呼び出されたサブルーティンから見えるような変数を使わなければなりませ
     ん。これは、動的スコープと呼ばれます。文面上の静的なスコープは、
     `my' を使って得られ、C の AUTO 宣言と同じように働きます。

     `local' はリストアップされた変数を、囲っているブロックやサブルーティ
     ン、`eval' や `do' の中で、ローカルなものにします。複数の値を並べ
     る場合には、括弧で括る必要があります。並べる要素は、左辺値として使
     用できるものでなければなりません。この演算子は LIST 中の、それらの
     変数の現在の値を隠れたスタックに保存し、ブロックやサブルーティンや
     eval から抜けるときに、それらの値を戻します。これによって、呼ばれ
     たサブルーティンはグローバルな変数ではなく、ローカルな変数を参照す
     ることができます。EXPR に代入を行なうことも可能で、ローカルな変数
     の初期化として使うことができます。(初期化子を与えなかった変数の値
     は、未定義値となります。)これはよく、サブルーティンの引数に名前を
     付けるのに使われます。例:

          sub RANGEVAL {
              local($min, $max, $thunk) = @_;
              local $result = ";
              local $i;

              # $thunk が $i へのリファレンスを作るとでしょう

              for ($i = $min; $i < $max; $i++) {
                  $result .= eval $thunk;
              }

              $result;
          }

          if ($sw eq '-v') {
              # ローカル配列をグローバル配列で初期化
              local @ARGV = @ARGV;
              unshift(@ARGV,'echo');
              system @ARGV;
          }
          # @ARGV が戻される

          # 一時的に連想配列 digits に加算
          if ($base12) {
              # (NOTE: これにこだわらない方が効率的 !)
              local(%digits) = (%digits,'t',10,'e',11);
              parse_num();
          }

     `local()' は実行時のコマンドですから、ループを通るごとに実行される
     ことに注意してください。Perl 4 では、ループを抜けるまで、それぞれ
     スタックメモリを使いました。Perl 5 はそれぞれスペースを取り戻しま
     すが、変数をループの外で宣言した方が効率的なのは、変わりありません。

     EXPR に代入を行なうとき、local は EXPR がスカラとして参照されるか、
     配列として参照されるかには、影響しません。つまり、

          local($foo) = <STDIN>;
          local @FOO = <STDIN>;

     は、どちらも右辺にリストコンテキストをもたらしますが、

          local $foo = <STDIN>;

     では、スカラコンテキストになります。


 -- Function: my EXPR
     `my' はリストアップされた変数を、囲っているブロックやサブルーティ
     ン、`eval' や `do' の中で (文面上の意味で)ローカルなものにします。
     複数の値を並べる場合には、括弧で括る必要があります。並べる要素は、
     左辺値として使用できるものでなければなりません。英数字の識別子だけ
     が、文面上の字句スコープに入れることができます。$/ のような、マジ
     カルな組み込み変数をローカル化するには、`local' を使う必要がありま
     す。特に、

          my $_;      # 不正

     とはできません。

     `local' の宣言とは違って、`my' で宣言した変数は、呼び出したサブルー
     ティンを含む、外界からは完全に見えないものになります (たとえ、それ
     が同一のサブルーティンであってもです。呼出ごとに新しいものになりま
     す)。

     (しかし、`eval()' を使えば、その `eval()' 自身の中で宣言によって、
     名前が見えないようになっているのでない限り、評価が行なわれる字句ス
     コープの変数を見ることができます。)*Note リファレンスとデータ構造
     のネスト::,を参照してください。

     EXPR に代入を行なうことも可能で、変数の初期化に使うことができます。
     (初期化子を与えなかった変数の値は、未定義値となります。)これはよく、
     サブルーティンの引数に名前を付けるのに使われます。例:

          sub RANGEVAL {
              my($min, $max, $thunk) = @_;
              my $result = ";
              my $i;

              # $thunk が $i へのリファレンスを作るとでしょう

              for ($i = $min; $i < $max; $i++) {
                  $result .= eval $thunk;
              }

              $result;
          }

          if ($sw eq '-v') {
              # my 配列をグローバル配列で初期化
              my @ARGV = @ARGV;
              unshift(@ARGV,'echo');
              system @ARGV;
          }
          # 外部の @ARGV が再び見えるようになる

     EXPR に代入を行なうとき、`my' は EXPR がスカラとして参照されるか、
     配列として参照されるかには、影響しません。つまり、

          my($foo) = <STDIN>;
          my @FOO = <STDIN>;

     は、どちらも右辺にリストコンテキストをもたらしますが、

          my $foo = <STDIN>;

     では、スカラコンテキストになります。

     なるべく、字句スコープの変数を使うようにすることもあるでしょう。暗
     黙のうちに、パッケージ変数を参照してしまうのを検出するために、

          use strict 'vars';

     とすれば、その場所から囲っているブロックの最後までは、字句変数か、パッケー
     ジ名で完全に修飾した変数でなければ、参照できないように制限できます。それ
     以外の変数参照は、コンパイルエラーとなります。内側のブロックで、
     `no strict 'vars'' として、これを打ち消すことができます。


 -- Function: ref EXPR
     EXPR がリファレンスであれば、真を返し、さもなくば、偽を返します。
     返される値は、リファレンスが参照するものの型に依存します。組み込み
     の型には、

        REF
        SCALAR
        ARRAY
        HASH
        CODE
        GLOB

     があります。参照されるオブジェクトが、何らかのパッケージに `bless'
     されたものであれば、これらの代わりに、そのパッケージ名が返されます。
     `ref()' は、`typeof()' 演算子のように考えることができます。

          if (ref($r) eq "HASH") {
              print "r is a reference to an associative array.\n";
          }
          if (!ref ($r) {
              print "r is not a reference at all.\n";
          }

     *Note リファレンスとデータ構造のネスト::,も参照してください。


 -- Function: undef EXPR
 -- Function: undef
     左辺値である EXPR の値を未定義にします。スカラ値、配列全体、("&"
     を使った) サブルーティン名だけに使用します。(特殊変数や DBM リスト
     値に `undef()' しても、おそらく期待通りの結果にはなりませんから、
     しないでください。)常に未定義値を返します。EXPR は省略することがで
     き、その場合には、何も未定義にされませんが、未定義値は返されますの
     で、それを、たとえば、サブルーティンの返却値として使うことができま
     す。例:

          undef $foo;
          undef $bar{'blurfl'};
          undef @ary;
          undef %assoc;
          undef &mysub;
          return (wantarray ? () : undef) if $they_blew_it;


 -- Function: wantarray
     現在実行中のサブルーティンがのコンテキストが、リスト値を要求するも
     のであれば、「真」を返します。スカラを要求するコンテキストであれば、
     「偽」を返します。

          return wantarray ? () : undef;




File: perl-ja.info, Node: 定義済み変数, Next: サブルーティン, Prev: 組み込み関数, Up: Top

定義済み変数
************

以下の名前は Perl では特別な意味を持ちます。記号的な名前の多くは記憶法
があるか、シェルでの類推が可能です。それでも長い名前を使用したい場合に
は

     use English;

とプログラムの最初に書いてください。これは、すべての短い名前の別名とし
て、カレントパッケージで長い名前を付けるものです。awk から持ってきた中
間的な名前を持っているものもあります。

もう一歩すすめて、現在選択されているファイルハンドルに依存する変数の場
合には、代わりに `FileHandle' オブジェクトに関するオブジェクトメソッド
を呼び出して設定することができます。 (以下の要約では HANDLE という語を
含んでいます。) まず最初に必ず、

     use FileHandle;

と書き、その後で

     method HANDLE EXPR

もしくは

     HANDLE->method(EXPR)

を使います。

それぞれのメソッドは、ファイルハンドル属性の昔の値を返します。メソッドは
それぞれ EXPR をとることができ、指定した場合には、問題の
`FileHandle' 属性の新しい値を指定することになります。指定しない場合
には、多くのメソッドでは現在の値に対して何もしませんが、
`autoflush()' では 1 を指定されたものとします。

これらの変数の中には "read-only" として扱われるものもあります。つまり、
そういった変数に対して、直接にしろ、リファレンスを介して間接にしろ、代
入を行なおうとした場合には、実行時に例外処理が起動されます。


 -- Variable: $ARG
 -- Variable: $_
     デフォルトの入力とパターン検索のスペース。以下の 2つは同値です:

          while (<>) {...}    # while の中でだけ同値 !
          while ($_ = <>) {...}

          /^Subject:/
          $_ =~ /^Subject:/

          tr/a-z/A-Z/
          $_ =~ tr/a-z/A-Z/

          chop
          chop($_)

     (記憶法: 下線はある操作を覚えるためのもの。)


 -- Variable: $<digit>
     最後のパターンマッチで対応する括弧のサブパターンにマッチした文字列
     が入っているが、既に抜けてしまったブロックでのパターンマッチは勘定
     に入れない。(記憶法: \digit のようなもの。)これらの変数はすべて
     read-only です。


 -- Variable: $MATCH
 -- Variable: $&
     最後に成功したパターンマッチでマッチした文字列 (現在の BLOCK で囲
     まれた BLOCK や eval() で隠れている部分でのマッチは勘定に入れない)。
     (記憶法: あるエディタの & ようなもの。) この変数は read-only です。


 -- Variable: $PREMATCH
 -- Variable: $`
     最後の成功したパターンマッチ (現在のBLOCK で囲まれた BLOCK や
     `eval()' に隠れている部分でのマッチは勘定に入れない) でマッチした
     部分の前の文字列。(記憶法: ` は多くの場合クォートされた文字列の前
     にある。)この変数は read-only です。


 -- Variable: $POSTMATCH
 -- Variable: $'
     最後の成功したパターンマッチ (現在のBLOCK で囲まれたBLOCK や
     `eval()' に隠れている部分でのマッチは勘定に入れない) でマッチした
     部分に続く文字列。(記憶法: ' は多くの場合クォートされた文字列の後
     にある。)例:
          $_ = 'abcdefghi';
          /def/;
          print "$`:$&:$'\n";         # abc:def:ghi と印字

     この変数は read-only です。


 -- Variable: $LAST_PAREN_MATCH
 -- Variable: $+
     最後に検索されたパターンの最後の括弧にマッチした文字列。これはいく
     つかの選択肢の中でどれがマッチするのかわからないような場合に使うと
     便利です。たとえば:

          /Version: (.*)|Revision: (.*)/ && ($rev = $+);

     (記憶法: ポジティブで前向き。) この変数は read-only です。


 -- Variable: $MULTILINE_MATCHING
 -- Variable: $*
     文字列中で複数行マッチを行なうために 1 に設定し、0 にすると、Perl
     が文字列に 1 行しか無いと仮定して、ある種のパターンマッチに関する
     最適化を行なうようになります。複数の改行を含む文字列でのパターンマッ
     チを "$*" が 0 のまま行なうと結果は信用のないものになります。デフォ
     ルトでは 0 になっています。(記憶法: * は複数のものにマッチしま
     す。)この変数は "^" と "$" の解釈にのみ影響します。リテラルの改行
     文字は、$* が 0 であっても検索することが可能です。

     Perl 5 では "$*" を使わないようにしてください。


 -- Method: input_line_number HANDLE EXPR
 -- Variable: $INPUT_LINE_NUMBER
 -- Variable: $NR
 -- Variable: $.
     最後に読み込みを行なったファイルハンドルの現在の入力行番号。この変
     数は、read-only と考えるべきです。明示的にファイルハンドルをクロー
     ズした場合にだけ、行番号がリセットされることに注意してください。
     <>" 構文では明示的にクローズを行ないませんから、ARGV のファイルに
     跨って行番号が数えられることになります (が、`eof()' の例を参照して
     ください)。(記憶法: 多くのプログラムで "." が現在行番号を示すよう
     に使われています。)


 -- Method: input_record_separator HANDLE EXPR
 -- Variable: $INPUT_RECORD_SEPARATOR
 -- Variable: $RS
 -- Variable: $/
     入力レコードセパレータで、デフォルトでは改行文字。空文字列に設定さ
     れると、空行を区切りとして扱うことを含めて、awk の変数 RS のように
     働きます。複数文字の区切文字を示すために、文字列を設定することもで
     きます。この変数に "\n\n" を設定すると、空行が続く場合において、
     を設定した場合とわずかに違う動作をするようになります。"" を設定し
     た場合には、複数の空行も 1 つの空行であるかのように扱います。
     n\n" を設定した場合には、単純に次の文字が (たとえ改行文字であって
     も)次の段落に含まれるものとして扱います。(記憶法: / は、詩を引用す
     るときに、行の区切りを示すのに使う文字です。)

          undef $/;
          $_ = <FH>;          # ファイル全体が読まれる
          s/\n[ \t]+/ /g;


 -- Method: autoflush HANDLE EXPR
 -- Variable: $OUTPUT_AUTOFLUSH
 -- Variable: $|
     0 以外に設定されると、その時点で選択されている出力チャネルに
     write や print を行なうごとに、強制的にフラッシュします。デフォル
     トでは 0 となっています。STDOUT は通常では、端末への出力時には行バッ
     ファリング、それ以外ではブロックバッファリングであることに注意して
     ください。これは、Perl のスクリプトを rsh 配下で実行して、実行状況
     を確認したい場合のように、パイプに出力するときに特に便利でしょう。
     (記憶法: パイプをホットな状態にしておくために使う。)


 -- Method: output_field_separator HANDLE EXPR
 -- Variable: $OUTPUT_FIELD_SEPARATOR
 -- Variable: $OFS
 -- Variable: $,
     print 演算子のための出力フィールドセパレータ。通常 `print' 演算子
     は、コンマで区切って指定したフィールドを単純に印字します。より、
     awk に近い動作をさせるには、フィールドの区切りとして印字されるもの
     として awk の変数 OFS に設定するものを、この変数に設定します。(記
     憶法: print 文で , を書いた場所に印字されるもの。)


 -- Method: output_record_separator HANDLE EXPR
 -- Variable: $OUTPUT_RECORD_SEPARATOR
 -- Variable: $ORS
 -- Variable: $\
     `print' 演算子のための出力レコードセパレータ。通常`print' 演算子は、
     コンマで区切って指定したフィールドを単純に印字し、改行などレコード
     セパレータと想定するものをつけません。より、awk に近い動作をさせる
     には、print の最後に印字されるものとして awk の変数 ORS に設定する
     ものを、この変数に設定します。(記憶法: print の最後に \n を付け加
     える代わりに "$\" を設定する。また、/ に似通っているが、Perl から
     「バック」されるものです。)


 -- Variable: $LIST_SEPARATOR
 -- Variable: $"
     "$," と同様ですが、これは 2 重引用符で括られた文字列(または、同様
     に扱われる文字列) 内で配列値が展開される際に適用されます。デフォル
     トではスペースになっています。(記憶法: 明らかでしょう。)


 -- Variable: $SUBSCRIPT_SEPARATOR
 -- Variable: $SUBSEP
 -- Variable: $;
     多次元配列のエミュレートのための添え字の区切文字。ハッシュの要素を

          $foo{$a,$b,$c}

     のようにして参照すると、実際には

          $foo{join($;, $a, $b, $c)}

     という意味になります。しかし、

          @foo{$a,$b,$c}      # スライス -- @ に注意

     としてはいけません。これは、

          ($foo{$a},$foo{$b},$foo{$c})

     という意味になります。

     デフォルトは "\034" で、awk の SUBSEP と同じです。使おうとしている
     key の値がバイナリのデータを含むならば、"$;" に設定する安全な値な
     どはないことになります。(記憶法: コンマ (構文上の添え字区切り文字)
     はセミ−セミコロンなのです。ええ、詭弁だとはわかってますが、"$,"
     はもう既にもっと重要な任務を持ってるんです。)

     Perl 5 では「本物の」多次元配列を使うようにしてください。


 -- Variable: $OFMT
 -- Variable: $#
     数字を印字する際の出力フォーマット。この変数は、不十分ではあります
     が、awk の変数 OFMT をエミュレートしようとするものです。しかしなが
     ら、awk と Perl は異なる記法で数値を表わしています。また、初期値は
     %.6gではなく、%.20g となっていますので、awk での値を得るには、明示
     的に "$#" を設定する必要があります。(記憶法: # は数値記号です。)

     Perl 5 では "$#" を使わないようにしてください。


 -- Method: format_page_number HANDLE EXPR
 -- Variable: $FORMAT_PAGE_NUMBER
 -- Variable: $%
     その時点で選択されている出力チャネルの、その時点でのページ番号。
     (記憶法: % は、nroff でのページ番号です。)


 -- Method: format_lines_per_page HANDLE EXPR
 -- Variable: $FORMAT_LINES_PER_PAGE
 -- Variable: $=
     その時点で選択されている出力チャネルの、その時点でのページ長 (印字
     可能行数)。デフォルトは 60 です。(記憶法: = には複数の水平線 (行)
     が含まれます。)


 -- Method: format_lines_left HANDLE EXPR
 -- Variable: $FORMAT_LINES_LEFT
 -- Variable: $-
     その時点で選択されている出力チャネルの、ページに残っている行数。
     (記憶法: "ページ行数" - "印字済み行数")


 -- Method: format_name HANDLE EXPR
 -- Variable: $FORMAT_NAME
 -- Variable: $~
     その時点で選択されている出力チャネルの、その時点でのフォーマット名。
     デフォルトでは、ファイルハンドルと同名。(記憶法: "$^" の兄弟。)


 -- Method: format_top_name HANDLE EXPR
 -- Variable: $FORMAT_TOP_NAME
 -- Variable: $^
     その時点で選択されている出力チャネルの、その時点でのページ先頭フォー
     マット名。デフォルトでは、ファイルハンドル名に _TOP を続けたもの。
     (記憶法: ページの先頭へのポインタ。)


 -- Method: format_line_break_characters HANDLE EXPR
 -- Variable: $FORMAT_LINE_BREAK_CHARACTERS
 -- Variable: $:
     フォーマットの充填継続フィールド (^ で始まるもの) への文字列で行分
     割を許す文字集合。デフォルトは " \n-"で空白か改行の後で行分割が可
     能となっています。(記憶法: 詩では「コロン」は、行の一部。)


 -- Method: format_formfeed HANDLE EXPR
 -- Variable: $FORMAT_FORMFEED
 -- Variable: $^L
     フォーマット出力で、改ページのために出力されるもの。デフォルトは
     f。


 -- Variable: $ACCUMULATOR
 -- Variable: $^A
     `format' 行のための、その時点での `write()' アキュムレータの値。
     format には、$^A に結果を残す、`formline()' コマンドが含まれます。
     自分のフォーマットを呼び出した後で、`write()' は $^A の内容を出力し
     てから消去します。したがって、自分で `formline()' を呼び出すのでな
     ければ、$^A の値が見えることはありません。*Note フォーマット文::,と
     *Note 組み込み関数::,の `formline()' の項を参照してください。


 -- Variable: $CHILD_ERROR
 -- Variable: $?
     最後に `close' したパイプ、バッククォート (``) コマンド、
     `system()' 演算子が返したステータス。このステータスワードは
     `wait()' システムコールが返したものですから、サブプロセスの exit
     値は、実際には ($? >> 8) であることに注意してください。つまり多く
     のシステムで$? & 255 は、もしあれば、そのプロセスを止めたシグナル
     とコアダンプがあるかどうかを示します。(記憶法: sh や ksh と同様。)


 -- Variable: $OS_ERROR
 -- Variable: $ERRNO
 -- Variable: $!
     数値コンテキストで用いられると、その時点の errno の値が (通常の注
     意事項と供に) 得られます。(これは、システムエラーを示す特定のエラー
     が得られた場合でもなければ、"$!" の値が、特に何かを示すものである
     と、頼ってはならないということです。)文字列コンテキストで使われる
     と、対応するシステムエラーのメッセージ文字列が得られます。たとえば、
     $!" にエラーの文字列を返して欲しいならば、errno を設定するため、あ
     るいは、die() 演算子の exit 値を設定するために、"$!" へ代入を行な
     うことが可能です。(記憶法: 何が bang(!) したか。)


 -- Variable: $EVAL_ERROR
 -- Variable: $@
     最後の eval() コマンドによる Perl の構文エラーメッセージです。空文
     字列であれば、最後の eval() が正常に解析され、実行されたことになり
     ます (が、実行した演算子が、通常の意味で失敗しているかもしれませ
     ん)。(記憶法: どこで ("at" where) 構文エラーが起ったか。)


 -- Variable: $PROCESS_ID
 -- Variable: $PID
 -- Variable: $$
     スクリプトを実行している Perl のプロセス番号です。(記憶法: シェル
     と同じ。)


 -- Variable: $REAL_USER_ID
 -- Variable: $UID
 -- Variable: $<
     本プロセスの実 uid を示します。(記憶法: setuid で実行中であれば、
     そこ「から」来た uid です。)


 -- Variable: $EFFECTIVE_USER_ID
 -- Variable: $EUID
 -- Variable: $>
     本プロセスの実効 uid を示します、例:

          $< = $>;            # 実 uid に実効 uid を設定
          ($<,$>) = ($>,$<);  # 実 uid と実効 uid を交換

     (記憶法: setuid で実行中であれば、そこ「へ」行く uidです。)"$<" と
     $>" の交換は、setreuid() をサポートしているマシンでのみ可能です。


 -- Variable: $REAL_GROUP_ID
 -- Variable: $GID
 -- Variable: $(
     本プロセスの実 gid を示します。同時に複数のグループに所属できるマ
     シンでは、所属するグループをスペースで区切ったリストが得られます。
     最初の数値は、getgid() で返されるものです。その後に getgroups()が
     返す値が続き、その中の 1 つは、最初の値と同じかもしれません。(記憶
     法: 括弧は、グループ化に使われます。setgid で実行中であれば、実
     gid は LEFT した、つまり離れたグループです。)


 -- Variable: $EFFECTIVE_GROUP_ID
 -- Variable: $EGID
 -- Variable: $)
     本プロセスの実効 gid を示します。同時に複数のグループに所属できる
     マシンでは、所属するグループをスペースで区切ったリストが得られます。
     最初の数値は、`getegid()' で返されるものです。その後に
     `getgroups()' が返す値が続き、その中の 1 つは、最初の値と同じかも
     しれません。(記憶法: 括弧は、グループ化に使われます。setgid で実行
     中であれば、実効 gid は RIGHT な、つまり正しいグループです。)

     注: "$<"、"$>"、"$("、"$)" は、実行するマシンで、対応する
     `set[re][ug]id()' ルーティンがサポートされているときにのみ設定可能
     です。"$(" と "$)" の交換は、`setregid()' がサポートされているマシ
     ンでのみ可能です。


 -- Variable: $PROGRAM_NAME
 -- Variable: $0
     実行されている Perl スクリプトの、ファイル名を示します。"$0" に代
     入を行なうと、ps(1) プログラムが覗く、引数エリアを修正します。実行
     しているプログラムを隠すよりは、実行中のプログラムの状態を表示する
     ときに、使うとよいでしょう。(記憶法: sh や ksh と同じ。)


 -- Variable: $[
     配列の最初の要素や、文字列の最初の文字のインデクスを示します。デフォ
     ルトは 0 ですが、`index()' 関数や `substr()' 関数を評価するときに、
     Perl の動作をより awk (や Fortran) に近づけるため、1 に設定するこ
     ともできます。(記憶法: [ は添え字付けの始め。)

     Perl 5 では "$[" への代入は、コンパイラへのディレクティブとして扱
     われ、他のファイルの動作に影響を与えることがなくなりました。この変
     数は使わないようにしてください。


 -- Variable: $PERL_VERSION
 -- Variable: $]
     `perl -v' としたときに表示される文字列を示します。スクリプトの最初
     で、そのスクリプトを実行しているインタプリタのバージョンが適切な範
     囲内にあるかを調べる、といったことができます。数値コンテキストで使
     われると、version + patchlevel / 1000 が返されます。例:

          # ファイル名補完の確認 (5.000 ではバグ)
          ($version,$patchlevel) = $] =~ /(\d+\.\d+).*\nPatch level: (\d+)/;
          print STDERR "(No filename completion available.)\n"
                if $version * 1000 + $patchlevel < 2016;

     あるいは、数値的に

          warn "No checksumming!\n" if $] < 3.019;

     (記憶法: Perl のバージョンは、正しい範囲 (right bracket) にあるか。)


 -- Variable: $DEBUGGING
 -- Variable: $^D
     デバッグフラグの現在の値を示します。(記憶法: `-D' スイッチの値。)


 -- Variable: $SYSTEM_FD_MAX
 -- Variable: $^F
     システムが使用するファイル記述子の最大値を示し、通常は 2 です。シ
     ステムファイル記述子は、`exec()' されたプロセスに渡されますが、そ
     れ以降のファイル記述子は渡されません。また、`open()' の実行中は、
     システムファイル記述子は、たとえ `open()' が失敗しても、保存されま
     す。(通常のファイル記述子は、`open()' が実行される前にクローズされ
     ます。)ファイル記述子の close-on-execのステータスは、exec 時ではな
     く、open 時の $^F の値によって決められます。


 -- Variable: $INPLACE_EDIT
 -- Variable: $^I
     置き換え編集の拡張子の値を示します。置き換え編集を禁止するためには、
     `undef' を設定します。(記憶法: `-i' スイッチの値。)


 -- Variable: $PERLDB
 -- Variable: $^P
     デバッガが自分自身をデバッグしないようにクリアする、内部フラグです。
     これをクリアして、デバッグしないようにすることも考えられます。


 -- Variable: $BASETIME
 -- Variable: $^T
     スクリプトを実行開始した時刻を、紀元 (1970) からの秒数で示したもの
     です。ファイルテスト `-M', `-A', `-C' で返される値は、この値に基づ
     いています。


 -- Variable: $WARNING
 -- Variable: $^W
     警告スイッチの値で、真か偽が設定されます。(記憶法: `-w' スイッチに
     関係します。)


 -- Variable: $EXECUTABLE_NAME
 -- Variable: $^X
     Perl バイナリ自身が実行された時の名前を C の argv[0]から持ってきた
     ものです。


 -- Variable: $ARGV
     <> から読込みを行なっているとき、その時点のファイル名を示します。


 -- Variable: @ARGV
     配列 @ARGV は、コマンドラインからスクリプトに渡す引数が入れられま
     す。$ARGV[0] がコマンド名ではなく、最初の引数ですから、$#ARGV は一
     般には、引数の個数 - 1となります。コマンド名については、"$0" を参
     照してください。


 -- Variable: @INC
     配列 @INC には、`do EXPR', `require', `use' によって評価する Perl
     スクリプトを探す場所のリストが納められています。初期状態では、コマ
     ンドラインスイッチ -I の引数とデフォルトの Perl ライブラリディレク
     トリ (おそらく"/usr/local/lib/perl5") とカレントディレクトリを表わ
     す "." を順につなげたものです。


 -- Variable: %INC
     ハッシュ %INC は、`do' や `require' によってインクルードされた、個々
     のファイル名をエントリとして持っています。key は指定したファイル名
     で、value は実際に見つかった場所となっています。`require' コマンド
     は、指定されたファイル名が既にインクルードされているかを、この配列
     を使って調べます。


 -- Variable: $ENV{expr}
     ハッシュ %ENV には、その時点の環境変数が設定されています。%ENV に
     値を設定することで、チャイルドプロセスの環境変数を変更します。


 -- Variable: $SIG{expr}
     ハッシュ %SIG は、さまざまなシグナルのハンドラを設定するのに使用さ
     れます。例:

          sub handler {       # 第一引数はシグナル名
              local($sig) = @_;
              print "Caught a SIG$sig--shutting down\n";
              close(LOG);
              exit(0);
          }

          $SIG{'INT'} = 'handler';
          $SIG{'QUIT'} = 'handler';
          ...
          $SIG{'INT'} = 'DEFAULT';    # デフォルトに戻す
          $SIG{'QUIT'} = 'IGNORE';    # SIGQUIT を無視する

     配列 %SIG には、Perl スクリプト内で実際に設定されたシグナルに対す
     る値だけを保持しています。いくつか他にも例を示します:

          $SIG{PIPE} = Plumber;       # やめて !!
          $SIG{"PIPE"} = "Plumber";   # よい、main::Plumber を仮定
          $SIG{"PIPE"} = \&Plumber;   # よい、現在の Plumber を仮定
          $SIG{"PIPE"} = Plumber();   # え？ Plumber() が返したもの？

     「やめて」と書いたのは、裸の単語なので、問題となるからです。時には
     関数を表現する文字列となりますが、時にはその時点、その場所で呼び出
     されるサブルーティンコールとなるからです。確実にする最善の方法は、
     クォートするか、リファレンスをとることです。*Plumber でもかまいま
     せん。*Note サブルーティン::,を参照してください。




File: perl-ja.info, Node: サブルーティン, Next: モジュールについて, Prev: 定義済み変数, Up: Top

サブルーティン
**************


Synopsis
========

サブルーティンの宣言:
          sub NAME;      # 「前方」宣言
          sub NAME BLOCK # 宣言かつ定義

サブルーティンのインポート:
          use PACKAGE qw(NAME1 NAME2 NAME3);

サブルーティンの呼び出し:
          &NAME          # その時点の @_ をサブルーティンに渡す。
          &NAME(LIST);   # & 形式では、引数に括弧が必要。
          NAME(LIST);    # 括弧があるときには & はなくてもよい。
          NAME LIST;     # 宣言済み/インポート済みのとき括弧はなく
                         # てもよい。




Description
===========

サブルーティンに渡された引数は、配列 @_ (すなわち $_[0], $_[1], ...) と
して参照できます。配列 @_ はローカルな配列ですが、その値は実際のスカラ
引数へのリファレンスです。サブルーティンが返却する値は、最後に評価された
値であり、リスト値である場合も、スカラ値である場合もあります。これとは別
に、return 文を使うと、返却する値を指定して、サブルーティンから抜けるこ
とができます。ローカルな変数を作るには、*Note 組み込み関数::,の
`local()' 演算子と `my()' 演算子を参照してください。

サブルーティンは、"&" という記号を頭に付けて呼び出すことができます。
Perl 5 では、"&" はなくてもよく、宣言済みのときには、括弧も省略できます。
(ただし、`defined()' や `undef()' の引数として使う場合のように、サブルー
ティンを名指しするときには"&" は省略できないことに気を付けてください。
また、サブルーティン名や、`&$subref()' や `&{$SUBREF}()' 構造を使ったリ
ファレンスでサブルーティンの間接呼び出しをするときにも省略できません。
さらには、*Note リファレンスとデータ構造のネスト::,を参照してください。)

例:
     sub MAX {
         my $max = pop(@_);
         foreach $foo (@_) {
             $max = $foo if $max < $foo;
         }
         $max;
     }
     ...
     $bestday = &MAX($mon,$tue,$wed,$thu,$fri);

例:
     # 空白で始まる行をつなげて、1 行入力する

     sub get_line {
         $thisline = $lookahead;
         LINE: while ($lookahead = <STDIN>) {
             if ($lookahead =~ /^[ \t]/) {
                 $thisline .= $lookahead;
             }
             else {
                 last LINE;
             }
         }
         $thisline;
     }

     $lookahead = <STDIN>;       # 最初の行を先読み
     while ($_ = get_line()) {
         ...
     }

形式引数に名前を付けるには、ローカルリストへの配列代入を行ないます:

     sub maybeset {
         my($key, $value) = @_;
         $foo{$key} = $value unless $foo{$key};
     }

代入では値をコピーしますから、参照呼び出しのサブルーティンを値呼び出し
のサブルーティンに変える働きもあります。

サブルーティンは再帰的に呼び出すこともできます。サブルーティンを "&" 形
式で呼び出す場合、引数リストは省略できます。省略した場合には、そのサブ
ルーティンに対しては、@_ 配列が設定されません。呼び出し時点での配列 @_
が、そのままサブルーティン側でも見えることになります。

     &foo(1,2,3);        # 3 つの引数を渡す
     foo(1,2,3);         # 同じ

     foo();              # 空リストを渡す
     &foo();             # 同じ
     &foo;               # 何も渡さない (より効率的)


* Menu:

* シンボルテーブルのエントリを渡す::
* 組み込み関数の再定義::
* 自動ロード::





File: perl-ja.info, Node: シンボルテーブルのエントリを渡す, Next: 組み込み関数の再定義, Prev: サブルーティン, Up: サブルーティン

シンボルテーブルのエントリを渡す
================================

[注意:この節で記述する機能は Perl 5 でもちゃんと動作しますが、一般的には
新規に追加されたリファレンス機能の方が扱いやすいでしょう。
*Note リファレンスとデータ構造のネスト::, を参照してください。]

配列のローカルなものではなく、グローバルなものの変更ができるように、配
列の値ではなく、名前を渡したいようなことがあるでしょう。Perl では、名前
の前にアスタリスクをつけて、`*foo' のようにして、特定の名前のすべてのオ
ブジェクトを参照することができます。先頭のアスタリスクは、変数やサブルー
ティンに付ける記号すべてにマッチする、ワイルドカードのように考えること
ができますから、よく「型グロブ」とよばれます。

型グロブは評価されると、その名前のすべてのオブジェクト (これには、ファ
イルハンドル、フォーマット、サブルーティンなども含まれます) を参照する
スカラ値となります。代入されると、指定された名前で、"*" 値に代入された
ものを参照するようになります。例:

     sub doubleary {
         local(*someary) = @_;
         foreach $elem (@someary) {
             $elem *= 2;
         }
     }
     doubleary(*foo);
     doubleary(*bar);

スカラ値は、サブルーティンに対して、すでにリファレンスとして渡されてい
ますから、この機能を使わなくても、明示的に $_[0]などを参照して、スカラ
引数を修正することができます。配列の要素をすべてスカラとして渡すことで、
その全部の要素を変更することができますが、`push'、`pop' や配列の大きさ
を変えるなどの操作には、* の機能 (あるいは同等のリファレンスの機能) を
使う必要があります。型グロブ (やリファレンス) を渡す方が確実に速くなり
ます。

配列を変更したい場合でなくても、1 つの LIST のなかで、複数の配列を渡し
たいときなどに、この方法が役に立ちます。通常は、LIST のしくみによって、
配列の値がつなげられていまうので、配列を個々に取り出すことができなくなっ
てしまうからです。





File: perl-ja.info, Node: 組み込み関数の再定義, Next: 自動ロード, Prev: シンボルテーブルのエントリを渡す, Up: サブルーティン

組み込み関数の再定義
====================

多くの組み込み関数は、再定義することができますが、これは、ちゃんとした
理由があるときに限って行なうべきです。UNIX 以外のシステムで、実装されて
いない組み込み関数をエミュレートするために使われるのが普通でしょう。

再定義は、モジュールから名前をインポートすることでのみ行なうことができ、
通常の前方宣言は十分ではありません。しかし、subs プラグマ (コンパイラディ
レクティブ) を使うと、インポート構文で前方宣言されたものと同様に有効と
なり、組み込み関数をその名前で再定義することができます:

     use subs 'chdir', 'chroot', 'chmod', 'chown';
     chdir $somewhere;
     sub chdir { ... }

ライブラリモジュールは一般に、デフォルトの @EXPORT リストの一部として
`open' や `chdir' といった組み込みの名前をエクスポートすべきではありま
せん。これらの名前は、思わぬところの名前空間に侵入して、思わぬように意
味を変えてしまうかも知れないからです。その代わりに、モジュール側で
@EXPORT_OK に名前を入れておけば、使用する側では暗黙にではなく、明示的に
インポートすることができるようになります。つまり、

     use Module 'open';

とは書くことができ、`open' をインポートして再定義しますが、

     use Module;

とした場合には、再定義の無いデフォルトのインポートが行なわれます。





File: perl-ja.info, Node: 自動ロード, Prev: 組み込み関数の再定義, Up: サブルーティン

自動ロード
==========

もし、未定義のサブルーティンを呼び出した場合には、通常はすぐに、「サブ
ルーティンがない」というコンパイル時の致命的エラーになります。(メソッド
として使われるサブルーティンも同様で、そのクラスのどの基底クラスにもメ
ソッドが存在しない場合に、エラーとなります。) しかし、`AUTOLOAD' という
サブルーティンが、そのパッケージか、もとのサブルーティンが探されるサブ
ルーティンで定義されていれば、その `AUTOLOAD' サブルーティンが、もとの
サブルーティンを呼び出すときに渡すはずだった引数を使って、呼び出されま
す。もとのサブルーティンの完全な名前は、`AUTOLOAD'ルーティンとして、同
じパッケージの変数 $AUTOLOAD に記録されています。名前は、普通の引数とし
ては渡されません。というのは、あー、その、だから ...

多くの `AUTOLOAD' ルーティンは、`eval' を用いて、問題のサブルーティンの
定義をロードし、そのサブルーティンを、トレースなしに`AUTOLOAD' ルーティ
ンのスタックフレームを消してくれる、特殊な形式の `goto' を使って呼び出
します。(たとえば、標準の`AutoLoader' モジュールを参照してください。)し
かし、改めて定義を行なわずに、`AUTOLOAD' ルーティン自身で、実行されるは
ずのルーティンをエミュレートすることも可能です。この形式の良い例として
は、未定義のサブルーティン呼び出しを UNIX プログラムへの呼び出しとして
扱う、標準の `Shell' モジュールがあげられます。

モジュールが自分自身を、標準の `AutoLoader' モジュールといっしょに使用
するために、自動ロード可能なファイルに分割するのを補助するしくみが用意
されています。拡張モジュールに関するドキュメントを参照してください。





File: perl-ja.info, Node: モジュールについて, Next: リファレンスとデータ構造のネスト, Prev: サブルーティン, Up: Top

モジュールについて
******************

* Menu:

* パッケージ::
* シンボルテーブル::
* パッケージのコンストラクタとデストラクタ::
* クラス::
* モジュール::
* モジュールライブラリ::
* プラグマ的モジュール::
* 標準モジュール::
* 拡張モジュール::





File: perl-ja.info, Node: パッケージ, Next: シンボルテーブル, Prev: モジュールについて, Up: モジュールについて

パッケージ
==========

Perl には、パッケージどうしがお互いの変数を踏みにじることが無いように、
名前空間を別ける機構が用意されています。デフォルトでは、Perl スクリプト
は `main' と言われるパッケージで、コンパイルを始めます。名前空間を
切り替えるには、`package' 宣言を使います。`package' 宣言のスコー
プは、その宣言の場所から、囲っているブロックの終わりまでです
(`local()' 演算子と同じスコープです)。`require' 演算子でインク
ルードされるファイルの、最初の宣言となるのが普通です。複数の場所で、同一
のパッケージに切り替えることもできます。この宣言は、ブロックの残りの部分
で、コンパイラがどのシンボルテーブルを使うのかに影響を与えるだけです。他
のパッケージの変数やファイルハンドルは、識別子名の前に、
`$Package::Variable' のようにパッケージ名とコロン 2 つで「修飾」す
ることで、参照することができます。パッケージ名が空の場合には、
`main' パッケージを参照しているものとみなされます。つまり、
`$::sail' は、`$main::sail' と同じです。

(以前はパッケージの区切文字にシングルクォートを使っていましたが、現在は
ダブルコロンが使われます。人間が読みやすいからであり、Emacs マクロが読
みやすいからです。また、C++ のプログラマが、何が起こっているかを理解し
やすいということもあります。)

パッケージは、`$OUTER::INNER::var' のように、別のパッケージの中にネスト
することもできます。しかし、これが名前の検索順序に関るものではありませ
ん。すべてのシンボルは、その時点のパッケージにローカルであるか、完全な
形でパッケージ名をつけて、外部のパッケージから導入したものでなければな
りません。たとえば、パッケージ `OUTER' にいるとすると、`$INNER::var' と
いう表現は、`$OUTER::INNER::var' を参照します。パッケージ `INNER' は、
まったく独立したグローバルなパッケージとして扱われます。

英字 (または、下線) で始まる識別子のみが、各々のパッケージのシンボルテー
ブルに蓄えることができます。他のすべてのシンボルは、パッケージ main に
置かれます。さらに、識別子 `STDIN'、`STDOUT'、`STDERR'、`ARGV'、
`ARGVOUT'、`ENV'、`INC'、`SIG' は、組み込みの用法とは異なることに使って
も、強制的にパッケージ `main' に置かれます。また、`m'、`s'、`y' という
パッケージを作った場合には、パッケージ名で修飾した形で識別子を使うこと
ができない場合があります。それぞれ、パターンマッチ、置換、変換と解釈さ
れるからです。

(以前は下線で始まる変数は、強制的に `main' パッケージに置かれましたが、
プライベートな変数やメソッドを表わすのに、先頭に下線を使うことができた
方が良いと判断しました。)

`eval()' された文字列は、`eval()' がコンパイルされたパッケージで、コン
パイルされます。(しかし、`$SIG{}' への代入は、指定したシグナルハンドラ
が、パッケージ `main' にあるものとして扱います。シグナルハンドラを別の
パッケージにおきたい場合には、そのシグナルハンドラ名にパッケージ名を付
けてください。)たとえば、Perl ライブラリの `perl5db.pl' を参照してくだ
さい。最初に、デバッグしようとするスクリプトの変数を、デバッガが壊さな
いように、パッケージ `DB' に切り替えます。しかし、多くのポイントで、さ
まざまな式をパッケージ `main' (や、もともと指定してたパッケージ) で評価
するために、一時的にパッケージ `main' に戻るようにしています。*Note デ
バッグ::,を参照してください。





File: perl-ja.info, Node: シンボルテーブル, Next: パッケージのコンストラクタとデストラクタ, Prev: パッケージ, Up: モジュールについて

シンボルテーブル
================

パッケージのシンボルテーブルは、パッケージ名に 2 つのコロンを付けた名前
の連想配列に蓄えられます。つまり、`main' のシンボルテーブルは、
`%main::'、または短く `%::' となります。同様に、先に述べたネストしたパッ
ケージは `%OUTER::INNER::' となります。

連想配列の個々のエントリの value は、*name 記法を使ったときに参照するも
のです。実際、

     local(*main::foo) = *main::bar;
     local($main::{'foo'}) = $main::{'bar'};

は、前者がシンボルテーブルの検索をコンパイル時に行ないますので、より効
率的ですが、同じことを行ないます。

たとえば、これを使って、パッケージ内のすべての変数を出力することができ
ます。

以下は、Perl ライブラリの `dumpvar.pl' です:

     package dumpvar;
     sub main::dumpvar {
         ($package) = @_;
         local(*stab) = eval("*${package}::");
         while (($key,$val) = each(%stab)) {
             local(*entry) = $val;
             if (defined $entry) {
                 print "\$$key = '$entry'\n";
             }

             if (defined @entry) {
                 print "\@$key = (\n";
                 foreach $num ($[ .. $#entry) {
                     print "  $num\t'",$entry[$num],"'\n";
                 }
                 print ")\n";
             }

             if ($key ne "${package}::" && defined %entry) {
                 print "\%$key = (\n";
                 foreach $key (sort keys(%entry)) {
                     print "  $key\t'",$entry{$key},"'\n";
                 }
                 print ")\n";
             }
         }
     }

このサブルーティンは、パッケージ `dumpvar' でコンパイルされているに
も関らず、サブルーティンの名前が修飾されているため、パッケージ
`main' の中に入れられることになります。

シンボルテーブルエントリへの代入は、別名付け操作になります。つまり、

     *dick = *richard;

は、`richard' という名前でアクセスできる変数、サブルーティン、ファイル
ハンドルを `dick' という名前でもアクセスできるようにします。リファレン
スを使えば、特定の変数だけ、サブルーティンだけ、というように個別に別名
を付けることができます:

     *dick = \$richard;

は、$richard と $dick を同じ変数にしますが、@richard と @dickは別の配列
のままです。難しいですか。





File: perl-ja.info, Node: パッケージのコンストラクタとデストラクタ, Next: クラス, Prev: シンボルテーブル, Up: モジュールについて

パッケージのコンストラクタとデストラクタ
========================================

パッケージのコンストラクタとデストラクタとして機能する、2 つの特別なサ
ブルーティン定義があります。それは、BEGIN ルーティンと END ルーティンで
す。このルーティンでは `sub' は省略できます。

BEGIN サブルーティンは、できるだけ早く、つまり、たとえファイルの残りが
解析されていなくても、定義された瞬間に実行されます。ファイル内に複数の
BEGIN ブロックを置くこともでき、定義された順番に実行されます。BEGIN ブ
ロックは即座に実行されるため、サブルーティンなどの定義を他のファイルか
ら読み込んで、ファイルの残りの部分から見えるようにすることができます。

END サブルーティンは、できるだけ遅く、つまり、たとえ `die()' 関数の結果
であっても、インタプリタが終了するときに実行されます。(しかし、シグナル
によって決壊してしまう時には実行されません。(できるものなら、) 自分でト
ラップしなければなりません。)ファイル内に複数の END ブロックを置くこと
もでき、定義とは逆の順序で実行されます。つまり、ラストインファーストア
ウト (LIFO) ということです。

Perl に `-n' や `-p' スイッチを使ったときには、 BEGIN と END は、縮退し
たケースとして、awk と同じように動作します。





File: perl-ja.info, Node: クラス, Next: モジュール, Prev: パッケージのコンストラクタとデストラクタ, Up: モジュールについて

クラス
======

Perl 5 には、特別なクラスのための構文はありませんが、メソッドとして機能
するサブルーティンを持つパッケージは、クラスとして機能することができま
す。そのようなパッケージでは、他のクラスパッケージの名前を配列 @ISA に
並べることで、そのクラスからメソッドのいくつかを引き込んでくることがで
きます。このことについて詳しくは、*Note オブジェクト::,を参照してくださ
い。





File: perl-ja.info, Node: モジュール, Next: モジュールライブラリ, Prev: クラス, Up: モジュールについて

モジュール
==========

Perl 5 では、パッケージの概念は、モジュールの概念に拡張されました。モ
ジュールは同じ名前のライブラリファイルで定義されたパッケージで、再利用
可能なように設計されたものです。そのモジュールを使用する、任意のパッケー
ジのシンボルテーブルに、自分のシンボルのいくつかをエクスポートする機能
を用意することでこれを行なっているともいえます。あるいは、モジュールは
クラス定義として機能することもでき、明示的にシンボルをエキスポートしな
くても、クラスやそのオブジェクトに対するメソッド呼び出しを通して、暗黙
のうちに意味が通じるようにすることができます。

Perl のモジュールは、

     use Module;

か、あるいは

     use Module LIST;

としてインクルードします。これは、

     BEGIN { require "Module.pm"; import Module; }

か、あるいは

     BEGIN { require "Module.pm"; import Module LIST; }

とするのと、全く同じことです。

Perl のモジュールはすべて `.pm' という拡張子を持ち、`use' は、これをデ
フォルトにしていますので、クォートで括って、"Module.pm"と書く必要はあり
ません。これはまた、新しいモジュールと古い`.pl' ファイルや `.ph' ファイ
ルとに差を設けるのにも役立っています。モジュール名は、プラグマとして働
くもの以外は、先頭を大文字にします。「プラグマ」は、コンパイラディレク
ティブであり、「プラグマ的モジュール」(あるいは、古典学者であれば「プラ
グマタ」) と呼ぶ人もあります。

`use' 文は、BEGIN ブロックを使っていますので、内容のインポートは、
`use' 文がコンパイルされるとき、ファイルの残りがコンパイルされる前に行
なわれます。それで、モジュールがプラグマとして機能することができ、また、
現在のファイルの残りの部分でリスト演算子として参照することのできるサブ
ルーティンの宣言ができるのです。これは、`use' の代わりに `require' を使っ
たのでは、うまく働きません。したがって、名前空間を変更するモジュールを
作ろうとしているのであれば、`use' を使い、さもなくば `require' を使いま
す。そうしないと、以下のような問題が起こります:

     require Cwd;                # Cwd:: を使えるようにする
     $here = Cwd::getcwd();

     use Cwd;                    # Cwd:: から名前をインポート
     $here = getcwd();

     require Cwd;                # Cwd:: を使えるようにするが
     $here = getcwd();           # main::getcwd() がない

Perl のパッケージは、他のパッケージ名の中にネストすることができますから、
`::' を含むパッケージ名を使えます。しかし、そのパッケージ名を直接、ファ
イル名として使うと、役に立たないものになるか、システムによってはファイ
ル名として使えません。そこで、`Text::Soundex' といったモジュール名であ
れば、その定義は、実際には `Text/Soundex.pm' というライブラリファイルに
置かれます。

Perl のモジュールは常に `.pm' ファイルを持っていますが、そのモジュール
に対応して、動的にリンクされる実行ファイルや、自動ロードサブルーティン
定義が存在する場合があります。そうなら、それらは、モジュールのユーザに
も完全に透過的に見えます。追加機能をロードする (あるいは、自動ロードの
準備をする) のは`.pm' ファイルの責任となります。`POSIX' モジュールは、
たまたま、動的ロードも自動ロードも行ないますが、使う側は、すべてを使え
るようにするために `use POSIX' と書くことができるだけです。

拡張モジュールの記述に関してさらに詳しくは、*Note 応用プログラムインタ
フェース::,や*Note 拡張を行なうための内部関数::,を参照してください。



モジュールについての注釈
------------------------
C++ や Ada や Modula-17 といった言語で行なわれているような、プライベー
ト部とパブリック部を分けるといったことは、Perl では行なっていません。
Perl は、強制されたプライバシーなどには興味がありせん。招かれたわけでは
ないから、リビングに入らない方がよいのであって、ショットガンがあるから
入らない方がよいのではありません。

モジュールとそのユーザの間には契約があります。一部は、非成文慣習法的な
ものであり、一部は「成文化」されたものです。慣習契約には、モジュールは
頼まれない限り名前空間を汚さない、ということがあります。モジュールの成
文化契約 (AKA ドキュメント) は、別の規約を作るかもしれません。しかし、
`use RedefineTheWorld' して、世界を再定義することで、結果を甘受するので
す。





File: perl-ja.info, Node: モジュールライブラリ, Next: プラグマ的モジュール, Prev: モジュール, Up: モジュールについて

モジュールライブラリ
====================

Perl の配布には、多くのモジュールが含まれています。これらについては、以
下に記述しており、すべて `.pm' で終わるようになっています。ライブラリディ
レクトリには、 `.pl' や `.ph' で終わるファイルがあることも発見するかも
しれません。これらの古いライブラリが提供されていますので、これを使う古
いプログラムも実行できます。h2ph で作られた `.ph' ファイルは、h2xs で作
られる拡張モジュールとなるかもしれません。(いくつかの `.ph' の値は既に、
POSIX モジュールで使用できるかもしれません。)配布の中の pl2pm ファイル
は、変換の手助けになるかもしれませんが、機械的な処理でしかないので、
「何でもこい」というものではありません。




File: perl-ja.info, Node: プラグマ的モジュール, Next: 標準モジュール, Prev: モジュールライブラリ, Up: モジュールライブラリ

プラグマ的モジュール
--------------------

これらは、プラグマのようにして動作し、プログラムのコンパイルに影響を与
えるもので、通常 `use' や `no' といっしょに使ったときに正常に動作します。
ローカルなスコープが存在しますから、内側の BLOCK で

     no integer;
     no strict 'refs';

として、撤回すれば、その BLOCK の最後までが影響されます。

以下のプログラムが定義され (て、独自のドキュメントを持っ) ています。

integer
     double の代わりに整数で演算を行なう Perl プラグマ

less
     コンパイラからのリソースを少なく要求するプラグマ

sigtrap
     不慮のシグナルで、スタックのバックとレースを許可する Perl プラグマ

strict
     安全でない構文を制限する Perl プラグマ

subs
     sub 名を、あらかじめ定義する Perl プラグマ





File: perl-ja.info, Node: 標準モジュール, Next: 拡張モジュール, Prev: プラグマ的モジュール, Up: モジュールライブラリ

標準モジュール
--------------

以下のもっジュールはすべて、`Exporter' モジュールを使用しているので、名
前空間の汚染に関してうまいやり方で動作することが、期待されます。詳しく
は、各々のドキュメントを参照してください。

Abbrev
     リストから省略形一覧を作成する

AnyDBM_File
     複数の DBM ファイルを扱う枠組みを与える

AutoLoader
     要求時にのみ関数をロードする

AutoSplit
     自動ロードのためにパッケージを分割する

Basename
     ファイル記述から、ファイル名とパス名を解析する

Benchmark
     コードの実行時ベンチマークを行なう

Carp
     (呼び元の観点からの) エラーの `warn' と `die'

CheckTree
     トリー上で多くのファイルテストチェックを行なう

Collate
     その時点の locale にしたがって、8-bit スカラデータを比較する

Config
     Perl の `config' オプションをアクセスする

Cwd
     カレントディレクトリのパス名を取得する

DynaLoader
     C ライブラリを Perl のコードに動的ロードする

English
     醜い記号のような変数名の代わりに、うまい英語 (あるいは awk) の名前
     を使う

Env
     環境変数をインポートする Perl モジュール

Exporter
     名前空間操作を制御するモジュール

Fcntl
     C の `fcntl.h' 定義をロードする

FileHandle
     ファイルハンドルに対し、オブジェクトメソッドを提供する

Find
     ファイルトリーのトラバースする

Finddepth
     ディレクトリ構造を、深度優先でトラバースする

Getopt
     getopt(3) 処理の基本的なものと拡張されたもの

MakeMaker
     Perl 拡張モジュールの `Makefile' を生成する

Open2
     読み書き両用のプロセスをオープンする

Open3
     読み書き、エラー処理のためのプロセスをオープンする

POSIX
     IEEE 1003.1 名前空間への Perl インタフェース

Ping
     ホストの起動状態を確認する

Socket
     C の `socket.h' 定義をロードする





File: perl-ja.info, Node: 拡張モジュール, Prev: 標準モジュール, Up: モジュールライブラリ

拡張モジュール
--------------

拡張モジュールは、C (あるいは、Perl と C の混成) で書かれ、それが必要に
なることがあれば、動的にロードされるものです。サポートされている拡張モ
ジュールには `Socket' モジュール、`Fcntl' モジュール、`POSIX' モジュー
ルが含まれます。

以下は、一般的な C の拡張モジュールで、Perl 5.0 のリリース時に利用可能
ですが、大きさの問題や、変更が多いなどの理由や、単純に適切なテストや、
Perl がベータテストされた多くの環境での構築の時間がとれなかったために
(少なくとも完全には) バンドルされていません。現状や場所を尋ねてランダム
に投稿する前に、archie(1L) や Perl FAQ、Meta-FAQ、WWW page、あるいは作
者自身に頼って、探すことをお勧めします。出力以降に、以下の名前やアドレ
スが変わっていないという保証はありませんし、事実変わっています。

Curses
     William Setzer <William_Setzer@ncsu.edu> が書いたもので、標準の配
     布には含まれませんが、この拡張モジュールは、多くのシステムに移植さ
     れています。お近くの Perl アーカイブサイトか、

          ftp://ftp.ncsu.edu/pub/math/wsetzer/cursperl5??.tar.gz

     から FTP してください。これは、現在アルファテスト中ですので、名前
     や ftp の場所は変わるかもしれません。

DBI
     <Tim.Bunce@ig.co.uk> が書いたポータブルなデータベースインタフェー
     スです。これは、perl4 になされた、多くのデータベースを扱うための移
     植に置き変わるものです。DBperl 拡張の正規のアーカイブは、
     `ftp.demon.co.uk:/pub/perl/db' です。このアーカイブには、rdb、
     shql といった non-SQL システムはもとより、Ingres、Oracle、Sybase、
     Informix、Unify、Postgres、Interbase のための perl4 の移植が含まれ
     ています。

DB_File
     DBM との組み合わせで最も速く、制限が最も少ない、この拡張モジュール
     は、ハッシュに `tie()' するために、一般的なバークレイ DB を使いま
     す。これには、標準的に配布される man page や動的ロード拡張モジュー
     ルが含まれていますが、バークレイのコードは、自分で入手する必要があ
     ります。どこにあるかについては、DB_File manapge を参照してください。

Sx
     この拡張モジュールは、Perl GUI プログラミングのための Athena と
     Xlib のフロントエンドとなるもので、Dominic Giampaolo
     <dbg@sgi.com> が書いたものを Frederic Chauveau <fmc@pasteur.fr> が
     Sx のために書き直しました。これは、

          ftp.pasteur.fr:/pub/Perl/Sx.tar.gz

     から FTP することができます。

Tk
     この拡張モジュールは、広く使われている tcl/tk X11 パッケージと組み
     合わせる、オブジェクト指向のPerl5 です。しかし、これを使うために
     TCL の知識はいりません。これは、Malcolm Beattie
     <mbeattie@sable.ox.ac.uk> が書いたもので、archie (1L) などのツール
     を使っても、どこにあるかがわからなければ、上にあげた Malcolm のマ
     シンの `/private/Tk-october.tar.gz' から入手することができます。





File: perl-ja.info, Node: リファレンスとデータ構造のネスト, Next: オブジェクト, Prev: モジュールについて, Up: Top

リファレンスとデータ構造のネスト
********************************

* Menu:

* ハードリファレンス::
* ハードリファレンスの作成::
* ハードリファレンスの参照::
* シンボリックリファレンス::
* さらに学ぶために::





File: perl-ja.info, Node: ハードリファレンス, Next: ハードリファレンスの作成, Prev: リファレンスとデータ構造のネスト, Up: リファレンスとデータ構造のネスト

ハードリファレンス
==================

Perl 4 では、複雑なデータ構造を表現するのは難しいことでした。すべてのリ
ファレンスはシンボリックでなければならず、シンボルテーブルのエントリで
はなく、特定の変数を参照したいような場合にも大変だったからです。Perl 5
は、変数へのシンボリックリファレンスを使い易くしただけではなく、どんな
データにも「ハード」リファレンスが行なえるようにしました。任意のスカラ
がハードリファレンスを保持することができます。スカラは、配列やハッシュ
の一部でもありますから、配列の配列、ハッシュの配列、配列のハッシュ、関
数のハッシュの配列といったものが簡単に作れるようになりました。

ハードリファレンスは賢く、実際に参照されている数を管理していて、その数
が 0 になれば、自動的に解放を行ないます。そのものがオブジェクトであると
きには、デストラクタが動作します。オブジェクトについてより詳しくは、
*Note オブジェクト::,を参照してください。(ある意味では、Perl のすべてが
オブジェクトですが、通常、クラスパッケージ内で公に `bless' されているも
のへのリファレンスに対して、この用語を用います。)

ファイルシステム上でのシンボリックリンクが、単にファイルの名前を持って
いるだけであるのと同様に、シンボリックリファレンスは、変数の名前を保持
します。`*glob' の記法は、シンボリックリファレンスの 1 種です。ハードリ
ファレンスは、ファイルシステム上のハードリンクに似ており、名前によらず、
基本となる同一のオブジェクトに到達する方法を与えるものです。

Perl では、「ハード」リファレンスは簡単に使えます。これを覆すような原則
は、1 つだけです。Perl は、暗黙の参照や被参照を行ないません。スカラがリ
ファレンスを保持しているときも、必ずスカラとして動作します。明示的に被
参照を指示しない限り、そのスカラが魔法のように配列やハッシュとなること
はないのです。





File: perl-ja.info, Node: ハードリファレンスの作成, Next: ハードリファレンスの参照, Prev: ハードリファレンス, Up: リファレンスとデータ構造のネスト

ハードリファレンスの作成
------------------------

リファレンスを作成する方法は、いくつかあります。

  1. 変数、サブルーティン、値にバックスラッシュ演算子を使うことによる。
     (これは C での & (アドレス) 演算子に似た働きをします。)既にシンボ
     ルテーブルには変数へのリファレンスが存在していますから、この方法は
     別のリファレンスを作るものであることに注意してください。しかし、シ
     ンボルテーブルのリファレンスがなくなったとしても、バックスラッシュ
     が返したリファレンスが存在することになります。例をいくつかあげます:

          $scalarref = \$foo;
          $arrayref  = \@ARGV
          $hashref   = \%ENV;
          $coderef   = \&handler;

  2. 名前の無い配列へのリファレンスは、大括弧を使って作ることができます:

          $arrayref = [1, 2, ['a', 'b', 'c']];

     ここでは、『「名前の無い 3 個の要素を持つ配列」を最後の要素として
     持つ 3 個要素の名前の無い配列』へのリファレンスを作っています。(あ
     とで述べる多次元構文を使って、これをアクセスすることができます。た
     とえば、上記のようにした後では、`$arrayref->[2][1]' が "b" となり
     ます。)

  3. 名前の無いハッシュへのリファレンスは、中括弧を使って作ることができ
     ます:

          $hashref = {
              'Adam'  => 'Eve',
              'Clyde' => 'Bonnie',
          };

     名無しのハッシュと配列のコンストラクタは、複雑な構造を作るために、自由に
     組み合わせることができます。後述する多次元構文は、そのようなものに対して
     も使うことができます。上記の value はリテラルですが、変数や式であっても
     かまいません。Perl での代入演算は、(たとえ、`local()' や
     `my()' の中でも) コンパイル時の宣言文ではなく、実行文ですからです。

     中括弧は、BLOCK を始め他のことにも使われますから、開き中括弧が
     BLOCK の開始でないことを Perl に教えるために、文の最初の中括弧の前
     に `+' や `return' をつけて、曖昧さをなくすようにする必要がある場
     合があります。この時折の余分な仕事は、中括弧の使用に関する経済的、
     記憶的価値があると思われます。

     たとえば、新しいハッシュを作って、それへのリファレンスを返す関数が
     欲しければ、以下のような選択肢があります:

          sub hashem {        { @_ } }   # ちょっと間違い
          sub hashem {       +{ @_ } }   # ok
          sub hashem { return { @_ } }   # ok


  4. 名前の無いサブルーティンのへのリファレンスは、サブルーティン名の無い
     `sub' を使って作ることができます:

          $coderef = sub { print "Boink!\n" };

     セミコロンがあることに注意してください。内部のコードが即座に実行されるの
     ではないという事実を除いて、`sub{}' は、宣言というよりもむしろ、
     `do{}' や `eval{}' のような演算子です。(しかし、
     `eval("...")' の中でなければ、何回その行を実行しようとも
     `$coderef' は、同一の無名サブルーティンを参照することになります。)

     こういったことを気にする方のため、現在のインプリメントでは、
     `local()' 変数の浅い結び付きとなっています。`my()' 変数はアクセス
     できません。これは、真のクロージャを疎外するものとなります。しかし、
     (コンパイル時ではなく、) 実行時の `eval()' を使えば、これに対応す
     ることができます:

          {
              my $x = time;
              $coderef = eval "sub { \$x }";
          }

     通常は、(`sub {}' だけをつかったり、`eval {}' をも使う場合にも) 新
     しい `sub' はグローバルな `$x' をアクセスすることができるだけです。
     しかし、実行時に `eval()' を使っているので、呼ばれるごとに、新しい
     サブルーティンリファレンスを作り出すだけではなく、グローバルな変数
     の代わりに、プログラム上で自分より前に出てくる `my()' 変数をアクセ
     スすることが許されます。一般には、アクセスされる `$x' は、新しい
     `sub' が作られるごとに、違うものとなります。このしくみでは、変数は、
     動的な深い結び付きとなります。(クロージャや、深い結び付き、浅い結
     び付きというものが何かを知らなくても、あまり悩まないでください。)

  5. リファレンスは、コンストラクタと呼ばれる特別なサブルーティンが返す
     ようにしていることが多くなっています。Perlのオブジェクトは、自分が
     どのパッケージと関係を持っているかを知っているものへのリファレンス
     でしかありません。コンストラクタは、その関係付けをどのように行なう
     かを知っているという意味で、特別なサブルーティンにすぎません。単な
     るリファレンスとしてスタートし、オブジェクトといわれている間でも通
     常のリファレンスであることに変わりはありません。コンストラクタは、
     慣習的に `new()' と名前を付けますが、そうしなければならないもので
     はありません:

          $objref = new Doggie (Tail => 'short', Ears => 'long');


  6. 適切な型のリファレンスは、そういったリファレンスが存在するかのよう
     な文脈で被参照すると、実際に存在するようになります。被参照について
     はまだ話していないので、例を示すことができませんが。

リファレンスの作り方はこれだけです。ここまでくると、どこかリファレンス
のかなたへ行ってしまったデータを取り戻すために、どうやってリファレンス
を使うかを知りたいことでしょう。基本的な方法がいくつかあります。





File: perl-ja.info, Node: ハードリファレンスの参照, Next: シンボリックリファレンス, Prev: ハードリファレンスの作成, Up: リファレンスとデータ構造のネスト

ハードリファレンスの参照
------------------------

  1. 変数名やサブルーティン名の一部として識別子を置くところでは、適切な
     型のリファレンスを持った単純スカラ変数で、その識別子を置き換えるこ
     とができます:

          $bar = $$scalarref;
          push(@$arrayref, $filename);
          $$arrayref[0] = "January";
          $$hashref{"KEY"} = "VALUE";
          &$coderef(1,2,3);

     `$arrayref[0]' や `$hashref{"KEY"}' という形で被参照しているのでは
     ないことが大切です。スカラ変数の被参照は、いかなる key の検索より
     も「前に」行なわれます。単純スカラ変数より込み入ったものはすべて、
     以下の 2 番か 3 番の方法が採られます。しかしながら、「単純スカラ」
     には、この 1番目の方法を再帰的に使っている識別子も含まれます。した
     がって、

          $refrefref = \\\"howdy";
          print $$$$refrefref;

     は、"howdy" と出力します。

  2. 変数名やサブルーティン名の一部として識別子を置くところでは、適切な
     型のリファレンスを返す BLOCK を伴う識別子で置き換えることができま
     す。言い換えると、先の例は以下のように書くことができます:

          $bar = ${$scalarref};
          push({$arrayref}, $filename);
          ${$arrayref}[0] = "January";
          ${$hashref}{"KEY"} = "VALUE";
          &{$coderef}(1,2,3);

     確かに、この場合には中括弧を付けるのは、莫迦げたことかもしれません
     が、BLOCK には任意の式、特に添字を付けた式を入れることができます:

          &{ $dispatch{$index} }(1,2,3);      # 正しいルーティ
                                              # ンの呼び出し

     単純な `$$x' の場合に中括弧が省略できるので、シンボルの被参照を適
     当な演算子のように受け取って、その優先順位はどのくらいかと悩む人が
     あります。しかし、もし演算子であれば、中括弧の代わりに、普通の括弧
     が使えることでしょう。そうではありません。以下の違いを考えてみてく
     ださい。CASE 0 は、CASE 1 を短くしたものであり、CASE 2 ではありま
     せん:

          $$hashref{"KEY"}   = "VALUE";       # CASE 0
          ${$hashref}{"KEY"} = "VALUE";       # CASE 1
          ${$hashref{"KEY"}} = "VALUE";       # CASE 2
          ${$hashref->{"KEY"}} = "VALUE";     # CASE 3

     CASE 2 もまた、間違えやすいもので、`%hashref' という変数をアクセス
     するものです。`$hashref' を仲介して、それが指すことになっているハッ
     シュを被参照しているいるものでは、ありません。それは、CASE 3 です。

  3. 配列の個々の要素を使う場合が増えると、2 番の方法を使うのが、煩わし
     くなってきます。構文上の打開策として、上記の2 行は、

          $arrayref->[0] = "January";
          $hashref->{"KEY} = "VALUE";

     のように書くことができます。

     矢印の左側は、以前の被参照を含めて、リファレンスを返す任意の式が書
     けます。(`$array[$x]' は、`$array->[$x]' と同じではありません。)

          $array[$x]->{"foo"}->[0] = "January";

     これが、先の左辺値コンテキストで用いると、リファレンスが存在するよ
     うになる、というケースの 1 つです。この文以前には、`$array[$x]' は
     未定義かもしれません。そうならば、自動的にハッシュリファレンスと定
     義されて、`{"foo"}' が検索できるようになります。同じように、
     `$array[$x]->{"foo"}'が配列リファレンスで定義され、`[0]' を探すこ
     とができます。

     もう一つ。矢印は、括弧付きの添字の「間」では、省略することができま
     すので、上の例は、

          $array[$x]{"foo"}[0] = "January";

     と書くことができます。通常の配列だけを使うように限定すれば、ちょう
     ど C の多次元配列のように使うことができます:

          $score[$x][$y][$z] += 42;

     ああ、そうだ、実際には全く C の配列と同じという訳ではありません。
     C では、必要に応じて配列を大きくするなどということはできません。
     Perl では、それができます。

  4. リファレンスが、オブジェクトに対するものである場合には、参照される
     ものをアクセスするためのメソッドがあるはずで、オブジェクトのメソッ
     ドを定義するクラスパッケージ内でなければ、そのメソッドを使うように
     した方が良いでしょう。言い換えると、良識をもって、特別正当な理由が
     ない限り、オブジェクトのカプセル化を反古にしてはいけないということ
     です。Perl は、カプセル化を強要したりはしません。私達は、全体主義
     者ではありません。ただ、なにがしかの基本的な節度を期待しています。

`ref()' 演算子が、リファレンスがどういった型のものを指しているかを、調
べるために使うことができます。*Note 組み込み関数::,を参照してください。

`bless()' 演算子は、リファレンスをオブジェクトクラスとして機能するパッ
ケージと組み合わせるために使うことができます。*Note オブジェクト::,を参
照してください。

被参照構文では、常に目的とするリファレンスの「型」を示すことができます
ので、型グロブをリファレンスと同じように被参照することができます。つま
り、`${*foo}' と `${\$foo}' は、どちらも同じスカラ変数を示すことになり
ます。

次の例に示すのは、文字列にサブルーティン呼び出しを埋め込む仕掛けです:

     print "My sub returned ${\mysub(1,2,3)}\n";

ダブルクォート文字列中に `${...}' が見つかると、ブロックとして評価され
ます。ブロックでは、`mysub(1,2,3)' の呼び出しを実行し、その結果に対する
リファレンスがとられます。つまり、ブロック全体では、スカラへのリファレ
ンスを返すこととなり、`${...}'  で被参照された後、ダブルクォート文字列
の中に、はり込まれることになります。




File: perl-ja.info, Node: シンボリックリファレンス, Next: さらに学ぶために, Prev: ハードリファレンスの参照, Up: リファレンスとデータ構造のネスト

シンボリックリファレンス
========================

リファレンスは、もし未定義であれば、必要に応じて存在するようになると言
いましたが、もしリファレンスとして使われた値が、既に定義されていたとき
には、どのようになるのか示していませんでした。このような場合にリファレ
ンスとして使ったなら、それは、シンボリックリファレンスとして扱われます。
つまり、スカラの値は、無名 (であるかもしれない) 値への直接のリンクでは
なく、変数の「名前」として扱われます。

そのように働くと思われていることが多いものです。それでそう動きます。

     $name = "foo";
     $$name = 1;               # $foo を設定
     ${$name} = 2;             # $foo を設定
     ${$name x 2} = 3;         # $foofoo を設定
     $name->[0] = 4;           # $foo[0] を設定
     @$name = ();              # @foo をクリア
     &$name();                 # &foo() を呼び出す(Perl 4 同様)
     $pack = "THAT";
     ${"${pack}::$name"} = 5;  # eval なしで $THAT::foo を設定

これは、非常に強力で、多少危険でもあります。(最大限の注意をはらって) ハー
ドリファレンスを使おうとした場合にも、誤ってシンボリックリファレンスを
使ってしまうような場合があるからです。これを防止するには、

     use strict 'refs';

と書いて、囲っているブロック内の残りの部分では、ハードリファレンスのみ
が許されるようにすることができます。内側のブロックでは、

     no strict 'refs';

と書いて、打ち消すこともできます。

シンボリックリファレンスでは、パッケージ変数だけを見ることができます。
(`my()' で宣言した) 静的なローカル変数は、シンボルテーブルにありません
ので、シンボリックリファレンスでは参照することができません。たとえば:

     local($value) = 10;
     $ref = \$value;
     {
         my $value = 20;
         print $$ref;
     }

これは、20 ではなく、10 と出力します。`local()' は、パッケージで「グロー
バルな」、パッケージ変数に影響するものです。




File: perl-ja.info, Node: さらに学ぶために, Prev: シンボリックリファレンス, Up: リファレンスとデータ構造のネスト

さらに学ぶために
================

明らかなドキュメントを除くと、ソースコードが多くのことを教えてくれます。
多少不自然な、リファレンスの使用例は、Perl のソースディレクトリの
`t/op/ref.t' レグレッションテストにもあります。





File: perl-ja.info, Node: オブジェクト, Next: オブジェクト指向の仕組みと例, Prev: リファレンスとデータ構造のネスト, Up: Top

オブジェクト
************

まず最初に、Perl でのリファレンスが何かを理解する必要があります。そのた
め、*Note リファレンスとデータ構造のネスト::,を参照してください。

ここに、安心材料としてとても簡潔な定義を 3 つ示します。

  1. オブジェクトとは、単に自分が属するクラスを知っているリファレンスの
     ことです。

  2. クラスとは、単にオブジェクトリファレンスを扱うためのメソッドを提供
     するパッケージのことです。

  3. メソッドとは、オブジェクトリファレンス (あるいは、静的メソッドには、
     パッケージ名) を最初の引数として期待するサブルーティンのことです。

ここでは、これらのポイントを掘り下げていきます。

* Menu:

* オブジェクトは単にリファレンスである::
* クラスとは単にパッケージである::
* メソッドとは単にサブルーティンである::
* メソッド呼び出し::
* デストラクタ::
* まとめ::





File: perl-ja.info, Node: オブジェクトは単にリファレンスである, Next: クラスとは単にパッケージである, Prev: オブジェクト, Up: オブジェクト

オブジェクトは単にリファレンスである
====================================

C++ とは違って、Perl ではコンストラクタのために、特別な構文を用意してい
ません。コンストラクタは単に、あるクラス内に `bless' されたリファレンス
を返すサブルーティンで、一般にそのクラスは、該当サブルーティンが定義さ
れているクラスです。典型的なクラスの例を示します:

     package Critter;
     sub new { bless {} }

`{}' は、key/value ペアを 1 つも含まず、名前の無いハッシュへのリファレ
ンスを作ります。`bless()' がそのリファレンスを受け取って、そのリファレ
ンスが参照するオブジェクトに対し、現在のパッケージが `Critter' であるこ
とを告げ、そのリファレンスを返します。これは、参照されたオブジェクト自
身が `bless' されたことを知っているため、簡単にしたもので、以下のように
そのリファレンスを直接返することができあます:

     sub new {
         my $self = {};
         bless $self;
         return $self;
     }

実際には、コンストラクタによる構築の一部として、クラス内のメソッドを呼
ぶような、より込み入ったコンストラクタで、このような構成を目にすること
が多くなります。

     sub new {
         my $self = {}
         bless $self;
         $self->initialize();
         $self;
     }

クラスパッケージ内では、メソッドは、そのリファレンスを通常のリファレン
スとして扱います。クラスパッケージの外では、そのリファレンスは一般に、
そのクラスのメソッドを通してのみアクセスできる、直接参照できない値とし
て扱われます。

コンストラクタは、その時点で別のクラスに属していて参照されているオブジェ
クトを、再度 `bless' することができますが、その場合には、新しいクラスが、
最後の後片付けに全責任を持ちます。以前に行なわれた `bless' は忘れ去られ、
オブジェクトは、その時点では、1 つのクラスにしか属することができません。
(ですが、もちろん多くのクラスからメソッドを継承することは、自由です。)

明確化事項: Perl オブジェクトは、`bless' されます。単なるリファレンスは、
されません。オブジェクトは、自分が属しているパッケージがどれであるかを
知っています。リファレンスは、知りません。`bless()' 関数は、オブジェク
トを探すために、単にリファレンスを用います。以下の例を見てみましょう:

     $a = {};
     $b = $a;
     bless $a, BLAH;
     print "\$b is a ", ref($b), "\n";

このプログラムは、`$b' が `BLAH' であると報告してくれます。つまり、明ら
かに `bless()' は、オブジェクトに対して働くのであって、リファレンスに働
くものではありません。





File: perl-ja.info, Node: クラスとは単にパッケージである, Next: メソッドとは単にサブルーティンである, Prev: オブジェクトは単にリファレンスである, Up: オブジェクト

クラスとは単にパッケージである
==============================

C++ などとは違って、Perl ではクラス定義のための特別な構文を用意していま
せん。メソッドの定義を入れることによって、パッケージをクラスとして使用
します。

各々のパッケージには、@ISA という特別な配列があり、現在のパッケージでメ
ソッドが見つからなかった場合に、どこを探すかということが書いてあります。
Perl では、これによって継承を実現しています。配列 @ISA の各要素は、たま
たまクラスである、他のパッケージの名前になっています。クラスは、@ISA に
現われる順序で、見つからなかったメソッドを (深度優先) 検索します。@ISA
を通じてアクセスできるクラスをカレントクラスの基底クラスといいます。

必要なメソッドが、基底クラスの中に見つかれば、効率化のために、現在のク
ラスの中にキャッシュされます。@ISA を変更したり、新しいサブルーティンを
定義すると、そのキャッシュを無効にし、再び Perl に検索させるようにしま
す。

メソッドが見つからず、`AUTOLOAD' ルーティンが見つかれば、見つからなかっ
たメソッドの代わりに、それが呼び出されます。

メソッドも `AUTOLOAD' ルーティンも @ISA に見つからなければ、最後の手段
として、`UNIVERSAL' というクラスで、メソッド (あるいは`AUTOLOAD' ルーティ
ン) を探します。これでもダメならば、最終的に諦めて、エラーを出すことに
なります。

Perl のクラスは、メソッドの継承だけを行ないます。データの継承は、クラス
自身に任されます。全般的にこのことは、Perlでは問題とはなりません。多く
のクラスは、自分のオブジェクトの属性を、名無しのハッシュを使ってモデル
化するからです。そのハッシュは、そのオブジェクトと何らかの関係を持とう
とする、さまざまなクラスによって切り分けられるために、自分自身の小規模
な名前空間として働きます。





File: perl-ja.info, Node: メソッドとは単にサブルーティンである, Next: メソッド呼び出し, Prev: クラスとは単にパッケージである, Up: オブジェクト

メソッドとは単にサブルーティンである
====================================

C++ などとは違って、Perl ではメソッド定義のための特別な構文を用意してい
ません。(だたし、メソッド呼び出しのためには、少しばかり構文を用意してい
ます。これについては後程。)メソッドでは、最初の引数がオブジェクトか、自
分が呼び出されたパッケージである必要があります。メソッドには、2 つの種
類があり、C++ での最も近い 2 つのメソッドの種類に準じて、静的メソッドと
仮想メソッドと呼びます。

静的メソッドは、最初の引数としてクラス名を期待します。これは、全体とし
てのクラスに対する機能を果たすもので、クラスに属する個々のオブジェクト
に対するものではありません。コンストラクタは、典型的な静的メソッドです。
多くの静的メソッドは、その第一引数を単に無視してしまいます。既にどのパッ
ケージにいるのかは、分かっていますし、どのパッケージを介して起動された
かは、関係がないからです。(静的メソッドは、通常の仮想メソッドと同じよう
に、継承トリーをたどっていますから、これらのパッケージが等しいとは限り
ません。)この他に、静的メソッドを使う典型例としては、名前によるオブジェ
クトの検索があげられます:

     sub find {
         my ($class, $name) = @_;
         $objtable{$name};
     }

仮想メソッドは、最初の引数としてオブジェクトリファレンスを期待します。
最初の引数を `shift' して、`self' や `this' という変数にいれ、通常のリ
ファレンスとして使うことがよく行なわれます。

     sub display {
         my $self = shift;
         my @keys = @_ ? @_ : sort keys %$self;
         foreach $key (@keys) {
             print "\t$key => $self->{$key}\n";
         }
     }





File: perl-ja.info, Node: メソッド呼び出し, Next: デストラクタ, Prev: メソッドとは単にサブルーティンである, Up: オブジェクト

メソッド呼び出し
================

メソッドを呼び出す方法には 2 つあり、その1つは既になじみの深いものです
し、もう1つは見たことのある格好をしています。Perl 4 は、既に

     print STDERR "help!!!\n";

としたときに使われる、「間接オブジェクト」構文を持っていました。

この同じ構文が、静的メソッドにも仮想メソッドにも使われます。先に定義し
た2つのメソッド、オブジェクトリファレンスを検索するための静的メソッド、
その属性を出力するための仮想メソッドを使ってみましょう。

     $fred = find Critter "Fred";
     display $fred 'Height', 'Weight';

これらは、間接オブジェクトのところに BLOCK を使って、1 つの文に組み合わ
せることができます:

     display {find Critter "Fred"} 'Height', 'Weight';

C++ ファンのために、同じことをする `->' を使った構文も用意してあります。
引数がある場合には、括弧が必要です。

     $fred = Critter->find("Fred");
     $fred->display('Height', 'Weight');

あるいは、1 文で、

     Critter->find("Fred")->display('Height', 'Weight');

ある構文が読みやすいと感じることがあり、別の構文の方が読みやすいと感じる
こともあります。間接オブジェクトの構文は、混乱させるようなものではありま
せんが、通常のリスト演算子としての、同様の曖昧さも持っています。間接オブ
ジェクトのメソッド呼び出しは、リスト演算子と同じ規則を使って解釈されます:
「関数のように見えれば、それは関数です。」(2つの並んだ単語が関数名のよう
に見えると考えれば、です。C++ のプログラマは、特に最初の単語が
`new' のときに、規則的にそのように考えるようです。)つまり、

     new Critter ('Barney', 1.5, 70)

という括弧は、その後に何が来ようとも、メソッドに対するすべての引数を囲っ
ているものとして扱われます。

     new Critter ('Bam' x 2), 1.4, 45

と書くのは、

     Critter->new('Bam' x 2), 1.4, 45

と同じことで、目的とは違うでしょう。

どのクラスのメソッドを使うかを指定したい場合もあります。その場合には、
通常のサブルーティン呼び出しとして、メソッドを呼び出すことができます。
必須の最初の引数は、明示的に渡さなければなりません:

     $fred =  MyCritter::find("Critter", "Fred");
     MyCritter::display($fred, 'Height', 'Weight');

しかしながら、この場合には継承を行ないません。単に Perl がメソッドの検
索を開始する特定のパッケージを指定したいだけならば、メソッド名にパッケー
ジ名を付けて、通常のメソッド呼び出しを使ってください:

     $fred = Critter->MyCritter::find("Fred");
     $fred->MyCritter::display('Height', 'Weight');




File: perl-ja.info, Node: デストラクタ, Next: まとめ, Prev: メソッド呼び出し, Up: オブジェクト

デストラクタ
============

オブジェクトに対する最終的な参照がなくなると、オブジェクトは自動的に、
削除されます。(これは、グローバル変数にリファレンスを入れている場合には、
`exit' した後になるかもしれません。)オブジェクトがなくなる直前に制御を
もらいたい場合には、クラス内で、`DESTROY' メソッドを定義することができ
ます。これは、適切なときに自動的に呼び出されますから、その中で独自の後
片付けを行なうことができます。

Perl では、ネストした削除を行ないません。コンストラクタで、基底クラスの
一つからリファレンスを再 `bless' したような場合には、`DESTORY' のなかで、
必要な基底クラスの `DESTROY' を呼び出す必要があるかもしれません。しかし、
これは再 `bless' されたオブジェクトにだけあてはまります。現在のオブジェ
クトに含まれているだけのオブジェクトリファレンスは、その現在のオブジェ
クトが解放されるときに、自動的に解放され、削除されます。




File: perl-ja.info, Node: まとめ, Prev: デストラクタ, Up: オブジェクト

まとめ
======

これで、ほとんどすべてです。さて、それでは、すぐにも出かけて、オブジェ
クト指向設計の方法論に関する本を仕入れて、今から半年くらいは、それに頭
を打ちつけ続けることが必要でしょう。

その他のオブジェクトのしくみ、わな、助言について、
*Note オブジェクト指向の仕組みと例::,もチェックしておいてください。





File: perl-ja.info, Node: オブジェクト指向の仕組みと例, Next: デバッグ, Prev: オブジェクト, Up: Top

オブジェクト指向の仕組みと例
****************************

これから示す技とヒントは、インスタンス変数の利用やオブジェクトとクラス
の関係といったことについての、好奇心をそそることを目指しています。これ
を読む方は、オブジェクト指向の定義と方法論に関する適切な本も、読んだ方
がよいでしょう。このドキュメントは、Perl 5 のオブジェクト指向機能の総括
的なガイドを目指すものでもなければ、スタイルガイドとして作られているわ
けでもありません。

Perl のモットーは、ここでも生きています: 「やり方は1通りではない。」

* Menu:

* インスタンス変数::
* スカラインスタンス変数::
* インスタンス変数継承::
* オブジェクトの関係::
* スーパークラスのメソッドのオーバライド::
* SDBM を伴う関係の使用::
* コード再利用の考慮::
* クラスコンテキストとオブジェクト::





File: perl-ja.info, Node: インスタンス変数, Next: スカラインスタンス変数, Prev: オブジェクト指向の仕組みと例, Up: オブジェクト指向の仕組みと例

インスタンス変数
================

無名の配列や無名のハッシュには、インスタンス変数を入れておくことができ
ます。名前付きパラメータの例もいっしょに示しておきます。

     package Foo;

     sub new {
             my $type = shift;
             my %params = @_;
             my $self = {};
             $self->{'High'} = $params{'High'};
             $self->{'Low'}  = $params{'Low'};
             bless $self;
     }

     package Bar;

     sub new {
             my $type = shift;
             my %params = @_;
             my $self = [];
             $self->[0] = $params{'Left'};
             $self->[1] = $params{'Right'};
             bless $self;
     }

     package main;

     $a = new Foo ( 'High' => 42, 'Low' => 11 );
     print "High=$a->{'High'}\n";
     print "Low=$a->{'Low'}\n";

     $b = new Bar ( 'Left' => 78, 'Right' => 40 );
     print "Left=$b->[0]\n";
     print "Right=$b->[1]\n";





File: perl-ja.info, Node: スカラインスタンス変数, Next: インスタンス変数継承, Prev: インスタンス変数, Up: オブジェクト指向の仕組みと例

スカラインスタンス変数
======================

無名のスカラは、1 つのインスタンス変数が必要とされるときにだけ、使うこ
とができます。

     package Foo;

     sub new {
             my $type = shift;
             my $self;
             $self = shift;
             bless \$self;
     }

     package main;

     $a = new Foo 42;
     print "a=$$a\n";





File: perl-ja.info, Node: インスタンス変数継承, Next: オブジェクトの関係, Prev: スカラインスタンス変数, Up: オブジェクト指向の仕組みと例

インスタンス変数継承
====================

この例では、新しいクラスで、取り込むためのスーパークラスから、インスタ
ンスを継承する方法を示します。この継承を行なうには、コンストラクタ内で
新しいオブジェクトに対して、スーパークラスのコンストラクタを呼び出して
継承部分の初期化を行なった後、自分自身のインスタンス変数の追加を行ない
ます。

     package Bar;

     sub new {
             my $self = {};
             $self->{'buz'} = 42;
             bless $self;
     }

     package Foo;
     @ISA = qw( Bar );

     sub new {
             my $self = new Bar;
             $self->{'biz'} = 11;
             bless $self;
     }

     package main;

     $a = new Foo;
     print "buz = ", $a->{'buz'}, "\n";
     print "biz = ", $a->{'biz'}, "\n";





File: perl-ja.info, Node: オブジェクトの関係, Next: スーパークラスのメソッドのオーバライド, Prev: インスタンス変数継承, Up: オブジェクト指向の仕組みと例

オブジェクトの関係
==================

以下の例では、オブジェクト間の「包含」および「使用」といわれる関係をイ
ンプリメントする方法を示します。

     package Bar;

     sub new {
             my $self = {};
             $self->{'buz'} = 42;
             bless $self;
     }

     package Foo;

     sub new {
             my $self = {};
             $self->{'Bar'} = new Bar ();
             $self->{'biz'} = 11;
             bless $self;
     }

     package main;

     $a = new Foo;
     print "buz = ", $a->{'Bar'}->{'buz'}, "\n";
     print "biz = ", $a->{'biz'}, "\n";





File: perl-ja.info, Node: スーパークラスのメソッドのオーバライド, Next: SDBM を伴う関係の使用, Prev: オブジェクトの関係, Up: オブジェクト指向の仕組みと例

スーパークラスのメソッドのオーバライド
======================================

以下の例は、スーパークラスのメソッドをオーバライドし、オーバライドされ
た後でそのメソッドを呼び出す方法を示します。`Foo::Inherit' クラスを使っ
て、オーバライドされたスーパークラスのメソッドが、実際には、どこで定義
されているか知らなくても、そのメソッドを呼び出せるようにしています。

     package Buz;
     sub goo { print "here's the goo\n" }

     package Bar; @ISA = qw( Buz );
     sub google { print "google here\n" }

     package Baz;
     sub mumble { print "mumbling\n" }

     package Foo;
     @ISA = qw( Bar Baz );
     @Foo::Inherit::ISA = @ISA;  # オーバライドされたメソッドのアクセス

     sub new { bless [] }
     sub grr { print "grumble\n" }
     sub goo {
             my $self = shift;
             $self->Foo::Inherit::goo();
     }
     sub mumble {
             my $self = shift;
             $self->Foo::Inherit::mumble();
     }
     sub google {
             my $self = shift;
             $self->Foo::Inherit::google();
     }

     package main;

     $foo = new Foo;
     $foo->mumble;
     $foo->grr;
     $foo->goo;
     $foo->google;





File: perl-ja.info, Node: SDBM を伴う関係の使用, Next: コード再利用の考慮, Prev: スーパークラスのメソッドのオーバライド, Up: オブジェクト指向の仕組みと例

SDBM を伴う関係の使用
=====================

この例は、`SDBM' クラスのためのインタフェースを示します。これは、
`SDBM' クラスと新しいクラス `Mydbm' との間の「使用」関係を作ります。

     use SDBM_File;
     use POSIX;

     package Mydbm;

     sub TIEHASH {
         my $self = shift;
         my $ref  = SDBM_File->new(@_);
         bless {'dbm' => $ref};
     }
     sub FETCH {
         my $self = shift;
         my $ref  = $self->{'dbm'};
         $ref->FETCH(@_);
     }
     sub STORE {
         my $self = shift;
         if (defined $_[0]){
             my $ref = $self->{'dbm'};
             $ref->STORE(@_);
         } else {
             die "Cannot STORE an undefined key in Mydbm\n";
         }
     }

     package main;

     tie %foo, Mydbm, "Sdbm", O_RDWR|O_CREAT, 0640;
     $foo{'bar'} = 123;
     print "foo-bar = $foo{'bar'}\n";

     tie %bar, Mydbm, "Sdbm2", O_RDWR|O_CREAT, 0640;
     $bar{'Cathy'} = 456;
     print "bar-Cathy = $bar{'Cathy'}\n";





File: perl-ja.info, Node: コード再利用の考慮, Next: クラスコンテキストとオブジェクト, Prev: SDBM を伴う関係の使用, Up: オブジェクト指向の仕組みと例

コード再利用の考慮
==================

オブジェクト指向言語の 1 つの強みは、古いコードが新しいコードを使うこと
が簡単にできるということです。次の例では、まずどのようなことがコードの
再利用を妨げるかを示して、それから、どのように再利用を推し進めるかを示
します。

最初の例は、「プライベートな」メソッド `BAZ()' をアクセスするために、メ
ソッドを呼び出すのにパッケージ名をすべて付けているクラスを示します。次
の例で、この `BAZ()' をオーバライドすることができないことを示します。

     package FOO;

     sub new { bless {} }
     sub bar {
             my $self = shift;
             $self->FOO::private::BAZ;
     }

     package FOO::private;

     sub BAZ {
             print "in BAZ\n";
     }

     package main;

     $a = FOO->new;
     $a->bar;

さて、`BAZ()' をオーバライドしてみましょう。`FOO::bar()' が
`GOOP::BAZ()' を呼ぶようにしたいのですが、`FOO::bar()' では、明示的に
`FOO::private::BAZ()' を呼んでいるため、これができません。

     package FOO;

     sub new { bless {} }
     sub bar {
             my $self = shift;
             $self->FOO::private::BAZ;
     }

     package FOO::private;

     sub BAZ {
             print "in BAZ\n";
     }

     package GOOP;
     @ISA = qw( FOO );
     sub new { bless {} }

     sub BAZ {
             print "in GOOP::BAZ\n";
     }

     package main;

     $a = GOOP->new;
     $a->bar;

再利用可能なコードを作るためには、クラス `FOO::private' の階層をなくし
て、クラス `FOO' を修正しなければなりません。次の例で、メソッド
`FOO::BAZ()' の代わりに `GOOP::BAZ()' を呼べるようにする再利用可能なク
ラス `FOO' を示します。

     package FOO;

     sub new { bless {} }
     sub bar {
             my $self = shift;
             $self->BAZ;
     }

     sub BAZ {
             print "in BAZ\n";
     }

     package GOOP;
     @ISA = qw( FOO );

     sub new { bless {} }
     sub BAZ {
             print "in GOOP::BAZ\n";
     }

     package main;

     $a = GOOP->new;
     $a->bar;





File: perl-ja.info, Node: クラスコンテキストとオブジェクト, Prev: コード再利用の考慮, Up: オブジェクト指向の仕組みと例

クラスコンテキストとオブジェクト
================================

パッケージとクラスのコンテキストの問題を解決するために、オブジェクトを
使います。メソッドが必要とするものはすべて、オブジェクトを通じて利用す
るか、メソッドへの引数として渡すようにしなければなりません。

クラスには、メソッドが使用する静的なデータやグローバルなデータを用意す
ることがあります。サブクラスで、このデータを新しいデータでオーバライド
したいこともあるでしょう。このようなときに、サブクラスでは新しいデータ
を探す方法を知ることができません。

この問題は、メソッドのコンテキストを定義するために、オブジェクトを使う
ことで解決することができます。データへのリファレンスを探すために、メソッ
ドにオブジェクトを覗かせます。別解として、メソッドに追いかけさせ (「こ
れは、私のクラスのものか、それともサブクラスのものなのか。いったい、ど
のサブクラスのものか。」)るものですが、不便で、遺物のようなものにしかな
らないでしょう。メソッドに対して、オブジェクトにデータがどこにあるのか
を言わせればよいでしょう。

     package Bar;

     %fizzle = ( 'Password' => 'XYZZY' );

     sub new {
             my $self = {};
             $self->{'fizzle'} = \%fizzle;
             bless $self;
     }

     sub enter {
             my $self = shift;

             # %Bar::fizzle を使うべきか、%Foo::fizzle を
             # 使うべきかを考えてはいけません。オブジェ
             # クトの方でもう分かっていますから、単に尋く
             # だけです。
             #
             my $fizzle = $self->{'fizzle'};

             print "The word is ", $fizzle->{'Password'}, "\n";
     }

     package Foo;
     @ISA = qw( Bar );

     %fizzle = ( 'Password' => 'Rumple' );

     sub new {
             my $self = Bar->new;
             $self->{'fizzle'} = \%fizzle;
             bless $self;
     }

     package main;

     $a = Bar->new;
     $b = Foo->new;
     $a->enter;
     $b->enter;





File: perl-ja.info, Node: デバッグ, Next: 診断メッセージ, Prev: オブジェクト指向の仕組みと例, Up: Top

デバッグ
********

まず最初に、一言「もう `-w' スイッチはお使いになりましたか。」

Perl を `-d' スイッチを付けて起動すれば、スクリプトはデバッガ上で実行さ
れることになります。しかし、Perl デバッガは C での環境の様に独立したプ
ログラムではありません。その代わりに、`-d' フラグによって、コンパイラが
インタプリタに渡す擬似コードにソース情報を埋め込むようにしています。(こ
れは、ソースがデバッガ上で動作できるためには、正常にコンパイルできない
といけないということです。)それからインタプリタが起動され、デバッガ自身
を含む Perl ライブラリをロードします。プログラムは、最初の実行文の直前
で停止し (ただし、以下を参照)、以下に示す、いずれかのコマンドが入力され
るのを待ちます: *Note デバッガコマンド一覧::,

* Menu:

* デバッガコマンド一覧::
* カスタマイズ::
* デバッガのバグ::





File: perl-ja.info, Node: デバッガコマンド一覧, Next: カスタマイズ, Prev: デバッグ, Up: デバッグ

コマンド一覧
============

h
     ヘルプメッセージの表示。

T
     スタックトレース。サブルーティン内で @_ 引数におかしなことをしてい
     る場合には、スタックのバックトレースで元の値が示されるとは限りませ
     ん。

s
     シングルステップ実行。別の実行文の先頭に到達するまで実行します。

n
     ネクスト。次の実行文の先頭に到達するまで、サブルーティンにまたがっ
     て実行します。

f
     フィニッシュ。現在のサブルーティンを終えるまで実行します。

c
     コンティニュー。次のブレイクポイントに到達するまで実行します。

c line
     指定行までのコンティニュー。1度きりのブレイクポイントを指定した行
     に設定する。

`<CR>'
     最後の `n' または `s' をリピートする。

l min+incr
     min から incr+1 行をリスト表示する。min を省略すると、最後に
     実行したリスト表示の終了か所から開始します。incr を省略すると前回の
     incr が使われます。

l min-max
     指定した範囲をリスト表示する。

l line
     指定行をリスト表示する。

l
     次の1ウィンドウをリスト表示する。

-
     前の1ウィンドウをリスト表示する。

w line
     指定行付近のウィンドウ (数行以上のコード) をリスト表示する。

l subname
     サブルーティンのリスト表示。長いサブルーティンの場合には最初の部分
     だけが表示されます。続きを表示する場合には、`l' を使用してください。

/pattern/
     ソースコード上で、pattern を用いて正規表現による検索を行う。最後の
     / はなくてもかまいません。

?pattern?
     ソースコード上で、pattern を用いて正規表現による逆方向検索を行う。
     最後の ? はなくてもかまいません。

L
     ブレイクポイントまたはアクションをもつ行をリストアップする。

S
     すべてのサブルーティン名をリストアップする。

t
     トレースモードの on/off を切り替える (トグル)。

b line [ condition ]
     ブレイクポイントを設定する。line を省略するとまさに実行しようとし
     ている行に、ブレイクポイントを設定します。condition が指定されると、
     その文にさしかかる度に評価され、condition が真となったときにだけブ
     レイクポイントが働きます。ブレイクポイントは、実行可能な文で始まる
     行にだけ、設定できます。condition には `if' を使いません:

          b 237 $x > 30
          b 33 /pattern/i

b subname [ condition ]
     サブルーティンの最初の実行可能文にブレイクポイントを設定します。

d line
     ブレイクポイントの削除。line が省略されると、まさに実行しようとし
     ている行のブレイクポイントを削除します。

D
     すべてのブレイクポイントの削除。

a line command
     line にアクションを設定する。複数行の command は、バックスラッシュ
     と改行で書くことができます。command は Perl コードであって、他のデ
     バッガコマンドではありません。

A
     すべての行のアクションを削除します。

< command
     デバッガがプロンプトを出す直前に、毎回実行するアクションを設定しま
     す。複数行の command は、バックスラッシュと改行で書くことができま
     す。

> command
     スクリプトの実行に戻るコマンドを入力した時に、デバッガがプロンプト
     を出した後で、毎回実行するアクションを設定します。複数行の
     command は、バックスラッシュと改行で書くことができます。

V package [ symbols ]
     package (デフォルトは `main') 内のすべて (または、一部) の変数
     (variable) をデータプリティプリンタを使って表示する (ハッシュは何
     が何か解るように、key と value を表示し、コントロール文字は表示で
     きる形にします)。以下に示すように、symbol は名前だけを示し、($ な
     どの) 型識別子を付けないようにしてください:

          V DB filename line

X [ symbols ]
     `V' コマンドと同じだが、現在のパッケージについて、表示する。

! number
     デバッグコマンドを再実行する。number が省略されると、直前のコマン
     ドを実行する。

! -number
     指定数値分前のコマンドを実行する。

H -number
     最近の指定数値分のコマンドを表示する。2文字以上のコマンドのみが表
     示されます。number が省略されると、全てを表示します。

q
^D
     クイット。(`quit' はこの目的には使えません。)

command
     command を Perl の文として実行します。セミコロンはなくてもかまいま
     せん。

p expr
     `print DB::OUT expr' と同じ。STDOUT がどこにリダイレクトされていて
     も、ファイルハンドル `DB::OUT'は、`/dev/tty' に対してオープンされ
     ています。

デバッガが認識できないコマンドを入力すると、Perl のコードとして、直接
`eval' されます。先頭にスペースを入れると、デバッガは、デバッガコマンド
と認識しません。

コンパイル時に実行されるコマンド (BEGIN ブロック内のコードやuse 文) が
あれば、それらはデバッガによって止めることができません (`require' は可
能)。しかし、以下のような文を自分でコードに含めれば、デバッガに制御を渡
すことができます。この文は、デバッガを起動していないときには、何もしま
せん:

     $DB::single = 1;





File: perl-ja.info, Node: カスタマイズ, Next: デバッガのバグ, Prev: デバッガコマンド一覧, Up: デバッグ

カスタマイズ
============

デバッガを変更したい場合には、`perl5db.pl' を Perl ライブラリから別
の名前にコピーし、必要に応じて修正してください。また、環境変数
PERL5DB には、以下のように設定する必要があるでしょう:

     BEGIN { require "myperl5db.pl" }

初期化コードを入れたファイル `.perldb' を設定することでも、いくらかのカ
スタマイズができます。たとえば、以下のようなエイリアスが行えます (特に
最後のものは、多くの人が使うでしょう):

     $DB::alias{'len'} = 's/^len(.*)/p length($1)/';
     $DB::alias{'stop'} = 's/^stop (at|in)/b/';
     $DB::alias{'.'} = 's/^\./p '
                     . '"\$DB::sub(\$DB::filename:\$DB::line):\t"'
                     . ',\$DB::dbline[\$DB::line]/' ;





File: perl-ja.info, Node: デバッガのバグ, Prev: カスタマイズ, Up: デバッグ

デバッガのバグ
==============

プログラムで `exit()' や `die()' を行なう場合には、デバッガも終わります。

1度終了して、再起動する以外に、デバッガを再実行する組み込みのしくみは用
意されていません。以下のようなエイリアスを行なうことができます:

     $DB::alias{'rerun'} = 'exec "perl -d $DB::filename"';

しかし、設定中のブレイクポイント情報は失われますし、正しいパスでない可
能性がある、といったことに注意しなくてはなりません。





File: perl-ja.info, Node: 診断メッセージ, Next: フォーマット文, Prev: デバッグ, Up: Top

診断メッセージ
**************

これらのメッセージは以下のように分類されます (重要度が増す順に並べてあ
ります):

   (W) 警告 (オプショナル)
   (D) A deprecation (オプショナル)
   (S) 重い警告 (必須)
   (F) 致命的エラー (トラップ可能)
   (P) 起こるはずのない内部エラー (トラップ可能)
   (X) 重大致命的エラー (トラップ不可能)

オプショナルな警告は、`-w' スイッチを使うことで現れます。トラップ可
能なエラーは、`eval' 演算子を使うことで、トラップすることができます。
*Note 組み込み関数::,の `eval' の項を参照してください。

いくつかのメッセージは、汎用的なものです。可変の部分は、ちょうど
printf のフォーマットのように %s で表わしています。%s! で始まるメッセー
ジもいくつかありますので、注意が必要です。"%-?@ といったシンボルは、英
字より前に並べられ、[ と \ は、後に並べられています。

"my" variable %s can't be in a package
     (F) 字句スコープの変数は、パッケージ内に置かれませんので、頭にパッ
     ケージ名を付けて宣言することは、無意味です。パッケージ変数をローカ
     ル化したい場合には、`local()' を使ってください。

"no" not allowed in expression
     (F) `no' キーワードは、コンパイル時に認識され、実行されるもので、
     意味のある値を返しません。*Note モジュール::,を参照してください。

"use" not allowed in expression
     (F) `use' キーワードは、コンパイル時に認識され、実行されるもので、
     意味のある値を返しません。*Note モジュール::,を参照してください。

% may only be used in unpack
     (F) チェックサムを指定して `pack' を行なうことはできません。チェッ
     クサム処理では、情報が失われ、どうしようもなくなるからです。
     *Note 組み込み関数::,の `unpack' の項を参照してください。

%s (...) interpreted as function
     (W) リスト演算子の直後に括弧を置くと、括弧内にあるリスト演算子引数を持つ
     関数になる、という規則が適用されました。*Note 演算子と優先順位::,の「
     *Note 項とリスト演算子 (左方向)::,」の節を参照してください。

%s argument is not a HASH element
     (F) `delete()' や `exists()' の引数は、

          $foo{$bar}
          $ref->[12]->{"susie"}

     のようなハッシュの要素でなければなりません。

%s did not return a true value
     (F) `require' (や `use') されたファイルは、正常にコンパイルされ、
     初期化コードを正しく実行したことを示すために、真を返さなければなり
     ません。こういったファイルは、"1;" で終わるようにするのが習慣です
     が、真となる値であれば、何でもかまいません。`組み込み関数'の
     `require' の項を参照してください。

%s found where operator expected
     (S) Perl の字句解析部は、次に項が来るか、演算子が来るかを知ってい
     ます。次に演算子が来ると思っているときに、項であるとわかるものが現
     れると、この警告が出ることになります。通常、演算子かセミコロンのよ
     うな区切り文字が省略されたことをしめします。

%s had compilation errors.
     (F) `perl -c' が失敗したときの最終まとめメッセージです。

%s has too many errors.
     (F) 構文解析部が、プログラム中に 10 個のエラーを見つけたため、それ
     以上の解析を諦めました。それ以上のメッセージは、おそらく意味がない
     でしょう。

%s matches null string many times
     (W) 指定したパターンは、もし、正規表現エンジンがチェックを行なって
     いなければ、無限ループに陥るものです。*Note 正規表現::,を参照して
     ください。

%s never introduced
     (S) 問題のシンボルは、宣言されましたが、使われる前にスコープから外
     れてしまいました。

%s syntax OK
     (F) `perl -c' が成功したときの最終まとめメッセージです。

-P not allowed for setuid/setgid script
     (F) C プリプロセッサがスクリプトをオープンするときには、名前でオー
     プンしなければいけませんが、これは、安全性を損なう競合条件をもたら
     します。

-T and -B not implemented on filehandles
     (F) Perl が、お使いの `stdio' のことをよく知らないとき、ファイルハ
     ンドルの `stdio' バッファを覗くことはできません。代わりにファイル
     名を使わなければなりません。

?+* follows nothing in regexp
     (F) 正規表現を、数量子で始めてしまいました。その文字自体を表現した
     いのであれば、バックスラッシュを付けてください。*Note 正規表現::,
     を参照してください。

@ outside of string
     (F) `unpack' される文字列の外に絶対位置指定している、テンプレート
     を指定しました。*Note 組み込み関数::,の `pack' の項を参照してくだ
     さい。

accept() on closed fd
     (W) クローズされたソケットに `accept' を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたのではありませ
     んか。*Note 組み込み関数::,の `accept' の項を参照してください。

Allocation too large: %lx
     (F) MS-DOS マシンでは、64K を越えるメモリアロケートをおこなえませ
     ん。

Arg too short for msgsnd
     (F) `msgsnd()' に渡す文字列は、少なくとも sizeof(long) の長さが必
     要です。

Args must match #! line
     (F) setuid エミュレータでは、Perl を起動したときの引数と、#! の行
     で指定された引数はマッチすることが要求されます。

Argument "%s" isn't numeric
     (W) ここに示した文字列は、数値が必要な演算子の引数として、与えられ
     ました。運がよければ、このメッセージによって、どの演算子が問題となっ
     たかがわかります。

Array @%s missing the @ in argument %d of %s()
     (D) 本当に古い Perl では、場所によっては、配列名の @ を省略できま
     した。この省略は、止めてください。

assertion botched: %s
     (P) Perl に付属の malloc ルーティンが内部エラーを起こした。

Assertion failed: file "%s"
     (P) 一般的なアサーションが失敗しました。問題の file を調べる必要が
     あります。

Assignment to both a list and a scalar
     (F) 条件演算子へ代入を行なう場合には、2 つめの引数と、3つめの引数
     は、ともにスカラか、ともにリストでなければなりません。そうでないと、
     Perl は右辺のコンテキストを決めることができません。

Attempt to free non-arena SV: 0x%lx
     (P) すべての `SV' オブジェクトは、`exit' 時にガーベジコレクション
     が行なわれるアリーナに割り当てるようになっています。ある `SV' が、
     そういったアリーナに入っていないことが、見つかりました。

Attempt to free temp prematurely
     (W) 消滅する値は、`free_tmps()' ルーティンで解放されるようになって
     います。このメッセージは、`free_tmps()' ルーティンの前に何ものかが、
     `SV' を解放しようとしていることを示していて、これは、
     `free_tmps()' が解放しようとしたときには、どこからも参照されていな
     いスカラを解放することになるということです。

Attempt to free unreferenced glob pointers
     (P) シンボルのエイリアスについて、参照カウントの値がおかしな状態に
     なった。

Attempt to free unreferenced scalar
     (W) Perl がスカラの参照カウントをデクリメントしようとして、0 にな
     るかを見たところ、既に 0 になっていることがわかりました。これは、
     既に解放されているべきものであり、実際は、おそらく、解放されたもの
     でしょう。これは、`SvREFCNT_dec()' が必要以上に呼ばれたか、
     `SvREFCNT_inc()' が必要なときに呼ばれなかったか、`SV' が消滅すべき
     で無いときに消滅してしまったか、メモリ異常になったことが考えられま
     す。

Bad arg length for %s, is %d, should be %d
     (F) `msgctl()'、`semctl()'、`shmctl()' のいずれかに、間違ったサイ
     ズのバッファを渡してしまいました。C の言い方で書くと、正しいサイズ
     はそれぞれ、`sizeof(struct msqid_ds *)'、`sizeof(struct semid_ds
     *)'、`sizeof(struct shmid_ds *)' です。

Bad associative array
     (P) 内部ハッシュルーティンで、ヌル `HV' ポインタを渡されたものがあっ
     た。

Bad filehandle: %s
     (F) ファイルハンドルが必要なものに、シンボルを渡しましたが、そのシ
     ンボルは、それに伴うファイルハンドルがありません。おそらく、
     `open()' を忘れたか、別のパッケージで `open()'したかでしょう。

Bad free() ignored
     (S) まず、`malloc()' されていないものに対して、内部ルーティンが
     `free()' を呼びました。

Bad name after %s::
     (F) パッケージプレフィクスでシンボル名を書き始めましたが、そのシン
     ボルが終了しませんでした。特に、クォートの外で、変数展開はできませ
     んから、

          $var = 'myvar';
          $sym = mypack::$var;

     は、

          $var = 'myvar';
          $sym = "mypack::$var";

     と同じではありません。

Bad symbol for array
     (P) シンボルテーブルエントリではないものに、配列エントリを登録する
     ような内部要求があがった。

Bad symbol for filehandle
     (P) シンボルテーブルエントリではないものに、ファイルハンドルエント
     リを登録するような内部要求があがった。

Bad symbol for hash
     (P) シンボルテーブルエントリではないものに、ハッシュエントリを登録
     するような内部要求があがった。

BEGIN failed--compilation aborted
     (F) BEGIN サブルーティンの実行中にトラップ不可能な例外が発生しまし
     た。コンパイルは、即座に停止し、インタプリタは中止します。

bind() on closed fd
     (W) クローズされたソケットに `bind' を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたのではありませ
     んか。*Note 組み込み関数::,の `bind' の項を参照してください。

Callback called exit
     (F) 外部パッケージから `perl_call_sv()' で起動されたサブルーティン
     が `exit' を呼んで終了しました。

Can't "last" outside a block
     (F) 現在のブロックから脱出するために、`last' 文を実行しましたが、残
     念なことにブロックの中ではありませんでした。`if' や `else' の
     ブロックは、「ループ風」ブロックではないので、勘違いしないでください。た
     だし、中括弧を二重にすれば、内側の中括弧が、1 度だけループするブロックと
     みなされますから、同じ効果が得られます。*Note 組み込み関数::, の
     `last' の項を参照してください。

Can't "next" outside a block
     (F) 現在のブロックの繰り返しを進めるために、`next' 文を実行しまし
     たが、ブロックの中ではありませんでした。`if' や `else' のブロック
     は、「ループ風」ブロックではないので、勘違いしないでください。ただ
     し、中括弧を二重にすれば、内側の中括弧が、1 度だけループするブロッ
     クとみなされますから、同じ効果が得られます。*Note 組み込み関数::,
     の `next' の項を参照してください。

Can't "redo" outside a block
     (F) 現在のブロックの繰り返しをもう一度行なうために、`redo' 文を実行
     しましたが、ブロックの中ではありませんでした。`if' や `else'
     のブロックは、「ループ風」ブロックではないので、勘違いしないでください。
     ただし、中括弧を二重にすれば、内側の中括弧が、1 度だけループするブロック
     とみなされますから、同じ効果が得られます。*Note 組み込み関数::,の
     `redo' の項を参照してください。

Can't bless non-reference value
     (F) ハードリファレンスのみが bless できます。これによって、Perl は
     オブジェクトのカプセル化を「強制」します。*Note オブジェクト::,を
     参照してください。

Can't break at that line
     (S) デバッガで実行中に出力される警告で、指定された行番号は、停止可
     能な実行文の場所ではないことを示しています。

Can't call method "%s" in empty package "%s"
     (F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケー
     ジを正しく示していますが、そのパッケージには、何も定義されておらず、
     メソッドだけになっています。*Note オブジェクト::,を参照してくださ
     い。

Can't call method "%s" on unblessed reference
     (F) メソッド呼び出しは、自分が呼び出されたパッケージがどれであるか
     を知る必要があります。普通は、渡したオブジェクトリファレンスからそ
     の情報を受け取りますが、この場合にはオブジェクトリファレンスが渡さ
     れませんでした。リファレンスは、`bless' されて始めて、オブジェクト
     リファレンスとなります。*Note オブジェクト::,を参照してください。

Can't call method "%s" without a package or object reference
     (F) メソッド呼び出しの構文を用いましたが、オブジェクトリファレンス、
     もしくはパッケージ名が書かれるべき場所に、オブジェクトリファレンス
     もパッケージ名も返さない式が書かれています。(おそらく、何も書いて
     ないかもしれません。)以下のようなものは、エラーとなります:

          $BADREF = undef;
          process $BADREF 1,2,3;
          $BADREF->process(1,2,3);

Can't chdir to %s
     (F) `perl -x/foo/bar' のようにして起動したが、`/foo/bar' に
     `chdir' することができません。おそらく、存在しないのでは、ないでしょ
     うか。

Can't coerce %s to integer in %s
     (F) ある種の `SV'、特に本物のシンボルテーブルエントリ (型グロブ)
     は、1つの型に留めておくことができません。したがって、

          *foo += 1;

     とすることはできません。

          $foo = *foo;
          $foo += 1;

     とすることはできますが、`$foo' にはもはやグロブは残っていません。

Can't coerce %s to number in %s
     (F) ある種の `SV'、特に本物のシンボルテーブルエントリ (型グロブ)
     は、1つの型に留めておくことができません。

Can't coerce %s to string in %s
     (F) ある種の `SV'、特に本物のシンボルテーブルエントリ (型グロブ)
     は、1 つの型に留めておくことができません。

Can't create pipe mailbox
     (F) VMS 特有のエラーです。

Can't declare %s in my
     (F) スカラ変数、配列変数、ハッシュ変数だけが、字句スコープの変数と
     して宣言できます。これらは、名前として通常の識別子を持たなければな
     りません。

Can't do inplace edit on %s: %s
     (S) 表示された理由により、新しいファイルの生成に失敗しました。

Can't do inplace edit without backup
     (F) 削除した (が、まだオープンされている) ファイルを読もうとすると
     おかしくなる MS-DOS のようなシステムで実行しています。`-i.bak' の
     ようにバックアップを指定してください。

Can't do inplace edit: %s > 14 characters
     (S) そのファイルのバックアップ名を作ると、ファイル名の長さの制限を
     オーバしてしまいます。

Can't do inplace edit: %s is not a regular file
     (S) `/dev' や FIFO のような、特殊ファイルに対して、`-i' スイッチを
     使おうとしました。そのファイルは、無視されました。

Can't do setegid!
     (P) suidperl の setuid エミュレータで何らかの理由により、
     `setegid()' 呼び出しが失敗しました。

Can't do seteuid!
     (P) suidperl の setuid エミュレータが何らかの理由によって失敗しま
     した。

Can't do setuid
     (F) このエラーは、通常、普通の perl が setuid エミュレーションのた
     めに suidperl を実行しようとしましたが、実行できなかったことを意味
     します。特に UNIX マシンの`/usr/local/bin' などでは、perl の実行ファ
     イルが、perl5.000 という名前のときには、同じディレクトリで
     sperl5.000 という形式の名前を探します。もし、ファイルが存在してい
     れば、実行パーミッションをチェックしてください。許可されていないよ
     うであれば、システム管理者の方に、わけを尋ねてみてください。

Can't do waitpid with flags
     (F) このマシンには、`waitpid()' も `wait4()' もありませんので、フ
     ラグの無い `waitpid()' のみがエミュレート可能です。

Can't do {n,m} with n > m
     (F) 最小値は最大値以下でなければなりません。もし、本当に正規表現が0回繰
     り返したものにマッチさせたいなら、単に {0} としてください。
     *Note 正規表現::,を参照してください。

Can't emulate -%s on #! line
     (F) #! 行にその時点で意味をなさないスイッチが指定されました。たと
     えば、#! 行に `-x' をおいても意味がありません。

Can't exec "%s": %s
     (W) 提示した理由によって、`system()' や `exec()' やパイプオープン
     呼び出しの指定されたプログラムが実行できませんでした。考えられる理
     由には: ファイルのパーミッションが間違っている、ファイルが
     $ENV{PATH} の中にない、問題の実行ファイルがこのマシン用ではない、
     スクリプトの #! 行が同じような理由で実行できないインタプリタを指し
     ている、というようなものがあります。(あるいは、このシステムで、#!
     がサポートされていなません。)

Can't exec %s
     (F) #! 行に書かれた内容にしたがって、Perl は示されたプログラムを実
     行しようとしました。そうしたくないのであれば、#! 行のどこかに、
     perl" と書いておいてください。

Can't execute %s
     (F) `-S' スイッチを使いましたが、実行するスクリプトが PATH の中に
     見つかりませんでした。少なくとも、正しいパーミッションではないと思
     われます。

Can't find label %s
     (F) どこにも見つからないラベルへ `goto' を行なおうとしました。
     *Note 組み込み関数::,の `goto' の項を参照してください。

Can't find string terminator %s anywhere before EOF
     (F) Perl の文字列は、複数行に渡ることができます。このメッセージは、
     文字列を終わる区切り文字が見つからなかったことを意味します。括弧類
     の区切り文字では、ネストを数えるので、

          print q(The character '(' starts a side comment.)

     では、最後の括弧が無いと言われます。

Can't fork
     (F) パイプラインをオープンしようとして、`fork' を行なおうとして、
     致命的エラーが発生しました。

Can't get pipe mailbox device name
     (F) VMS 特有のエラーです。

Can't get SYSGEN parameter value for MAXBUF
     (F) VMS 特有のエラーです。

Can't goto subroutine outside a subroutine
     (F) 結構マジカルな "goto subroutine" の呼び出しは、あるサブルーティ
     ン呼び出しを別のもので置き換えるだけです。反物の状態から作り上げる
     ことはできません。一般に、これを行なうのは、AUTOLOAD ルーティンか
     ら抜け出すときだけにしておくべきです。*Note 組み込み関数::,の
     `goto' の項を参照してください。

Can't locate %s in @INC
     (F) ファイルを `do' (または、`require'、`use') するように指示され
     ましたが、@INC で示されるライブラリの中に見つかりませんでした。お
     そらく、追加ライブラリの場所を示すために、PERL5LIB 環境変数を指定
     する必要があるか、スクリプトの中で @INC にライブラリ名を追加する必
     要があります。ファイル名のスペルミスの可能性もあります。*Note 組み
     込み関数::, の `require' の項を参照してください。

Can't locate object method "%s" via package "%s"
     (F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケー
     ジを正しく示していますが、そのパッケージにも、基底クラスにも、該当
     のメソッドが定義されていません。*Note オブジェクト::,を参照してく
     ださい。

Can't locate package %s for @%s::ISA
     (W) 配列 @ISA に別のパッケージ名が記されていますが、存在していない
     ようです。

Can't mktemp()
     (F) `-e' スイッチを処理しようとして、何らかの理由により、mktemp()
     ルーティンがうまく行きませんでした。/tmp パーティションがいっぱい
     か、壊れている可能性があります。

Can't modify %s in %s
     (F) 指定されたものは、代入、インクリメントなど、変更が許されていま
     せん。

Can't modify non-existent substring
     (P) substr() への代入を行なう内部ルーティンに NULL が渡されました。

Can't msgrcv to readonly var
     (F) msgrcv で使用する変数は、受信バッファとして使用しますので、変
     更可能なものでなければなりません。

Can't open %s: %s
     (S) 置き換え編集で、表示した理由によって、元のファイルがオープンで
     きませんでした。通常、これはそのファイルのリード権が無いときに起こ
     ります。

Can't open bidirectional pipe
     (W) サポートされていない `open(CMD, "|cmd|")' を行なおうとしました。
     これを行なうためには、Perl ライブラリの`open2.pl' のようないくつか
     のモジュールを使うことができます。別の方法として、パイプされたもの
     を ">" を使っていったんファイルに出力し、あとで別のファイルハンド
     ルで読み込みを行なうことも考えられます。

Can't open perl script "%s": %s
     (F) 指定したスクリプトが、表示した理由によってオープンできませんで
     した。

Can't rename %s to %s: %s, skipping file
     (S) `-i' スイッチで行なわれた rename が何らかの理由によって、うま
     く行きませんでした。ディレクトリに書き込み権がないことも考えられま
     す。

Can't reswap uid and euid
     (P) suidperl の setuid エミュレータで何らかの理由により、
     setreuid() 呼び出しが失敗しました。

Can't return outside a subroutine
     (F) `return' 文が、`return' で抜けるべきサブルーティンがない、
     main" コードで実行されました。{サブルーティン}を参照してください。

Can't stat script "%s"
     (P) 何らかの理由で、例え既にオープンしていたとしても、`fstat()' が
     行なえません。困ったもんだ。

Can't swap uid and euid
     (P) suidperl の setuid エミュレータで何らかの理由により、
     setreuid() 呼び出しが失敗しました。

Can't take log of %g
     (F) 対数は、正の実数に対してのみ定義されています。

Can't take sqrt of %g
     (F) 通常の実数では、負数の平方根をとることはできません。しかし、本
     当にその計算を行ないたいのであれば、`Complex' パッケージが Perl に
     用意されています。

Can't undef active subroutine
     (F) 実行中のルーティンを未定義にすることはできません。しかし、実行中に再
     定義することはでき、古いルーティンを実行中に、再定義したサブルーティンを
     `undef' することさえできます。Go figure。

Can't unshift
     (F) Perl のメインスタックのように、`unshift' することのできない
     「実在しない」配列に対して、`unshift' を行なおうとしました。

Can't upgrade that kind of scalar
     (P) 内部の sv_upgrade ルーティンは、`SV' に「メンバ」を加えて、よ
     り特別な種類の `SV' にします。しかし、上位のいくつかの `SV' 型は、
     特殊化され過ぎて、内部変換することができません。このメッセージは、
     そのような変更を行なおうとしたことを示しています。

Can't upgrade to undef
     (P) 未定義 `SV' は、upgrade の仕組みにおいて、階層構造の最下位に位
     置するものです。`undef' への upgrade は、sv_upgrade を呼ぶコードの
     エラーを示します。

Can't use %s as left arg of an implicit ->
     (F) コンパイラが、配列リファレンスへの添え字として、大括弧で括った
     式を解釈しようとしました。大括弧の左が、アロー (->) で終わっていな
     い式であったり、添え字付けされた式になっています。複数の添え字を持
     つ、添え字付けされた式だけが、間のアローを省略できます。

Can't use %s for loop variable
     (F) 単純スカラ変数だけが、`foreach' のループ変数として使用すること
     ができます。

Can't use %s ref as %s ref
     (F) リファレンス型を混同しています。必要な型のリファレンスを被参照
     しなければなりません。必要ならば、リファレンスの型を調べるのに、
     `ref()' 関数を使うことができます。

Can't use a string as %s ref while "strict refs" in use
     (F) `strict refs' では、ハードリファレンスだけが許されます。シンボ
     リックリファレンスは、許されていません。
     *Note リファレンスとデータ構造のネスト::,を参照してください。

Can't use an undefined value as %s reference
     (F) ハードリファレンスやシンボリックリファレンスとして使用する値は、
     定義済みの値でなければなりません。潜伏中のエラーを引きずり出す助け
     となります。

Can't use delimiter brackets within expression
     (F) ${name} という用法は、文字列で識別子の曖昧さを取り除くためのも
     ので、通常のコードの中では使えません。

Can't use global %s in "my"
     (F) マジカル変数を、字句スコープ変数として宣言しようとしました。こ
     れが許されていないのは、マジック変数は1か所だけにおくことができる
     (つまりグローバル変数) からであり、マジカル変数に見えながら、そう
     でないものがプログラム中に現われると混乱の元となるためです。

Can't write to temp file for -e: %s
     (F) `-e' スイッチを処理しようとして、何らかの理由により、書き込み
     ルーティンがうまく行きませんでした。`/tmp' パーティションがいっぱ
     いか、壊れている可能性があります。

Can't x= to readonly value
     (F) 定数値 (未定義値であることが多い) を、自らを書き換えることを意
     味する、代入演算子で繰り返しを行なおうとしました。テンポラリ変数に
     値を移してから、繰り返すと良いでしょう。

Cannot open temporary file
     (F) `-e' スイッチを処理しようとして、何らかの理由により、ファイル
     生成ルーティンがうまく行きませんでした。`/tmp' パーティションがいっ
     ぱいか、壊れている可能性があります。

chmod: mode argument is missing initial 0
     (W) 初心者の方は、

          chmod 777, $filename

     というふうに、777 が 01411 に等しい 10 進数であることに気付かない
     で使うことがあります。Perl では、8 進数の定数は、C と同じように、
     先頭に 0 を付けて表わします。

Close on unopened file <%s>
     (W) オープンされていないファイルハンドルをクローズしようとしました。

connect() on closed fd
     (W) クローズされたソケットに `connent' を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたたのではありま
     せんか。*Note 組み込み関数::,の `connect' の項を参照してください。

Corrupt malloc ptr 0x%lx at 0x%lx
     (P) Perl に付属の malloc ルーティンが内部エラーを起こした。

corrupted regexp pointers
     (P) 正規表現コンパイラが渡したもので、正規表現エンジンが処理できな
     くなった。

corrupted regexp program
     (P) 正規表現エンジンが、有効なマジックナンバーを持たないregexp プ
     ログラムを渡しました。

Deep recursion on subroutine "%s"
     (W) このサブルーティンは、(直接、間接に) 自分自身の呼び出しを、
     `return' より100回多く行ないました。変わったベンチマークプログラム
     を書いているのでなければ、無限再帰の可能性があります。ベンチマーク
     を書いている場合には、別のことを示しています。

Did you mean $ instead of %?
     (W) `$hash{$key}' のつもりで `%hash{$key}' と書いたと思われます。

Don't know how to handle magic of type '%s'
     (P) マジック変数の内部処理がおかしくなっています。

do_study: out of memory
     (P) これは、本来 safemalloc() で、引っ掛かるはずのものです。

Duplicate free() ignored
     (S) 既に解放されているものに対して、内部ルーティンが、`free()' を
     行なおうとしました。

END failed--cleanup aborted
     (F) END サブルーティンを実行中に、トラップできない例外が発生しまし
     た。インタプリタは、即座に実行を中止します。

Execution of %s aborted due to compilation errors.
     (F) Perl のコンパイルが失敗したときの、最後のまとめメッセージです。

Exiting eval via %s
     (W) `goto' やループ制御文など、おかしな方法で `eval' を抜けました。

Exiting subroutine via %s
     (W) `goto' やループ制御文など、おかしな方法でサブルーティンを抜け
     ました。

Exiting substitution via %s
     (W) `return' や `goto' やループ制御文など、おかしな方法で置換を抜
     けました。

Fatal $PUTMSG error: %d
     (F) VMS 特有のエラーです。

fcntl is not implemented
     (F) このマシんでは、fcntl() がインプリメントされていないように見え
     ます。PDP-11 か何かでしょうか。

Filehandle %s never opened
     (W) 初期化していないファイルハンドルに対して、I/O 操作を行なおうと
     しました。`open()' や `socket()'、`FileHandle' パッケージのコンス
     トラクタを呼び出す必要があります。

Filehandle %s opened only for input
     (W) リードオンリーのファイルハンドルに対して、書込みを行なおうとしました。
     読み書き両用ファイルハンドルにしたいのであれば、"<" を付けたり、何も付け
     なかったりするのではなく、"+<" や "+>" や "+>>" を付けて `open' す
     る必要があります。ライトオンリーであれば、">" や ">>" を使ってください。
     *Note 組み込み関数::,の `open' の項を参照してください。

Filehandle only opened for input
     (W) リードオンリーのファイルハンドルに対して、書込みを行なおうとしました。
     読み書き両用ファイルハンドルにしたいのであれば、"<" を付けたり、何も付け
     なかったりするのではなく、"+<" や "+>" や "+>>" を付けて `open' す
     る必要があります。ライトオンリーであれば、">" や ">>" を使ってください。
     *Note 組み込み関数::,の `open' の項を参照してください。

Final $ should be \$ or $name
     (F) 文字列の最後の $ が、リテラルのドル記号なのか、変数名を入れよ
     うとして忘れたのかを、はっきりさせなければなりません。バックスラッ
     シュを付けるか、名前を入れてください。

Final @ should be \@ or @name
     (F) 文字列の最後の @ が、リテラルのアットマークなのか、変数名を入
     れようとして忘れたのかを、はっきりさせなければなりません。バックス
     ラッシュを付けるか、名前を入れてください。

Format %s redefined
     (W) フォーマットを再定義しました。この警告を止めるには、

          {
              local $^W = 0;
              eval "format NAME =...";
          }

     としてください。

Format not terminated
     (F) フォーマットは、単独のドットだけからなる行で終わらなければなり
     ません。そのような行が見つからないまま、スクリプトの最後に行き当たっ
     てしまいました。

Found = in conditional, should be ==
     (W) おそらく、

          if ($foo == 123)

     とすべきところを

          if ($foo = 123)

     としています (あるいは似たようなこと)。

gdbm store returned %d, errno %d, key "%s"
     (S) `GDBM_File' 拡張モジュールが、値の設定に失敗したという警告です。

gethostent not implemented
     (F) C ライブラリに gethostent() がインプリメントされていないようで
     す。おそらく、インプリメントすると Internet 上のすべてのホスト名を
     返さなければいけないと思っているのでしょう。

get{sock,peer}name() on closed fd
     (W) クローズされたソケットに、`get{sock,peer}name()' を行なおうと
     しました。`socket()' の呼び出し時に、返却値のチェックを忘れたので
     はありませんか。

Glob not terminated
     (F) 項が必要とされるところで、開き山括弧が見つけたため、対応する閉
     じ山括弧を探しましたが、見つかりませんでした。可能性としては、必要
     な括弧を省いてしまい、本当は、「小なり記号」を表したかった場合が考
     えられます。

Global symbol "%s" requires explicit package name
     (F) `use strict vars' が指定されていますので、すべての変数は、
     (`my' を使った) 字句スコープの変数か、グローバル変数がどのパッケー
     ジのものかを ("::" を使って)、明示的に修飾しなくてはなりません。

goto must have label
     (F) `next' や `last' とは違って、`goto' には必ず、飛び先を指定しな
     くてはなりません。*Note 組み込み関数::,の `goto' の項を参照してく
     ださい。

Had to create %s unexpectedly
     (S) あるルーティンが、既に存在しているはずのシンボルを、シンボルテー
     ブルで探しましたが、何らかの理由で存在せず、コアダンプを避けるため
     に、緊急に生成しました。

Hash %%s missing the % in argument %d of %s()
     (D) 古い Perl では、ハッシュ名の % を省略できる場所がありました。
     省略はしないようにしてください。

Identifier "%s::%s" used only once: possible typo
     (W) タイプミスは、多くの場合に、その識別子が1度しか現れないことで
     発覚します。何か理由があって、その識別子を1度しか使っていないので
     あれば、単にどこかでその識別子を書いておくだけでこのメッセージは止
     められます。

Illegal division by zero
     (F) ゼロで割り算をしようとしました。ロジックの誤りか、意味の無い入
     力を防ぐために、条件を付けることが必要かのどちらかでしょう。

Illegal modulus zero
     (F) 余りを求めるのに、ゼロで割り算をしようとしました。これは、ほと
     んどの数体系で受け入れられません。

Illegal octal digit
     (F) 8進数で8か9を使いました。

Insecure dependency in %s
     (F) 何か汚染チェックの機構が、望ましくないと判断することを行なおうとしま
     した。setuid や setgid を実行したときや、明示的に `-T' で指定したと
     きに、汚染チェック機構が働きます。汚染チェック機構は、信頼がおけないと仮
     定されるユーザが直接、間接を問わず、指定したデータに印を付けます。そのよ
     うなデータを「危険な」操作に用いると、このエラーが発生します。詳しくは、
     *Note セキュリティ::,を参照してください。

Insecure directory in %s
     (F) $ENV{PATH} の中に、誰にでも書き込みができるディレクトリが含ま
     れているとき、`system()'、`exec()'、パイプのオープンを行なうことは
     できません。*Note セキュリティ::,を参照してください。

Insecure PATH
     (F) $ENV{PATH} の中に、ユーザが指定した (あるいはその可能性がある)
     データから作られたものが含まれるとき、`system()'、`exec()'、パイプ
     のオープンを行なうことはできません。スクリプト内で、信頼できるデー
     タに基づいて、パスに既知の値を設定しなければなりません。*Note セキュ
     リティ::,を参照してください。

internal disaster in regexp
     (P) 正規表現解析部に何か悪いことが起こりました。

internal urp in regexp at /%s/
     (P) 正規表現解析部に何か間違ったことが起こりました。

invalid [] range in regexp
     (F) 文字クラスに指定した範囲の最小値が、最大値よりも大きくなっています。
     *Note 正規表現::,を参照してください。

ioctl is not implemented
     (F) C をサポートしているマシンではおかしなことだと思いますが、この
     マシンでは ioctl() がインプリメントされていないようです。

junk on end of regexp
     (P) 正規表現の構文解析ができなくなった。

Label not found for "last %s"
     (F) 脱出するループを指定しましたが、その名前のループの中にいません、たと
     え、呼び出された場所がそうであっても、今はそうではありません。
     *Note 組み込み関数::,の `last' の項を参照してください。

Label not found for "next %s"
     (F) 次の繰り返しを行なうループを指定しましたが、その名前のループの中にい
     ません。たとえ、呼び出された場所がそうであっても、今はそうではありません。
     *Note 組み込み関数::, の `next' の項を参照してください。

Label not found for "redo %s"
     (F) 繰り返しの再実行を行なうループを指定しましたが、その名前のルー
     プの中にいません。たとえ、呼び出された場所がそうであっても、今はそ
     うではありません。*Note 組み込み関数::,の `redo' の項を参照してく
     ださい。

listen() on closed fd
     (W) クローズされたソケットに listen を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたのではありませ
     んか。*Note 組み込み関数::,の `listen' の項を参照してください。

Literal @%s now requires backslash
     (F) Perl は、配列を展開したいのか、リテラルの @ を使いたいのかを推
     察するようにしていました。これは、実行時に文字列が最初に使われたと
     きに、行なわれました。現在、文字列はコンパイル時に解析され、曖昧
     な @ は、リテラルであることを示すためにバックスラッシュを付けるか、
     プログラム内で (字面の上で) 文字列よりも前に、宣言 (あるいは、使
     用)することによって、配列であることを示さなければなりません。(その
     うちに、バックスラッシュのない @ は、単純に配列と解釈するようにな
     ります。)

Method for operation %s not found in package %s during blessing
     (F) 多重定義テーブルで、有効なメソッドを指していないエントリを指定
     しようとしました。*Note 多重定義::,を参照してください。

Might be a runaway multi-line %s string starting on line %d
     (S) ようやく現在行になって、文字列やパターンの終わりが見つかったこ
     とから、先のエラーが、文字列やパターンのデリミタが、見つからなかっ
     たことで起ったかもしれないことを、補足的に示しています。

Misplaced _ in number
     (W) 十進数定数で下線が、3桁ごとでありませんでした。

Missing $ on loop variable
     (F) csh を使いすぎた症状が現れているようです。Perl では、変数は常
     に $ を付けて表わされます。その時によって違う、シェルとは違ってい
     ます。

Missing comma after first argument to %s function
     (F) ある種の関数では、引数リストの前に、ファイルハンドルや「間接オ
     ブジェクト」をおくことができますが、この関数は、そういったものでは
     ありません。

Missing right bracket
     (F) 字句解析部が、閉じ中括弧よりも開き中括弧を多く発見しました。一
     般的な規則として、最後に修正した場所の近くに間違いがあるといえます。

Missing semicolon on previous line?
     (S) このメッセージは、"%s found where operator expected" というメッ
     セージに伴って出される経験的な想像によるものです。このメッセージが
     出たからといって、機械的に前の行にセミコロンを付けることはしないで
     ください。

Modification of a read-only value attempted
     (F) 直接、間接に関らず、定数値を変更しようとしました。もちろん、コ
     ンパイラが発見できる、"2 = 1" などといったことをしたわけではありま
     せん。しかし、同じことは、

          sub mod { $_[0] = 1 }
          mod(2);

     としても起こります。`substr()' で、文字列の終わりよりも後ろに代入
     を行なうことでも起こります。

Modification of non-creatable array value attempted, subscript %d
     (F) 配列値を存在するようにしようとしました。おそらく、インデクスが
     負数で、配列の終わりから逆に数えたとしても、おかしな位置を指してい
     るようです。

Modification of non-creatable hash value attempted, subscript "%s"
     (F) ハッシュ値を存在するようにしようとしましたが、何か特別な理由で、
     できませんでした。

Module name must be constant
     (F) `use' の最初の引数としてモジュール名を示すのに許されているのは、
     裸の単語だけです。

msg%s not implemented
     (F) このシステムでは、System V メッセージ IPC は使えません。

Multidimensional syntax %s not supported
     (W) 多次元配列は、$foo[1,2,3] のようには書けません。これは、C のよ
     うに $foo[1][2][3] のように書きます。

Negative length
     (F) ゼロより短い長さのバッファで、読み込み、書き込み、送信、受信を
     行なおうとしました。どのようなことがしたいのか判断できません。

nested *?+ in regexp
     (F) 括弧を挟まないで、数量子を数量子で修飾することはできません。つまり、
     ** や +* や ?* といったものは、正しくありません。

     しかし、最短一致数量子の *?、+?、?? は、ネストした数量子のように見
     えますが、そうではありません。*Note 正規表現::,を参照してください。


No #! line
     (F) setuid エミュレータでは、たとえマシンがサポートしていなくても、
     完全な形の #! 行がスクリプトに書かれていなければなりません。

No %s allowed while running setuid
     (F) ある種の操作は、setuid や setgid スクリプトにとって、やってみ
     ることはできても、とても安全なものとは考えられないものです。一般に
     言って、安全ではなくても、安全にしうる、別の方法があるはずです。
     *Note セキュリティ::,を参照してください。

No -e allowed in setuid scripts
     (F) setuid スクリプトは、ユーザによって指定することはできません。

No comma allowed after %s
     (F) ファイルハンドルや「間接オブジェクト」を伴うリスト演算子では、
     それらとそれ以降の引数の間にコンマを入れることはできません。そのよ
     うにした場合には、引数の一つとなってしまいます。

No DB::DB routine defined
     (F) 現在実行中のコードは、`-d' スイッチを付けてコンパイルされまし
     たが、何らかの理由により、perl5db.pl (あるいは、その複製) が各実行
     文の頭で呼び出すルーティンを定義していません。そのファイルは自動的
     に `require' されるものであり、正しく解釈できなければ、`require'
     が失敗するはずですので、これはとても有り得ない状態です。

No dbm on this machine
     (P) これは、内部エラーとして扱われます。Perl に `SDBM'が付いてくる
     ので、どのマシンでも dbm が使えるはずだからです。*Note
     SDBM_File::,を参照してください。

No DBsub routine
     (F) 現在実行中のコードは、`-d' スイッチを付けてコンパイルされまし
     たが、何らかの理由により、`perl5db.pl' (あるいは、その複製) が各サ
     ブルーティン呼び出しの頭で呼び出す `DB::sub' ルーティンを定義して
     いませんでした。

No Perl script found in input
     (F) `perl -x' を呼び出しましたが、そのファイルに #! で始まり、
     perl" という語を含む行が見つかりませんでした。

No setregid available
     (F) Configure が、システム上に setregid() のような関数を見つけられ
     ませんでした。

No setreuid available
     (F) Configure が、システム上に setreuid() のような関数を見つけられ
     ませんでした。

No space allowed after -I
     (F) `-I' の引数は、`-I' の直後にスペースを空けないで書く必要があり
     ます。

No such signal: SIG%s
     (W) %SIG の添え字として認識できないシグナル名を指定しました。お使
     いのシステムで使用可能なシグナル名を調べるには、シェル上で
     `kill -l' などとしてください。

Not a CODE reference
     (F) Perl がコード値 (サブルーティン) へのリファレンスを評価しようとしま
     したが、別のものへのリファレンスでした。実際にどんな種類のリファレンスか
     を調べるには、`ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,も参照してください。

Not a format reference
     (F) どのように無名のフォーマットへのリファレンスを生成したのかはわ
     かりませんが、このメッセージは、それが指定されて、存在しなかったこ
     とを示します。

Not a GLOB reference
     (F) Perl が「型グロブ」(これは、*foo のようなシンボルテーブルエン
     トリです) へのリファレンスを評価しようとしましたが、別のものへのリ
     ファレンスでした。実際にどんな種類のリファレンスかを調べるには、
     `ref()' 関数を使うことができます。*Note リファレンスとデータ構造の
     ネスト::,を参照してください。

Not a HASH reference
     (F) Perl がハッシュ値へのリファレンスを評価しようとしましたが、別のもの
     へのリファレンスでした。実際にどんな種類のリファレンスかを調べるには、
     `ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,を参照してください。

Not a perl script
     (F) setuid エミュレータでは、たとえマシンがサポートしていなくても、
     完全な形の #! 行がスクリプトに書かれていなければなりません。この行
     で指定されるのは、perl でなければなりません。

Not a SCALAR reference
     (F) Perl がスカラ値へのリファレンスを評価しようとしましたが、別のものへ
     のリファレンスでした。実際にどんな種類のリファレンスかを調べるには、
     `ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,を参照してください。

Not a subroutine reference
     (F) Perl がコード値 (サブルーティン) へのリファレンスを評価しようとしま
     したが、別のものへのリファレンスでした。実際にどんな種類のリファレンスか
     を調べるには、`ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,も参照してください。

Not a subroutine reference in %OVERLOAD
     (F) 多重定義テーブルで、有効なサブルーティンを指していないエントリ
     を指定しようとしました。*Note 多重定義::,を参照してください。

Not an ARRAY reference
     (F) Perl が配列値へのリファレンスを評価しようとしましたが、別のものへの
     リファレンスでした。実際にどんな種類のリファレンスかを調べるには、
     `ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,を参照してください。

Not enough arguments for %s
     (F) この関数は、指定したよりも多くの引数を必要とします。

Not enough format arguments
     (W) 指定したフォーマットに、次の行で指定したより多くのピクチャフィー
     ルドがあります。*Note フォーマット文::,を参照してください。

Null filename used
     (F) 特に、多くのマシンでカレントディレクトリを意味するため、空のファ
     イル名は `require' できません。*Note 組み込み関数::,の `require'
     の項を参照してください。

NULL OP IN RUN
     (P) 内部ルーティンで、ヌル opcode ポインタで run() を呼んだものが
     あります。

Null realloc
     (P) realloc NULL を行なおうとしました。

NULL regexp argument
     (P) 内部パターンマッチルーティンが、大当たりです。

NULL regexp parameter
     (P) 内部パターンマッチルーティンが、狂っています。

Odd number of elements in hash list
     (S) ハッシュリストへの要素の数が奇数でした。ハッシュリストは、
     key/value のペアで与えられますから、これは奇妙なことです。

oops: oopsAV
     (S) 文法がおかしくなったことを示す内部警告です。

oops: oopsHV
     (S) 文法がおかしくなったことを示す内部警告です。

Operation `%s' %s: no method found,
     (F) 多重定義テーブルで、もはや有効なメソッドを指していないエントリ
     を使おうとしました。*Note 多重定義::,を参照してください。

Out of memory for yacc stack
     (F) yacc パーサーが解析を続けるために、スタックを広げようとしましたが、
     `realloc()' が仮想やその他のメモリを確保できませんでした。

Out of memory!
     (X) 要求を満たすだけの、十分な残メモリ (または、仮想メモリ) が取得
     できないことを示す、0 を `malloc()' 関数が返しました。

page overflow
     (W) `write()' の 1 度の呼び出しで、1 ページに収まるより多くの行が
     できました。*Note フォーマット文::,を参照してください。

panic: ck_grep
     (P) `grep' をコンパイルしようとして、内部の一貫性チェックに引っ掛
     かりました。

panic: ck_split
     (P) `split' をコンパイルしようとして、内部の一貫性チェックに引っ掛
     かりました。

panic: corrupt saved stack index
     (P) セーブスタックにある以上のローカル化した値を元に戻す要求があり
     ました。

panic: die %s
     (P) `eval' コンテキストへコンテキストスタックをポップしたあと、
     `eval' コンテキストでないことがわかりました。

panic: do_match
     (P) 内部の pp_match() ルーティンが、無効な省略可能データを付けて呼
     ばれました。

panic: do_split
     (P) `split' の準備中に何かまずいことが起こってしまいました。

panic: do_subst
     (P) 内部の pp_subst() ルーティンが、無効な省略可能データを付けて呼
     ばれました。

panic: do_trans
     (P) 内部の pp_trans() ルーティンが、無効な省略可能データを付けて呼
     ばれました。

panic: goto
     (P) 指定したラベルを伴うコンテキストへコンテキストスタックをポップ
     したあと、どのように `goto' するかがわかっているコンテキストでない
     ことがわかりました。

panic: INTERPCASEMOD
     (P) 大文字小文字修飾子のところで、字句解析部がおかしな状態に陥りま
     した。

panic: INTERPCONCAT
     (P) 中括弧を伴う文字列を解析中に、字句解析部がおかしな状態に陥りま
     した。

panic: last
     (P) block コンテキストへコンテキストスタックをポップしたあと、
     block コンテキストでないことがわかりました。

panic: leave_scope clearsv
     (P) 書き込み可能な字句スコープ変数が、どういうわけか、スコープ内で
     リードオンリーになりました。

panic: leave_scope inconsistency
     (P) おそらく、セーブスタックの同期がとれていません。少なくとも、トッ
     プに不正な enum がありました。

panic: malloc
     (P) malloc に負のバイト数で要求が行なわれました。

panic: mapstart
     (P) コンパイラが、map() 関数に関しておかしくなりました。

panic: null array
     (P) 内部配列ルーティンで、ヌル `AV' ポインタを渡されたものがあった。

panic: pad_alloc
     (P) コンパイラが、一時領域や字句形式を割り当て、解放しているスクラッ
     チパッドについて混乱しました。

panic: pad_free curpad
     (P) コンパイラが、一時領域や字句形式を割り当て、解放しているスクラッ
     チパッドについて混乱しました。

panic: pad_free po
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pad_reset curpad
     (P) コンパイラが、一時領域や字句形式を割り当て、解放しているスクラッ
     チパッドについて混乱しました。

panic: pad_sv po
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pad_swipe curpad
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pad_swipe po
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pp_iter
     (P) `foreach' の繰返し子が、ループ文脈以外のところで呼ばれました。

panic: realloc
     (P) 何か、realloc に負のバイト数を要求したものがあります。

panic: restartop
     (P) 内部ルーティンから `goto' (または、同じようなもの) が要求され
     ましたが、飛び先が与えれていません。

panic: return
     (P) サブルーティンコンテキストや `eval' コンテキストへ、コンテキス
     トスタックをポップしたあと、サブルーティンコンテキストや `eval' コ
     ンテキストでないことがわかりました。

panic: scan_num
     (P) scan_num() が、何か数字でないものに対して呼ばれました。

panic: sv_insert
     (P) sv_insert() ルーティンが、存在する以上の文字列を削除するように
     指示されました。

panic: top_env
     (P) コンパイラが、`goto' など妙なことを行なおうとしました。

panic: yylex
     (P) 大文字小文字修飾子を処理中に、字句解析部がおかしな状態に陥りま
     した。

Parens missing around "%s" list
     (W) おそらく、

          my ($foo, $bar) = @_;

     のようにすべきところで、

          my $foo, $bar = @_;

     のように書いてしまいました。`my' や `local' は、コンマよりも強く結
     合することを忘れないでください。

Perl %3.3f required--this is only version %s, stopped
     (F) 問題のモジュールは、現在実行中の Perl よりも最近のバージョンの機能を
     使っています。ところで、どのくらいアップグレードしていないのですか。
     *Note 組み込み関数::,の `require' の項を参照してください。

Permission denied
     (F) suidperl の setuid エミュレータは、実行者が安全とは言えないと
     判断しました。

POSIX getpgrp can't take an argument
     (F) お使いの C コンパイラは、引数に pid をとる BSD バージョンの
     `getpgrp()' と違って、引数をとらない POSIX のものを使っています。

Possible memory corruption: %s overflowed 3rd argument
     (F) `ioctl()' や `fcntl()' が、Perl が求めていた以上のものを返して
     きました。Perl は、適量のバッファサイズを見積もりますが、念のため
     にバッファの最後に目印を付けています。この目印が壊されたため、
     Perl はメモリの破壊が起こったと判断しました。*Note 組み込み関数::,の
     `ioctl' の項を参照してください。

Precedence problem: open %s should be open(%s)
     (S) 古い変則的な構文

          open FOO || die;

     は現在は、Perl 5 の文法の厳しい正規化の結果、単項演算子かリスト演
     算子と解釈されますので、

          open(FOO || die);

     という風に誤った解釈がなされます。(古い `open' は、単項演算子とリ
     スト演算子の中間のようなものでした。)ファイルハンドルの前後を括弧
     で囲むか、"||" 演算子の代わりに`or' 演算子を使わなくてはなりません。

print on closed filehandle %s
     (W) `print' を行なおうとしたファイルハンドルは、既にクローズされて
     います。ロジックの流れをチェックしてください。

printf on closed filehandle %s
     (W) `printf' を行なおうとしたファイルハンドルは、既にクローズされ
     ています。ロジックの流れをチェックしてください。

Probable precedence problem on %s
     (W) コンパイラが、条件を期待するところで、裸の単語を見つけました。
     これは、多くの場合、|| や && が前の構文の最後の引数の一部として解
     釈されたときに発生します。たとえば、

          open FOO || die;

     のような場合です。

Read on closed filehandle <%s>
     (W) 読み込みを行なおうとしたファイルハンドルは、既にクローズされて
     います。ロジックの流れをチェックしてください。

Reallocation too large: %lx
     (F) MS-DOS マシンでは、64K を越えるメモリを割り当てることはできま
     せん。

Recompile perl with -DDEBUGGING to use -D switch
     (F) Perl のコンパイル時に、適切な出力ルーティンが組み込まれていな
     ければ、`-D' スイッチを使うことはできません。これは、多少のオーバ
     ヘッドがかかるもので、それが現在使っている Perl に組み込んでない理
     由でしょう。

Recursive inheritance detected
     (F) 100 レベル以上の継承が行なわれました。おそらく、継承階層の中で、
     予想外のループになっている部分があるものと思われます。

Reference miscount in sv_replace()
     (W) 内部の `sv_replace()' 関数が、参照数が1でない、新規の `SV' を
     扱いました。

regexp memory corruption
     (P) 正規表現コンパイラが渡したもので、正規表現エンジンが処理できな
     くなった。

regexp out of space
     (P) `safemalloc()' が見つけるはずなので、「起こるはずのないエラー」
     です。

regexp too big
     (F) 現在の正規表現のインプリメンテーションでは、文字列のアドレスのオフセッ
     トを表わすのに short を使っています。このメッセージは、正規表現を編集し
     たときに、32767 を越えてしまったことを表しています。通常、このように正規
     表現が巨大化してしまうときには、文を分けた、より良い方法があるはずです。
     *Note 正規表現::,を参照してください。

Reversed %s= operator
     (W) 代入演算子を逆順に書いています。等号の後に単項演算子が続くとき
     に、曖昧になるのを避けるため、代入演算子では、等号 = が、最後にこ
     ないといけません。

Runaway format
     (F) 定義したフォーマットに、空になるまで繰り返す ~~ が含まれていま
     したが、一度に 200 行以上となり、199 行目と200 行目が全く同じにな
     りました。(スカラ変数には) @ の代わりに ^ を用いるか、(配列変数に
     は) `shift' か `pop' を行なうかして、引数が自動的になくなるように
     なっていないといけませんが、そうなっていないようです。*Note 組み込
     み関数::,を参照してください。

Scalar value @%s[%s] better written as $%s[%s]
     (W) 配列の一つの要素を選ぶのに、(@ で示される) 配列スライスを用い
     ました。一般には、($ で示される) スカラ値を使った方が良いと思われ
     ます。違いは、$foo[&bar] とした場合、代入の対象としたときにも、添
     字を評価するときにも、常にスカラとして振る舞うのに対し、
     @foo[&bar] の場合には、代入の対象としてもリストとして振る舞い、添
     字にもリストコンテキストを与えることになります。これは、1 つの添字
     だけを期待するときには、おかしなこととなるでしょう。

Script is not setuid/setgid in suidperl
     (F) 妙なことに、setuid ビット、もしくは setgid ビットが立っていな
     いスクリプトに対して、suidperl プログラムが起動されました。これは
     意味がありません。

Search pattern not terminated
     (F) `//' もしくは `m{}' 構文の最後の区切り文字が見つかりませんでし
     た。括弧類の区切り文字では、ネストを数えることを忘れないでください。

seek() on unopened file
     (W) オープンされていないファイルハンドルか、既にクローズされたファ
     イルハンドルに対して、`seek()' 関数を使おうとしました。

select not implemented
     (F) このマシンでは、`select()' システムコールはインプリメントされ
     ていません。

sem%s not implemented
     (F) このシステムでは、System V セマフォ IPC は使えません。

semi-panic: attempt to dup freed string
     (S) 既に解放と印を付けたスカラを複製するために、内部の
     `newSVsv()' ルーティンが呼ばれました。

Semicolon seems to be missing
     (W) この付近の構文エラーは、おそらくセミコロンか、コンマなどの演算
     子がなかったために起こったものと考えられます。

Send on closed socket
     (W) 送信を行なおうとしたソケットは、既にクローズされています。ロジッ
     クの流れをチェックしてください。

Sequence (?#... not terminated
     (F) 正規表現コメントは、閉じ括弧で終わらなければなりません。括弧を
     含めることは許されません。*Note 正規表現::,を参照してください。

Sequence (?%s...) not implemented
     (F) 使おうとした正規表現の拡張は、予約された文字ですが、まだインプ
     リメントされていません。*Note 正規表現::,を参照してください。

Sequence (?%s...) not recognized
     (F) お使いになった正規表現の拡張は、意味をなしません。*Note 正規表
     現::,を参照してください。

setegid() not implemented
     (F) `$)' へ代入を行なおうとしましたが、この OS では、`setegid()'
     システムコール (または、同等のもの) がサポートされていません。少な
     くとも Configure では、そう判断されました。

seteuid() not implemented
     (F) `$>' へ代入を行なおうとしましたが、この OS では、`seteuid()'
     システムコール (または、同等のもの) がサポートされていません。少な
     くとも Configure では、そう判断されました。

setrgid() not implemented
     (F) `$(' へ代入を行なおうとしましたが、この OS では、`setrgid()'
     システムコール (または、同等のもの) がサポートされていません。少な
     くとも Configure では、そう判断されました。

setruid() not implemented
     (F) $< へ代入を行なおうとしましたが、この OS では、setruid() シス
     テムコール (または、同等のもの) がサポートされていません。少なくと
     も Configure では、そう判断されました。

Setuid/gid script is writable by world
     (F) setuid エミュレータは、誰もが書き込みができるようになっている
     スクリプトは実行しません。誰かが既に書き換えたかも知れないからです。

shm%s not implemented
     (F) このシステムでは、System V 共有メモリ IPC は使えません。

shutdown() on closed fd
     (W) クローズされたソケットに shutdown を行なおうとしました。多少、
     無駄のように思われます。

SIG%s handler "%s" not defined.
     (W) %SIG 内で指定したシグナルハンドラが、存在しません。間違ったパッ
     ケージで、設定を行なっているのかもしれません。

sort is now a reserved word
     (F) もはや、誰もお目にかかることのない、旧世代のエラーメッセージで
     す。ただ、`sort' がキーワードとなる前には、これをファイルハンドル
     として使う方がいました。

Sort subroutine didn't return a numeric value
     (F) `sort' の比較ルーティンは、必ず数値を返さなければなりません。
     `<=>' や `cmp' を使わなかったか、正しく使わなかったものと思います。
     *Note 組み込み関数::,の `sort' の項を参照してください。

Sort subroutine didn't return single value
     (F) `sort' の比較サブルーティンは、要素が 1 個以外のリスト値を返す
     ことはできません。*Note 組み込み関数::,の `sort' の項を参照してく
     ださい。

Split loop
     (P) `split' が無限ループに陥りました。(明らかに、`split' は、
     入力文字数以上にはできないはずですが、そうなってしまいました。)
     *Note 組み込み関数::,の `split' の項を参照してください。

Stat on unopened file <%s>
     (W) オープンされていないファイルハンドルか、既にクローズされたファ
     イルハンドルに対して、`stat()' 関数 (か、同様なファイルテスト) を
     使おうとしました。

Statement unlikely to be reached
     (W) `exec()' の後に、die() 以外の実行文があります。失敗したとき以外
     は、`exec()' から `return' することはありませんから、ほとんど
     の場合には誤りでしょう。`return' してくる`system()' に置き換え
     る必要があるかもしれません。この警告を止めるには、ブロック内に
     `exec()' だけを記述してください。

Subroutine %s redefined
     (W) サブルーティンを再定義しました。この警告を止めるには、

          {
              local $^W = 0;
              eval "sub name { ... }";
          }

     としてください。

Substitution loop
     (P) 置換が無限ループに陥りました。(明らかに、置換は入力文字数以上
     には起こらないはずですが、それが起こってしまいました。)*Note 演算
     子と優先順位::,の「クォートとクォートのような演算子」の節の置換に
     関する記述を参照してください。

Substitution pattern not terminated
     (F) `s///' もしくは `s{}{}' 構文の真ん中の区切り文字が見つかりませ
     んでした。括弧類の区切り文字では、ネストを数えることを忘れないでく
     ださい。

Substitution replacement not terminated
     (F) `s///' もしくは `s{}{}' 構文の最後の区切り文字が見つかりません
     でした。括弧類の区切り文字では、ネストを数えることを忘れないでくだ
     さい。

substr outside of string
     (W) 文字列の外を指す `substr()' を参照しようとしました。つまり、オ
     フセットの絶対値が、文字列の長さより大きくなっています。
     *Note 組み込み関数::,の `substr' の項を参照してください。

suidperl is no longer needed since...
     (F) お使いの Perl は、-DSETUID_SCRIPTS_ARE_SECURE_NOW を指定してコ
     ンパイルされていますが、setuid エミュレータが、実行されてしまいま
     した。

syntax error
     (F) おそらく、構文エラーが起こっています。よくある原因としては、

        * キーワードのスペルミス。
        * セミコロンを忘れた。
        * コンマを忘れた。
        * 開き括弧、閉じ括弧を忘れた。
        * 開き中括弧、閉じ中括弧を忘れた。
        * クォートの閉じ忘れ。

     が考えられます。多くの場合、構文エラーと一緒に、別のエラーメッセー
     ジが出て、情報を与えてくれます。(`-w' を付けることが、助けになるこ
     ともあります。)エラーメッセージ自身には、何行目まで行って、諦めた
     のかということも含まれています。Perl はでたらめな入力を理解するの
     が得意なので、実際のエラーはもう少し前に在ることもあります。ときに
     は、行番号が全く役に立たないこともあり、はまってしまったなら、エラー
     のきっかけが何かを見つける唯一の手段は、プログラムを寸断して、エラー
     がなくなるまで、`perl -c' を繰り返すしかありません。頭の体操 20 問
     だと思ってください。

System V IPC is not implemented on this machine
     (F) 何か、名前が "sem"、"shm"、"msg" で始まる関数を実行しようとしました。
     *Note 組み込み関数::,の `semctl' などの項を参照してください。

Syswrite on closed filehandle
     (W) 書き込みを行なおうとしたファイルハンドルは、既にクローズされて
     います。ロジックの流れをチェックしてください。

tell() on unopened file
     (W) オープンされていないファイルハンドルか、既にクローズされたファ
     イルハンドルに対して、`tell()' 関数を使おうとしました。

Test on unopened file <%s>
     (W) オープンされていないファイルハンドルに対して、ファイルテスト演
     算子を実行しようとしました。ロジックをチェックしてください。*Note
     組み込み関数::,の `-X' の節を参照してください。

That use of $[ is unsupported
     (F) 現在、$[ への代入は、厳しく制限され、コンパイラディレクティブ
     と解釈されます。使えるのは、

          $[ = 0;
          $[ = 1;
          ...
          local $[ = 0;
          local $[ = 1;
          ...

     の一つだけです。これは、一つのモジュールで、他のモジュールが意図しないよ
     うな、配列のベースを変更する問題を回避するためのものです。
     *Note 定義済み変数::,の $[ の節を参照してください。

The %s function is unimplemented
     (F) この関数は、Configure の調査によると、このアーキテクチャでは、
     インプリメントされていないようです。

The crypt() function is unimplemented due to excessive paranoia.
     (F) Configure は、マシン上で `crypt()' 関数を見つけられませんでし
     た。おそらく、ベンダからの供給がなかったからで、おそらく、ベンダは
     アメリカ政府がそれを秘密だとしていると思っているか、少なくとも思っ
     ているというふりをしているのでしょう。私を引き合いに出したところで、
     それは否定されることでしょう。

The stat preceding -l _ wasn't an lstat
     (F) 過去の `stat' がシンボリックリンクを通り過ぎた、実際のファイル
     の情報を取って、`stat' バッファに入れているときに、シンボリックタ
     イプの `stat' をカレント `stat' バッファに対して行なっても意味があ
     りません。実際のファイル名を使ってください。

times not implemented
     (F) お使いの C ライブラリでは、`times()' を行わないようです。UNIX
     ではない環境でしょうか。

Too few args to syscall
     (F) `syscall()' には、最低限でも呼び出すシステムコールを示す、引数
     が一つ必要です。

Too many args to syscall
     (F) Perl では、`syscall()' に最大 14 までしか、引数を渡すことがで
     きません。

Too many arguments for %s
     (F) 関数が要求する以上の引数を指定しました。

trailing \ in regexp
     (F) 正規表現が、バックスラッシュを付けていないバックスラッシュで終
     了しました。バックスラッシュを付けてください。*Note 正規表現::,を
     参照してください。

Translation pattern not terminated
     (F) `tr///' もしくは `tr[][]' 構文の真ん中の区切り文字が見つかりま
     せんでした。

Translation replacement not terminated
     (F) `tr///' もしくは `tr[][]' 構文の最後の区切り文字が見つかりませ
     んでした。

truncate not implemented
     (F) このマシンでは、Configure が知りうる、ファイルの切り詰めの機能
     がインプリメントされていません。

Type of arg %d to %s must be %s (not %s)
     (F) この関数は、その位置に決まった型の引数を必要とします。配列は、
     @NAME もしくは @{EXPR} でなくてはならず、ハッシュは、%NAME もしく
     は %{EXPR} でなければなりません。暗黙の被参照は許されませんので、
     明示的な被参照として、{EXPR} 形式を使ってください。*Note リファレ
     ンスとデータ構造のネスト::,を参照してください。

umask: argument is missing initial 0
     (W) `umask 222' は正しくありません。Perl の 8 進数リテラルは、C と
     同じように 0 で始まりますから、 0222 とすべきです。

Unbalanced context: %d more PUSHes than POPs
     (W) いくつの実行コンテキストに入って、出たかということの内部矛盾が
     `exit' コードで発見されました。

Unbalanced saves: %d more saves than restores
     (W) いくつの値が、一時的にローカル化されたかということの内部矛盾が
     `exit' コードで発見されました。

Unbalanced scopes: %d more ENTERs than LEAVEs
     (W) いくつのブロックにに入って、出たかということの内部矛盾が
     `exit' コードで発見されました。

Unbalanced tmps: %d more allocs than frees
     (W) いくつの揮発性スカラの割り当てを行ない、解放したかということの
     内部矛盾が `exit' コードで発見されました。

Undefined format "%s" called
     (F) このフォーマットは存在しないように見えます。おそらく、別のパッ
     ケージに存在するのではないでしょうか。*Note フォーマット文::,を参
     照してください。

Undefined sort subroutine "%s" called
     (F) 指定された `sort' の比較ルーティンは存在していないように思われ
     ます。おそらく、別のパッケージに存在するのではないでしょうか。
     *Note 組み込み関数::,の `sort' の項を参照してください。

Undefined subroutine &%s called
     (F) 指定されたサブルーティンが定義されていません。定義されていたと
     しても、既に未定義になっています。

Undefined subroutine called
     (F) 呼びだそうとしている無名のサブルーティンは、定義されていません。
     定義されていたとしても、既に未定義になっています。

Undefined subroutine in sort
     (F) 指定された `sort' の比較ルーティンは宣言されましたが、定義され
     ていないようです。*Note 組み込み関数::,の `sort' の項を参照してく
     ださい。

unexec of %s into %s failed!
     (F) unexec() ルーティンが何らかの理由によって失敗しました。最初に
     インストールしたであろう、サイトの FSF 代表者にたずねてみてくださ
     い。

Unknown BYTEORDER
     (F) このバイト順序を入れ替える関数がありません。

unmatched () in regexp
     (F) 正規表現の中では、バックスラッシュを付けていない括弧は、必ず対
     応していなければなりません。vi をお使えであれば、% を使って対応す
     る括弧を探すことができます。*Note 正規表現::,を参照してください。

Unmatched right bracket
     (F) 字句解析部が開き中括弧よりも多くの閉じ中括弧を見つけました。開
     き中括弧のもれと思われます。一般的な規則として、最後に修正した場所
     の付近に、忘れた中括弧 (であるはずのもの) があることでしょう。

unmatched [] in regexp
     (F) 文字クラスの前後の大括弧は、対応していないといけません。文字ク
     ラスの中に閉じ大括弧を入れたいのであれば、バックスラッシュを付ける
     か、文字クラスの最初に置いてください。*Note 正規表現::,を参照して
     ください。

Unquoted string "%s" may clash with future reserved word
     (W) いつの日にか、予約語とかち合うかもしれない、裸の単語を使用して
     います。そのような単語は、クォートするか、大文字を入れるか、アンダー
     バー (_) をいれるかしてください。その裸の単語は、サブルーティンと
     して宣言することも可能です。

Unrecognized character \%03o ignored
     (S) 入力にゴミの文字が見つかり、無視しました。EBCDICマシーンの制御
     文字だとかの場合のためのメッセージです。

Unrecognized signal name "%s"
     (F) `kill()' 関数に、認識できないシグナル名を指定しました。お使い
     のシステムで使用可能なシグナル名を調べるには、シェル上で
     `kill -l' などとしてください。

Unrecognized switch: -%s
     (F) Perl に間違ったオプションを指定しました。これを行なってはいけ
     ません。(指定したつもりがないのであれば、#! 行に間違ったオプション
     がスイッチが指定されていないかをチェックしてください。)

Unsuccessful %s on filename containing newline
     (W) あるファイル名に対して、ファイル操作を行ないましたが、失敗しました。
     「おそらく」ファイル名に改行文字がついていたからで、「おそらく」
     `chop()' や `chomp()' するのを忘れたのでしょう。
     *Note 組み込み関数::,の `chop' の項を参照してください。

Unsupported directory function "%s" called
     (F) このマシンでは、`opendir()' や `readdir()' がサポートされてい
     ません。

Unsupported function %s
     (F) このマシンでは、表示した関数はインプリメントされていません。少
     なくとも、Configure はそう判断しました。

Unsupported socket function "%s" called
     (F) このマシンでは、バークレイのソケット機構がサポートされていない
     か、少なくとも Configure がそう判断しました。

Unterminated <> operator
     (F) 項が必要とされるところで、開き山括弧が見つけたため、対応する閉
     じ山括弧を探しましたが、見つかりませんでした。可能性としては、必要
     な括弧を省いてしまい、本当は、「小なり記号」を表したかった場合が考
     えられます。

Use of $# is deprecated
     (D) これは、貧相な awk の機能をエミュレートしようとするものでした。
     代わりに、明示的に `printf()' や `sprintf()' を使ってください。

Use of $* is deprecated
     (D) この変数は、自分のスクリプトでも、たまたま呼んだ先のサブルーティンで
     も、複数行のパターンマッチを有効にしてしまいます。$* の離れたところに与
     える危険な影響を避けてこれを行なうために、新しい `//m' 修飾子と
     `//s' 修飾子を使ってください。

Use of %s is deprecated
     (D) 示した構文は、もはや使うことが推奨されません。一般にはもっと良
     い方法があるからであり、また古い方法は、悪い副作用があるからです。

Use of implicit split to @_ is deprecated
     (D) サブルーティンの引数を壊すとコンパイラに多大な労力をかけること
     になるので、`split()' の結果は明示的に配列 (やリスト) に代入を行な
     うようにしてください。

Use of uninitialized value
     (W) 未定義値を、あたかも既に定義されているかのように使用しました。
     これは、"" か 0 と解釈されますが、間違いの可能性があります。この警
     告を止めるには、変数に初期値を代入してください。

Useless use of %s in void context
     (W) ブロックの値を返さない文や、スカラのコンマ演算子の左側のように
     返却値の無い文脈で、副作用のないことを行ないました。多くは、みなさ
     んの間違いを指摘するものではなく、Perl がみなさんの意向を汲み取っ
     た解釈ができないことで起こります。たとえば、みなさんが C の優先順
     位を Pythonの優先順位と混同して、

          ($one, $two) = (1, 2);

     とするべきところで、

          $one, $two = 1, 2;

     とすれば、このエラーとなります。

Warning: unable to close filehandle %s properly.
     (S) `open()' によって暗黙のうちに行なわれる `close()' が、
     `close()' のエラーとなりました。通常、ファイルシステムがいっぱいで
     あることを示します。

Warning: Use of "%s" without parens is ambiguous
     (S) 単項演算子の後に、何か項にも単項演算子にも解釈できる、二項演算
     子のようなものが置かれました。たとえば、`rand'関数がデフォルトの引
     数として、1.0 をとることを知っていれば、

          rand + 5;

     と書いて、

          rand() + 5;

     と同じことと思うかもしれませんが、実際には、

          rand(+5);

     の意味になります。したがって、思うように解釈させるには、括弧が必要
     になります。

Write on closed filehandle
     (W) 書き込みを行なおうとしたファイルハンドルは、既にクローズされて
     います。ロジックの流れをチェックしてください。

X outside of string
     (F) `unpack' している文字列の先頭より前の相対位置を示している
     `pack' テンプレートを指定しました。*Note 組み込み関数::,の
     `pack' の項を参照してください。

x outside of string
     (F) `unpack' している文字列の最後より後の相対位置を示している
     `pack' テンプレートを指定しました。*Note 組み込み関数::,の
     `pack' の項を参照してください。

Xsub "%s" called in sort
     (F) ソートの比較ルーティンとして、外部サブルーティンを使用すること
     は、まだサポートされていません。

Xsub called in sort
     (F) ソートの比較ルーティンとして、外部サブルーティンを使用すること
     は、まだサポートされていません。

You can't use -l on a filehandle
     (F) ファイルはオープンされたファイルを表わすものであり、ファイルを
     オープンしたときには、探しているシンボリックリンクは、既に通り過ぎ
     た後です。代わりにファイル名を使ってください。

YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!
(このカーネルでは、SET-ID スクリプトが禁止されていません!)
     (F) そして、そうすることはできないでしょう。カーネルのソースはお持
     ちではないでしょうし、ベンダも欲しいものを提供してはくれないでしょ
     うから。もっとも良いのは、スクリプトに setuid C ラッパーを被せるた
     めに、eg ディレクトリの wrapsuid スクリプトを使ってみることです。

You need to quote "%s"
     (W) シグナルハンドラ名に、裸の単語を代入しました。残念ながら、その
     サブルーティンは既に宣言されていて、Perl 5では、おそらく思惑とは違っ
     て、代入の実行時にサブルーティンの呼び出しが起こります。(もし、本
     当にそうしたいのであれば、サブルーティン名に & を付けてください。)

[gs]etsockopt() on closed fd
     (W) クローズされたソケットに `getsockopt' または `setsockopt'を行
     なおうとしました。`socket()' の呼び出し時に、返却値のチェックを忘
     れたのではありませんか。*Note 組み込み関数::,の `getsockopt' の項
     を参照してください。

\1 better written as $1
     (W) パターンの外では、後方参照は変数の形で存在します。後方参照の利
     用は、置換の右側の部分で扱われますが、スタイル的には、他の Perl プ
     ログラマが期待し、9個以上の後方参照があるときにもうまく動作する、
     変数形式を使う方が良いでしょう。




File: perl-ja.info, Node: フォーマット文, Next: プロセス間通信, Prev: 診断メッセージ, Up: Top

フォーマット文
**************

Perl は、単純なレポートやチャートを作成するお手伝いができます。これを簡
単にするために、Perl では、印字された時にどのように見えるかに近い形で、
コードの中で出力ページをレイアウトできます。Perl はまた、1ページに何行
入るか、現在何ページめか、いつページヘッダを出力するかといったことのめ
んどうをみてくれます。使用されるキーワードは FORTRAN から持ってきたもの
で、宣言に `format' 文を用い、実行に `write()' を使います。*Note 組み込
み関数::,で `formline' と `write' の項を参照してください。幸い、レイア
ウトは BASIC の PRINT USING 文のようなものより読みやすいものです。安上
がりな nroff(1) と考えてください。

フォーマットは、パッケージやサブルーティンと同じく、実行文ではなく、宣
言文ですから、プログラムのどこにおいてもかまいません。(しかしながら、普
通は1か所にまとめておいた方が良いでしょう。)フォーマットは Perl の他の
「型」とは別に名前空間がとられます。このことは、`Foo' という名前の関数
を持っているとき、それは、`Foo' という名前のフォーマットを持っているの
とは違うということです。しかし、あるファイルハンドルに対して付随する
フォーマットのデフォルトの名前は、そのファイルハンドルの名前と同じもの
です。つまり、STDOUT に対するデフォルトのデフォルトのフォーマットは
`STDOUT' であり、ファイルハンドル TEMP に対するデフォルトのフォーマット
名は `TEMP' だということです。これらは同じように見えますが、違うもので
す。

出力レコードのフォーマットは以下のように宣言します:

     format NAME =
     FORMLIST
     .

NAME を指定しないと、`STDOUT' というフォーマットが定義されます。
FORMLIST は行の並びからなり、それぞれの行は次の 3 つのどれかになります:

  1. コメント。行頭に # を置くとその行はコメントとして扱われます。

  2. ピクチャ行。出力する行のフォーマットを 1 行単位で示します。

  3. 引数行。先行するピクチャ行に埋め込む値を示します。

ピクチャ行は、ある種のフィールドが、その行に値を埋め込むのに使われる他
は、まったく見た目の通りに印字されます。ピクチャ行の各々のフィールドは、
@" や "^" で始まるようになっています。ピクチャ行では、いかなる形でも変
数の展開は行なわれません。"@" フィールド (配列の "@" と混同しないこと)
は、通常のフィードで、"^" フィールドが複数行に渡るテキストのブロックを
作るために使われます。フィールドの長さは、"@" や "^" のあとに "<" や
>" や "|" を必要な数だけ並べることで表わし、それぞれ、左づめ、右づめ、
センタリングを表わします。もし、値がフィールドをはみだす場合には、切り
捨てられてしまいます。

右づめの別の形式として、数値フィールドを示す、"#" (と "." も可) を使うこ
ともできます。この方法で、小数点の位置を揃えることができます。こういった
フィールドに与えられる値に改行が含まれていると、その改行までのテキストが
印字されます。もう1つ "@*" というフィールドを使うと、値の切捨てを行なわ
ずに、複数行にわたって印字するために使用するようにできます。このフィール
ドを使う場合には、同じ行に別のフィールドを指定できません。

各フィールドへの値は、次の行に、ピクチャフィールドと同じ順番で指定しま
す。値を示す式は、コンマで区切られている必要があります。式はすべて、そ
の行が評価される前に、リストコンテキストで評価されますので、1つのリスト
式が複数のリスト要素を作るようにもできます。式は、中括弧で括って、複数
行にすることもできます。もし、そのようにするときは、最初の行の最初のトー
クンを、開き中括弧にしなければなりません。

"@" ではなく、"^" で始まるピクチャフィールドは、特別な扱いを受けます。
#" を使ったフィールドでは、値が未定義の場合に、空白となります。他のタイ
プのフィールドでは、"^" はある種の充填モードになります。値として指定で
きるものは、任意の式ではなく、テキスト文字列が入ったスカラ変数名でなけ
ればなりません。Perl はそのフィールドに入るだけのテキストを詰め込んで、
変数内の文字列の先頭から、その分を切り落とします。次にその変数が参照さ
れるときには、残りの部分のテキストが印字できることになります。(そうです、
このことは変数自身が `write()' の実行中に変更され、もとには戻らないとい
うことです。)普通は、テキストを矩形に表示するように、フィールドを縦に積
むような形で使われます。一番最後のフィールドを "..." という文字列で終わ
らせておくと、表示するテキストがその最後のフィールドにも収まりきらなかっ
たときに、そのまま "..." が出力されます。`$:' (English モジュール使用時
は `$FORMAT_LINE_BREAK_CHARACTERS')という変数に文字列を設定すると、出力
する文字列の中に、この変数内に設定した文字列中の 1 字が見つかったときに
改行するようになります。

"^" フィールドを使うと可変長のレコードが作れます。フォーマットされるテ
キストが短ければ、行のどこかに "~" をおくことで空行の出力をサプレスする
ことができます。出力時には、"~" は空白に変換されます。"~" を2つ並べて書
くと、すべてのフィールドに入れられる値が尽きてしまうまで、そのピクチャ
行と引数行を繰り返して使用します。(もし、"@" タイプのフィールドを使うな
らば、与える式は永久に同じ値を出すことの無いようにしないといけません。)

ページ先頭フォーマットの処理はデフォルトでは、現在のファイルハンドル名
に `_TOP' をつなげた名前のフォーマットで行なわれます。これは、各々のペー
ジの先頭で使われます。*Note 組み込み関数::,の `write()' の項を参照して
ください。

例:
     # /etc/passwd ファイルについてのレポート
     format STDOUT_TOP =
                             Passwd File
     Name                Login    Office   Uid   Gid Home
     ------------------------------------------------------------------
     .
     format STDOUT =
     @<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<
     $name,              $login,  $office,$uid,$gid, $home
     .

     # バグ報告書からのレポート
     format STDOUT_TOP =
                             Bug Reports
     @<<<<<<<<<<<<<<<<<<<<<<<     @|||         @>>>>>>>>>>>>>>>>>>>>>>>
     $system,                      $%,         $date
     ------------------------------------------------------------------
     .
     format STDOUT =
     Subject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              $subject
     Index: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            $index,                       $description
     Priority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
               $priority,        $date,   $description
     From: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           $from,                         $description
     Assigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                  $programmer,            $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
                                          $description
     .

同じ出力チャネルに `print()' と `write()' を混ぜて使うことも可能ですが、
`$-' (`$FORMAT_LINES_LEFT') を自分で調整する必要があります。

* Menu:

* フォーマット変数::
* フッタ::
* 内部のフォーマット動作へのアクセス::





File: perl-ja.info, Node: フォーマット変数, Next: フッタ, Prev: フォーマット文, Up: フォーマット文

フォーマット変数
================

その時点でのフォーマット名は、変数 `$~' (`$FORMAT_NAME') に入れられてお
り、ページ先頭フォーマットは、`$^' (`$FORMAT_TOP_NAME')に入れられていま
す。ページ番号は、`$%' (`$FORMAT_PAGE_NUMBER')に、ページあたりの行数は
`$=' (`$FORMAT_LINES_PER_PAGE') に入っています。そのファイルハンドルに
対して出力を自動フラッシュするか否かは、`$|' (`$OUTPUT_AUTOFLUSH') に入
れられています。(先頭ページ以外の) ページの先頭の前に出力する文字列は、
`$^L' (`$FORMAT_FORMFEED') に蓄えられます。これらの変数は、ファイルハン
ドルごとに設定されますので、特定のファイルハンドルのものを変更するには
`select()' する必要があります:

     select((select(OUTF),
             $~ = "My_Other_Format",
             $^ = "My_Top_Format"
            )[0]);

汚いですか？でも、普通のイディオムなので、見つけたときには驚かないでく
ださい。少なくとも以前のファイルハンドルを保持するのに一時変数を使うこ
とができます。(読みやすいばかりでなく、デバッガでステップ実行するときに
式の途中で、中間的な状態を用意できることになりますから、一般にはこちら
の方がずっと良いでしょう):

     $ofh = select(OUTF);
     $~ = "My_Other_Format";
     $^ = "My_Top_Format";
     select($ofh);

`English' モジュールを使えば、変数名を読むことさえできます:

     use English;
     $ofh = select(OUTF);
     $FORMAT_NAME     = "My_Other_Format";
     $FORMAT_TOP_NAME = "My_Top_Format";
     select($ofh);

しかし、意味不明の `select()' がまだ残っています。`FileHandle' モジュー
ルを使ってください。小文字のメソッドを使って、特殊変数をアクセスするこ
とができるようになります:

     use FileHandle;
     format_name     OUTF "My_Other_Format";
     format_top_name OUTF "My_Top_Format";

ずっと良いでしょう !



NOTES
-----

引数行には、( ^ フィールドに対してではなく、@ フィールドに対して) 任意
の式が許容されますから、もっと込み入った処理には、`sprintf()' や独自の
関数などに任せることもできます。たとえば:

     format Ident =
         @<<<<<<<<<<<<<<<
         &commify($n)
     .

実際に @ や ^ をフィールドに表示するには、以下のようにします:

     format Ident =
     I have an @ here.
             "@"
     .

テキスト全体をセンタリングするには、このようになります:

     format Ident =
     @|||||||||||||||||||||||||||||||||||||||||||||||
             "Some text line"
     .

「どんな幅であっても、右端に寄せるようにしたい。」というような要望に答え
る方法は組み込まれていません。表示する場所を必ず指定する必要があります。
窮余の策としては、現在のカラム数に基づいて、その場でフォーマットを作って、
`eval()' することができます:

     $format  = "format STDOUT = \n";
              . '^' . '<' x $cols . "\n";
              . '$entry' . "\n";
              . "\t^" . "<" x ($cols-8) . "~~\n";
              . '$entry' . "\n";
              . ".\n";
     print $format if $Debugging;
     eval $format;
     die $@ if $@;

これは、以下のようなフォーマット文を生成します:

     format STDOUT =
     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     $entry
             ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
     $entry
     .

fmt(1) のようなプログラム:

     format =
     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~
     $_
     .

     $/ = ";
     while (<>) {
         s/\s*\n\s*/ /g;
         write;
     }





