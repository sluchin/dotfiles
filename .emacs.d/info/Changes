New things
----------
    -w スイッチの情報量が多くなった。

    リファレンス。　例は t/op/ref.t を参照。　Perl 5 でのすべてのエント
    リの参照数は記憶されているので、参照がなくなった時に自動的に削除され
    る。

    オブジェクト。　例は t/op/ref.t を参照。

    => がコンマの同義語となった。　これは、連想配列の初期化リストやサブ
    ルーティンへの名前付き引数など、ペアになっている引数を記述するのに便
    利である。

    すべての関数は、リスト演算子か単項演算子となった。　つまり、括弧は必
    須ではない。　サブルーティンでさえも、宣言済みであれば、リスト演算子
    として呼び出すことができる。

    組み込みがたやすくなった。　main.c と embed_h.SH を参照。　同一プロ
    セスでの複数インタプリタがサポートされた(が、実行のインタリーブはま
    だである)。

    インタプリタが単純化された。　Perl 4 の eval.c と Perl 5 の pp.c を
    比べて欲しい。　Perl 4 の cmd.c の 900 行に及ぶインタプリタループと
    Perl 5 の run.c における 1 行のインタプリタループを比べて欲しい。
    最終的に何もブロック化せずに済むのでスケジューラとのインタフェースも
    良好である。

    eval は、よりサブルーティンコールらしく扱われるようになった。　この
    ことは、何にもまして eval から return できるということである。

    フォーマットの値リストは {} ブロックで囲って、複数行に渡って書けるよ
    うになった。　(訳注: 原文には、do {} と書いてあるが、t/op/write.t を
    見るとただの BLOCK のようだ。　実際にはどちらでもよいみたい。　リス
    トコンテキストで評価された結果が使われるだけ。)

    個々のパッケージに BEGIN と END サブルーティンを定義できる。　BEGIN
    サブルーティンは、解析された時に実行される。　END サブルーティンは、
    プログラムが exit する直前に実行される。

    スクリプトを直接実行した場合でなくても #! 行のフラグが解釈される。
    (スクリプトが "perl -x" で示される場合にもである !)

    ?: 演算子は、左辺値としても使用することができる。

    リストコンテキストは && や || の右辺や ?: の第 2、第 3 引数にも伝わ
    る。

    "defined" 関数が一般の式を取れるようになった。
    (訳注: exists() なんてのも ...)

    "my" によって、文面の上でローカルなスコープを作ることができる。　eval
    では、この字句スコープの変数を参照することができる。

    パッケージを参照する区切り文字は ' ではなく、:: を使った方がよい。
    (訳注: $main'var や @main'array ではなく、$main::var や @main::array)

    tie/untie を dbmopen/dbmclose の代わりに使った方がよい。　複数の DBM
    インプリメンテーションを同一の実行ファイルで扱うことができるので、異
    なるフォーマットのデータを変換するスクリプトを書くこともできる。

    "and" と "or" という演算子が && と || と同じように使用できるが、優先
    順位はコンマよりも低い。これは、リスト演算子と使うときに便利である。

    新しい関数が用意された: abs(), chr(), uc(), ucfirst(), lc(), lcfirst(),
    chomp(), glob()
    (訳注: 実際には他にも、便利な内部関数などが公開されている。　chomp()
    は、欲しかった人も多いかも。)

    require に数値を与えると、実行中の Perl のバージョンが、最低限その数
    値であることをチェックする。

    外部モジュールの動的ロードがサポートされた。

    クォート形式 qw// が新設され、これは split(' ', q//) と同値となる。

    グロブ値へのリファレンスの代入によって、そのリファレンスの型に対応す
    るグロブ内の単一要素を置き換えられるようになった:
	*foo = \$bar, *foo = \&bletch;

    ファイルハンドルに対するメソッドがサポートされた:
	output_autoflush STDOUT 1;

    暗号的な変数名を人間が読みやすい形に変換する "English" モジュールが
    提供される。

    自動ロード部分では goto &realsub で代わりのサブルーティンを呼び出す
    ことができるようになった。

    どんなパッケージでも AUTOLOAD ルーティンを宣言することで、サブルーテ
    ィンを怠けて定義できるようになる。　AUTOLOAD ルーティンは、そのパッ
    ケージの存在しないサブルーティンが呼ばれたときにコールされる。

    以前追加された幾つかの機能が、新しいキーワード "use" と "no" の下に
    統合された。　"use Module LIST" と書くと、
	BEGIN { require Module; import Module LIST; }
    を短くしたものとして扱われる。　"no" キーワードは "unimport" を代わ
    りに呼ぶことを除いて同一である。　以前のプラグマ機構は、現在この機構
    を使っていて、"use integer" と "use strict vars, refs, subs" のバリ
    エーションをインプリメントするために 2 つの新しいモジュールがライブ
    ラリに追加された。

    頭に \Q を付けると、変数は文字どおりにパターンに展開できるようになっ
    た。　これは、\U のような感じで働くが、代わりに英数字にバックスラッ
    シュをつける。　対応する関数 quotemeta もある。

    正規表現内のすべての数量子には ? を続けて書くことができ、最短一致を
    表わすことができる。

    パターンマッチには、明示的に複数行と単一行を示すために m もしくは s
    修飾子を付けることができるようになった。　s 修飾子を用いた場合には、
    . が改行にもマッチする。

    パターンには文字列の最初にだけマッチする \A と最後にだけマッチする
    \Z を含めることができる。　^ や $ との違いは、複数行の意味を無視する
    ということである。　さらに、\G は最後に m//g や s///g が実行された場
    所にマッチする。

    開き括弧の直後に ? を続けて、さらに括弧の目的を示す文字を続けること
    によって、様々な種類の後方参照を行わない括弧を使用することができる。
    たとえば、: は単なるグループ化を表わす。　(?:a|b|c) は a, b, c のい
    ずれかにマッチするが、後方参照を行わない。入力はなくなってしまう。
    入力を行なわないで、先読みを行なうアサーションもある。　(?=stuff) は
    次に続くものが "stuff" でなければならないことを示している。
    (?!nonsense) は次が "nonsense" であってはならないことを示している。

    負号演算子は非数値文字列を特別にあつかうようになった。　-"text" は、
    "-text" となるため、-bareword は "-bareword" と同じである。　文字列
    に既に + や - がついていた場合には、符号を反転する。

Incompatibilities
-----------------
    二重引用タイプの文字列では、@ は常に配列を展開する。　プログラムによ
    っては @ が展開されないように、バックスラッシュが必要となるだろう。

    通常の下線文字で始まる変数が main パッケージに置かれることが強制され
    なくなった。

    s'$lhs'$rhs' においては、どちらも展開されなくなった。　以前は、$lhs
    は展開され、$rhs は展開されなかった。

    splice の 2 番目と 3 番目の引数が (本に書かれているように) リストコ
    ンテキストではなくスカラコンテキストで評価されるようになった。

    "shift @foo + 20" は優先順位の関係から、エラーとなるようになった。

    "open FOO || die" は、誤りとなった。　ファイルハンドルに括弧が必要で
    ある。　(訳注: 代わりに or を使って open FOO or die とできる。)

    フォーマットの引数リストの要素がリストコンテキストで評価されるように
    なった。これにより、リスト値を展開することができるようになった。

    最適化されてなくなるブロック内に goto することはできません。ちぇっ。

    空白を変数の名前としてや、引用構文の区切り文字として使用することは、
    構文的に正しいものではなくなった。

    いくつかのエラーメッセージが変更された。

    caller 関数は、呼び元がないとき、スカラコンテキストで偽を返すように
    なった。　これによりライブラリは require されたのか判断することがで
    きる。

    m//g は正規表現にではなく、サーチ文字列の方に状態を括りつけるように
    なった。

    "reverse" を sort サブルーティンの名前として使用することができなくな
    った。

    taintperl はもはや独立した実行ファイルとしては存在しない。　自動的に
    taint の機能が働かない時のために -T スイッチが用意されている。

    _ で始まるシンボルは、$_ 自身 (と @_ など) を除いて、もはや main パ
    ッケージに強制されていない。

    二重引用文字列がエスケープされていない $ や @ で終了することがなくな
    った。

    負の添え字は、配列の終わりから数えるようになった。

    スカラコンテキストでのコンマ演算子は、その引数に対してスカラコンテキ
    ストを与えることが保証されるようになった。

    ** 演算子は、単項のマイナスよりも強く結合するようになった。

    デストラクタがうまく動作するように、$#array を小さく設定すると配列要
    素を捨てるようになった。

    delete は tie された配列の昔の値を返すことを保証しなくなった。　この
    機能が、いくつかのモジュールにとってインプリメントしづらいもの可能性
    があるからだ。

    変数 $1 から $9 に値を設定しようとするとランタイムエラーになるように
    なった。

-------- * --------
    以下、訳注

    $[ がコンパイラディレクティブのように扱われるようになった。　(ファイ
    ル単位で有効ということ。)

    @a = /(PAT)(TE)(RN)/ のような場合にも ($a[0], $a[1],... だけでなく)
    $1, $2,... が設定される。

    grep BLOCK LIST

    スカラコンテキストで localtime が ctime(2) の文字列を返す。
